CCS PCH C Compiler, Version 5.025, 16586               11-Aug-19 15:24

               Filename:   D:\SVN\Work\Projects\Automation\InMotionWeighing\02_Designs\04_Firmware\IMWM_Cam\01_Code\M0_ADC_Module\M0_ADC_Module.X\build\default\production\_ext\1472\vmIMW_MCU0.lst

               ROM used:   10960 bytes (17%)
                           Largest free fragment is 54572
               RAM used:   1927 (53%) at main() level
                           2777 (76%) worst case
               Stack used: 4 locations (3 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   26D6
*
00008:  NOP   
0000A:  NOP   
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FF2.5
00066:  GOTO   0070
0006A:  BTFSC  FF2.2
0006C:  GOTO   03BC
00070:  BTFSS  F9D.0
00072:  GOTO   007C
00076:  BTFSC  F9E.0
00078:  GOTO   015C
0007C:  BTFSS  FA0.1
0007E:  GOTO   0088
00082:  BTFSC  FA1.1
00084:  GOTO   00E2
00088:  BTFSS  FF0.5
0008A:  GOTO   0094
0008E:  BTFSC  FF0.2
00090:  GOTO   0136
00094:  MOVFF  0E,00
00098:  MOVFF  0F,01
0009C:  MOVFF  10,02
000A0:  MOVFF  11,03
000A4:  MOVFF  0C,FE9
000A8:  MOVFF  07,FEA
000AC:  BSF    07.7
000AE:  MOVFF  08,FE1
000B2:  MOVFF  09,FE2
000B6:  MOVFF  0A,FD9
000BA:  MOVFF  0B,FDA
000BE:  MOVFF  12,FF3
000C2:  MOVFF  13,FF4
000C6:  MOVFF  14,FFA
000CA:  MOVFF  15,FF5
000CE:  MOVFF  16,FF6
000D2:  MOVFF  17,FF7
000D6:  MOVF   04,W
000D8:  MOVFF  06,FE0
000DC:  MOVFF  05,FD8
000E0:  RETFIE 0
....................  
.................... #include "vmSystemConfig.h" 
....................  
.................... #ifndef _VI_SYSTEM_CONFIG_H_ 
.................... #define _VI_SYSTEM_CONFIG_H_ 
....................  
.................... //****************** Inclusion Files *************************** 
.................... #include "18F46K80.h" 
.................... //////////// Standard Header file for the PIC18F46K80 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F46K80 
*
0031C:  MOVFF  FEC,FFA
00320:  MOVF   FED,F
00322:  MOVFF  FEF,FE8
00326:  MOVWF  FF9
00328:  RETURN 0
*
005BA:  MOVLB  A
005BC:  MOVF   xC7,W
005BE:  MULWF  xC9
005C0:  MOVFF  FF3,01
005C4:  MOVFF  FF4,00
005C8:  MULWF  xCA
005CA:  MOVF   FF3,W
005CC:  ADDWF  00,F
005CE:  MOVF   xC8,W
005D0:  MULWF  xC9
005D2:  MOVF   FF3,W
005D4:  ADDWFC 00,W
005D6:  MOVWF  02
005D8:  MOVLB  0
005DA:  RETURN 0
*
00CC2:  BTFSC  FD8.1
00CC4:  GOTO   0CD0
00CC8:  MOVLW  0A
00CCA:  MOVWF  FEA
00CCC:  MOVLW  CD
00CCE:  MOVWF  FE9
00CD0:  CLRF   00
00CD2:  CLRF   01
00CD4:  CLRF   02
00CD6:  CLRF   03
00CD8:  MOVLB  A
00CDA:  CLRF   xCD
00CDC:  CLRF   xCE
00CDE:  CLRF   xCF
00CE0:  CLRF   xD0
00CE2:  MOVF   xCC,W
00CE4:  IORWF  xCB,W
00CE6:  IORWF  xCA,W
00CE8:  IORWF  xC9,W
00CEA:  BTFSC  FD8.2
00CEC:  GOTO   0D5A
00CF0:  MOVLW  20
00CF2:  MOVWF  xD1
00CF4:  BCF    FD8.0
00CF6:  RLCF   xC5,F
00CF8:  RLCF   xC6,F
00CFA:  RLCF   xC7,F
00CFC:  RLCF   xC8,F
00CFE:  RLCF   xCD,F
00D00:  RLCF   xCE,F
00D02:  RLCF   xCF,F
00D04:  RLCF   xD0,F
00D06:  MOVF   xCC,W
00D08:  SUBWF  xD0,W
00D0A:  BTFSS  FD8.2
00D0C:  GOTO   0D28
00D10:  MOVF   xCB,W
00D12:  SUBWF  xCF,W
00D14:  BTFSS  FD8.2
00D16:  GOTO   0D28
00D1A:  MOVF   xCA,W
00D1C:  SUBWF  xCE,W
00D1E:  BTFSS  FD8.2
00D20:  GOTO   0D28
00D24:  MOVF   xC9,W
00D26:  SUBWF  xCD,W
00D28:  BTFSS  FD8.0
00D2A:  GOTO   0D4C
00D2E:  MOVF   xC9,W
00D30:  SUBWF  xCD,F
00D32:  MOVF   xCA,W
00D34:  BTFSS  FD8.0
00D36:  INCFSZ xCA,W
00D38:  SUBWF  xCE,F
00D3A:  MOVF   xCB,W
00D3C:  BTFSS  FD8.0
00D3E:  INCFSZ xCB,W
00D40:  SUBWF  xCF,F
00D42:  MOVF   xCC,W
00D44:  BTFSS  FD8.0
00D46:  INCFSZ xCC,W
00D48:  SUBWF  xD0,F
00D4A:  BSF    FD8.0
00D4C:  RLCF   00,F
00D4E:  RLCF   01,F
00D50:  RLCF   02,F
00D52:  RLCF   03,F
00D54:  DECFSZ xD1,F
00D56:  GOTO   0CF4
00D5A:  MOVFF  ACD,FEF
00D5E:  MOVFF  ACE,FEC
00D62:  MOVFF  ACF,FEC
00D66:  MOVFF  AD0,FEC
00D6A:  MOVLB  0
00D6C:  RETURN 0
*
00E1A:  MOVLB  A
00E1C:  CLRF   xD1
00E1E:  CLRF   xD2
00E20:  MOVLW  01
00E22:  MOVWF  xD3
00E24:  CLRF   FDA
00E26:  CLRF   FD9
00E28:  MOVLW  0A
00E2A:  MOVWF  xD6
00E2C:  MOVLW  C9
00E2E:  MOVWF  xD5
00E30:  MOVLW  0A
00E32:  MOVWF  FEA
00E34:  MOVLW  CD
00E36:  MOVWF  FE9
00E38:  MOVFF  AD6,FE2
00E3C:  MOVFF  AD5,FE1
00E40:  MOVFF  AD3,AD4
00E44:  BCF    FD8.0
00E46:  MOVF   FE5,W
00E48:  MULWF  FEE
00E4A:  MOVF   FF3,W
00E4C:  ADDWFC xD1,F
00E4E:  MOVF   FF4,W
00E50:  ADDWFC xD2,F
00E52:  DECFSZ xD4,F
00E54:  GOTO   0E44
00E58:  MOVFF  AD1,FDE
00E5C:  MOVFF  AD2,AD1
00E60:  CLRF   xD2
00E62:  BTFSC  FD8.0
00E64:  INCF   xD2,F
00E66:  INCF   xD5,F
00E68:  BTFSC  FD8.2
00E6A:  INCF   xD6,F
00E6C:  INCF   xD3,F
00E6E:  MOVF   xD3,W
00E70:  SUBLW  05
00E72:  BTFSS  FD8.2
00E74:  GOTO   0E30
00E78:  MOVLB  0
00E7A:  RETURN 0
*
010B6:  MOVLB  A
010B8:  MOVF   xBF,W
010BA:  CLRF   01
010BC:  SUBWF  xBE,W
010BE:  BTFSC  FD8.0
010C0:  GOTO   10CC
010C4:  MOVFF  ABE,00
010C8:  GOTO   10E6
010CC:  CLRF   00
010CE:  MOVLW  08
010D0:  MOVWF  xC0
010D2:  RLCF   xBE,F
010D4:  RLCF   00,F
010D6:  MOVF   xBF,W
010D8:  SUBWF  00,W
010DA:  BTFSC  FD8.0
010DC:  MOVWF  00
010DE:  RLCF   01,F
010E0:  DECFSZ xC0,F
010E2:  GOTO   10D2
010E6:  MOVLB  0
010E8:  GOTO   1196 (RETURN)
*
02AAE:  ADDWF  FE8,W
02AB0:  CLRF   FF7
02AB2:  RLCF   FF7,F
02AB4:  ADDLW  C9
02AB6:  MOVWF  FF6
02AB8:  MOVLW  2A
02ABA:  ADDWFC FF7,F
02ABC:  TBLRD*-
02ABE:  MOVF   FF5,W
02AC0:  MOVWF  FFA
02AC2:  TBLRD*
02AC4:  MOVF   FF5,W
02AC6:  MOVWF  FF9
02AC8:  DATA 1E,2A
02ACA:  DATA 24,2A
02ACC:  DATA 30,2A
02ACE:  DATA 2A,2A
02AD0:  DATA 30,2A
02AD2:  DATA 9A,2A
....................  
.................... #list 
....................  
.................... #include "vmPINConfig.h" 
.................... #ifndef _VI_PIN_CONFIG_H_ 
.................... #define _VI_PIN_CONFIG_H_ 
....................  
.................... //#include "18F46K80.h" 
....................  
.................... // DI PIN Mapping. 
.................... #define PIN_IN_DI_00               PIN_D4  
.................... #define PIN_IN_DI_01               PIN_B0  
.................... #define PIN_IN_DI_02               PIN_B1  
.................... #define PIN_IN_DI_03               PIN_B2  
.................... #define PIN_IN_DI_04               PIN_B4    
.................... #define PIN_IN_DI_05               PIN_B5  
.................... #define PIN_IN_DI_06               PIN_A0  
.................... #define PIN_IN_DI_07               PIN_A1  
....................  
.................... // D0 PIN Mapping. 
.................... #define PIN_OUT_DO_00              PIN_E0  
.................... #define PIN_OUT_DO_01              PIN_E1  
.................... #define PIN_OUT_DO_02              PIN_E2  
.................... #define PIN_OUT_DO_03              PIN_C0  
.................... #define PIN_OUT_DO_04              PIN_C1  
.................... #define PIN_OUT_DO_05              PIN_D0 
.................... #define PIN_OUT_DO_06              PIN_D1 
.................... #define PIN_OUT_DO_07              PIN_D2 
....................  
....................  
.................... // LAN Communication Pin Mapping. 
.................... #define PIN_LAN_COMM_XMIT          PIN_C6 
.................... #define PIN_LAN_COMM_RCV    	   PIN_C7 
....................  
.................... // ADC Communication PIN Mapping; IC -> ADS1131(18-bit ADC). 
.................... #define PIN_ADC_DOUT_DRDY           PIN_C4 
.................... #define PIN_ADC_SCLK                PIN_C3 
.................... #define PIN_ADC_PDWN                PIN_C2 
....................  
....................  
.................... // IBC Communication PIN Mapping. 
.................... #define PIN_IBC_RCV                 PIN_B3 
.................... #define PIN_IBC_XMIT                PIN_D5 
....................  
.................... // UART To UART Communication PIN Mapping. 
.................... #define PIN_UART2_COMM_XMIT         PIN_D6 
.................... #define PIN_UART2_COMM_RCV          PIN_D7 
....................  
....................  
.................... #endif /* _VI_PIN_CONFIG_H_ */ 
....................  
....................  
....................  
....................  
.................... //****************** Component Configuration ******************** 
....................  
.................... //optimization level. 
.................... #pragma opt 8 
....................   
.................... //********* CPU Settings ******************************************* 
....................  
.................... #pragma device HIGH_INTS=TRUE 
.................... #pragma fuses NOPLLEN,ECH,WDT1024,NOPROTECT,NOBROWNOUT,NOFCMEN,NOIESO,NOPUT /* WDT1024 => 1024 * 4 ms = 4096 mS Watchdog Timer */ /* For Field Mode */ 
....................  
.................... #pragma use delay(clock=20000000,restart_wdt) 
*
00C20:  MOVLW  0A
00C22:  MOVWF  FEA
00C24:  MOVLW  AB
00C26:  MOVWF  FE9
00C28:  MOVF   FEF,W
00C2A:  BTFSC  FD8.2
00C2C:  GOTO   0C52
00C30:  MOVLW  06
00C32:  MOVWF  01
00C34:  MOVLW  BF
00C36:  MOVWF  00
00C38:  CLRWDT
00C3A:  DECFSZ 00,F
00C3C:  BRA    0C38
00C3E:  DECFSZ 01,F
00C40:  BRA    0C34
00C42:  MOVLW  7A
00C44:  MOVWF  00
00C46:  DECFSZ 00,F
00C48:  BRA    0C46
00C4A:  BRA    0C4C
00C4C:  CLRWDT
00C4E:  DECFSZ FEF,F
00C50:  BRA    0C30
00C52:  GOTO   28C4 (RETURN)
....................  
....................  
.................... //******** Serial Interface ************ 
.................... //#pragma use rs232(stream=RS485, xmit=PIN_RS485_XMIT, rcv=PIN_RS485_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
.................... #pragma use rs232(stream=ARD_RS232, xmit=PIN_LAN_COMM_XMIT, rcv=PIN_LAN_COMM_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
....................  
.................... //#define unsigned int8 BYTE 
.................... #ifndef M0_ADC_MODULE 
.................... #define M0_ADC_MODULE 1 
.................... #endif 
....................  
.................... #endif /* _VI_SYSTEM_CONFIG_H_ */ 
....................  
.................... #include "../Common/vmIBCConfig.h" 
.................... #ifndef _VI_IBC_CONFIG_H_ 
.................... #define _VI_IBC_CONFIG_H_ 
....................  
.................... #include "vmSystemConfig.h" 
....................  
.................... #ifndef _VI_SYSTEM_CONFIG_H_ 
.................... #define _VI_SYSTEM_CONFIG_H_ 
....................  
.................... //****************** Inclusion Files *************************** 
.................... #include "18F46K80.h" 
.................... #include "vmPINConfig.h" 
....................  
.................... //****************** Component Configuration ******************** 
....................  
.................... //optimization level. 
.................... #pragma opt 8 
....................   
.................... //********* CPU Settings ******************************************* 
....................  
.................... #pragma device HIGH_INTS=TRUE 
.................... #pragma fuses NOPLLEN,ECH,WDT1024,NOPROTECT,NOBROWNOUT,NOFCMEN,NOIESO,NOPUT /* WDT1024 => 1024 * 4 ms = 4096 mS Watchdog Timer */ /* For Field Mode */ 
....................  
.................... #pragma use delay(clock=20000000,restart_wdt) 
....................  
....................  
.................... //******** Serial Interface ************ 
.................... //#pragma use rs232(stream=RS485, xmit=PIN_RS485_XMIT, rcv=PIN_RS485_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
.................... #pragma use rs232(stream=ARD_RS232, xmit=PIN_LAN_COMM_XMIT, rcv=PIN_LAN_COMM_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
....................  
.................... //#define unsigned int8 BYTE 
.................... #ifndef M0_ADC_MODULE 
.................... #define M0_ADC_MODULE 1 
.................... #endif 
....................  
.................... #endif /* _VI_SYSTEM_CONFIG_H_ */ 
....................  
.................... #include "vmCRCConfig.h" 
.................... #ifndef _VM_CRC_CONFIG_H_ 
.................... #define _VM_CRC_CONFIG_H_ 
....................  
.................... // Table of CRC values for high–order byte. 
.................... unsigned int8 const auchCRCHi[] =  
.................... { 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40 
.................... } ; 
....................  
.................... // Table of CRC values for low–order byte. 
.................... unsigned int8 const auchCRCLo[] =  
.................... { 
.................... 0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 
.................... 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 
.................... 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 
.................... 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 
.................... 0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7, 
.................... 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 
.................... 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 
.................... 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 
.................... 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 
.................... 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 
.................... 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 
.................... 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5, 
.................... 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91, 
.................... 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 
.................... 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 
.................... 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 
.................... 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // CRC calculation. 
.................... static unsigned int16 ModbusCRC16 (unsigned int8* puiMsg,   // Message to calculate CRC upon. 
....................                                    unsigned short usDataLen) // Quantity of bytes in message. 
.................... { 
....................     unsigned int8 uchCRCHi = 0xFF; // High byte of CRC initialized. 
....................     unsigned int8 uchCRCLo = 0xFF; // Low byte of CRC initialized. 
....................     unsigned int8 uIndex;          // Will index into CRC lookup table. 
....................  
....................     while (usDataLen--) // Loop through message buffer. 
....................     { 
....................         uIndex = uchCRCLo ^ *puiMsg++; // Calculate the CRC. 
....................         uchCRCLo = uchCRCHi ^ auchCRCHi[uIndex]; 
....................         uchCRCHi = auchCRCLo[uIndex]; 
....................     } 
....................  
....................     return ((((unsigned int16)uchCRCHi) << 8) | uchCRCLo); 
.................... } 
....................  
.................... unsigned int16 calculateCrc( unsigned int8* pDataBuff, unsigned int8 uiDataLen ) 
.................... { 
.................... 	unsigned int16 uiCRC        = 0x00; 
.................... 	unsigned int16 shRemainder  = 0xFFFF; 
.................... 	unsigned int16 shGP         = 40961; 
.................... 	unsigned int8  uiByteCount  = 0; 
.................... 	unsigned int8  bShiftCount  = 0; 
.................... 	unsigned int8  bShiftCarry  = 0; 
....................  
.................... 	while (1) 
.................... 	{ 
.................... 		if (uiByteCount == uiDataLen) 
.................... 		{ 
.................... 			break; 
.................... 		} 
....................  
.................... 		uiByteCount++; 
.................... 		bShiftCount = 0; 
....................  
.................... 		while (1) 
.................... 		{ 
.................... 			if (0 == bShiftCount) 
.................... 			{ 
.................... 				if (1 == uiByteCount) 
.................... 				{ 
.................... 					uiCRC = (pDataBuff[uiByteCount - 1]) ^ shRemainder; 
.................... 				} 
.................... 				else 
.................... 				{ 
.................... 					uiCRC = uiCRC ^ (pDataBuff[uiByteCount - 1]); 
.................... 				} 
.................... 			} 
.................... 			else 
.................... 			{ 
.................... 				uiCRC = uiCRC ^ shGP; 
.................... 			} 
....................  
.................... 		    NoBitCarry: 
....................  
.................... 			bShiftCount++; 
....................  
.................... 			if (bShiftCount > 8) 
.................... 			{ 
.................... 				break; 
.................... 			} 
....................  
.................... 			bShiftCarry = uiCRC & 1; 
....................  
.................... 			uiCRC = uiCRC >> 1; 
....................  
.................... 			if (1 == bShiftCarry) 
.................... 			{ 
.................... 				continue; 
.................... 			} 
.................... 			else 
.................... 			{ 
.................... 				goto NoBitCarry; 
.................... 			} 
.................... 		} 
.................... 	} 
....................  
.................... 	return uiCRC; 
.................... } 
....................  
.................... #endif /* _VM_CRC_CONFIG_H_ */ 
....................  
.................... #include "vmDigitalIOConfig.h" 
.................... #ifndef _VM_DIGITAL_IO_CONFIG_H_ 
.................... #define _VM_DIGITAL_IO_CONFIG_H_ 
....................  
.................... //***************************************************************************** 
.................... // Below -> Data Structure for Digital Input Output *************************** 
.................... //***************************************************************************** 
.................... typedef struct _ST_ALL_DI_STATE_BIT 
.................... { 
....................     unsigned int8 m_ui1SWDICn07: 1; 
....................     unsigned int8 m_ui1SWDICn06: 1; 
....................     unsigned int8 m_ui1SWDICn05: 1; 
....................     unsigned int8 m_ui1SWDICn04: 1; 
....................     unsigned int8 m_ui1SWDICn03: 1; 
....................     unsigned int8 m_ui1SWDICn02: 1; 
....................     unsigned int8 m_ui1SWDICn01: 1; 
....................     unsigned int8 m_ui1SWDICn00: 1; 
....................  
....................     unsigned int8 m_ui1GDICn05: 1; 
....................     unsigned int8 m_ui1GDICn04: 1; 
....................     unsigned int8 m_ui1GDICn03: 1; 
....................     unsigned int8 m_ui1GDICn02: 1; 
....................     unsigned int8 m_ui1GDICn01: 1; 
....................     unsigned int8 m_ui1GDICn00: 1; 
....................  
....................     unsigned int8 m_ui1HWDICn17: 1; 
....................     unsigned int8 m_ui1HWDICn16: 1; 
....................     unsigned int8 m_ui1HWDICn15: 1; 
....................     unsigned int8 m_ui1HWDICn14: 1; 
....................     unsigned int8 m_ui1HWDICn13: 1; 
....................     unsigned int8 m_ui1HWDICn12: 1; 
....................     unsigned int8 m_ui1HWDICn11: 1; 
....................     unsigned int8 m_ui1HWDICn10: 1; 
....................     unsigned int8 m_ui1HWDICn09: 1; 
....................     unsigned int8 m_ui1HWDICn08: 1; 
....................     unsigned int8 m_ui1HWDICn07: 1; 
....................     unsigned int8 m_ui1HWDICn06: 1; 
....................     unsigned int8 m_ui1HWDICn05: 1; 
....................     unsigned int8 m_ui1HWDICn04: 1; 
....................     unsigned int8 m_ui1HWDICn03: 1; 
....................     unsigned int8 m_ui1HWDICn02: 1; 
....................     unsigned int8 m_ui1HWDICn01: 1; 
....................     unsigned int8 m_ui1HWDICn00: 1; 
.................... } ST_ALL_DI_STATE_BIT; 
....................  
.................... typedef union _UN_ALL_DIS 
.................... { 
.................... 	unsigned int8       m_bArr[4]; 
....................     unsigned int32      m_ui32AllDIs; 
....................     ST_ALL_DI_STATE_BIT m_stAllDIBits; 
.................... } UN_ALL_DIS; 
....................  
....................  
.................... typedef struct _ST_ALL_DO_STATE_BIT 
.................... { 
....................     unsigned int8 m_ui1SRDOCn07: 1; 
....................     unsigned int8 m_ui1SRDOCn06: 1; 
....................     unsigned int8 m_ui1SRDOCn05: 1; 
....................     unsigned int8 m_ui1SRDOCn04: 1; 
....................     unsigned int8 m_ui1SRDOCn03: 1; 
....................     unsigned int8 m_ui1SRDOCn02: 1; 
....................     unsigned int8 m_ui1SRDOCn01: 1; 
....................     unsigned int8 m_ui1SRDOCn00: 1; 
....................  
....................     unsigned int8 m_ui1HWDOCn07: 1; 
....................     unsigned int8 m_ui1HWDOCn06: 1; 
....................     unsigned int8 m_ui1HWDOCn05: 1; 
....................     unsigned int8 m_ui1HWDOCn04: 1; 
....................     unsigned int8 m_ui1HWDOCn03: 1; 
....................     unsigned int8 m_ui1HWDOCn02: 1; 
....................     unsigned int8 m_ui1HWDOCn01: 1; 
....................     unsigned int8 m_ui1HWDOCn00: 1; 
.................... } ST_ALL_DO_STATE_BIT; 
....................  
.................... typedef union _UN_ALL_DOS 
.................... { 
....................     unsigned int8       m_bArr[2]; 
....................     unsigned int16      m_ui16AllDOs; 
....................     ST_ALL_DO_STATE_BIT m_stAllDOBits; 
.................... } UN_ALL_DOS; 
....................  
.................... typedef struct _ST_ALL_COUNTER_STATE_BIT 
.................... { 
....................     unsigned int8 m_ui3Counter0: 3; 
....................     unsigned int8 m_ui3Counter1: 3; 
....................     unsigned int8 m_ui2Counter2: 2; 
....................  
....................     unsigned int8 m_ui2Counter3: 2; 
....................     unsigned int8 m_ui2Counter4: 2; 
....................     unsigned int8 m_ui2Counter5: 2; 
....................     unsigned int8 m_ui2Counter6: 2; 
.................... } ST_ALL_COUNTER_STATE_BIT; 
....................  
.................... typedef union _UN_ALL_COUNTERS 
.................... { 
....................     unsigned int8              m_bArr[2]; 
....................     unsigned int16             m_ui16AllCounters; 
....................     ST_ALL_COUNTER_STATE_BIT   m_stAllCounterBits; 
.................... } UN_ALL_COUNTERS; 
....................  
.................... //***************************************************************************** 
.................... // Above -> Data Structure for Digital Input Output *************************** 
.................... //***************************************************************************** 
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
.................... UN_ALL_DIS      g_unDIState; 
.................... UN_ALL_DOS      g_unDOState; 
.................... UN_ALL_COUNTERS g_unAllCounters; 
.................... UN_ALL_DIS      g_unDIStateFilter; 
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //*****************************************************************************  
....................  
.................... #endif /* _VI_DIGITAL_IO_CONFIG_H_ */ 
....................  
.................... //typedef struct _ST_ALL_DI_STATE_BIT 
.................... //{ 
.................... //    unsigned int8 m_ui1HWDICn15: 1; 
.................... //    unsigned int8 m_ui1HWDICn14: 1; 
.................... //    unsigned int8 m_ui1HWDICn13: 1; 
.................... //    unsigned int8 m_ui1HWDICn12: 1; 
.................... //    unsigned int8 m_ui1HWDICn11: 1; 
.................... //    unsigned int8 m_ui1HWDICn10: 1; 
.................... //    unsigned int8 m_ui1HWDICn09: 1; 
.................... //    unsigned int8 m_ui1HWDICn08: 1; 
.................... // 
.................... //    unsigned int8 m_ui1HWDICn07: 1; 
.................... //    unsigned int8 m_ui1HWDICn06: 1; 
.................... //    unsigned int8 m_ui1HWDICn05: 1; 
.................... //    unsigned int8 m_ui1HWDICn04: 1; 
.................... //    unsigned int8 m_ui1HWDICn03: 1; 
.................... //    unsigned int8 m_ui1HWDICn02: 1; 
.................... //    unsigned int8 m_ui1HWDICn01: 1; 
.................... //    unsigned int8 m_ui1HWDICn00: 1; 
.................... //}ST_ALL_DI_STATE_BIT; 
.................... // 
.................... //typedef union _UN_ALL_DIS 
.................... //{ 
.................... //	unsigned int8       m_bArr[2]; 
.................... //    unsigned int16      m_ui16AllDIs; 
.................... //    ST_ALL_DI_STATE_BIT m_stAllDIBits; 
.................... //} UN_ALL_DIS; 
.................... // 
.................... //typedef struct _ST_ALL_DO_STATE_BIT 
.................... //{ 
.................... //    unsigned int8 m_ui1HWDOCn07: 1; 
.................... //    unsigned int8 m_ui1HWDOCn06: 1; 
.................... //    unsigned int8 m_ui1HWDOCn05: 1; 
.................... //    unsigned int8 m_ui1HWDOCn04: 1; 
.................... //    unsigned int8 m_ui1HWDOCn03: 1; 
.................... //    unsigned int8 m_ui1HWDOCn02: 1; 
.................... //    unsigned int8 m_ui1HWDOCn01: 1; 
.................... //    unsigned int8 m_ui1HWDOCn00: 1; 
.................... // 
.................... //}ST_ALL_DO_STATE_BIT; 
.................... // 
.................... //typedef union _UN_ALL_DOS 
.................... //{ 
.................... //    unsigned int8     m_ui8AllDOs; 
.................... //    ST_ALL_DO_STATE_BIT m_stAllDOBits; 
.................... //} UN_ALL_DOS; 
.................... // 
.................... ////***************************************************************************** 
.................... //// Above -> Data Structure for Digital Input Output *************************** 
.................... ////***************************************************************************** 
.................... // 
.................... // 
.................... ////***************************************************************************** 
.................... //// Below -> Global Variable Declaration *************************************** 
.................... ////***************************************************************************** 
.................... //UN_ALL_DIS      g_unDICurrState; 
.................... //UN_ALL_DOS      g_unDOCurrState; 
.................... // 
.................... //UN_ALL_DIS      g_unDIPrevState; 
.................... //UN_ALL_DOS      g_unDOPrevState; 
.................... // 
.................... //UN_ALL_DIS      g_unDIStateFilter; 
.................... ////***************************************************************************** 
.................... //// Above -> Global Variable Declaration *************************************** 
.................... ////*****************************************************************************  
....................  
.................... //#endif /* _VM_DIGITAL_IO_CONFIG_H_ */ 
....................  
.................... //#include "ctype.h" 
.................... #include "vmPINConfig.h" 
.................... #ifndef _VI_PIN_CONFIG_H_ 
.................... #define _VI_PIN_CONFIG_H_ 
....................  
.................... //#include "18F46K80.h" 
....................  
.................... // DI PIN Mapping. 
.................... #define PIN_IN_DI_00               PIN_D4  
.................... #define PIN_IN_DI_01               PIN_B0  
.................... #define PIN_IN_DI_02               PIN_B1  
.................... #define PIN_IN_DI_03               PIN_B2  
.................... #define PIN_IN_DI_04               PIN_B4    
.................... #define PIN_IN_DI_05               PIN_B5  
.................... #define PIN_IN_DI_06               PIN_A0  
.................... #define PIN_IN_DI_07               PIN_A1  
....................  
.................... // D0 PIN Mapping. 
.................... #define PIN_OUT_DO_00              PIN_E0  
.................... #define PIN_OUT_DO_01              PIN_E1  
.................... #define PIN_OUT_DO_02              PIN_E2  
.................... #define PIN_OUT_DO_03              PIN_C0  
.................... #define PIN_OUT_DO_04              PIN_C1  
.................... #define PIN_OUT_DO_05              PIN_D0 
.................... #define PIN_OUT_DO_06              PIN_D1 
.................... #define PIN_OUT_DO_07              PIN_D2 
....................  
....................  
.................... // LAN Communication Pin Mapping. 
.................... #define PIN_LAN_COMM_XMIT          PIN_C6 
.................... #define PIN_LAN_COMM_RCV    	   PIN_C7 
....................  
.................... // ADC Communication PIN Mapping; IC -> ADS1131(18-bit ADC). 
.................... #define PIN_ADC_DOUT_DRDY           PIN_C4 
.................... #define PIN_ADC_SCLK                PIN_C3 
.................... #define PIN_ADC_PDWN                PIN_C2 
....................  
....................  
.................... // IBC Communication PIN Mapping. 
.................... #define PIN_IBC_RCV                 PIN_B3 
.................... #define PIN_IBC_XMIT                PIN_D5 
....................  
.................... // UART To UART Communication PIN Mapping. 
.................... #define PIN_UART2_COMM_XMIT         PIN_D6 
.................... #define PIN_UART2_COMM_RCV          PIN_D7 
....................  
....................  
.................... #endif /* _VI_PIN_CONFIG_H_ */ 
....................  
....................  
....................  
.................... #include "vmIBCGlobal.h" 
.................... #ifndef _VM_IBC_GOBAL_H_ 
.................... #define _VM_IBC_GOBAL_H_ 
....................  
.................... #define IBC_SEND_LOCK                   1 
.................... #define IBC_SEND_UNLOCK                 0 
....................  
.................... typedef enum _EN_IBC_COMMANDS 
.................... { 
....................     IBC_CMD_MODE_HOME                   = 100, 
....................     // Calibration Mode 
....................     IBC_CMD_MODE_CALIB                  = 101, 
....................     IBC_CMD_GET_CALIB_POINT             = 102, 
....................     IBC_CMD_RESET_CALIB_POINT_TARE      = 103, 
....................     IBC_CMD_RESET_CALIB_POINT           = 104, 
....................     IBC_CMD_RESET_CALIB_POINT_WEIGHT    = 105,  
....................     IBC_CMD_TARE_REQUEST                = 106, 
....................     IBC_CMD_SET_LOAD_CELL_FACTOR        = 115,         
....................  
....................     // Pre-Production Mode 
....................     IBC_CMD_MODE_PRE_PROD               = 107, 
....................     IBC_CMD_PRE_PROD_AVG_WEIGHT         = 108, 
....................     IBC_CMD_PRE_PROD_TOLERANCE          = 109, 
....................     IBC_CMD_MODE_AUTO_CALIB             = 110, 
....................     IBC_CMD_MODE_FIXED_CALIB            = 111, 
....................  
....................  
....................     // Production Mode 
....................     IBC_CMD_MODE_PROD                   = 112, 
....................     IBC_CMD_START_PROD                  = 113, 
....................     IBC_CMD_PROD_WEIGH_DATA             = 114, 
....................  
....................     IBC_CMD_PROD_TARE_DATA              = 118, 
....................     IBC_CMD_PROD_AVG_WT_DATA            = 119, 
....................              
....................     IBC_CMD_PROD_INTMD_DATA             = 122 
....................              
....................              
.................... } EN_IBC_COMMANDS; 
....................  
.................... // Mode type 
.................... enum boardModeType 
.................... { 
....................     BOARD_MODE_TYPE_NOTHING         = 0, 
....................     BOARD_MODE_TYPE_HOME            = 1, 
....................     BOARD_MODE_TYPE_PRE_PRODUCTION  = 2, 
.................... 	BOARD_MODE_TYPE_PRODUCTION      = 3, 
....................     BOARD_MODE_TYPE_CONFIGURATION   = 4, 
....................     BOARD_MODE_TYPE_CALIBRATION     = 5 
.................... }; 
....................  
.................... // Mode action on Hardware 
.................... enum manualModeActionHW { 
....................     MANUAL_MODE_ACTION_ON_NOTHING               = 0, 
....................     MANUAL_MODE_ACTION_ON_COIL_STOPPER_UNIT_1   = 1, 
....................     MANUAL_MODE_ACTION_ON_COIL_STOPPER_UNIT_2   = 2, 
....................     MANUAL_MODE_ACTION_ON_GRIPPER_ARM_1         = 3, 
....................     MANUAL_MODE_ACTION_ON_GRIPPER_ARM_2         = 4, 
....................     MANUAL_MODE_ACTION_ON_ARCH_CHUTE            = 5, 
....................     MANUAL_MODE_ACTION_ON_SERVO                 = 6, 
....................  
.................... 	MANUAL_MODE_ACTION_ON_LA1                   = 7, 
....................     MANUAL_MODE_ACTION_ON_LA2                   = 8, 
....................     MANUAL_MODE_ACTION_ON_VFD                   = 9, 
....................     MANUAL_MODE_ACTION_ON_PNEUMATIC_DRIVE       = 10, 
....................      
....................     MANUAL_MODE_ACTION_ON_COIL_TRANSFER         = 11, 
....................     MANUAL_MODE_ACTION_ON_TUNION                = 12 
....................  
.................... }; 
....................  
.................... //typedef struct _ST_IBC_PROD_M_WEIGHT_DATA 
.................... //{ 
.................... //    int16 m_i16BoxCount; 
.................... //    int16 m_i16BoxWeight; 
.................... //} ST_IBC_PROD_M_WEIGHT_DATA; 
.................... typedef struct _ST_IBC_PROD_M_WEIGHT_DATA 
.................... { 
....................     unsigned int16 m_ui16BoxCount; 
....................     int16 m_i16BoxWeight; 
.................... } ST_IBC_PROD_M_WEIGHT_DATA; 
....................  
....................  
.................... typedef union _UN_IBC_PROD_M_WEIGHT_DATA 
.................... { 
....................     ST_IBC_PROD_M_WEIGHT_DATA m_stWeighingData; 
....................     unsigned int8             m_ui8Arr[4]; 
.................... } UN_IBC_PROD_M_WEIGHT_DATA; 
....................  
.................... typedef struct _ST_IBC_PROD_M_TARE_DATA 
.................... { 
....................     int16 m_i16Padding; 
....................     int16 m_i16TareData; 
.................... } ST_IBC_PROD_M_TARE_DATA; 
....................  
.................... typedef union _UN_IBC_PROD_M_TARE_DATA 
.................... { 
....................     ST_IBC_PROD_M_TARE_DATA m_stTareData; 
....................     unsigned int8           m_ui8Arr[4]; 
.................... } UN_IBC_PROD_M_TARE_DATA; 
....................  
.................... typedef struct _ST_IBC_AVG_WT_NODE 
.................... { 
....................     int16 m_i16AvgWt; 
....................     int16 m_i16Padding; 
.................... } ST_IBC_AVG_WT_NODE; 
....................  
.................... typedef union _UN_IBC_AVG_WT_NODE 
.................... { 
....................     ST_IBC_AVG_WT_NODE m_stIBCAvgNode; 
....................     unsigned int8      m_ui8Arr[4]; 
.................... } UN_IBC_AVG_WT_NODE; 
....................  
.................... typedef struct _ST_IBC_TOL_NODE 
.................... { 
....................     int16 m_i16PositiveTol; 
....................     int16 m_i16NegativeTol; 
.................... } ST_IBC_TOL_NODE; 
....................  
.................... typedef union _UN_IBC_TOLERANCE_NODE 
.................... { 
....................     ST_IBC_TOL_NODE m_stIBCTolNode; 
....................     unsigned int8   m_ui8Arr[4]; 
.................... }UN_IBC_TOLERANCE_NODE; 
....................  
....................  
.................... typedef struct _ST_IBC_RESET_CALIB_POINT 
.................... { 
....................     int16         m_i16CalibPoint; 
....................     int16         m_i16CurrCalibPoint; 
.................... } ST_IBC_RESET_CALIB_POINT; 
....................  
.................... typedef union _UN_IBC_RESET_CALIB_POINT 
.................... { 
....................     ST_IBC_RESET_CALIB_POINT m_stIBCResetCalibPoint; 
....................     unsigned int8            m_ui8Arr[4]; 
.................... } UN_IBC_RESET_CALIB_POINT; 
....................  
....................  
.................... typedef struct _ST_IBC_RESET_CALIB_POINT_ACK 
.................... { 
....................     int16         m_i16PassCount; 
....................     int16         m_i16CalibValue; 
.................... } ST_IBC_RESET_CALIB_POINT_ACK; 
....................  
.................... typedef union _UN_IBC_RESET_CALIB_POINT_ACK 
.................... { 
....................     ST_IBC_RESET_CALIB_POINT_ACK m_stIBCResetCalibPoint; 
....................     unsigned int8                m_ui8Arr[4]; 
.................... } UN_IBC_RESET_CALIB_POINT_ACK; 
....................  
.................... typedef struct _ST_IBC_RESET_CALIB_POINT_TARE 
.................... { 
....................     unsigned int32 m_ui32CalibADCForTare; 
.................... }ST_IBC_RESET_CALIB_POINT_TARE; 
....................  
.................... typedef union _UN_IBC_RESET_CALIB_POINT_TARE 
.................... { 
....................     ST_IBC_RESET_CALIB_POINT_TARE m_stIBCResetCalibTare; 
....................     unsigned int8                 m_ui8Arr[4]; 
.................... }UN_IBC_RESET_CALIB_POINT_TARE; 
....................  
.................... typedef struct _ST_IBC_RESET_CALIB_POINT_WEIGHT 
.................... { 
....................     unsigned int32 m_ui32CalibADCForWeight; 
.................... }ST_IBC_RESET_CALIB_POINT_WEIGHT; 
....................  
.................... typedef union _UN_IBC_RESET_CALIB_POINT_WEIGHT 
.................... { 
....................     ST_IBC_RESET_CALIB_POINT_WEIGHT m_stIBCResetCalibWeight; 
....................     unsigned int8                 m_ui8Arr[4]; 
.................... }UN_IBC_RESET_CALIB_POINT_WEIGHT; 
....................  
.................... // Send Current Average Weight from MCU0 to MCU1, for IBC_CMD_PROD_AVG_WT_DATA 
.................... typedef struct _ST_IBC_PROD_MODE_CUR_AVG 
.................... { 
....................     int16 m_i16CurAvg; 
....................     int16 m_i16Padding; 
.................... } ST_IBC_PROD_MODE_CUR_AVG; 
....................  
.................... typedef union _UN_IBC_PROD_MODE_CUR_AVG 
.................... { 
....................     ST_IBC_PROD_MODE_CUR_AVG m_stAvgData; 
....................     unsigned int8            m_ui8Arr[4]; 
.................... } UN_IBC_PROD_MODE_CUR_AVG; 
....................  
.................... typedef struct _ST_IBC_LOAD_CELL_FACTOR 
.................... { 
....................     unsigned int16 m_ui16CurrLoadCellFactor; 
....................     unsigned int16 m_ui16Padding; 
....................      
.................... }ST_IBC_LOAD_CELL_FACTOR; 
....................  
.................... typedef union _UN_IBC_LOAD_CELL_FACTOR 
.................... { 
....................     ST_IBC_LOAD_CELL_FACTOR     m_stLoadCellFactor; 
....................     unsigned int8               m_ui8Arr[4]; 
.................... }UN_IBC_LOAD_CELL_FACTOR; 
....................  
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //*****************************************************************************  
.................... boardModeType           g_boardModeType; 
.................... boardModeType           g_boardModeTypePre; 
.................... manualModeActionHW      g_manualModeActionOnHw; 
.................... unsigned int16          g_ui16DIStatus; 
.................... unsigned int16          g_ui16DOStatus; 
.................... unsigned int16          g_ui16ErrorStatus; 
.................... unsigned int8           g_ui8IncrementIndex; 
.................... int8                    g_fIBCSendLockStatus = IBC_SEND_UNLOCK; 
....................  
.................... UN_IBC_PROD_M_WEIGHT_DATA    g_unIBCProdModeWtData; 
.................... UN_IBC_PROD_M_TARE_DATA      g_unIBCProdModeTrData; 
.................... UN_IBC_AVG_WT_NODE           g_unIBCAvgNode; 
.................... UN_IBC_TOLERANCE_NODE        g_unIBCTolNode; 
.................... UN_IBC_RESET_CALIB_POINT     g_unIBCResetCalib; 
.................... UN_IBC_RESET_CALIB_POINT_ACK g_unIBCResetCalibAck; 
.................... UN_IBC_PROD_MODE_CUR_AVG     g_unIBCProdModeAvg; 
.................... UN_IBC_LOAD_CELL_FACTOR      g_unIBCCurrLoadCellFactor; 
.................... UN_IBC_RESET_CALIB_POINT_TARE g_unIBCResetCalibTare; 
.................... UN_IBC_RESET_CALIB_POINT_WEIGHT g_unIBCResetCalibWeight; 
....................  
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... // function for set mode as Nothing 
.................... void SetModeNothing(void) 
.................... { 
....................     g_boardModeTypePre  = g_boardModeType; 
....................     g_boardModeType     = BOARD_MODE_TYPE_NOTHING; 
.................... } 
....................  
.................... // function for check mode is Nothing or not 
.................... int8 IsModeNothing(void) 
.................... { 
....................     int8 bRetVal = 0; 
....................      
....................     if(g_boardModeType == BOARD_MODE_TYPE_NOTHING)  
....................     { 
....................         bRetVal = 1; 
....................     } 
....................      
....................     return bRetVal; 
.................... } 
....................  
.................... // function for set mode as WakeUp 
.................... void SetModeHome(void) 
.................... { 
....................     g_boardModeTypePre  = g_boardModeType; 
....................     g_boardModeType     = BOARD_MODE_TYPE_HOME; 
.................... } 
....................  
.................... // function for check mode is WakeUp or not 
.................... int8 IsModeHome(void) 
.................... { 
....................     int8 bRetVal = 0; 
....................      
....................     if(g_boardModeType == BOARD_MODE_TYPE_HOME)  
....................     { 
....................         bRetVal = 1; 
....................     } 
....................      
....................     return bRetVal; 
.................... } 
....................  
.................... // function for set mode as manual 
.................... void SetModeCalibration(void) 
.................... { 
....................     g_boardModeTypePre  = g_boardModeType; 
....................     g_boardModeType     = BOARD_MODE_TYPE_CALIBRATION; 
.................... } 
....................  
.................... // function for check mode is manual or not 
.................... int8 IsCalibrationMode(void) 
.................... { 
....................     int8 bRetVal = 0; 
....................      
....................     if(g_boardModeType == BOARD_MODE_TYPE_CALIBRATION)  
....................     { 
....................         bRetVal = 1; 
....................     } 
....................      
....................     return bRetVal; 
.................... } 
....................  
.................... // function for set mode as pre production 
.................... void SetModePreProduction() 
.................... { 
....................     g_boardModeTypePre  = g_boardModeType; 
....................     g_boardModeType     = BOARD_MODE_TYPE_PRE_PRODUCTION; 
.................... } 
....................  
.................... // function for check mode is pre production or not 
.................... int8 IsPreProductionMode(void) 
.................... { 
....................     int8 bRetVal = 0; 
....................      
....................     if(g_boardModeType == BOARD_MODE_TYPE_PRE_PRODUCTION)  
....................     { 
....................         bRetVal = 1; 
....................     } 
....................      
....................     return bRetVal; 
.................... } 
....................  
.................... // function for set mode as production 
.................... void SetModeProduction() 
.................... { 
....................     g_boardModeTypePre  = g_boardModeType; 
....................     g_boardModeType     = BOARD_MODE_TYPE_PRODUCTION; 
.................... } 
....................  
.................... // function for check mode is production or not 
.................... int8 IsProductionMode(void) 
.................... { 
....................     int8 bRetVal = 0; 
....................      
....................     if(g_boardModeType == BOARD_MODE_TYPE_PRODUCTION)  
....................     { 
....................         bRetVal = 1; 
....................     } 
....................      
....................     return bRetVal; 
.................... } 
....................  
.................... //// function for set mode as post production 
.................... //void SetModePostProduction() 
.................... //{ 
.................... //    g_boardModeTypePre  = g_boardModeType; 
.................... //    g_boardModeType     = BOARD_MODE_TYPE_POST_PRODUCTION; 
.................... //} 
.................... // 
.................... //// function for check mode is post production or not 
.................... //int8 IsPostProductionMode(void) 
.................... //{ 
.................... //    int8 bRetVal = 0; 
.................... //     
.................... //    if(g_boardModeType == BOARD_MODE_TYPE_POST_PRODUCTION)  
.................... //    { 
.................... //        bRetVal = 1; 
.................... //    } 
.................... //     
.................... //    return bRetVal; 
.................... //} 
....................  
.................... // function for set mode as configuration 
.................... void SetModeConfiguration(void) 
.................... { 
....................     g_boardModeTypePre  = g_boardModeType; 
....................     g_boardModeType     = BOARD_MODE_TYPE_CONFIGURATION; 
.................... } 
....................  
.................... // function for check mode is configuration or not 
.................... int8 IsConfigurationMode(void) 
.................... { 
....................     int8 bRetVal = 0; 
....................      
....................     if(g_boardModeType == BOARD_MODE_TYPE_CONFIGURATION)  
....................     { 
....................         bRetVal = 1; 
....................     } 
....................      
....................     return bRetVal; 
.................... } 
....................  
.................... #endif /* _VM_IBC_GOBAL_H_ */ 
....................  
....................  
.................... #define IBC_MSG_BYTE_COUNT                       5 
.................... #define IBC_DATA_BITS_LENGTH                     10 
.................... #define IBC_DATA_BYTES_LENGTH                    10 
.................... #define IBC_BOARD_ID                             1 
....................  
.................... #define IBC_BAUD_RATE_9600                       20 
.................... #define IBC_BAUD_RATE_19200                      21 
....................  
.................... #define T1_DIV_PRESCALE                          T1_DIV_BY_8 
.................... #define T3_DIV_PRESCALE                          T3_DIV_BY_8 
....................  
.................... #define IBC_TX_1_BT_LOAD_VALUE_9600              (0xFFFF - 0x0041 + 1) 
.................... #define IBC_TX_1_BT_LOAD_VALUE_19200             (0xFFFF - 0x0021 + 1) 
....................  
.................... #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL_9600       (0xFFFF - 0x0062 + 1) // For 9600 
.................... #define IBC_RX_BIT_TIME_T1LOAD_VAL_9600           (0xFFFF - 0x0041 + 1) // For 9600 
....................  
.................... #ifdef M1_COMM_MODULE 
....................     #define IBC_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)  // 78us Instead of 104us we load 91.2 for per bit time. 
.................... #else 
....................     #define IBC_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)//   IBC_RX_BIT_TIME_T1LOAD_VAL_9600  // 104 us 
.................... #endif 
.................... //#define IBC_RX_1_BT_CUSTOMISED_VAL_9600           (0xFFFF - 0x0031 + 1)  // Instead of 104us we load 78 us for per bit time. 
.................... #define IBC_RX_BIT_TIME_1_2_T1LOAD_VAL_9600       (0xFFFF - 0x004E + 1) 
.................... #define IBC_RX_BIT_TIME_1_3_T1LOAD_VAL_9600       (0xFFFF - 0x0051 + 1) 
.................... #define IBC_RX_BIT_TIME_1_4_T1LOAD_VAL_9600       (0xFFFF - 0x005B + 1) 
....................  
....................  
.................... #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL_19200     (0xFFFF - 0x0031 + 1) // For 19200 
.................... #define IBC_RX_BIT_TIME_T1LOAD_VAL_19200         (0xFFFF - 0x0041 + 1) // For 19200 
....................  
.................... #define SIZE_IBC_SEND_BYTE_SEGMENT                15  //1+3+8+3, 1 Start Bit, 3 Sequence Bits, 8 bits of Data and 3 Stop Bits; Total 15bits in one segment/ custised byte 
....................  
.................... #define IBC_TIMER_0_CRITICAL_ON                   0 
.................... #define IBC_TIMER_0_CRITICAL_OFF                  1 
....................  
.................... //***************************************************************************** 
.................... // Below -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
.................... typedef struct _ST_INT_BOARD_ALL_BITS 
.................... { 
....................     unsigned int8 m_ui1IBCRcvbit_0: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_1: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_2: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_3: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_4: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_5: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_6: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_7: 1; 
.................... } ST_INT_BOARD_ALL_BITS; 
....................  
.................... //typedef union _UN_INT_BOARD_BYTE_TYPE 
.................... //{ 
.................... //    unsigned int8          m_ui8Byte; 
.................... //    ST_INT_BOARD_ALL_BITS  m_stByte; 
.................... //    char				   m_chData;	 
.................... //} UN_INT_BOARD_BYTE_TYPE; 
....................  
.................... typedef struct _ST_INT_BOARD_DATA 
.................... { 
....................     char 			m_boardData[IBC_DATA_BITS_LENGTH]; 
....................     unsigned int8  	m_boardID; 
.................... } ST_INT_BOARD_DATA; 
....................  
....................  
.................... //***************************************************************************** 
.................... // Above -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Interboard Communication  RX #  From M1_COMM ********************** 
.................... //***************************************************************************** 
....................  
.................... // Below -> Multiple Baud Rate Settings. 
....................  
.................... #ifdef IBC_BOUD_RATE_1000 
....................     #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL   (0xFFFF - 0x0EA6 + 1) 
....................     #define IBC_RX_BIT_TIME_T1LOAD_VAL       (0xFFFF - 0x09C4 + 1) 
.................... #endif 
....................  
.................... #ifdef IBC_BOUD_RATE_9600 
....................     #define IBC_RX_TIME_DELAY_1_5_BIT           156  
....................     #define IBC_RX_TIME_DELAY_1_BIT             104 
....................     #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL   (0xFFFF - 0x0062 + 1) 
....................     #define IBC_RX_BIT_TIME_T1LOAD_VAL       (0xFFFF - 0x0041 + 1) 
.................... #endif 
....................  
.................... #ifdef IBC_BOUD_RATE_19200 
....................     #define IBC_RX_TIME_DELAY_1_5_VAL           78  
....................     #define IBC_RX_TIME_DELAY_1_VAL             52 
....................     #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL   (0xFFFF - 0x0031 + 1) 
....................     #define IBC_RX_BIT_TIME_T1LOAD_VAL       (0xFFFF - 0x0021 + 1) 
.................... #endif 
....................  
.................... // Above -> Multiple Baud Rate Settings. 
....................  
.................... // Initialize IBC Data Set, Should be called from main()) 
.................... //void InitIBCDataSet() 
.................... //{ 
.................... //    g_unTempRxData1.m_uiByte = 0; 
.................... //} 
....................  
.................... typedef struct _ST_IBC_RCV_BYTE_NODE 
.................... { 
....................  
....................     unsigned int8 m_ui8SeqBit0 :1; 
....................     unsigned int8 m_ui8SeqBit1 :1; 
....................     unsigned int8 m_ui8SeqBit2 :1; 
....................     unsigned int8 m_ui8Padding :5; 
....................      
....................     unsigned int8 m_ui8DataBit0 :1; 
....................     unsigned int8 m_ui8DataBit1 :1; 
....................     unsigned int8 m_ui8DataBit2 :1; 
....................     unsigned int8 m_ui8DataBit3 :1; 
....................     unsigned int8 m_ui8DataBit4 :1; 
....................     unsigned int8 m_ui8DataBit5 :1; 
....................     unsigned int8 m_ui8DataBit6 :1; 
....................     unsigned int8 m_ui8DataBit7 :1; 
.................... } ST_IBC_RCV_BYTE_NODE; 
....................  
.................... typedef union _UN_IBC_RCV_BYTE_NODE 
.................... { 
....................     ST_IBC_RCV_BYTE_NODE m_stIBCNode; 
....................     unsigned int8        m_ui8Arr[2]; 
.................... } UN_IBC_RCV_BYTE_NODE; 
....................  
....................  
....................  
.................... typedef struct _ST_IBC_DATA_NODE 
.................... { 
....................     unsigned int8 g_ui8ArrIBCData[IBC_MSG_BYTE_COUNT]; 
.................... } ST_IBC_DATA_NODE; 
....................  
.................... #define SIZE_IBC_DATA_SEND_QUEUE 15 
....................  
.................... //typedef struct _ST_IBC_DATA_SEND_QUEUE 
.................... //{ 
.................... //    ST_IBC_DATA_NODE m_stArrIBCDataNode[SIZE_IBC_DATA_SEND_QUEUE]; 
.................... //    int8             m_i8Front; 
.................... //    int8             m_i8Rear; 
.................... //} ST_IBC_DATA_SEND_QUEUE; 
....................  
.................... typedef struct _ST_IBC_MSG_QUEUE 
.................... { 
....................     ST_IBC_DATA_NODE m_stArrIBCDataNode[SIZE_IBC_DATA_SEND_QUEUE]; 
....................     int8             m_i8Front; 
....................     int8             m_i8Rear; 
.................... } ST_IBC_MSG_QUEUE; 
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... //UN_INT_BOARD_BYTE_TYPE    g_unIBCRcvData; 
.................... unsigned int8             g_ui8IBCRcvBitCount = 0; 
.................... unsigned int8             g_ui8IBCTxBitCount  = 0; 
....................  
.................... // TESTING 
.................... unsigned int8             g_ui8IBCDataToSend = 0xA5; 
.................... unsigned int8             g_fIBCCommStatus   = 0; 
....................  
.................... ST_IBC_DATA_NODE          g_stIBCRcvData; 
.................... ST_IBC_DATA_NODE          g_stIBCSendData; 
.................... unsigned int8             g_ui8ArrSendSingleMSG[IBC_MSG_BYTE_COUNT*(SIZE_IBC_SEND_BYTE_SEGMENT)] = {0}; // 
.................... unsigned int8             g_fIBCDataReceived = 0; 
....................  
.................... //ST_IBC_DATA_SEND_QUEUE    g_stIBCDataSendQueue; 
.................... unsigned int8             g_fIBCSendBusy = 0; 
.................... UN_IBC_RCV_BYTE_NODE      g_unIBCRcvByteNode; 
....................  
.................... ST_IBC_MSG_QUEUE          g_stIBCSendQueue; 
.................... ST_IBC_MSG_QUEUE          g_stIBCRcvQueue; 
....................  
.................... unsigned int8             g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... ////////// 
.................... //////////void InitializeDataSendQueue() 
.................... //////////{ 
.................... //////////    int iLoopCount1 = 0; 
.................... //////////    int iLoopCount2 = 0; 
.................... //////////    g_stIBCDataSendQueue.m_i8Front = g_stIBCDataSendQueue.m_i8Rear = -1; 
.................... //////////     
.................... //////////    for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBC_DATA_SEND_QUEUE; iLoopCount1++) 
.................... //////////    { 
.................... //////////        for (iLoopCount2 = 0; iLoopCount2 < IBC_MSG_BYTE_COUNT; iLoopCount2++) 
.................... //////////        { 
.................... //////////           g_stIBCDataSendQueue.m_stArrIBCDataNode[iLoopCount1].g_ui8ArrIBCData[iLoopCount2] = 0; 
.................... //////////        } 
.................... //////////    } 
.................... //////////} 
.................... ////////// 
.................... //////////void CopySendData(int8 i8Location, ST_IBC_DATA_NODE* pstIBCData) 
.................... //////////{ 
.................... //////////    int8 i8LoopCount = 0; 
.................... //////////     
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        g_stIBCDataSendQueue.m_stArrIBCDataNode[i8Location].g_ui8ArrIBCData[i8LoopCount] = pstIBCData->g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////    } 
.................... //////////} 
.................... ////////// 
.................... //////////void CopyFromSendQueue(int8 i8Location, ST_IBC_DATA_NODE** ppstIBCData) 
.................... //////////{ 
.................... //////////    int8 i8LoopCount = 0; 
.................... //////////     
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        *ppstIBCData->g_ui8ArrIBCData[i8LoopCount] = g_stIBCDataSendQueue.m_stArrIBCDataNode[i8Location].g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////    } 
.................... //////////} 
.................... /* Function to create Circular queue */ 
.................... //////////void InsertSendQueue(ST_IBC_DATA_NODE* pstIBCData)  
.................... //////////{ 
.................... //////////    if (!pstIBCData) 
.................... //////////    { 
.................... //////////        return; 
.................... //////////    } 
.................... //////////     
.................... //////////    if ((g_stIBCDataSendQueue.m_i8Front == 0 && g_stIBCDataSendQueue.m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1) ||  
.................... //////////            (g_stIBCDataSendQueue.m_i8Front == g_stIBCDataSendQueue.m_i8Rear + 1))  
.................... //////////    {  
.................... //////////        //printf("\nQueue is Full");  
.................... //////////        return;  
.................... //////////    } 
.................... //////////   
.................... //////////    else if (g_stIBCDataSendQueue.m_i8Front == -1) /* Insert First Element */ 
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Front = g_stIBCDataSendQueue.m_i8Rear = 0; 
.................... //////////         
.................... //////////        // Insert Data 
.................... //////////        //arr[g_stIBCDataSendQueue.m_i8Rear] = value; 
.................... //////////        CopySendData(g_stIBCDataSendQueue.m_i8Rear, pstIBCData); 
.................... //////////    }  
.................... //////////   
.................... //////////    else if (g_stIBCDataSendQueue.m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1 && g_stIBCDataSendQueue.m_i8Front != 0)  
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Rear = 0;  
.................... //////////        CopySendData(g_stIBCDataSendQueue.m_i8Rear, pstIBCData);  
.................... //////////    }  
.................... //////////   
.................... //////////    else 
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Rear++;  
.................... //////////        CopySendData(g_stIBCDataSendQueue.m_i8Rear, pstIBCData); 
.................... //////////    }  
.................... //////////}  
....................  
.................... //////////void DeleteQueue(ST_IBC_DATA_NODE* pstIBCData)  
.................... //////////{  
.................... //////////    int8 i8LoopCount = 0; 
.................... ////////// 
.................... //////////    if (g_stIBCDataSendQueue.m_i8Front == -1) 
.................... //////////    {  
.................... //////////        //printf("\nQueue is Empty");  
.................... //////////        return;  
.................... //////////    }  
.................... //////////   
.................... //////////    //int data = arr[g_stIBCDataSendQueue.m_i8Front]; 
.................... //////////    //CopyFromSendQueue(g_stIBCDataSendQueue.m_i8Front, &pstIBCData); 
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        pstIBCData->g_ui8ArrIBCData[i8LoopCount] = g_stIBCDataSendQueue.m_stArrIBCDataNode[g_stIBCDataSendQueue.m_i8Front].g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////    } 
.................... //////////     
.................... //////////    //arr[g_stIBCDataSendQueue.m_i8Front] = -1;  
.................... //////////    if (g_stIBCDataSendQueue.m_i8Front == g_stIBCDataSendQueue.m_i8Rear)  
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Front = -1;  
.................... //////////        g_stIBCDataSendQueue.m_i8Rear = -1;  
.................... //////////    }  
.................... //////////    else if (g_stIBCDataSendQueue.m_i8Front == SIZE_IBC_DATA_SEND_QUEUE-1)  
.................... //////////        g_stIBCDataSendQueue.m_i8Front = 0;  
.................... //////////    else 
.................... //////////        g_stIBCDataSendQueue.m_i8Front++;  
.................... //////////   
.................... //////////    return; 
.................... //////////}  
.................... ////////// 
.................... //////////int8 IsMSGAvailableInIBCSendQueue() 
.................... //////////{ 
.................... //////////    if (g_stIBCDataSendQueue.m_i8Front == -1) 
.................... //////////    { 
.................... //////////        return 0; 
.................... //////////    } 
.................... //////////     
.................... //////////    return 1; 
.................... //////////} 
.................... ////////// 
.................... //////////void SendIBCMSG() 
.................... //////////{ 
.................... //////////    int8          i8LoopCount    = 0; 
.................... //////////    unsigned int8 ui8Sequence    = 0; 
.................... //////////    unsigned int8 ui8TempData    = 0; 
.................... //////////     
.................... //////////    // Initialize the Send Array 
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount] = 0; 
.................... //////////    } 
.................... ////////// 
.................... //////////    // Get Node from Queue 
.................... //////////    DeleteQueue(&g_stIBCSendData); 
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        // Step 1: First Stuff 1 Start Bit 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 0] = 0;   // Start Bit Always 0 
.................... //////////         
.................... //////////        // Step 2: Now Stuff 3 bit Message Byte Sequence Number 
.................... //////////         
.................... //////////        // Stuff the 1st Sequence Bit 
.................... //////////        ui8Sequence = i8LoopCount; 
.................... //////////        ui8Sequence = ui8Sequence << 7; 
.................... //////////        ui8Sequence = ui8Sequence >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 1] = ui8Sequence; 
.................... //////////         
.................... //////////        // Stuff the 2nd Sequence Bit  
.................... //////////        ui8Sequence = i8LoopCount; 
.................... //////////        ui8Sequence = ui8Sequence << 6; 
.................... //////////        ui8Sequence = ui8Sequence >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 2] = ui8Sequence; 
.................... //////////         
.................... //////////        // Stuff the 3rd Bit 
.................... //////////        ui8Sequence = i8LoopCount; 
.................... //////////        ui8Sequence = ui8Sequence << 5; 
.................... //////////        ui8Sequence = ui8Sequence >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 3] = ui8Sequence; 
.................... //////////         
.................... //////////        // Step 3: Now Stuff 8 bit Data 
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 7; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 4] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 6; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 5] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 5; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 6] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 4; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 7] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 3; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 8] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 2; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 9] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 1; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 10] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 11] = ui8TempData; 
.................... //////////         
.................... //////////        // Step 4: Stuff three Stop Bits 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 12] = 1;  // Stop bit is 1 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 13] = 1; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 14] = 1; 
.................... //////////    } 
.................... //////////     
.................... //////////    // So message stuffing is done now start the send timer 
.................... //////////    // Initialize send counter. 
.................... //////////    g_ui8IBCTxBitCount = 0; 
.................... //////////     
.................... //////////    // TESTING Start 
.................... ////////////    g_ui8ArrSendSingleMSG[0] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[1] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[2] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[3] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[4] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[5] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[6] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[7] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[8] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[9] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[10] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[11] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[12] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[13] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[14] = 1;     
.................... //////////    // TESTING End 
.................... //////////     
.................... //////////    // Start Timer3 that handle bit by bit sending. 
.................... //////////    // Set Timer3 as per Bit Time Value. 
.................... //////////    setup_timer_3(T3_INTERNAL | T3_DIV_PRESCALE); 
.................... //////////    set_timer3(IBC_TX_1_BT_LOAD_VALUE_9600); 
.................... //////////     
.................... //////////    clear_interrupt(INT_TIMER3); 
.................... //////////    enable_interrupts(INT_TIMER3); 
.................... //////////} 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving START /////////////// 
....................  
.................... void InitializeDataQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue) 
*
005DC:  MOVLB  A
005DE:  CLRF   xAE
005E0:  CLRF   xAF
.................... { 
....................     int iLoopCount1 = 0; 
....................     int iLoopCount2 = 0; 
....................     pstIBCMSGQueue->m_i8Front = pstIBCMSGQueue->m_i8Rear = -1; 
005E2:  MOVLW  4B
005E4:  ADDWF  xAC,W
005E6:  MOVWF  01
005E8:  MOVLW  00
005EA:  ADDWFC xAD,W
005EC:  MOVWF  03
005EE:  MOVLW  4C
005F0:  ADDWF  xAC,W
005F2:  MOVWF  FE9
005F4:  MOVLW  00
005F6:  ADDWFC xAD,W
005F8:  MOVWF  FEA
005FA:  SETF   FEF
005FC:  MOVLW  FF
005FE:  MOVFF  03,FEA
00602:  MOVFF  01,FE9
00606:  MOVWF  FEF
....................      
....................     for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBC_DATA_SEND_QUEUE; iLoopCount1++) 
00608:  CLRF   xAE
0060A:  MOVF   xAE,W
0060C:  SUBLW  0E
0060E:  BTFSS  FD8.0
00610:  GOTO   065E
....................     { 
....................         for (iLoopCount2 = 0; iLoopCount2 < IBC_MSG_BYTE_COUNT; iLoopCount2++) 
00614:  CLRF   xAF
00616:  MOVF   xAF,W
00618:  SUBLW  04
0061A:  BTFSS  FD8.0
0061C:  GOTO   0658
....................         { 
....................            pstIBCMSGQueue->m_stArrIBCDataNode[iLoopCount1].g_ui8ArrIBCData[iLoopCount2] = 0; 
00620:  CLRF   xC8
00622:  MOVFF  AAE,AC7
00626:  CLRF   xCA
00628:  MOVLW  05
0062A:  MOVWF  xC9
0062C:  MOVLB  0
0062E:  CALL   05BA
00632:  MOVFF  01,AB0
00636:  MOVLB  A
00638:  MOVF   xAF,W
0063A:  ADDWF  01,W
0063C:  MOVWF  01
0063E:  MOVLW  00
00640:  ADDWFC 02,W
00642:  MOVWF  03
00644:  MOVF   01,W
00646:  ADDWF  xAC,W
00648:  MOVWF  FE9
0064A:  MOVF   xAD,W
0064C:  ADDWFC 03,W
0064E:  MOVWF  FEA
00650:  CLRF   FEF
00652:  INCF   xAF,F
00654:  GOTO   0616
....................         } 
00658:  INCF   xAE,F
0065A:  GOTO   060A
....................     } 
0065E:  MOVLB  0
00660:  RETURN 0
.................... } 
....................  
.................... void CopyIBCMsg(ST_IBC_DATA_NODE* pstIBCSource, ST_IBC_DATA_NODE* pstIBCDDest) 
*
010EC:  MOVLB  A
010EE:  CLRF   xC1
.................... { 
....................     int8 i8LoopCount = 0; 
....................      
....................     for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
010F0:  CLRF   xC1
010F2:  MOVF   xC1,W
010F4:  SUBLW  04
010F6:  BTFSS  FD8.0
010F8:  GOTO   112A
....................     { 
....................         pstIBCDDest->g_ui8ArrIBCData[i8LoopCount] = pstIBCSource->g_ui8ArrIBCData[i8LoopCount]; 
010FC:  MOVF   xC1,W
010FE:  ADDWF  xBF,W
01100:  MOVWF  01
01102:  MOVLW  00
01104:  ADDWFC xC0,W
01106:  MOVWF  03
01108:  MOVF   xC1,W
0110A:  ADDWF  xBD,W
0110C:  MOVWF  FE9
0110E:  MOVLW  00
01110:  ADDWFC xBE,W
01112:  MOVWF  FEA
01114:  MOVFF  FEF,AC4
01118:  MOVFF  03,FEA
0111C:  MOVFF  01,FE9
01120:  MOVFF  AC4,FEF
01124:  INCF   xC1,F
01126:  GOTO   10F2
....................     } 
0112A:  MOVLB  0
0112C:  RETURN 0
.................... } 
....................  
.................... /* Function to create Circular queue */ 
.................... void InsertIBCMsgQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue, ST_IBC_DATA_NODE* pstIBCData)  
.................... { 
....................     if (!pstIBCData) 
0112E:  MOVLB  A
01130:  MOVF   xB9,W
01132:  IORWF  xBA,W
01134:  BTFSS  FD8.2
01136:  GOTO   113E
....................     { 
....................         return; 
0113A:  GOTO   131E
....................     } 
....................      
....................     if ((pstIBCMSGQueue->m_i8Front == 0 && pstIBCMSGQueue->m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1) ||  
....................             (pstIBCMSGQueue->m_i8Rear == (pstIBCMSGQueue->m_i8Front-1)%(SIZE_IBC_DATA_SEND_QUEUE-1)))  
0113E:  MOVLW  4B
01140:  ADDWF  xB7,W
01142:  MOVWF  FE9
01144:  MOVLW  00
01146:  ADDWFC xB8,W
01148:  MOVWF  FEA
0114A:  MOVF   FEF,F
0114C:  BTFSS  FD8.2
0114E:  GOTO   1168
01152:  MOVLW  4C
01154:  ADDWF  xB7,W
01156:  MOVWF  FE9
01158:  MOVLW  00
0115A:  ADDWFC xB8,W
0115C:  MOVWF  FEA
0115E:  MOVF   FEF,W
01160:  SUBLW  0E
01162:  BTFSC  FD8.2
01164:  GOTO   11A2
01168:  MOVLW  4C
0116A:  ADDWF  xB7,W
0116C:  MOVWF  FE9
0116E:  MOVLW  00
01170:  ADDWFC xB8,W
01172:  MOVWF  FEA
01174:  MOVFF  FEF,ABB
01178:  MOVLW  4B
0117A:  ADDWF  xB7,W
0117C:  MOVWF  FE9
0117E:  MOVLW  00
01180:  ADDWFC xB8,W
01182:  MOVWF  FEA
01184:  MOVLW  01
01186:  SUBWF  FEF,W
01188:  MOVWF  xBD
0118A:  MOVWF  xBE
0118C:  MOVLW  0E
0118E:  MOVWF  xBF
01190:  MOVLB  0
01192:  GOTO   10B6
01196:  MOVF   00,W
01198:  MOVLB  A
0119A:  SUBWF  xBB,W
0119C:  BTFSS  FD8.2
0119E:  GOTO   11AA
....................     {  
....................         //printf("\nQueue is Full");  
....................         return; 
011A2:  GOTO   131E
....................     } 
011A6:  GOTO   131E
....................    
....................     else if (pstIBCMSGQueue->m_i8Front == -1) /* Insert First Element */ 
011AA:  MOVLW  4B
011AC:  ADDWF  xB7,W
011AE:  MOVWF  FE9
011B0:  MOVLW  00
011B2:  ADDWFC xB8,W
011B4:  MOVWF  FEA
011B6:  MOVF   FEF,W
011B8:  SUBLW  FF
011BA:  BTFSS  FD8.2
011BC:  GOTO   1238
....................     {  
....................         pstIBCMSGQueue->m_i8Front = pstIBCMSGQueue->m_i8Rear = 0; 
011C0:  MOVLW  4B
011C2:  ADDWF  xB7,W
011C4:  MOVWF  01
011C6:  MOVLW  00
011C8:  ADDWFC xB8,W
011CA:  MOVWF  03
011CC:  MOVLW  4C
011CE:  ADDWF  xB7,W
011D0:  MOVWF  FE9
011D2:  MOVLW  00
011D4:  ADDWFC xB8,W
011D6:  MOVWF  FEA
011D8:  CLRF   FEF
011DA:  MOVLW  00
011DC:  MOVFF  03,FEA
011E0:  MOVFF  01,FE9
011E4:  MOVWF  FEF
....................          
....................         // Insert Data 
....................         //arr[g_stIBCDataSendQueue.m_i8Rear] = value; 
....................         CopyIBCMsg(pstIBCData, &(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Rear])); 
011E6:  MOVLW  4C
011E8:  ADDWF  xB7,W
011EA:  MOVWF  FE9
011EC:  MOVLW  00
011EE:  ADDWFC xB8,W
011F0:  MOVWF  FEA
011F2:  CLRF   xC8
011F4:  MOVFF  FEF,AC7
011F8:  CLRF   xCA
011FA:  MOVLW  05
011FC:  MOVWF  xC9
011FE:  MOVLB  0
01200:  CALL   05BA
01204:  MOVFF  02,03
01208:  MOVF   01,W
0120A:  MOVLB  A
0120C:  ADDWF  xB7,W
0120E:  MOVWF  01
01210:  MOVF   xB8,W
01212:  ADDWFC 03,F
01214:  MOVFF  01,ABB
01218:  MOVFF  03,ABC
0121C:  MOVFF  ABA,ABE
01220:  MOVFF  AB9,ABD
01224:  MOVFF  03,AC0
01228:  MOVFF  01,ABF
0122C:  MOVLB  0
0122E:  CALL   10EC
....................     }  
01232:  GOTO   131C
01236:  MOVLB  A
....................    
....................     else if (pstIBCMSGQueue->m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1 && pstIBCMSGQueue->m_i8Front != 0)  
01238:  MOVLW  4C
0123A:  ADDWF  xB7,W
0123C:  MOVWF  FE9
0123E:  MOVLW  00
01240:  ADDWFC xB8,W
01242:  MOVWF  FEA
01244:  MOVF   FEF,W
01246:  SUBLW  0E
01248:  BTFSS  FD8.2
0124A:  GOTO   12C2
0124E:  MOVLW  4B
01250:  ADDWF  xB7,W
01252:  MOVWF  FE9
01254:  MOVLW  00
01256:  ADDWFC xB8,W
01258:  MOVWF  FEA
0125A:  MOVF   FEF,F
0125C:  BTFSC  FD8.2
0125E:  GOTO   12C2
....................     {  
....................         pstIBCMSGQueue->m_i8Rear = 0;  
01262:  MOVLW  4C
01264:  ADDWF  xB7,W
01266:  MOVWF  FE9
01268:  MOVLW  00
0126A:  ADDWFC xB8,W
0126C:  MOVWF  FEA
0126E:  CLRF   FEF
....................         CopyIBCMsg(pstIBCData, &(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Rear])); 
01270:  MOVLW  4C
01272:  ADDWF  xB7,W
01274:  MOVWF  FE9
01276:  MOVLW  00
01278:  ADDWFC xB8,W
0127A:  MOVWF  FEA
0127C:  CLRF   xC8
0127E:  MOVFF  FEF,AC7
01282:  CLRF   xCA
01284:  MOVLW  05
01286:  MOVWF  xC9
01288:  MOVLB  0
0128A:  CALL   05BA
0128E:  MOVFF  02,03
01292:  MOVF   01,W
01294:  MOVLB  A
01296:  ADDWF  xB7,W
01298:  MOVWF  01
0129A:  MOVF   xB8,W
0129C:  ADDWFC 03,F
0129E:  MOVFF  01,ABB
012A2:  MOVFF  03,ABC
012A6:  MOVFF  ABA,ABE
012AA:  MOVFF  AB9,ABD
012AE:  MOVFF  03,AC0
012B2:  MOVFF  01,ABF
012B6:  MOVLB  0
012B8:  CALL   10EC
....................     }  
012BC:  GOTO   131C
012C0:  MOVLB  A
....................    
....................     else 
....................     {  
....................         pstIBCMSGQueue->m_i8Rear++;  
012C2:  MOVLW  4C
012C4:  ADDWF  xB7,W
012C6:  MOVWF  FE9
012C8:  MOVLW  00
012CA:  ADDWFC xB8,W
012CC:  MOVWF  FEA
012CE:  INCF   FEF,F
....................         CopyIBCMsg(pstIBCData, &(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Rear])); 
012D0:  MOVLW  4C
012D2:  ADDWF  xB7,W
012D4:  MOVWF  FE9
012D6:  MOVLW  00
012D8:  ADDWFC xB8,W
012DA:  MOVWF  FEA
012DC:  CLRF   xC8
012DE:  MOVFF  FEF,AC7
012E2:  CLRF   xCA
012E4:  MOVLW  05
012E6:  MOVWF  xC9
012E8:  MOVLB  0
012EA:  CALL   05BA
012EE:  MOVFF  02,03
012F2:  MOVF   01,W
012F4:  MOVLB  A
012F6:  ADDWF  xB7,W
012F8:  MOVWF  01
012FA:  MOVF   xB8,W
012FC:  ADDWFC 03,F
012FE:  MOVFF  01,ABB
01302:  MOVFF  03,ABC
01306:  MOVFF  ABA,ABE
0130A:  MOVFF  AB9,ABD
0130E:  MOVFF  03,AC0
01312:  MOVFF  01,ABF
01316:  MOVLB  0
01318:  CALL   10EC
0131C:  MOVLB  A
....................     }  
0131E:  MOVLB  0
01320:  RETURN 0
.................... }  
....................  
.................... void DeleteIBCMsgQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue, ST_IBC_DATA_NODE* pstIBCData)  
.................... { 
....................     if (pstIBCMSGQueue->m_i8Front == -1) 
*
019D2:  MOVLW  4B
019D4:  MOVLB  A
019D6:  ADDWF  xB1,W
019D8:  MOVWF  FE9
019DA:  MOVLW  00
019DC:  ADDWFC xB2,W
019DE:  MOVWF  FEA
019E0:  MOVF   FEF,W
019E2:  SUBLW  FF
019E4:  BTFSS  FD8.2
019E6:  GOTO   19EE
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
019EA:  GOTO   1AB8
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBCMsg(&(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Front]), pstIBCData); 
019EE:  MOVLW  4B
019F0:  ADDWF  xB1,W
019F2:  MOVWF  FE9
019F4:  MOVLW  00
019F6:  ADDWFC xB2,W
019F8:  MOVWF  FEA
019FA:  CLRF   xC8
019FC:  MOVFF  FEF,AC7
01A00:  CLRF   xCA
01A02:  MOVLW  05
01A04:  MOVWF  xC9
01A06:  MOVLB  0
01A08:  CALL   05BA
01A0C:  MOVFF  02,03
01A10:  MOVF   01,W
01A12:  MOVLB  A
01A14:  ADDWF  xB1,W
01A16:  MOVWF  01
01A18:  MOVF   xB2,W
01A1A:  ADDWFC 03,F
01A1C:  MOVFF  01,AB5
01A20:  MOVFF  03,AB6
01A24:  MOVFF  03,ABE
01A28:  MOVFF  01,ABD
01A2C:  MOVFF  AB4,AC0
01A30:  MOVFF  AB3,ABF
01A34:  MOVLB  0
01A36:  CALL   10EC
....................  
....................     if (pstIBCMSGQueue->m_i8Front == pstIBCMSGQueue->m_i8Rear)  
01A3A:  MOVLW  4B
01A3C:  MOVLB  A
01A3E:  ADDWF  xB1,W
01A40:  MOVWF  FE9
01A42:  MOVLW  00
01A44:  ADDWFC xB2,W
01A46:  MOVWF  FEA
01A48:  MOVFF  FEF,AB5
01A4C:  MOVLW  4C
01A4E:  ADDWF  xB1,W
01A50:  MOVWF  FE9
01A52:  MOVLW  00
01A54:  ADDWFC xB2,W
01A56:  MOVWF  FEA
01A58:  MOVF   FEF,W
01A5A:  SUBWF  xB5,W
01A5C:  BTFSS  FD8.2
01A5E:  GOTO   1A82
....................     {  
....................         pstIBCMSGQueue->m_i8Front = -1;  
01A62:  MOVLW  4B
01A64:  ADDWF  xB1,W
01A66:  MOVWF  FE9
01A68:  MOVLW  00
01A6A:  ADDWFC xB2,W
01A6C:  MOVWF  FEA
01A6E:  SETF   FEF
....................         pstIBCMSGQueue->m_i8Rear = -1;  
01A70:  MOVLW  4C
01A72:  ADDWF  xB1,W
01A74:  MOVWF  FE9
01A76:  MOVLW  00
01A78:  ADDWFC xB2,W
01A7A:  MOVWF  FEA
01A7C:  SETF   FEF
....................     }  
01A7E:  GOTO   1AB8
....................     else if (pstIBCMSGQueue->m_i8Front == SIZE_IBC_DATA_SEND_QUEUE-1)  
01A82:  MOVLW  4B
01A84:  ADDWF  xB1,W
01A86:  MOVWF  FE9
01A88:  MOVLW  00
01A8A:  ADDWFC xB2,W
01A8C:  MOVWF  FEA
01A8E:  MOVF   FEF,W
01A90:  SUBLW  0E
01A92:  BTFSS  FD8.2
01A94:  GOTO   1AAA
....................         pstIBCMSGQueue->m_i8Front = 0;  
01A98:  MOVLW  4B
01A9A:  ADDWF  xB1,W
01A9C:  MOVWF  FE9
01A9E:  MOVLW  00
01AA0:  ADDWFC xB2,W
01AA2:  MOVWF  FEA
01AA4:  CLRF   FEF
01AA6:  GOTO   1AB8
....................     else 
....................         pstIBCMSGQueue->m_i8Front++;  
01AAA:  MOVLW  4B
01AAC:  ADDWF  xB1,W
01AAE:  MOVWF  FE9
01AB0:  MOVLW  00
01AB2:  ADDWFC xB2,W
01AB4:  MOVWF  FEA
01AB6:  INCF   FEF,F
....................    
....................     return; 
01AB8:  MOVLB  0
01ABA:  RETURN 0
.................... } 
....................  
....................  
.................... int8 IsMSGInIBCQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue) 
.................... { 
....................     if (pstIBCMSGQueue->m_i8Front == -1) 
*
019AA:  MOVLW  4B
019AC:  MOVLB  A
019AE:  ADDWF  xAB,W
019B0:  MOVWF  FE9
019B2:  MOVLW  00
019B4:  ADDWFC xAC,W
019B6:  MOVWF  FEA
019B8:  MOVF   FEF,W
019BA:  SUBLW  FF
019BC:  BTFSS  FD8.2
019BE:  GOTO   19CA
....................     { 
....................         return 0; 
019C2:  MOVLW  00
019C4:  MOVWF  01
019C6:  GOTO   19CE
....................     } 
....................      
....................     return 1; 
019CA:  MOVLW  01
019CC:  MOVWF  01
019CE:  MOVLB  0
019D0:  RETURN 0
.................... } 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving END ///////////////// 
.................... void SendIBCMSGFromQ() 
*
01ABC:  MOVLB  A
01ABE:  CLRF   xAB
01AC0:  CLRF   xAC
01AC2:  CLRF   xAD
.................... { 
....................     int8          i8LoopCount    = 0; 
....................     unsigned int8 ui8Sequence    = 0; 
....................     unsigned int8 ui8TempData    = 0; 
....................  
....................     // Initialize the Send Array 
....................     for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
01AC4:  CLRF   xAB
01AC6:  MOVF   xAB,W
01AC8:  SUBLW  04
01ACA:  BTFSS  FD8.0
01ACC:  GOTO   1AE6
....................     { 
....................         g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount] = 0; 
01AD0:  CLRF   03
01AD2:  MOVF   xAB,W
01AD4:  ADDLW  61
01AD6:  MOVWF  FE9
01AD8:  MOVLW  00
01ADA:  ADDWFC 03,W
01ADC:  MOVWF  FEA
01ADE:  CLRF   FEF
01AE0:  INCF   xAB,F
01AE2:  GOTO   1AC6
....................     } 
....................  
....................     // Get Node from Queue 
....................     DeleteIBCMsgQueue(&g_stIBCSendQueue, &g_stIBCSendData); 
01AE6:  CLRF   xB2
01AE8:  MOVLW  B5
01AEA:  MOVWF  xB1
01AEC:  CLRF   xB4
01AEE:  MOVLW  61
01AF0:  MOVWF  xB3
01AF2:  MOVLB  0
01AF4:  CALL   19D2
....................     for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
01AF8:  MOVLB  A
01AFA:  CLRF   xAB
01AFC:  MOVF   xAB,W
01AFE:  SUBLW  04
01B00:  BTFSS  FD8.0
01B02:  GOTO   1DB4
....................     { 
....................         // Step 1: First Stuff 1 Start Bit 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 0] = 0;   // Start Bit Always 0 
01B06:  MOVF   xAB,W
01B08:  MULLW  0F
01B0A:  MOVF   FF3,W
01B0C:  CLRF   03
01B0E:  ADDLW  66
01B10:  MOVWF  FE9
01B12:  MOVLW  00
01B14:  ADDWFC 03,W
01B16:  MOVWF  FEA
01B18:  CLRF   FEF
....................          
....................         // Step 2: Now Stuff 3 bit Message Byte Sequence Number 
....................          
....................         // Stuff the 1st Sequence Bit 
....................         ui8Sequence = i8LoopCount; 
01B1A:  MOVFF  AAB,AAC
....................         ui8Sequence = ui8Sequence << 7; 
01B1E:  RRCF   xAC,W
01B20:  CLRF   xAC
01B22:  BTFSC  FD8.0
01B24:  BSF    xAC.7
....................         ui8Sequence = ui8Sequence >> 7; 
01B26:  RLCF   xAC,W
01B28:  CLRF   xAC
01B2A:  BTFSC  FD8.0
01B2C:  BSF    xAC.0
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 1] = ui8Sequence; 
01B2E:  MOVF   xAB,W
01B30:  MULLW  0F
01B32:  MOVF   FF3,W
01B34:  ADDLW  01
01B36:  CLRF   03
01B38:  ADDLW  66
01B3A:  MOVWF  FE9
01B3C:  MOVLW  00
01B3E:  ADDWFC 03,W
01B40:  MOVWF  FEA
01B42:  MOVFF  AAC,FEF
....................          
....................         // Stuff the 2nd Sequence Bit  
....................         ui8Sequence = i8LoopCount; 
01B46:  MOVFF  AAB,AAC
....................         ui8Sequence = ui8Sequence << 6; 
01B4A:  SWAPF  xAC,F
01B4C:  RLCF   xAC,F
01B4E:  RLCF   xAC,F
01B50:  MOVLW  C0
01B52:  ANDWF  xAC,F
....................         ui8Sequence = ui8Sequence >> 7; 
01B54:  RLCF   xAC,W
01B56:  CLRF   xAC
01B58:  BTFSC  FD8.0
01B5A:  BSF    xAC.0
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 2] = ui8Sequence; 
01B5C:  MOVF   xAB,W
01B5E:  MULLW  0F
01B60:  MOVF   FF3,W
01B62:  ADDLW  02
01B64:  CLRF   03
01B66:  ADDLW  66
01B68:  MOVWF  FE9
01B6A:  MOVLW  00
01B6C:  ADDWFC 03,W
01B6E:  MOVWF  FEA
01B70:  MOVFF  AAC,FEF
....................          
....................         // Stuff the 3rd Bit 
....................         ui8Sequence = i8LoopCount; 
01B74:  MOVFF  AAB,AAC
....................         ui8Sequence = ui8Sequence << 5; 
01B78:  SWAPF  xAC,F
01B7A:  RLCF   xAC,F
01B7C:  MOVLW  E0
01B7E:  ANDWF  xAC,F
....................         ui8Sequence = ui8Sequence >> 7; 
01B80:  RLCF   xAC,W
01B82:  CLRF   xAC
01B84:  BTFSC  FD8.0
01B86:  BSF    xAC.0
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 3] = ui8Sequence; 
01B88:  MOVF   xAB,W
01B8A:  MULLW  0F
01B8C:  MOVF   FF3,W
01B8E:  ADDLW  03
01B90:  CLRF   03
01B92:  ADDLW  66
01B94:  MOVWF  FE9
01B96:  MOVLW  00
01B98:  ADDWFC 03,W
01B9A:  MOVWF  FEA
01B9C:  MOVFF  AAC,FEF
....................          
....................         // Step 3: Now Stuff 8 bit Data 
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
01BA0:  CLRF   03
01BA2:  MOVF   xAB,W
01BA4:  ADDLW  61
01BA6:  MOVWF  FE9
01BA8:  MOVLW  00
01BAA:  ADDWFC 03,W
01BAC:  MOVWF  FEA
01BAE:  MOVFF  FEF,AAD
....................         ui8TempData = ui8TempData << 7; 
01BB2:  RRCF   xAD,W
01BB4:  CLRF   xAD
01BB6:  BTFSC  FD8.0
01BB8:  BSF    xAD.7
....................         ui8TempData = ui8TempData >> 7; 
01BBA:  RLCF   xAD,W
01BBC:  CLRF   xAD
01BBE:  BTFSC  FD8.0
01BC0:  BSF    xAD.0
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 4] = ui8TempData; 
01BC2:  MOVF   xAB,W
01BC4:  MULLW  0F
01BC6:  MOVF   FF3,W
01BC8:  ADDLW  04
01BCA:  CLRF   03
01BCC:  ADDLW  66
01BCE:  MOVWF  FE9
01BD0:  MOVLW  00
01BD2:  ADDWFC 03,W
01BD4:  MOVWF  FEA
01BD6:  MOVFF  AAD,FEF
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
01BDA:  CLRF   03
01BDC:  MOVF   xAB,W
01BDE:  ADDLW  61
01BE0:  MOVWF  FE9
01BE2:  MOVLW  00
01BE4:  ADDWFC 03,W
01BE6:  MOVWF  FEA
01BE8:  MOVFF  FEF,AAD
....................         ui8TempData = ui8TempData << 6; 
01BEC:  SWAPF  xAD,F
01BEE:  RLCF   xAD,F
01BF0:  RLCF   xAD,F
01BF2:  MOVLW  C0
01BF4:  ANDWF  xAD,F
....................         ui8TempData = ui8TempData >> 7; 
01BF6:  RLCF   xAD,W
01BF8:  CLRF   xAD
01BFA:  BTFSC  FD8.0
01BFC:  BSF    xAD.0
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 5] = ui8TempData; 
01BFE:  MOVF   xAB,W
01C00:  MULLW  0F
01C02:  MOVF   FF3,W
01C04:  ADDLW  05
01C06:  CLRF   03
01C08:  ADDLW  66
01C0A:  MOVWF  FE9
01C0C:  MOVLW  00
01C0E:  ADDWFC 03,W
01C10:  MOVWF  FEA
01C12:  MOVFF  AAD,FEF
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
01C16:  CLRF   03
01C18:  MOVF   xAB,W
01C1A:  ADDLW  61
01C1C:  MOVWF  FE9
01C1E:  MOVLW  00
01C20:  ADDWFC 03,W
01C22:  MOVWF  FEA
01C24:  MOVFF  FEF,AAD
....................         ui8TempData = ui8TempData << 5; 
01C28:  SWAPF  xAD,F
01C2A:  RLCF   xAD,F
01C2C:  MOVLW  E0
01C2E:  ANDWF  xAD,F
....................         ui8TempData = ui8TempData >> 7; 
01C30:  RLCF   xAD,W
01C32:  CLRF   xAD
01C34:  BTFSC  FD8.0
01C36:  BSF    xAD.0
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 6] = ui8TempData; 
01C38:  MOVF   xAB,W
01C3A:  MULLW  0F
01C3C:  MOVF   FF3,W
01C3E:  ADDLW  06
01C40:  CLRF   03
01C42:  ADDLW  66
01C44:  MOVWF  FE9
01C46:  MOVLW  00
01C48:  ADDWFC 03,W
01C4A:  MOVWF  FEA
01C4C:  MOVFF  AAD,FEF
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
01C50:  CLRF   03
01C52:  MOVF   xAB,W
01C54:  ADDLW  61
01C56:  MOVWF  FE9
01C58:  MOVLW  00
01C5A:  ADDWFC 03,W
01C5C:  MOVWF  FEA
01C5E:  MOVFF  FEF,AAD
....................         ui8TempData = ui8TempData << 4; 
01C62:  SWAPF  xAD,F
01C64:  MOVLW  F0
01C66:  ANDWF  xAD,F
....................         ui8TempData = ui8TempData >> 7; 
01C68:  RLCF   xAD,W
01C6A:  CLRF   xAD
01C6C:  BTFSC  FD8.0
01C6E:  BSF    xAD.0
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 7] = ui8TempData; 
01C70:  MOVF   xAB,W
01C72:  MULLW  0F
01C74:  MOVF   FF3,W
01C76:  ADDLW  07
01C78:  CLRF   03
01C7A:  ADDLW  66
01C7C:  MOVWF  FE9
01C7E:  MOVLW  00
01C80:  ADDWFC 03,W
01C82:  MOVWF  FEA
01C84:  MOVFF  AAD,FEF
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
01C88:  CLRF   03
01C8A:  MOVF   xAB,W
01C8C:  ADDLW  61
01C8E:  MOVWF  FE9
01C90:  MOVLW  00
01C92:  ADDWFC 03,W
01C94:  MOVWF  FEA
01C96:  MOVFF  FEF,AAD
....................         ui8TempData = ui8TempData << 3; 
01C9A:  RLCF   xAD,F
01C9C:  RLCF   xAD,F
01C9E:  RLCF   xAD,F
01CA0:  MOVLW  F8
01CA2:  ANDWF  xAD,F
....................         ui8TempData = ui8TempData >> 7; 
01CA4:  RLCF   xAD,W
01CA6:  CLRF   xAD
01CA8:  BTFSC  FD8.0
01CAA:  BSF    xAD.0
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 8] = ui8TempData; 
01CAC:  MOVF   xAB,W
01CAE:  MULLW  0F
01CB0:  MOVF   FF3,W
01CB2:  ADDLW  08
01CB4:  CLRF   03
01CB6:  ADDLW  66
01CB8:  MOVWF  FE9
01CBA:  MOVLW  00
01CBC:  ADDWFC 03,W
01CBE:  MOVWF  FEA
01CC0:  MOVFF  AAD,FEF
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
01CC4:  CLRF   03
01CC6:  MOVF   xAB,W
01CC8:  ADDLW  61
01CCA:  MOVWF  FE9
01CCC:  MOVLW  00
01CCE:  ADDWFC 03,W
01CD0:  MOVWF  FEA
01CD2:  MOVFF  FEF,AAD
....................         ui8TempData = ui8TempData << 2; 
01CD6:  RLCF   xAD,F
01CD8:  RLCF   xAD,F
01CDA:  MOVLW  FC
01CDC:  ANDWF  xAD,F
....................         ui8TempData = ui8TempData >> 7; 
01CDE:  RLCF   xAD,W
01CE0:  CLRF   xAD
01CE2:  BTFSC  FD8.0
01CE4:  BSF    xAD.0
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 9] = ui8TempData; 
01CE6:  MOVF   xAB,W
01CE8:  MULLW  0F
01CEA:  MOVF   FF3,W
01CEC:  ADDLW  09
01CEE:  CLRF   03
01CF0:  ADDLW  66
01CF2:  MOVWF  FE9
01CF4:  MOVLW  00
01CF6:  ADDWFC 03,W
01CF8:  MOVWF  FEA
01CFA:  MOVFF  AAD,FEF
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
01CFE:  CLRF   03
01D00:  MOVF   xAB,W
01D02:  ADDLW  61
01D04:  MOVWF  FE9
01D06:  MOVLW  00
01D08:  ADDWFC 03,W
01D0A:  MOVWF  FEA
01D0C:  MOVFF  FEF,AAD
....................         ui8TempData = ui8TempData << 1; 
01D10:  BCF    FD8.0
01D12:  RLCF   xAD,F
....................         ui8TempData = ui8TempData >> 7; 
01D14:  RLCF   xAD,W
01D16:  CLRF   xAD
01D18:  BTFSC  FD8.0
01D1A:  BSF    xAD.0
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 10] = ui8TempData; 
01D1C:  MOVF   xAB,W
01D1E:  MULLW  0F
01D20:  MOVF   FF3,W
01D22:  ADDLW  0A
01D24:  CLRF   03
01D26:  ADDLW  66
01D28:  MOVWF  FE9
01D2A:  MOVLW  00
01D2C:  ADDWFC 03,W
01D2E:  MOVWF  FEA
01D30:  MOVFF  AAD,FEF
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
01D34:  CLRF   03
01D36:  MOVF   xAB,W
01D38:  ADDLW  61
01D3A:  MOVWF  FE9
01D3C:  MOVLW  00
01D3E:  ADDWFC 03,W
01D40:  MOVWF  FEA
01D42:  MOVFF  FEF,AAD
....................         ui8TempData = ui8TempData >> 7; 
01D46:  RLCF   xAD,W
01D48:  CLRF   xAD
01D4A:  BTFSC  FD8.0
01D4C:  BSF    xAD.0
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 11] = ui8TempData; 
01D4E:  MOVF   xAB,W
01D50:  MULLW  0F
01D52:  MOVF   FF3,W
01D54:  ADDLW  0B
01D56:  CLRF   03
01D58:  ADDLW  66
01D5A:  MOVWF  FE9
01D5C:  MOVLW  00
01D5E:  ADDWFC 03,W
01D60:  MOVWF  FEA
01D62:  MOVFF  AAD,FEF
....................          
....................         // Step 4: Stuff three Stop Bits 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 12] = 1;  // Stop bit is 1 
01D66:  MOVF   xAB,W
01D68:  MULLW  0F
01D6A:  MOVF   FF3,W
01D6C:  ADDLW  0C
01D6E:  CLRF   03
01D70:  ADDLW  66
01D72:  MOVWF  FE9
01D74:  MOVLW  00
01D76:  ADDWFC 03,W
01D78:  MOVWF  FEA
01D7A:  MOVLW  01
01D7C:  MOVWF  FEF
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 13] = 1; 
01D7E:  MOVF   xAB,W
01D80:  MULLW  0F
01D82:  MOVF   FF3,W
01D84:  ADDLW  0D
01D86:  CLRF   03
01D88:  ADDLW  66
01D8A:  MOVWF  FE9
01D8C:  MOVLW  00
01D8E:  ADDWFC 03,W
01D90:  MOVWF  FEA
01D92:  MOVLW  01
01D94:  MOVWF  FEF
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 14] = 1; 
01D96:  MOVF   xAB,W
01D98:  MULLW  0F
01D9A:  MOVF   FF3,W
01D9C:  ADDLW  0E
01D9E:  CLRF   03
01DA0:  ADDLW  66
01DA2:  MOVWF  FE9
01DA4:  MOVLW  00
01DA6:  ADDWFC 03,W
01DA8:  MOVWF  FEA
01DAA:  MOVLW  01
01DAC:  MOVWF  FEF
01DAE:  INCF   xAB,F
01DB0:  GOTO   1AFC
....................          
.................... ////////        // TESTING Start 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 0] = 0;   
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 1] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 2] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 3] = 1;  
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 4] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 5] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 6] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 7] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 8] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 9] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 10] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 11] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 12] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 13] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 14] = 1; 
.................... ////////        // TESTING End 
....................     } 
....................      
....................      
.................... ////    // TESTING Start 
.................... ////    g_ui8ArrSendSingleMSG[0] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[1] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[2] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[3] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[4] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[5] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[6] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[7] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[8] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[9] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[10] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[11] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[12] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[13] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[14] = 1;     
.................... ////    // TESTING End 
....................          
....................     // So message stuffing is done now start the send timer 
....................     // Initialize send counter. 
....................     g_ui8IBCTxBitCount = 0; 
01DB4:  CLRF   59
....................      
....................     // Hold the IBC Send Lock 
....................     g_fIBCSendLockStatus = IBC_SEND_LOCK; 
01DB6:  MOVLW  01
01DB8:  MOVWF  2F
....................     // Start Timer3 that handle bit by bit sending. 
....................     // Set Timer3 as per Bit Time Value. 
....................     setup_timer_3(T3_INTERNAL | T3_DIV_PRESCALE); 
01DBA:  CLRF   FB0
01DBC:  MOVLW  37
01DBE:  MOVWF  FB1
....................     set_timer3(IBC_TX_1_BT_LOAD_VALUE_9600); 
01DC0:  SETF   FB3
01DC2:  MOVLW  BF
01DC4:  MOVWF  FB2
....................      
....................     // Before Sending Data in IBC Run Timer0 in Time Critical. This we are doing 
....................     // just because we have seen the IBC Send Receive is affecting while Timer 0 
....................     // is executing, hence the IBC data send receive is not sampled at proper time 
....................     g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_ON; 
01DC6:  MOVLB  1
01DC8:  CLRF   x4F
....................      
....................     clear_interrupt(INT_TIMER3); 
01DCA:  BCF    FA1.1
....................     enable_interrupts(INT_TIMER3); 
01DCC:  BSF    FA0.1
01DCE:  MOVLB  0
01DD0:  GOTO   2966 (RETURN)
.................... } 
....................  
.................... void IBCProcessRcvMsg() 
.................... { 
....................     // I 
.................... } 
....................  
.................... #INT_TIMER3    // Used for IBC Send 
.................... void IBC_Tx_ISR(void) 
.................... { 
....................     // Send IBC bits 
....................     output_bit(PIN_IBC_XMIT, g_ui8ArrSendSingleMSG[g_ui8IBCTxBitCount++]); 
*
000E2:  MOVF   59,W
000E4:  INCF   59,F
000E6:  CLRF   03
000E8:  ADDLW  66
000EA:  MOVWF  FE9
000EC:  MOVLW  00
000EE:  ADDWFC 03,W
000F0:  MOVWF  FEA
000F2:  MOVF   FEF,F
000F4:  BTFSS  FD8.2
000F6:  GOTO   0100
000FA:  BCF    F8C.5
000FC:  GOTO   0102
00100:  BSF    F8C.5
00102:  BCF    F95.5
....................     // Reset Timer3 at 1Bit Time value. 
....................     set_timer3(IBC_TX_1_BT_LOAD_VALUE_9600); 
00104:  SETF   FB3
00106:  MOVLW  BF
00108:  MOVWF  FB2
....................     clear_interrupt( INT_TIMER3 ); 
0010A:  BCF    FA1.1
....................  
....................     // Check if IBC Sending completed 
....................     if ((IBC_MSG_BYTE_COUNT*SIZE_IBC_SEND_BYTE_SEGMENT) == g_ui8IBCTxBitCount) 
0010C:  MOVF   59,W
0010E:  SUBLW  4B
00110:  BTFSS  FD8.2
00112:  GOTO   0130
....................     { 
....................         // First release Timer0 Critical run lock 
....................         g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
00116:  MOVLW  01
00118:  MOVLB  1
0011A:  MOVWF  x4F
....................          
....................         // Release Send Busy status 
....................         g_fIBCSendBusy     = 0; 
0011C:  MOVLB  0
0011E:  CLRF   xB2
....................          
....................         // Send Stop bit forever 
....................         output_bit(PIN_IBC_XMIT, 1); 
00120:  BSF    F8C.5
00122:  BCF    F95.5
....................  
....................         // Reset Tx counter 
....................         g_ui8IBCTxBitCount = 0; 
00124:  CLRF   59
....................         // Reset IBC Send checking status flag. 
....................         //g_fIBCCommStatus = 0; 
....................         // Disable Timer 
....................         setup_timer_3 (T3_DISABLED); 
00126:  CLRF   FB0
00128:  CLRF   FB1
....................         disable_interrupts(INT_TIMER3); 
0012A:  BCF    FA0.1
....................         // Clear Timer1 interrupt 
....................         clear_interrupt(INT_TIMER3); 
0012C:  BCF    FA1.1
....................          
....................         // Release IBC Send Lock 
....................         g_fIBCSendLockStatus = IBC_SEND_UNLOCK; 
0012E:  CLRF   2F
....................     } 
....................      
....................     // TESTING 
....................     //output_toggle(PIN_IN_EXT_DI_00); 
....................   
.................... } 
....................  
....................  
....................  
.................... /* 
....................     Timer1 is used to handle IBC Received bytes. 
....................  and Timer3 is used to handle IBC sent bytes. 
....................  */ 
.................... #ifdef M1_COMM_MODULE 
.................... #INT_EXT1  
.................... #else 
00130:  BCF    FA1.1
00132:  GOTO   0094
.................... #INT_EXT3 
.................... #endif 
.................... void IBC_Rx_ISR(void) 
.................... { 
....................    
....................     // Initialize Rx Bit Counter. 
....................    	g_ui8IBCRcvBitCount = 0; 
00136:  CLRF   58
....................     g_unIBCRcvByteNode.m_ui8Arr[0] = 0; 
00138:  CLRF   xB3
....................     g_unIBCRcvByteNode.m_ui8Arr[1] = 0; 
0013A:  CLRF   xB4
....................    	 
....................     // Setup Timer1 at 1.5 Bit Time.                   // Here we are using DIV_BY_8. 
....................     setup_timer_1( T1_INTERNAL | T1_DIV_PRESCALE ); // CPU Ext Clock is 20MHz, 20/4 => 5MHz is Peripheral Clock 
0013C:  MOVLW  37
0013E:  MOVWF  FCD
00140:  CLRF   FAA
....................                                                 // => T1_DIV_BY_2 => 5/2 = 2.5MHz => (1/2.5)us = 0.4us 
....................                                                 // To Get 1Ms quanta = (1000us/0.4) = 2500 => 0x09C4 
....................                                                 // So, The timer will start counting from (0xFFFF - 0x09C4 + 1) 
....................                                                 // To Get 1.5Ms quanta = (1500us/0.4) = 3750 => 0x0EA6 
....................                                                 // So, The timer will start counting from (0xFFFF - 0x0EA6 + 1)  
....................      
.................... #ifdef M1_COMM_MODULE 
....................     set_timer1( IBC_RX_BIT_TIME_1_4_T1LOAD_VAL_9600);  
.................... #else 
....................     set_timer1( IBC_RX_BIT_TIME_1_5_T1LOAD_VAL_9600); 
00142:  SETF   FCF
00144:  MOVLW  9E
00146:  MOVWF  FCE
.................... #endif 
....................      
....................     // Before Sending Data in IBC Run Timer0 in Time Critical. This we are doing 
....................     // just because we have seen the IBC Send Receive is affecting while Timer 0 
....................     // is executing, hence the IBC data send receive is not sampled at proper time 
....................     g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_ON; 
00148:  MOVLB  1
0014A:  CLRF   x4F
....................      
....................     clear_interrupt( INT_TIMER1 ); 
0014C:  BCF    F9E.0
....................     enable_interrupts( INT_TIMER1 ); 
0014E:  BSF    F9D.0
....................      
....................     // Clear and Disable External Interrupt 1  
.................... #ifdef M1_COMM_MODULE 
....................     clear_interrupt(INT_EXT1); 
....................     disable_interrupts(INT_EXT1);  
.................... #else 
....................     clear_interrupt(INT_EXT3); 
00150:  BCF    FF0.2
....................     disable_interrupts(INT_EXT3); 
00152:  BCF    FF0.5
.................... #endif 
....................      
....................     // TESTING Start 
.................... #ifdef M1_COMM_MODULE 
....................     //output_high(PIN_IN_EXT_DI_00); 
.................... #endif 
....................     // TESTING End 
00154:  BCF    FF0.2
00156:  MOVLB  0
00158:  GOTO   0094
.................... } 
....................  
.................... // TESTING Start 
.................... int8 g_i8RcvByteCount = 0; 
.................... // TESTING End 
....................  
.................... #INT_TIMER1           // This is for Receive                 
.................... void IBC_Rx_Sampling_ISR(void) 
.................... {  
.................... ////////    // TESTING Start 
.................... ////////#ifdef M1_COMM_MODULE 
.................... ////////    //output_toggle(PIN_IN_EXT_DI_00); 
.................... ////////#else 
.................... ////////    output_toggle(PIN_A5); 
.................... ////////#endif 
.................... ////////    // TESTING End 
....................      
....................     // Increment Rx Bit Counter for each received bit. 
....................    	g_ui8IBCRcvBitCount++; 
0015C:  INCF   58,F
.................... 	 
....................     // Check Rx Bit Counter and read Bits 
....................     switch(g_ui8IBCRcvBitCount) 
0015E:  MOVF   58,W
00160:  XORLW  01
00162:  BTFSC  FD8.2
00164:  GOTO   01C4
00168:  XORLW  03
0016A:  BTFSC  FD8.2
0016C:  GOTO   01D8
00170:  XORLW  01
00172:  BTFSC  FD8.2
00174:  GOTO   01EC
00178:  XORLW  07
0017A:  BTFSC  FD8.2
0017C:  GOTO   0200
00180:  XORLW  01
00182:  BTFSC  FD8.2
00184:  GOTO   0214
00188:  XORLW  03
0018A:  BTFSC  FD8.2
0018C:  GOTO   0228
00190:  XORLW  01
00192:  BTFSC  FD8.2
00194:  GOTO   023C
00198:  XORLW  0F
0019A:  BTFSC  FD8.2
0019C:  GOTO   0250
001A0:  XORLW  01
001A2:  BTFSC  FD8.2
001A4:  GOTO   0264
001A8:  XORLW  03
001AA:  BTFSC  FD8.2
001AC:  GOTO   0278
001B0:  XORLW  01
001B2:  BTFSC  FD8.2
001B4:  GOTO   028C
001B8:  XORLW  07
001BA:  BTFSC  FD8.2
001BC:  GOTO   02A8
001C0:  GOTO   02FA
....................     { 
....................         case 1: // Sequence Bit 0  
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8SeqBit0 = input(PIN_IBC_RCV); 
001C4:  BSF    F93.3
001C6:  BCF    xB3.0
001C8:  BTFSC  F81.3
001CA:  BSF    xB3.0
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
001CC:  SETF   FCF
001CE:  MOVLW  BF
001D0:  MOVWF  FCE
....................             clear_interrupt( INT_TIMER1 ); 
001D2:  BCF    F9E.0
....................             break; 
001D4:  GOTO   0316
....................         case 2: // Sequence Bit 1 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8SeqBit1 = input(PIN_IBC_RCV); 
001D8:  BSF    F93.3
001DA:  BCF    xB3.1
001DC:  BTFSC  F81.3
001DE:  BSF    xB3.1
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
001E0:  SETF   FCF
001E2:  MOVLW  BF
001E4:  MOVWF  FCE
....................             clear_interrupt( INT_TIMER1 ); 
001E6:  BCF    F9E.0
....................             break; 
001E8:  GOTO   0316
....................         case 3: // Sequence Bit 2 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8SeqBit2 = input(PIN_IBC_RCV); 
001EC:  BSF    F93.3
001EE:  BCF    xB3.2
001F0:  BTFSC  F81.3
001F2:  BSF    xB3.2
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
001F4:  SETF   FCF
001F6:  MOVLW  BF
001F8:  MOVWF  FCE
....................             clear_interrupt( INT_TIMER1 ); 
001FA:  BCF    F9E.0
....................             break; 
001FC:  GOTO   0316
....................         case 4: // Data Bit Bit 0 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit0 = input(PIN_IBC_RCV); 
00200:  BSF    F93.3
00202:  BCF    xB4.0
00204:  BTFSC  F81.3
00206:  BSF    xB4.0
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
00208:  SETF   FCF
0020A:  MOVLW  BF
0020C:  MOVWF  FCE
....................             clear_interrupt( INT_TIMER1 ); 
0020E:  BCF    F9E.0
....................             break; 
00210:  GOTO   0316
....................         case 5: // Bit 4 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit1 = input(PIN_IBC_RCV); 
00214:  BSF    F93.3
00216:  BCF    xB4.1
00218:  BTFSC  F81.3
0021A:  BSF    xB4.1
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
0021C:  SETF   FCF
0021E:  MOVLW  BF
00220:  MOVWF  FCE
....................             clear_interrupt( INT_TIMER1 ); 
00222:  BCF    F9E.0
....................             break; 
00224:  GOTO   0316
....................         case 6: // Bit 5 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit2 = input(PIN_IBC_RCV); 
00228:  BSF    F93.3
0022A:  BCF    xB4.2
0022C:  BTFSC  F81.3
0022E:  BSF    xB4.2
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
00230:  SETF   FCF
00232:  MOVLW  BF
00234:  MOVWF  FCE
....................             clear_interrupt( INT_TIMER1 ); 
00236:  BCF    F9E.0
....................             break; 
00238:  GOTO   0316
....................         case 7: // Bit 6 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit3 = input(PIN_IBC_RCV); 
0023C:  BSF    F93.3
0023E:  BCF    xB4.3
00240:  BTFSC  F81.3
00242:  BSF    xB4.3
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
00244:  SETF   FCF
00246:  MOVLW  BF
00248:  MOVWF  FCE
....................             clear_interrupt( INT_TIMER1 ); 
0024A:  BCF    F9E.0
....................             break; 
0024C:  GOTO   0316
....................         case 8: // Bit 7 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit4 = input(PIN_IBC_RCV); 
00250:  BSF    F93.3
00252:  BCF    xB4.4
00254:  BTFSC  F81.3
00256:  BSF    xB4.4
....................             // Setup Timer1 at 1 Bit Time. 
....................          	set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
00258:  SETF   FCF
0025A:  MOVLW  BF
0025C:  MOVWF  FCE
....................          	clear_interrupt( INT_TIMER1 ); 
0025E:  BCF    F9E.0
....................             break; 
00260:  GOTO   0316
....................              
....................              
....................         case 9: // Bit 8 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit5 = input(PIN_IBC_RCV); 
00264:  BSF    F93.3
00266:  BCF    xB4.5
00268:  BTFSC  F81.3
0026A:  BSF    xB4.5
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_1_BT_CUSTOMISED_VAL_9600); 
0026C:  SETF   FCF
0026E:  MOVLW  C7
00270:  MOVWF  FCE
....................             clear_interrupt( INT_TIMER1 ); 
00272:  BCF    F9E.0
....................             break; 
00274:  GOTO   0316
....................         case 10: // Bit 9 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit6 = input(PIN_IBC_RCV); 
00278:  BSF    F93.3
0027A:  BCF    xB4.6
0027C:  BTFSC  F81.3
0027E:  BSF    xB4.6
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_1_BT_CUSTOMISED_VAL_9600); 
00280:  SETF   FCF
00282:  MOVLW  C7
00284:  MOVWF  FCE
....................             clear_interrupt( INT_TIMER1 ); 
00286:  BCF    F9E.0
....................             break; 
00288:  GOTO   0316
....................         case 11: // Bit 10 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit7 = input(PIN_IBC_RCV); 
0028C:  BSF    F93.3
0028E:  BCF    xB4.7
00290:  BTFSC  F81.3
00292:  BSF    xB4.7
....................              
....................             // We have received all data so now we can release Timer0 Critical Run 
....................             g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
00294:  MOVLW  01
00296:  MOVLB  1
00298:  MOVWF  x4F
....................              
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_1_BT_CUSTOMISED_VAL_9600); 
0029A:  SETF   FCF
0029C:  MOVLW  C7
0029E:  MOVWF  FCE
....................             clear_interrupt( INT_TIMER1 ); 
002A0:  BCF    F9E.0
....................             break; 
002A2:  MOVLB  0
002A4:  GOTO   0316
....................              
....................         case 12: // STOP Bit 
....................             // Check if the Stop Bit is High. 
....................             if(1 == input(PIN_IBC_RCV)) // Stop bit detected 
002A8:  BSF    F93.3
002AA:  BTFSS  F81.3
002AC:  GOTO   02B4
....................             { 
....................                 // Byte received successfully 
....................                 // Save received byte to the Message Array 1 
....................                 //g_arruiIBCRxMsg1[g_uiIBCRxByteCount1 - 1] = g_unTempRxData1.m_uiByte; 
....................             } 
002B0:  GOTO   02B4
....................             else 
....................             {  
....................                 // Handle error. 
....................                 // Framing error. 
....................                 // Set Flag tracking Framing Error. 
....................                 //g_uiIBCRxFramingErr1 = 1; 
....................                 //g_uiIBCSTXReceived1  = 0; 
....................             } 
....................             // Disable Timer1. 
....................             setup_timer_1 (T1_DISABLED); 
002B4:  CLRF   FCD
002B6:  CLRF   FAA
....................             disable_interrupts(INT_TIMER1);  
002B8:  BCF    F9D.0
....................             // Clear Timer1 interrupt. 
....................             clear_interrupt(INT_TIMER1);  
002BA:  BCF    F9E.0
....................   
....................              
....................             g_i8RcvByteCount++; 
002BC:  MOVLB  1
002BE:  INCF   x50,F
....................             if (5 == g_i8RcvByteCount) 
002C0:  MOVF   x50,W
002C2:  SUBLW  05
002C4:  BTFSS  FD8.2
002C6:  GOTO   02CC
....................             { 
....................                 g_i8RcvByteCount = 0; 
002CA:  CLRF   x50
....................             } 
....................             // Now check the Byte Sequence 
....................             g_stIBCRcvData.g_ui8ArrIBCData[g_unIBCRcvByteNode.m_ui8Arr[0]] = g_unIBCRcvByteNode.m_ui8Arr[1]; 
002CC:  CLRF   03
002CE:  MOVLB  0
002D0:  MOVF   xB3,W
002D2:  ADDLW  5C
002D4:  MOVWF  FE9
002D6:  MOVLW  00
002D8:  ADDWFC 03,W
002DA:  MOVWF  FEA
002DC:  MOVFF  B4,FEF
....................              
....................             if ((IBC_MSG_BYTE_COUNT - 1) == g_unIBCRcvByteNode.m_ui8Arr[0]) 
002E0:  MOVF   xB3,W
002E2:  SUBLW  04
002E4:  BTFSS  FD8.2
002E6:  GOTO   02EE
....................             { 
....................                 // The complete 5 byte data has been received 
....................                 // Now we can process the data 
....................                 g_fIBCDataReceived = 1; 
002EA:  MOVLW  01
002EC:  MOVWF  xB1
....................                  
....................                 // Insert Message into IBC Receive Queue 
.................... ////////                InsertIBCMsgQueue(&g_stIBCRcvQueue, &g_stIBCRcvData);   
....................             } 
....................             // Reset Rx Bit Counter. 
....................             g_ui8IBCRcvBitCount = 0; 
002EE:  CLRF   58
....................              
....................             // Enable External Interrupt to detect next byte. 
.................... #ifdef M1_COMM_MODULE 
....................             ext_int_edge(1, H_TO_L);  
....................             clear_interrupt(INT_EXT1); 
....................             enable_interrupts(INT_EXT1); 
.................... #else 
....................             ext_int_edge(3, H_TO_L);  
002F0:  BCF    FF1.3
....................             clear_interrupt(INT_EXT3); 
002F2:  BCF    FF0.2
....................             enable_interrupts(INT_EXT3); 
002F4:  BSF    FF0.5
.................... #endif 
....................             break; 
002F6:  GOTO   0316
....................  
....................         default: 
....................             // Framing error. 
....................             // Set Flag tracking Framing Error. 
....................             //g_uiIBCRxFramingErr1 = 1; 
....................              
....................             // First release Timer0 Critical run lock 
....................             g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
002FA:  MOVLW  01
002FC:  MOVLB  1
002FE:  MOVWF  x4F
....................              
....................             // Disable Timer1. 
....................             setup_timer_1 (T1_DISABLED); 
00300:  CLRF   FCD
00302:  CLRF   FAA
....................             disable_interrupts(INT_TIMER1);  
00304:  BCF    F9D.0
....................             // Clear Timer1 interrupt. 
....................             clear_interrupt(INT_TIMER1);  
00306:  BCF    F9E.0
....................              
....................             // Reset Rx Bit Counter 1. 
....................             g_ui8IBCRcvBitCount = 0; 
00308:  CLRF   58
....................              
....................             // Enable External Interrupt 0 to detect next start bit. 
....................             ext_int_edge(1, H_TO_L);  
0030A:  BCF    FF1.5
....................             clear_interrupt(INT_EXT1); 
0030C:  BCF    FF0.0
....................             enable_interrupts(INT_EXT1); 
0030E:  BSF    FF0.3
....................             break; 
00310:  MOVLB  0
00312:  GOTO   0316
....................     } 
....................      
.................... } 
....................  
....................  
....................  
.................... #endif /* _VI_IBC_CONFIG_H_ */ 
....................  
.................... #include "../Common/vmIBCGlobal.h" 
.................... #ifndef _VM_IBC_GOBAL_H_ 
.................... #define _VM_IBC_GOBAL_H_ 
....................  
.................... #define IBC_SEND_LOCK                   1 
.................... #define IBC_SEND_UNLOCK                 0 
....................  
.................... typedef enum _EN_IBC_COMMANDS 
.................... { 
....................     IBC_CMD_MODE_HOME                   = 100, 
....................     // Calibration Mode 
....................     IBC_CMD_MODE_CALIB                  = 101, 
....................     IBC_CMD_GET_CALIB_POINT             = 102, 
....................     IBC_CMD_RESET_CALIB_POINT_TARE      = 103, 
....................     IBC_CMD_RESET_CALIB_POINT           = 104, 
....................     IBC_CMD_RESET_CALIB_POINT_WEIGHT    = 105,  
....................     IBC_CMD_TARE_REQUEST                = 106, 
....................     IBC_CMD_SET_LOAD_CELL_FACTOR        = 115,         
....................  
....................     // Pre-Production Mode 
....................     IBC_CMD_MODE_PRE_PROD               = 107, 
....................     IBC_CMD_PRE_PROD_AVG_WEIGHT         = 108, 
....................     IBC_CMD_PRE_PROD_TOLERANCE          = 109, 
....................     IBC_CMD_MODE_AUTO_CALIB             = 110, 
....................     IBC_CMD_MODE_FIXED_CALIB            = 111, 
....................  
....................  
....................     // Production Mode 
....................     IBC_CMD_MODE_PROD                   = 112, 
....................     IBC_CMD_START_PROD                  = 113, 
....................     IBC_CMD_PROD_WEIGH_DATA             = 114, 
....................  
....................     IBC_CMD_PROD_TARE_DATA              = 118, 
....................     IBC_CMD_PROD_AVG_WT_DATA            = 119, 
....................              
....................     IBC_CMD_PROD_INTMD_DATA             = 122 
....................              
....................              
.................... } EN_IBC_COMMANDS; 
....................  
.................... // Mode type 
.................... enum boardModeType 
.................... { 
....................     BOARD_MODE_TYPE_NOTHING         = 0, 
....................     BOARD_MODE_TYPE_HOME            = 1, 
....................     BOARD_MODE_TYPE_PRE_PRODUCTION  = 2, 
.................... 	BOARD_MODE_TYPE_PRODUCTION      = 3, 
....................     BOARD_MODE_TYPE_CONFIGURATION   = 4, 
....................     BOARD_MODE_TYPE_CALIBRATION     = 5 
.................... }; 
....................  
.................... // Mode action on Hardware 
.................... enum manualModeActionHW { 
....................     MANUAL_MODE_ACTION_ON_NOTHING               = 0, 
....................     MANUAL_MODE_ACTION_ON_COIL_STOPPER_UNIT_1   = 1, 
....................     MANUAL_MODE_ACTION_ON_COIL_STOPPER_UNIT_2   = 2, 
....................     MANUAL_MODE_ACTION_ON_GRIPPER_ARM_1         = 3, 
....................     MANUAL_MODE_ACTION_ON_GRIPPER_ARM_2         = 4, 
....................     MANUAL_MODE_ACTION_ON_ARCH_CHUTE            = 5, 
....................     MANUAL_MODE_ACTION_ON_SERVO                 = 6, 
....................  
.................... 	MANUAL_MODE_ACTION_ON_LA1                   = 7, 
....................     MANUAL_MODE_ACTION_ON_LA2                   = 8, 
....................     MANUAL_MODE_ACTION_ON_VFD                   = 9, 
....................     MANUAL_MODE_ACTION_ON_PNEUMATIC_DRIVE       = 10, 
....................      
....................     MANUAL_MODE_ACTION_ON_COIL_TRANSFER         = 11, 
....................     MANUAL_MODE_ACTION_ON_TUNION                = 12 
....................  
.................... }; 
....................  
.................... //typedef struct _ST_IBC_PROD_M_WEIGHT_DATA 
.................... //{ 
.................... //    int16 m_i16BoxCount; 
.................... //    int16 m_i16BoxWeight; 
.................... //} ST_IBC_PROD_M_WEIGHT_DATA; 
.................... typedef struct _ST_IBC_PROD_M_WEIGHT_DATA 
.................... { 
....................     unsigned int16 m_ui16BoxCount; 
....................     int16 m_i16BoxWeight; 
.................... } ST_IBC_PROD_M_WEIGHT_DATA; 
....................  
....................  
.................... typedef union _UN_IBC_PROD_M_WEIGHT_DATA 
.................... { 
....................     ST_IBC_PROD_M_WEIGHT_DATA m_stWeighingData; 
....................     unsigned int8             m_ui8Arr[4]; 
.................... } UN_IBC_PROD_M_WEIGHT_DATA; 
....................  
.................... typedef struct _ST_IBC_PROD_M_TARE_DATA 
.................... { 
....................     int16 m_i16Padding; 
....................     int16 m_i16TareData; 
.................... } ST_IBC_PROD_M_TARE_DATA; 
....................  
.................... typedef union _UN_IBC_PROD_M_TARE_DATA 
.................... { 
....................     ST_IBC_PROD_M_TARE_DATA m_stTareData; 
....................     unsigned int8           m_ui8Arr[4]; 
.................... } UN_IBC_PROD_M_TARE_DATA; 
....................  
.................... typedef struct _ST_IBC_AVG_WT_NODE 
.................... { 
....................     int16 m_i16AvgWt; 
....................     int16 m_i16Padding; 
.................... } ST_IBC_AVG_WT_NODE; 
....................  
.................... typedef union _UN_IBC_AVG_WT_NODE 
.................... { 
....................     ST_IBC_AVG_WT_NODE m_stIBCAvgNode; 
....................     unsigned int8      m_ui8Arr[4]; 
.................... } UN_IBC_AVG_WT_NODE; 
....................  
.................... typedef struct _ST_IBC_TOL_NODE 
.................... { 
....................     int16 m_i16PositiveTol; 
....................     int16 m_i16NegativeTol; 
.................... } ST_IBC_TOL_NODE; 
....................  
.................... typedef union _UN_IBC_TOLERANCE_NODE 
.................... { 
....................     ST_IBC_TOL_NODE m_stIBCTolNode; 
....................     unsigned int8   m_ui8Arr[4]; 
.................... }UN_IBC_TOLERANCE_NODE; 
....................  
....................  
.................... typedef struct _ST_IBC_RESET_CALIB_POINT 
.................... { 
....................     int16         m_i16CalibPoint; 
....................     int16         m_i16CurrCalibPoint; 
.................... } ST_IBC_RESET_CALIB_POINT; 
....................  
.................... typedef union _UN_IBC_RESET_CALIB_POINT 
.................... { 
....................     ST_IBC_RESET_CALIB_POINT m_stIBCResetCalibPoint; 
....................     unsigned int8            m_ui8Arr[4]; 
.................... } UN_IBC_RESET_CALIB_POINT; 
....................  
....................  
.................... typedef struct _ST_IBC_RESET_CALIB_POINT_ACK 
.................... { 
....................     int16         m_i16PassCount; 
....................     int16         m_i16CalibValue; 
.................... } ST_IBC_RESET_CALIB_POINT_ACK; 
....................  
.................... typedef union _UN_IBC_RESET_CALIB_POINT_ACK 
.................... { 
....................     ST_IBC_RESET_CALIB_POINT_ACK m_stIBCResetCalibPoint; 
....................     unsigned int8                m_ui8Arr[4]; 
.................... } UN_IBC_RESET_CALIB_POINT_ACK; 
....................  
.................... typedef struct _ST_IBC_RESET_CALIB_POINT_TARE 
.................... { 
....................     unsigned int32 m_ui32CalibADCForTare; 
.................... }ST_IBC_RESET_CALIB_POINT_TARE; 
....................  
.................... typedef union _UN_IBC_RESET_CALIB_POINT_TARE 
.................... { 
....................     ST_IBC_RESET_CALIB_POINT_TARE m_stIBCResetCalibTare; 
....................     unsigned int8                 m_ui8Arr[4]; 
.................... }UN_IBC_RESET_CALIB_POINT_TARE; 
....................  
.................... typedef struct _ST_IBC_RESET_CALIB_POINT_WEIGHT 
.................... { 
....................     unsigned int32 m_ui32CalibADCForWeight; 
.................... }ST_IBC_RESET_CALIB_POINT_WEIGHT; 
....................  
.................... typedef union _UN_IBC_RESET_CALIB_POINT_WEIGHT 
.................... { 
....................     ST_IBC_RESET_CALIB_POINT_WEIGHT m_stIBCResetCalibWeight; 
....................     unsigned int8                 m_ui8Arr[4]; 
.................... }UN_IBC_RESET_CALIB_POINT_WEIGHT; 
....................  
.................... // Send Current Average Weight from MCU0 to MCU1, for IBC_CMD_PROD_AVG_WT_DATA 
.................... typedef struct _ST_IBC_PROD_MODE_CUR_AVG 
.................... { 
....................     int16 m_i16CurAvg; 
....................     int16 m_i16Padding; 
.................... } ST_IBC_PROD_MODE_CUR_AVG; 
....................  
.................... typedef union _UN_IBC_PROD_MODE_CUR_AVG 
.................... { 
....................     ST_IBC_PROD_MODE_CUR_AVG m_stAvgData; 
....................     unsigned int8            m_ui8Arr[4]; 
.................... } UN_IBC_PROD_MODE_CUR_AVG; 
....................  
.................... typedef struct _ST_IBC_LOAD_CELL_FACTOR 
.................... { 
....................     unsigned int16 m_ui16CurrLoadCellFactor; 
....................     unsigned int16 m_ui16Padding; 
....................      
.................... }ST_IBC_LOAD_CELL_FACTOR; 
....................  
.................... typedef union _UN_IBC_LOAD_CELL_FACTOR 
.................... { 
....................     ST_IBC_LOAD_CELL_FACTOR     m_stLoadCellFactor; 
....................     unsigned int8               m_ui8Arr[4]; 
.................... }UN_IBC_LOAD_CELL_FACTOR; 
....................  
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //*****************************************************************************  
.................... boardModeType           g_boardModeType; 
.................... boardModeType           g_boardModeTypePre; 
.................... manualModeActionHW      g_manualModeActionOnHw; 
.................... unsigned int16          g_ui16DIStatus; 
.................... unsigned int16          g_ui16DOStatus; 
.................... unsigned int16          g_ui16ErrorStatus; 
.................... unsigned int8           g_ui8IncrementIndex; 
.................... int8                    g_fIBCSendLockStatus = IBC_SEND_UNLOCK; 
....................  
.................... UN_IBC_PROD_M_WEIGHT_DATA    g_unIBCProdModeWtData; 
.................... UN_IBC_PROD_M_TARE_DATA      g_unIBCProdModeTrData; 
.................... UN_IBC_AVG_WT_NODE           g_unIBCAvgNode; 
.................... UN_IBC_TOLERANCE_NODE        g_unIBCTolNode; 
.................... UN_IBC_RESET_CALIB_POINT     g_unIBCResetCalib; 
.................... UN_IBC_RESET_CALIB_POINT_ACK g_unIBCResetCalibAck; 
.................... UN_IBC_PROD_MODE_CUR_AVG     g_unIBCProdModeAvg; 
.................... UN_IBC_LOAD_CELL_FACTOR      g_unIBCCurrLoadCellFactor; 
.................... UN_IBC_RESET_CALIB_POINT_TARE g_unIBCResetCalibTare; 
.................... UN_IBC_RESET_CALIB_POINT_WEIGHT g_unIBCResetCalibWeight; 
....................  
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... // function for set mode as Nothing 
.................... void SetModeNothing(void) 
.................... { 
....................     g_boardModeTypePre  = g_boardModeType; 
....................     g_boardModeType     = BOARD_MODE_TYPE_NOTHING; 
.................... } 
....................  
.................... // function for check mode is Nothing or not 
.................... int8 IsModeNothing(void) 
.................... { 
....................     int8 bRetVal = 0; 
....................      
....................     if(g_boardModeType == BOARD_MODE_TYPE_NOTHING)  
....................     { 
....................         bRetVal = 1; 
....................     } 
....................      
....................     return bRetVal; 
.................... } 
....................  
.................... // function for set mode as WakeUp 
.................... void SetModeHome(void) 
.................... { 
....................     g_boardModeTypePre  = g_boardModeType; 
....................     g_boardModeType     = BOARD_MODE_TYPE_HOME; 
.................... } 
....................  
.................... // function for check mode is WakeUp or not 
.................... int8 IsModeHome(void) 
.................... { 
....................     int8 bRetVal = 0; 
....................      
....................     if(g_boardModeType == BOARD_MODE_TYPE_HOME)  
....................     { 
....................         bRetVal = 1; 
....................     } 
....................      
....................     return bRetVal; 
.................... } 
....................  
.................... // function for set mode as manual 
.................... void SetModeCalibration(void) 
.................... { 
....................     g_boardModeTypePre  = g_boardModeType; 
....................     g_boardModeType     = BOARD_MODE_TYPE_CALIBRATION; 
.................... } 
....................  
.................... // function for check mode is manual or not 
.................... int8 IsCalibrationMode(void) 
.................... { 
....................     int8 bRetVal = 0; 
....................      
....................     if(g_boardModeType == BOARD_MODE_TYPE_CALIBRATION)  
....................     { 
....................         bRetVal = 1; 
....................     } 
....................      
....................     return bRetVal; 
.................... } 
....................  
.................... // function for set mode as pre production 
.................... void SetModePreProduction() 
.................... { 
....................     g_boardModeTypePre  = g_boardModeType; 
....................     g_boardModeType     = BOARD_MODE_TYPE_PRE_PRODUCTION; 
.................... } 
....................  
.................... // function for check mode is pre production or not 
.................... int8 IsPreProductionMode(void) 
.................... { 
....................     int8 bRetVal = 0; 
....................      
....................     if(g_boardModeType == BOARD_MODE_TYPE_PRE_PRODUCTION)  
....................     { 
....................         bRetVal = 1; 
....................     } 
....................      
....................     return bRetVal; 
.................... } 
....................  
.................... // function for set mode as production 
.................... void SetModeProduction() 
.................... { 
....................     g_boardModeTypePre  = g_boardModeType; 
....................     g_boardModeType     = BOARD_MODE_TYPE_PRODUCTION; 
.................... } 
....................  
.................... // function for check mode is production or not 
.................... int8 IsProductionMode(void) 
.................... { 
....................     int8 bRetVal = 0; 
....................      
....................     if(g_boardModeType == BOARD_MODE_TYPE_PRODUCTION)  
....................     { 
....................         bRetVal = 1; 
....................     } 
....................      
....................     return bRetVal; 
.................... } 
....................  
.................... //// function for set mode as post production 
.................... //void SetModePostProduction() 
.................... //{ 
.................... //    g_boardModeTypePre  = g_boardModeType; 
.................... //    g_boardModeType     = BOARD_MODE_TYPE_POST_PRODUCTION; 
.................... //} 
.................... // 
.................... //// function for check mode is post production or not 
.................... //int8 IsPostProductionMode(void) 
.................... //{ 
.................... //    int8 bRetVal = 0; 
.................... //     
.................... //    if(g_boardModeType == BOARD_MODE_TYPE_POST_PRODUCTION)  
.................... //    { 
.................... //        bRetVal = 1; 
.................... //    } 
.................... //     
.................... //    return bRetVal; 
.................... //} 
....................  
.................... // function for set mode as configuration 
.................... void SetModeConfiguration(void) 
.................... { 
....................     g_boardModeTypePre  = g_boardModeType; 
....................     g_boardModeType     = BOARD_MODE_TYPE_CONFIGURATION; 
.................... } 
....................  
.................... // function for check mode is configuration or not 
.................... int8 IsConfigurationMode(void) 
.................... { 
....................     int8 bRetVal = 0; 
....................      
....................     if(g_boardModeType == BOARD_MODE_TYPE_CONFIGURATION)  
....................     { 
....................         bRetVal = 1; 
....................     } 
....................      
....................     return bRetVal; 
.................... } 
....................  
.................... #endif /* _VM_IBC_GOBAL_H_ */ 
....................  
.................... #include "../Common/vmADS1131.h" 
.................... #ifndef VM_ADS1131_H 
.................... #define VM_ADS1131_H 
....................  
.................... #include "vmPINConfig.h" 
00316:  BCF    F9E.0
00318:  GOTO   0094
.................... #ifndef _VI_PIN_CONFIG_H_ 
.................... #define _VI_PIN_CONFIG_H_ 
....................  
.................... //#include "18F46K80.h" 
....................  
.................... // DI PIN Mapping. 
.................... #define PIN_IN_DI_00               PIN_D4  
.................... #define PIN_IN_DI_01               PIN_B0  
.................... #define PIN_IN_DI_02               PIN_B1  
.................... #define PIN_IN_DI_03               PIN_B2  
.................... #define PIN_IN_DI_04               PIN_B4    
.................... #define PIN_IN_DI_05               PIN_B5  
.................... #define PIN_IN_DI_06               PIN_A0  
.................... #define PIN_IN_DI_07               PIN_A1  
....................  
.................... // D0 PIN Mapping. 
.................... #define PIN_OUT_DO_00              PIN_E0  
.................... #define PIN_OUT_DO_01              PIN_E1  
.................... #define PIN_OUT_DO_02              PIN_E2  
.................... #define PIN_OUT_DO_03              PIN_C0  
.................... #define PIN_OUT_DO_04              PIN_C1  
.................... #define PIN_OUT_DO_05              PIN_D0 
.................... #define PIN_OUT_DO_06              PIN_D1 
.................... #define PIN_OUT_DO_07              PIN_D2 
....................  
....................  
.................... // LAN Communication Pin Mapping. 
.................... #define PIN_LAN_COMM_XMIT          PIN_C6 
.................... #define PIN_LAN_COMM_RCV    	   PIN_C7 
....................  
.................... // ADC Communication PIN Mapping; IC -> ADS1131(18-bit ADC). 
.................... #define PIN_ADC_DOUT_DRDY           PIN_C4 
.................... #define PIN_ADC_SCLK                PIN_C3 
.................... #define PIN_ADC_PDWN                PIN_C2 
....................  
....................  
.................... // IBC Communication PIN Mapping. 
.................... #define PIN_IBC_RCV                 PIN_B3 
.................... #define PIN_IBC_XMIT                PIN_D5 
....................  
.................... // UART To UART Communication PIN Mapping. 
.................... #define PIN_UART2_COMM_XMIT         PIN_D6 
.................... #define PIN_UART2_COMM_RCV          PIN_D7 
....................  
....................  
.................... #endif /* _VI_PIN_CONFIG_H_ */ 
....................  
....................  
....................  
....................  
....................  
....................  
.................... unsigned int32 read_ext_adc() 
*
0213A:  MOVLW  05
0213C:  MOVLB  A
0213E:  MOVWF  xB0
.................... { 
....................    int i; 
....................    unsigned int32 data; 
....................    unsigned int8 ui8Test = 5; 
....................  
....................    data=0; 
02140:  CLRF   xAF
02142:  CLRF   xAE
02144:  CLRF   xAD
02146:  CLRF   xAC
....................    //output_low(ADS8320_CS); 
....................     
....................    ui8Test = input(PIN_ADC_DOUT_DRDY); 
02148:  BSF    F94.4
0214A:  CLRF   xB0
0214C:  BTFSC  F82.4
0214E:  INCF   xB0,F
....................  
....................    for(i=0;i<18;++i) {           // send sample over spi 
02150:  CLRF   xAB
02152:  MOVF   xAB,W
02154:  SUBLW  11
02156:  BTFSS  FD8.0
02158:  GOTO   218C
....................       output_high(PIN_ADC_SCLK); 
0215C:  BCF    F94.3
0215E:  BSF    F8B.3
....................       delay_us(1); 
02160:  CLRWDT
02162:  BRA    2164
02164:  BRA    2166
....................       shift_left(&data,3,input(PIN_ADC_DOUT_DRDY)); 
02166:  BSF    F94.4
02168:  BTFSC  F82.4
0216A:  GOTO   2174
0216E:  BCF    FD8.0
02170:  GOTO   2176
02174:  BSF    FD8.0
02176:  RLCF   xAC,F
02178:  RLCF   xAD,F
0217A:  RLCF   xAE,F
....................       output_low(PIN_ADC_SCLK); 
0217C:  BCF    F94.3
0217E:  BCF    F8B.3
....................       delay_us(1); 
02180:  CLRWDT
02182:  BRA    2184
02184:  BRA    2186
02186:  INCF   xAB,F
02188:  GOTO   2152
....................    } 
....................     
....................    ui8Test = input(PIN_ADC_DOUT_DRDY); 
0218C:  BSF    F94.4
0218E:  CLRF   xB0
02190:  BTFSC  F82.4
02192:  INCF   xB0,F
....................             
....................    // Apply 19th clock pulse to make DOUT PIN high i.e.data retrieve done. 
....................    delay_us(1); 
02194:  CLRWDT
02196:  BRA    2198
02198:  BRA    219A
....................    output_high(PIN_ADC_SCLK); 
0219A:  BCF    F94.3
0219C:  BSF    F8B.3
....................    delay_us(1); 
0219E:  CLRWDT
021A0:  BRA    21A2
021A2:  BRA    21A4
....................    output_low(PIN_ADC_SCLK); 
021A4:  BCF    F94.3
021A6:  BCF    F8B.3
....................    //delay_us(90); 
....................     
....................    ui8Test = input(PIN_ADC_DOUT_DRDY); 
021A8:  BSF    F94.4
021AA:  CLRF   xB0
021AC:  BTFSC  F82.4
021AE:  INCF   xB0,F
....................     
....................    //output_high(ADS8320_CS); 
....................    return(data); 
021B0:  MOVFF  AAC,00
021B4:  MOVFF  AAD,01
021B8:  MOVFF  AAE,02
021BC:  MOVFF  AAF,03
021C0:  MOVLB  0
021C2:  GOTO   2996 (RETURN)
.................... } 
....................  
.................... float convert_to_volts(long data) { 
....................    return ((float)data*5.0/0xffff); 
.................... } 
....................  
.................... #endif /* VM_ADS1131_H */ 
....................  
.................... #include "../Common/vmEEPROMConfig.h" 
.................... #ifndef _VM_EEPROM_CONFIG_H_ 
.................... #define _VM_EEPROM_CONFIG_H_ 
....................  
.................... #rom int 0xf00000={1,2,3,4} 
....................  
.................... void WriteEEPROMInt8( unsigned int16 uiAddress, unsigned int8 uiValue ) 
.................... { 
....................     write_eeprom(uiAddress,uiValue); 
.................... } 
....................  
.................... void WriteEEPROMInt16( unsigned int16 uiAddress, unsigned int16 uiValue ) 
*
01DD4:  MOVLB  A
01DD6:  CLRF   xB9
.................... { 
....................     unsigned int8 uiTemp = 0; 
....................  
....................     // Write first byte. 
....................     uiTemp = uiValue>>8; 
01DD8:  MOVFF  AB8,AB9
....................     write_eeprom(uiAddress,uiTemp); 
01DDC:  MOVF   FF2,W
01DDE:  MOVWF  00
01DE0:  BCF    FF2.7
01DE2:  MOVFF  AB6,F75
01DE6:  MOVFF  AB5,F74
01DEA:  MOVFF  AB9,F73
01DEE:  BCF    F7F.6
01DF0:  BCF    F7F.7
01DF2:  BSF    F7F.2
01DF4:  MOVLB  F
01DF6:  MOVLW  55
01DF8:  MOVWF  F7E
01DFA:  MOVLW  AA
01DFC:  MOVWF  F7E
01DFE:  BSF    F7F.1
01E00:  BTFSC  F7F.1
01E02:  GOTO   1E00
01E06:  BCF    F7F.2
01E08:  MOVF   00,W
01E0A:  IORWF  FF2,F
....................     // Increment write address. 
....................     uiAddress++; 
01E0C:  MOVLB  A
01E0E:  INCF   xB5,F
01E10:  BTFSC  FD8.2
01E12:  INCF   xB6,F
....................     // Write second byte. 
....................     uiTemp = 0; 
01E14:  CLRF   xB9
....................     uiTemp = uiValue & 0x00FF; 
01E16:  MOVFF  AB7,AB9
....................     write_eeprom(uiAddress,uiTemp); 
01E1A:  MOVF   FF2,W
01E1C:  MOVWF  00
01E1E:  BCF    FF2.7
01E20:  MOVFF  AB6,F75
01E24:  MOVFF  AB5,F74
01E28:  MOVFF  AB9,F73
01E2C:  BCF    F7F.6
01E2E:  BCF    F7F.7
01E30:  BSF    F7F.2
01E32:  MOVLB  F
01E34:  MOVLW  55
01E36:  MOVWF  F7E
01E38:  MOVLW  AA
01E3A:  MOVWF  F7E
01E3C:  BSF    F7F.1
01E3E:  BTFSC  F7F.1
01E40:  GOTO   1E3E
01E44:  BCF    F7F.2
01E46:  MOVF   00,W
01E48:  IORWF  FF2,F
01E4A:  MOVLB  0
01E4C:  GOTO   1E72 (RETURN)
.................... } 
....................  
.................... unsigned int8 ReadEEPROMInt8( unsigned int16 uiAddress ) 
.................... { 
....................     unsigned int8 uiValue = 0; 
....................  
....................     uiValue = read_eeprom(uiAddress); 
....................  
....................     return uiValue; 
.................... } 
....................  
.................... unsigned int16 ReadEEPROMInt16( unsigned int16 uiAddress ) 
*
006C8:  MOVLB  A
006CA:  CLRF   xB1
006CC:  CLRF   xB0
006CE:  CLRF   xB3
006D0:  CLRF   xB2
.................... { 
....................     unsigned int16 uiValue = 0; 
....................     unsigned int16 uiTemp  = 0; 
....................  
....................     // Read first byte. 
....................     uiTemp = read_eeprom(uiAddress); 
006D2:  MOVFF  FF2,AB4
006D6:  BCF    FF2.7
006D8:  MOVFF  AAF,F75
006DC:  MOVFF  AAE,F74
006E0:  BCF    F7F.6
006E2:  BCF    F7F.7
006E4:  BSF    F7F.0
006E6:  MOVF   F73,W
006E8:  BTFSC  xB4.7
006EA:  BSF    FF2.7
006EC:  CLRF   xB3
006EE:  MOVWF  xB2
....................     uiValue = uiTemp << 8; 
006F0:  MOVFF  AB2,AB1
006F4:  CLRF   xB0
....................     // Increment read address. 
....................     uiAddress++; 
006F6:  INCF   xAE,F
006F8:  BTFSC  FD8.2
006FA:  INCF   xAF,F
....................     // Read second byte. 
....................     uiTemp = read_eeprom(uiAddress); 
006FC:  MOVFF  FF2,AB4
00700:  BCF    FF2.7
00702:  MOVFF  AAF,F75
00706:  MOVFF  AAE,F74
0070A:  BCF    F7F.6
0070C:  BCF    F7F.7
0070E:  BSF    F7F.0
00710:  MOVF   F73,W
00712:  BTFSC  xB4.7
00714:  BSF    FF2.7
00716:  CLRF   xB3
00718:  MOVWF  xB2
....................     uiValue = uiValue | uiTemp; 
0071A:  MOVF   xB2,W
0071C:  IORWF  xB0,F
0071E:  MOVF   xB3,W
00720:  IORWF  xB1,F
....................  
....................     return uiValue; 
00722:  MOVFF  AB0,01
00726:  MOVFF  AB1,02
0072A:  MOVLB  0
0072C:  GOTO   0742 (RETURN)
.................... } 
....................  
.................... #endif /* _VM_EEPROM_CONFIG_H_ */ 
....................  
.................... #include "../Common/vmStateMachine.h" 
.................... #ifndef _VI_STATE_MACHINE_H_ 
.................... #define _VI_STATE_MACHINE_H_ 
....................  
.................... #include "vmDigitalIOConfig.h" 
.................... #ifndef _VM_DIGITAL_IO_CONFIG_H_ 
.................... #define _VM_DIGITAL_IO_CONFIG_H_ 
....................  
.................... //***************************************************************************** 
.................... // Below -> Data Structure for Digital Input Output *************************** 
.................... //***************************************************************************** 
.................... typedef struct _ST_ALL_DI_STATE_BIT 
.................... { 
....................     unsigned int8 m_ui1SWDICn07: 1; 
....................     unsigned int8 m_ui1SWDICn06: 1; 
....................     unsigned int8 m_ui1SWDICn05: 1; 
....................     unsigned int8 m_ui1SWDICn04: 1; 
....................     unsigned int8 m_ui1SWDICn03: 1; 
....................     unsigned int8 m_ui1SWDICn02: 1; 
....................     unsigned int8 m_ui1SWDICn01: 1; 
....................     unsigned int8 m_ui1SWDICn00: 1; 
....................  
....................     unsigned int8 m_ui1GDICn05: 1; 
....................     unsigned int8 m_ui1GDICn04: 1; 
....................     unsigned int8 m_ui1GDICn03: 1; 
....................     unsigned int8 m_ui1GDICn02: 1; 
....................     unsigned int8 m_ui1GDICn01: 1; 
....................     unsigned int8 m_ui1GDICn00: 1; 
....................  
....................     unsigned int8 m_ui1HWDICn17: 1; 
....................     unsigned int8 m_ui1HWDICn16: 1; 
....................     unsigned int8 m_ui1HWDICn15: 1; 
....................     unsigned int8 m_ui1HWDICn14: 1; 
....................     unsigned int8 m_ui1HWDICn13: 1; 
....................     unsigned int8 m_ui1HWDICn12: 1; 
....................     unsigned int8 m_ui1HWDICn11: 1; 
....................     unsigned int8 m_ui1HWDICn10: 1; 
....................     unsigned int8 m_ui1HWDICn09: 1; 
....................     unsigned int8 m_ui1HWDICn08: 1; 
....................     unsigned int8 m_ui1HWDICn07: 1; 
....................     unsigned int8 m_ui1HWDICn06: 1; 
....................     unsigned int8 m_ui1HWDICn05: 1; 
....................     unsigned int8 m_ui1HWDICn04: 1; 
....................     unsigned int8 m_ui1HWDICn03: 1; 
....................     unsigned int8 m_ui1HWDICn02: 1; 
....................     unsigned int8 m_ui1HWDICn01: 1; 
....................     unsigned int8 m_ui1HWDICn00: 1; 
.................... } ST_ALL_DI_STATE_BIT; 
....................  
.................... typedef union _UN_ALL_DIS 
.................... { 
.................... 	unsigned int8       m_bArr[4]; 
....................     unsigned int32      m_ui32AllDIs; 
....................     ST_ALL_DI_STATE_BIT m_stAllDIBits; 
.................... } UN_ALL_DIS; 
....................  
....................  
.................... typedef struct _ST_ALL_DO_STATE_BIT 
.................... { 
....................     unsigned int8 m_ui1SRDOCn07: 1; 
....................     unsigned int8 m_ui1SRDOCn06: 1; 
....................     unsigned int8 m_ui1SRDOCn05: 1; 
....................     unsigned int8 m_ui1SRDOCn04: 1; 
....................     unsigned int8 m_ui1SRDOCn03: 1; 
....................     unsigned int8 m_ui1SRDOCn02: 1; 
....................     unsigned int8 m_ui1SRDOCn01: 1; 
....................     unsigned int8 m_ui1SRDOCn00: 1; 
....................  
....................     unsigned int8 m_ui1HWDOCn07: 1; 
....................     unsigned int8 m_ui1HWDOCn06: 1; 
....................     unsigned int8 m_ui1HWDOCn05: 1; 
....................     unsigned int8 m_ui1HWDOCn04: 1; 
....................     unsigned int8 m_ui1HWDOCn03: 1; 
....................     unsigned int8 m_ui1HWDOCn02: 1; 
....................     unsigned int8 m_ui1HWDOCn01: 1; 
....................     unsigned int8 m_ui1HWDOCn00: 1; 
.................... } ST_ALL_DO_STATE_BIT; 
....................  
.................... typedef union _UN_ALL_DOS 
.................... { 
....................     unsigned int8       m_bArr[2]; 
....................     unsigned int16      m_ui16AllDOs; 
....................     ST_ALL_DO_STATE_BIT m_stAllDOBits; 
.................... } UN_ALL_DOS; 
....................  
.................... typedef struct _ST_ALL_COUNTER_STATE_BIT 
.................... { 
....................     unsigned int8 m_ui3Counter0: 3; 
....................     unsigned int8 m_ui3Counter1: 3; 
....................     unsigned int8 m_ui2Counter2: 2; 
....................  
....................     unsigned int8 m_ui2Counter3: 2; 
....................     unsigned int8 m_ui2Counter4: 2; 
....................     unsigned int8 m_ui2Counter5: 2; 
....................     unsigned int8 m_ui2Counter6: 2; 
.................... } ST_ALL_COUNTER_STATE_BIT; 
....................  
.................... typedef union _UN_ALL_COUNTERS 
.................... { 
....................     unsigned int8              m_bArr[2]; 
....................     unsigned int16             m_ui16AllCounters; 
....................     ST_ALL_COUNTER_STATE_BIT   m_stAllCounterBits; 
.................... } UN_ALL_COUNTERS; 
....................  
.................... //***************************************************************************** 
.................... // Above -> Data Structure for Digital Input Output *************************** 
.................... //***************************************************************************** 
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
.................... UN_ALL_DIS      g_unDIState; 
.................... UN_ALL_DOS      g_unDOState; 
.................... UN_ALL_COUNTERS g_unAllCounters; 
.................... UN_ALL_DIS      g_unDIStateFilter; 
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //*****************************************************************************  
....................  
.................... #endif /* _VI_DIGITAL_IO_CONFIG_H_ */ 
....................  
.................... //typedef struct _ST_ALL_DI_STATE_BIT 
.................... //{ 
.................... //    unsigned int8 m_ui1HWDICn15: 1; 
.................... //    unsigned int8 m_ui1HWDICn14: 1; 
.................... //    unsigned int8 m_ui1HWDICn13: 1; 
.................... //    unsigned int8 m_ui1HWDICn12: 1; 
.................... //    unsigned int8 m_ui1HWDICn11: 1; 
.................... //    unsigned int8 m_ui1HWDICn10: 1; 
.................... //    unsigned int8 m_ui1HWDICn09: 1; 
.................... //    unsigned int8 m_ui1HWDICn08: 1; 
.................... // 
.................... //    unsigned int8 m_ui1HWDICn07: 1; 
.................... //    unsigned int8 m_ui1HWDICn06: 1; 
.................... //    unsigned int8 m_ui1HWDICn05: 1; 
.................... //    unsigned int8 m_ui1HWDICn04: 1; 
.................... //    unsigned int8 m_ui1HWDICn03: 1; 
.................... //    unsigned int8 m_ui1HWDICn02: 1; 
.................... //    unsigned int8 m_ui1HWDICn01: 1; 
.................... //    unsigned int8 m_ui1HWDICn00: 1; 
.................... //}ST_ALL_DI_STATE_BIT; 
.................... // 
.................... //typedef union _UN_ALL_DIS 
.................... //{ 
.................... //	unsigned int8       m_bArr[2]; 
.................... //    unsigned int16      m_ui16AllDIs; 
.................... //    ST_ALL_DI_STATE_BIT m_stAllDIBits; 
.................... //} UN_ALL_DIS; 
.................... // 
.................... //typedef struct _ST_ALL_DO_STATE_BIT 
.................... //{ 
.................... //    unsigned int8 m_ui1HWDOCn07: 1; 
.................... //    unsigned int8 m_ui1HWDOCn06: 1; 
.................... //    unsigned int8 m_ui1HWDOCn05: 1; 
.................... //    unsigned int8 m_ui1HWDOCn04: 1; 
.................... //    unsigned int8 m_ui1HWDOCn03: 1; 
.................... //    unsigned int8 m_ui1HWDOCn02: 1; 
.................... //    unsigned int8 m_ui1HWDOCn01: 1; 
.................... //    unsigned int8 m_ui1HWDOCn00: 1; 
.................... // 
.................... //}ST_ALL_DO_STATE_BIT; 
.................... // 
.................... //typedef union _UN_ALL_DOS 
.................... //{ 
.................... //    unsigned int8     m_ui8AllDOs; 
.................... //    ST_ALL_DO_STATE_BIT m_stAllDOBits; 
.................... //} UN_ALL_DOS; 
.................... // 
.................... ////***************************************************************************** 
.................... //// Above -> Data Structure for Digital Input Output *************************** 
.................... ////***************************************************************************** 
.................... // 
.................... // 
.................... ////***************************************************************************** 
.................... //// Below -> Global Variable Declaration *************************************** 
.................... ////***************************************************************************** 
.................... //UN_ALL_DIS      g_unDICurrState; 
.................... //UN_ALL_DOS      g_unDOCurrState; 
.................... // 
.................... //UN_ALL_DIS      g_unDIPrevState; 
.................... //UN_ALL_DOS      g_unDOPrevState; 
.................... // 
.................... //UN_ALL_DIS      g_unDIStateFilter; 
.................... ////***************************************************************************** 
.................... //// Above -> Global Variable Declaration *************************************** 
.................... ////*****************************************************************************  
....................  
.................... //#endif /* _VM_DIGITAL_IO_CONFIG_H_ */ 
....................  
.................... /*************************** Inclusion files **********************************/ 
....................  
.................... #define FLAG_STATE_CHANGED           1 
.................... #define FLAG_STATE_NOT_CHANGED       0 
.................... #define MAX_NUMBER_OF_STATE_MACHINES 5 
.................... #define MIN_NUMBER_OF_STATE_MACHINES 1 
.................... #define MAX_NUMBER_OF_STATE          10 
.................... #define MAX_NO_OF_EXP_NXT_STATES     4 
....................  
.................... #define STATE_MACHINE_0              0 
.................... #define STATE_MACHINE_1              1 
.................... #define STATE_MACHINE_2              2 
.................... #define STATE_MACHINE_3              3 
.................... #define STATE_MACHINE_4              4 
....................  
.................... //#define TIMER_FLAG_SUCTION_WAIT_ON   1 
.................... //#define TIMER_FLAG_SUCTION_WAIT_OFF  0 
.................... //#define COUNTER_SUCTION_WAIT         300 
....................  
.................... // Return codes 
.................... #define VI_RETN_SUCCESS               0 
....................  
.................... #define STATE_NOTHING 0 
.................... #define STATE_01 1 
.................... #define STATE_02 2 
.................... #define STATE_03 3 
.................... #define STATE_04 4 
.................... #define STATE_05 5 
.................... #define STATE_06 6 
.................... #define STATE_07 7 
.................... #define STATE_08 8 
.................... #define STATE_09 9 
.................... #define STATE_10 10 
.................... #define STATE_11 11 
.................... #define STATE_12 12 
.................... #define STATE_13 13 
.................... #define STATE_14 14 
.................... #define STATE_15 15 
.................... #define STATE_16 16 
.................... #define STATE_17 17 
.................... #define STATE_18 18 
.................... #define STATE_19 19 
....................  
.................... #define STATE_CONTINUE_OFF 0 
.................... #define STATE_CONTINUE_ON  1 
....................  
.................... /*typedef struct _ST_ALL_DI_STATE_BIT 
.................... { 
....................     unsigned int8 m_ui1SWDICn07: 1; 
....................     unsigned int8 m_ui1SWDICn06: 1; 
....................     unsigned int8 m_ui1SWDICn05: 1; 
....................     unsigned int8 m_ui1SWDICn04: 1; 
....................     unsigned int8 m_ui1SWDICn03: 1; 
....................     unsigned int8 m_ui1SWDICn02: 1; 
....................     unsigned int8 m_ui1SWDICn01: 1; 
....................     unsigned int8 m_ui1SWDICn00: 1; 
....................  
....................     unsigned int8 m_ui1GDICn05: 1; 
....................     unsigned int8 m_ui1GDICn04: 1; 
....................     unsigned int8 m_ui1GDICn03: 1; 
....................     unsigned int8 m_ui1GDICn02: 1; 
....................     unsigned int8 m_ui1GDICn01: 1; 
....................     unsigned int8 m_ui1GDICn00: 1; 
....................  
....................     unsigned int8 m_ui1HWDICn17: 1; 
....................     unsigned int8 m_ui1HWDICn16: 1; 
....................     unsigned int8 m_ui1HWDICn15: 1; 
....................     unsigned int8 m_ui1HWDICn14: 1; 
....................     unsigned int8 m_ui1HWDICn13: 1; 
....................     unsigned int8 m_ui1HWDICn12: 1; 
....................     unsigned int8 m_ui1HWDICn11: 1; 
....................     unsigned int8 m_ui1HWDICn10: 1; 
....................     unsigned int8 m_ui1HWDICn09: 1; 
....................     unsigned int8 m_ui1HWDICn08: 1; 
....................     unsigned int8 m_ui1HWDICn07: 1; 
....................     unsigned int8 m_ui1HWDICn06: 1; 
....................     unsigned int8 m_ui1HWDICn05: 1; 
....................     unsigned int8 m_ui1HWDICn04: 1; 
....................     unsigned int8 m_ui1HWDICn03: 1; 
....................     unsigned int8 m_ui1HWDICn02: 1; 
....................     unsigned int8 m_ui1HWDICn01: 1; 
....................     unsigned int8 m_ui1HWDICn00: 1; 
....................  
.................... } ST_ALL_DI_STATE_BIT; 
....................  
.................... typedef ST_ALL_DI_STATE_BIT ST_ALL_DIS; 
.................... typedef union _UN_ALL_DIS 
.................... { 
.................... 	unsigned int8      m_bArr[4]; 
....................     unsigned int32     m_ui32AllDIs; 
....................     ST_ALL_DIS         m_stAllDIBits; 
.................... } UN_ALL_DIS; 
....................  
.................... typedef struct _ST_ALL_DO_STATE_BIT 
.................... { 
....................     unsigned int8 m_ui1SRDOCn07: 1; 
....................     unsigned int8 m_ui1SRDOCn06: 1; 
....................     unsigned int8 m_ui1SRDOCn05: 1; 
....................     unsigned int8 m_ui1SRDOCn04: 1; 
....................     unsigned int8 m_ui1SRDOCn03: 1; 
....................     unsigned int8 m_ui1SRDOCn02: 1; 
....................     unsigned int8 m_ui1SRDOCn01: 1; 
....................     unsigned int8 m_ui1SRDOCn00: 1; 
....................  
....................     unsigned int8 m_ui1HWDOCn07: 1; 
....................     unsigned int8 m_ui1HWDOCn06: 1; 
....................     unsigned int8 m_ui1HWDOCn05: 1; 
....................     unsigned int8 m_ui1HWDOCn04: 1; 
....................     unsigned int8 m_ui1HWDOCn03: 1; 
....................     unsigned int8 m_ui1HWDOCn02: 1; 
....................     unsigned int8 m_ui1HWDOCn01: 1; 
....................     unsigned int8 m_ui1HWDOCn00: 1; 
.................... } ST_ALL_DO_STATE_BIT; 
....................  
.................... typedef ST_ALL_DO_STATE_BIT ST_ALL_DOS; 
.................... typedef union _UN_ALL_DOS 
.................... { 
....................     unsigned int8     m_bArr[2]; 
....................     unsigned int16    m_ui16AllDOs; 
....................     ST_ALL_DOS        m_stAllDOBits; 
.................... } UN_ALL_DOS; 
....................  
.................... typedef struct _ST_ALL_COUNTER_STATE_BIT 
.................... { 
....................     unsigned int8 m_ui3Counter0: 3; 
....................     unsigned int8 m_ui3Counter1: 3; 
....................     unsigned int8 m_ui2Counter2: 2; 
....................  
....................     unsigned int8 m_ui2Counter3: 2; 
....................     unsigned int8 m_ui2Counter4: 2; 
....................     unsigned int8 m_ui2Counter5: 2; 
....................     unsigned int8 m_ui2Counter6: 2; 
.................... } ST_ALL_COUNTER_STATE_BIT; 
....................  
.................... typedef ST_ALL_COUNTER_STATE_BIT ST_ALL_COUNTERS; 
.................... typedef union _UN_ALL_COUNTERS 
.................... { 
....................     unsigned int8     m_bArr[2]; 
....................     unsigned int16    m_ui16AllCounters; 
....................     ST_ALL_COUNTERS   m_stAllCounterBits; 
.................... } UN_ALL_COUNTERS; 
.................... */ 
....................  
.................... int8 g_ui8NumberOfActiveMachines; //= MIN_NUMBER_OF_STATE_MACHINES; 
....................  
....................  
....................  
.................... typedef struct _ST_STATE_INDEX_TABLE_NODE 
.................... { 
....................     int32 m_ui32DIState;      // Populate the DI State after applying the State DI Filter 
....................     int16 m_ui16DOState;      // Populate the DO State after applying the State DO Filter 
.................... } ST_STATE_INDEX_TABLE_NODE; 
....................  
....................  
.................... typedef unsigned int8(*PTR_STATE_FUNCTION)(int8, int8); 
.................... //typedef unsigned int8(*PTR_STATE_FUNCTION)(void); 
....................  
.................... typedef struct _ST_STATE_LOOKUP_TABLE_NODE 
.................... { 
....................     int32              m_ui32DIState;      // Populate the DI State after applying the State DI Filter 
....................     int16              m_ui16DOState;      // Populate the DO State after applying the State DO Filter 
....................     int8               m_i8ArrExpNextState[MAX_NO_OF_EXP_NXT_STATES]; 
....................     PTR_STATE_FUNCTION pFunStateFunction; 
....................      
.................... } ST_STATE_LOOKUP_TABLE_NODE; 
....................  
....................  
.................... typedef struct _ST_STATE_MACHINE 
.................... { 
....................     unsigned int32               m_ui32StateDIFilter; 
....................     unsigned int16               m_ui16StateDOFilter; 
....................     unsigned int16               m_uiStateCounterFilter; 
....................     ST_STATE_INDEX_TABLE_NODE    m_stArrStateIndexTable[MAX_NUMBER_OF_STATE]; 
....................     ST_STATE_LOOKUP_TABLE_NODE   m_stArrStateLookupTable[MAX_NUMBER_OF_STATE]; 
....................     // Temporary Values 
....................     unsigned int32               m_ui32LastDIState; 
....................     unsigned int16               m_ui16LastDOState; 
....................  
....................     //int8                       m_iExpNxtStates; 
....................     int8                         m_i8ArrCurExpNextState[MAX_NO_OF_EXP_NXT_STATES];    // Expected Next States 
....................     int8                         m_i8PrevState; 
....................     int8                         m_fContinue; 
.................... } ST_STATE_MACHINE; 
....................  
....................  
.................... //================= All Variable Declarations Start ==========================// 
.................... //UN_ALL_DIS      g_unAllDIs; 
.................... //UN_ALL_DOS      g_unDOState; 
.................... //UN_ALL_COUNTERS g_unAllCounters; 
....................  
.................... unsigned int32 g_ui32AllDIsPreviousState      = 0;      //TODO This should be overwrite by Board Initialization 
.................... unsigned int16 g_ui32AllDOsCurrentState       = 0;      //TODO This should be overwrite by Board Initialization 
.................... unsigned int16 g_ui32AllDOsPreviousState      = 0;      //TODO This should be overwrite by Board Initialization 
.................... unsigned int16 g_ui32AllCountersCurrentState  = 0;      //TODO This should be overwrite by Board Initialization 
.................... unsigned int16 g_ui32AllCountersPreviousState = 0;      //TODO This should be overwrite by Board Initialization 
....................  
.................... unsigned int8  g_uiStateChange = FLAG_STATE_NOT_CHANGED; 
.................... unsigned int8  g_fSuctionWait = 0;  
.................... unsigned int16 g_ui16TimerCount = 0;  
.................... //================= All Variable Declarations End ============================// 
....................  
.................... // Timer Function for DI Polling 
.................... /*void PollingInterrupt() 
.................... { 
....................     // Step 1 : Poll all DIs 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn00 = input(PIN_IN_DI_00); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn01 = input(PIN_IN_DI_01); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn02 = input(PIN_IN_DI_02); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn03 = input(PIN_IN_DI_03); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn04 = input(PIN_IN_DI_04); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn05 = input(PIN_IN_DI_05); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn06 = input(PIN_IN_DI_06); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn07 = input(PIN_IN_DI_07); 
....................  
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn08 = input(PIN_IN_DI_08); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn09 = input(PIN_IN_DI_09); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn10 = input(PIN_IN_DI_10); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn11 = input(PIN_IN_DI_11); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn12 = input(PIN_IN_DI_12); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn13 = input(PIN_IN_DI_13); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn14 = input(PIN_IN_DI_14); 
....................     unsigned int8 ui8Test =  
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn15 = input(PIN_IN_DI_15); 
....................  
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn16 = input(PIN_IN_DI_16); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn17 = input(PIN_IN_DI_17); 
....................  
....................     // Step 2: Check for any state change 
....................     // Check ALL DI States Changes and all DO State Changes 
....................     if (g_unAllDIs.m_ui32AllDIs == g_ui32AllDIsPreviousState && 
....................         g_unDOState.m_ui16AllDOs == g_ui32AllDOsPreviousState) 
....................     { 
....................         g_uiStateChange = FLAG_STATE_NOT_CHANGED; 
....................     } 
....................     else 
....................     { 
....................         g_uiStateChange = FLAG_STATE_CHANGED; 
....................         g_ui32AllDIsPreviousState = g_unAllDIs.m_ui32AllDIs; 
....................         g_ui32AllDOsPreviousState = g_unDOState.m_ui16AllDOs; 
....................     } 
....................  
....................  
....................     if (g_fSuctionWait == TIMER_FLAG_SUCTION_WAIT_ON) 
....................     { 
....................         g_ui16TimerCount++; 
....................     } 
....................  
.................... }*/ 
....................  
.................... void ExecuteALLDOs(void) 
.................... { 
....................     delay_us(10); 
*
0032A:  CLRWDT
0032C:  MOVLW  0F
0032E:  MOVWF  00
00330:  DECFSZ 00,F
00332:  BRA    0330
00334:  BRA    0336
00336:  NOP   
....................     output_bit(PIN_OUT_DO_00, g_unDOState.m_stAllDOBits.m_ui1HWDOCn00); 
00338:  BTFSC  1E.7
0033A:  GOTO   0344
0033E:  BCF    F8D.0
00340:  GOTO   0346
00344:  BSF    F8D.0
00346:  BCF    F96.0
....................     output_bit(PIN_OUT_DO_01, g_unDOState.m_stAllDOBits.m_ui1HWDOCn01); 
00348:  BTFSC  1E.6
0034A:  GOTO   0354
0034E:  BCF    F8D.1
00350:  GOTO   0356
00354:  BSF    F8D.1
00356:  BCF    F96.1
....................     output_bit(PIN_OUT_DO_02, g_unDOState.m_stAllDOBits.m_ui1HWDOCn02); 
00358:  BTFSC  1E.5
0035A:  GOTO   0364
0035E:  BCF    F8D.2
00360:  GOTO   0366
00364:  BSF    F8D.2
00366:  BCF    F96.2
....................     output_bit(PIN_OUT_DO_03, g_unDOState.m_stAllDOBits.m_ui1HWDOCn03); 
00368:  BTFSC  1E.4
0036A:  GOTO   0374
0036E:  BCF    F8B.0
00370:  GOTO   0376
00374:  BSF    F8B.0
00376:  BCF    F94.0
....................     output_bit(PIN_OUT_DO_04, g_unDOState.m_stAllDOBits.m_ui1HWDOCn04); 
00378:  BTFSC  1E.3
0037A:  GOTO   0384
0037E:  BCF    F8B.1
00380:  GOTO   0386
00384:  BSF    F8B.1
00386:  BCF    F94.1
....................     output_bit(PIN_OUT_DO_05, g_unDOState.m_stAllDOBits.m_ui1HWDOCn05); 
00388:  BTFSC  1E.2
0038A:  GOTO   0394
0038E:  BCF    F8C.0
00390:  GOTO   0396
00394:  BSF    F8C.0
00396:  BCF    F95.0
....................     output_bit(PIN_OUT_DO_06, g_unDOState.m_stAllDOBits.m_ui1HWDOCn06); 
00398:  BTFSC  1E.1
0039A:  GOTO   03A4
0039E:  BCF    F8C.1
003A0:  GOTO   03A6
003A4:  BSF    F8C.1
003A6:  BCF    F95.1
....................     output_bit(PIN_OUT_DO_07, g_unDOState.m_stAllDOBits.m_ui1HWDOCn07);    
003A8:  BTFSC  1E.0
003AA:  GOTO   03B4
003AE:  BCF    F8C.2
003B0:  GOTO   03B6
003B4:  BSF    F8C.2
003B6:  BCF    F95.2
003B8:  GOTO   0500 (RETURN)
.................... } 
....................      
.................... int8 HandleStateError(ST_STATE_MACHINE *pstStateMachine) 
*
021C6:  MOVLW  01
021C8:  MOVLB  A
021CA:  MOVWF  xBD
.................... { 
....................     int8 iStateIdx = 1; 
....................     // Check for all the states and find suitable state 
....................     for (iStateIdx = 1; iStateIdx < MAX_NUMBER_OF_STATE; iStateIdx++) 
021CC:  MOVWF  xBD
021CE:  MOVF   xBD,W
021D0:  SUBLW  09
021D2:  BTFSS  FD8.0
021D4:  GOTO   21DE
....................     { 
021D8:  INCF   xBD,F
021DA:  GOTO   21CE
....................          
....................     }     
....................     return 0; 
021DE:  MOVLW  00
021E0:  MOVWF  01
021E2:  MOVLB  0
021E4:  RETURN 0
.................... } 
....................  
....................  
.................... int8 CheckState(ST_STATE_MACHINE *pstStateMachine, int8 i8StMacIndex) 
*
02472:  MOVLB  A
02474:  CLRF   xB3
02476:  CLRF   xB2
02478:  CLRF   xB1
0247A:  CLRF   xB0
0247C:  CLRF   xB5
0247E:  CLRF   xB4
02480:  CLRF   xB6
02482:  CLRF   xB7
02484:  CLRF   xB9
02486:  CLRF   xB8
02488:  CLRF   xBA
.................... { 
....................     unsigned int32 ui32DIState   = 0; 
....................     unsigned int16 ui16DOState   = 0; 
....................     int8           i8ExpNxtState = 0; 
....................     int8           i8TempState   = 0; 
....................     ST_STATE_LOOKUP_TABLE_NODE* pStLookUptableNode = 0; 
....................     unsigned int8 ui8ExpNextState = 0; 
....................      
....................     // Step 1: Apply DI and DO Filter 
....................     ui32DIState = g_unDIState.m_ui32AllDIs & pstStateMachine->m_ui32StateDIFilter; 
0248A:  MOVFF  AAD,FE9
0248E:  MOVFF  AAE,FEA
02492:  MOVFF  FEF,00
02496:  MOVFF  FEC,01
0249A:  MOVFF  FEC,02
0249E:  MOVFF  FEC,03
024A2:  MOVF   00,W
024A4:  ANDWF  19,W
024A6:  MOVWF  xB0
024A8:  MOVF   01,W
024AA:  ANDWF  1A,W
024AC:  MOVWF  xB1
024AE:  MOVF   02,W
024B0:  ANDWF  1B,W
024B2:  MOVWF  xB2
024B4:  MOVF   03,W
024B6:  ANDWF  1C,W
024B8:  MOVWF  xB3
....................     //ui16DOState = g_unDOState.m_ui16AllDOs & pstStateMachine->m_ui16StateDOFilter; 
....................     
....................     // Step 2: Check with DO State Filter 
....................     // If Any change not found then Return 
....................     if (!(ui32DIState ^ pstStateMachine->m_ui32LastDIState) && pstStateMachine->m_fContinue == STATE_CONTINUE_OFF) 
024BA:  MOVLW  BC
024BC:  ADDWF  xAD,W
024BE:  MOVWF  FE9
024C0:  MOVLW  00
024C2:  ADDWFC xAE,W
024C4:  MOVWF  FEA
024C6:  MOVFF  FEF,00
024CA:  MOVFF  FEC,01
024CE:  MOVFF  FEC,02
024D2:  MOVFF  FEC,03
024D6:  MOVF   00,W
024D8:  XORWF  xB0,W
024DA:  MOVWF  00
024DC:  MOVF   01,W
024DE:  XORWF  xB1,W
024E0:  MOVWF  01
024E2:  MOVF   02,W
024E4:  XORWF  xB2,W
024E6:  MOVWF  02
024E8:  MOVF   03,W
024EA:  XORWF  xB3,W
024EC:  MOVWF  03
024EE:  MOVF   00,F
024F0:  BTFSS  FD8.2
024F2:  GOTO   252A
024F6:  MOVF   01,F
024F8:  BTFSS  FD8.2
024FA:  GOTO   252A
024FE:  MOVF   02,F
02500:  BTFSS  FD8.2
02502:  GOTO   252A
02506:  MOVF   03,F
02508:  BTFSS  FD8.2
0250A:  GOTO   252A
0250E:  MOVLW  C7
02510:  ADDWF  xAD,W
02512:  MOVWF  FE9
02514:  MOVLW  00
02516:  ADDWFC xAE,W
02518:  MOVWF  FEA
0251A:  MOVF   FEF,F
0251C:  BTFSS  FD8.2
0251E:  GOTO   252A
....................     { 
....................         // No Change 
....................         // So Return 0 
....................         return 0; 
02522:  MOVLW  00
02524:  MOVWF  01
02526:  GOTO   26D0
....................     } 
....................     // Step 3: IF Change found then do the following: 
....................     //     a. Update last state value 
....................     //     b. Check if the State is matching with the expected next state 
....................     //     c. If YES then call State function 
....................     //     d. If the State is not matching then perform Error Handling 
....................      
....................     // Stape 3a: Update last state value 
....................     //pstStateMachine->m_ui32LastDIState = ui32DIState; 
....................  
....................     // Step 3b: Check if the State is matching with the expected next states 
....................     for (i8ExpNxtState = 0; i8ExpNxtState < MAX_NO_OF_EXP_NXT_STATES; i8ExpNxtState++) 
0252A:  CLRF   xB6
0252C:  MOVF   xB6,W
0252E:  SUBLW  03
02530:  BTFSS  FD8.0
02532:  GOTO   26AC
....................     {        
....................         //pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8PrevState].; 
....................         //if (pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8ArrCurExpNextState[i8ExpNxtState]].m_ui32DIState ^ ui32DIState) 
....................         //if (0 == (pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8ArrCurExpNextState[i8ExpNxtState]].m_ui32DIState ^ ui32DIState)) 
....................         ui8ExpNextState = pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8PrevState].m_i8ArrExpNextState[i8ExpNxtState]; 
02536:  MOVLW  C6
02538:  ADDWF  xAD,W
0253A:  MOVWF  FE9
0253C:  MOVLW  00
0253E:  ADDWFC xAE,W
02540:  MOVWF  FEA
02542:  CLRF   xC8
02544:  MOVFF  FEF,AC7
02548:  CLRF   xCA
0254A:  MOVLW  0C
0254C:  MOVWF  xC9
0254E:  MOVLB  0
02550:  CALL   05BA
02554:  MOVF   01,W
02556:  ADDLW  44
02558:  MOVLB  A
0255A:  MOVWF  xBB
0255C:  MOVLW  00
0255E:  ADDWFC 02,W
02560:  MOVWF  xBC
02562:  MOVLW  06
02564:  ADDWF  xBB,F
02566:  MOVLW  00
02568:  ADDWFC xBC,F
0256A:  MOVF   xB6,W
0256C:  ADDWF  xBB,W
0256E:  MOVWF  01
02570:  MOVLW  00
02572:  ADDWFC xBC,W
02574:  MOVWF  03
02576:  MOVF   01,W
02578:  ADDWF  xAD,W
0257A:  MOVWF  FE9
0257C:  MOVF   xAE,W
0257E:  ADDWFC 03,W
02580:  MOVWF  FEA
02582:  MOVFF  FEF,ABA
....................         if (ui8ExpNextState == STATE_NOTHING) 
02586:  MOVF   xBA,F
02588:  BTFSS  FD8.2
0258A:  GOTO   25A4
....................         { 
....................             // No State Matched, this is an Error 
....................             // Handle Error 
....................             return HandleStateError(pstStateMachine); 
0258E:  MOVFF  AAE,ABC
02592:  MOVFF  AAD,ABB
02596:  MOVLB  0
02598:  CALL   21C6
0259C:  MOVF   01,W
0259E:  MOVLB  A
025A0:  GOTO   26D0
....................         }     
....................          
....................         if (0 == (pstStateMachine->m_stArrStateLookupTable[ui8ExpNextState].m_ui32DIState ^ ui32DIState)) 
025A4:  CLRF   xC8
025A6:  MOVFF  ABA,AC7
025AA:  CLRF   xCA
025AC:  MOVLW  0C
025AE:  MOVWF  xC9
025B0:  MOVLB  0
025B2:  CALL   05BA
025B6:  MOVFF  02,03
025BA:  MOVF   01,W
025BC:  ADDLW  44
025BE:  MOVLB  A
025C0:  MOVWF  xBB
025C2:  MOVLW  00
025C4:  ADDWFC 02,W
025C6:  MOVWF  xBC
025C8:  MOVF   xAD,W
025CA:  ADDWF  xBB,W
025CC:  MOVWF  FE9
025CE:  MOVF   xAE,W
025D0:  ADDWFC xBC,W
025D2:  MOVWF  FEA
025D4:  MOVFF  FEF,ABD
025D8:  MOVFF  FEC,ABE
025DC:  MOVFF  FEC,ABF
025E0:  MOVFF  FEC,AC0
025E4:  MOVF   xBD,W
025E6:  XORWF  xB0,W
025E8:  MOVWF  00
025EA:  MOVF   xBE,W
025EC:  XORWF  xB1,W
025EE:  MOVWF  01
025F0:  MOVF   xBF,W
025F2:  XORWF  xB2,W
025F4:  MOVWF  02
025F6:  MOVF   xC0,W
025F8:  XORWF  xB3,W
025FA:  MOVWF  03
025FC:  MOVF   00,F
025FE:  BTFSS  FD8.2
02600:  GOTO   26A6
02604:  MOVF   01,F
02606:  BTFSS  FD8.2
02608:  GOTO   26A6
0260C:  MOVF   02,F
0260E:  BTFSS  FD8.2
02610:  GOTO   26A6
02614:  MOVF   03,F
02616:  BTFSS  FD8.2
02618:  GOTO   26A6
....................         {    
....................             // State Is matching 
....................             // Call State Function 
....................             pstStateMachine->m_stArrStateLookupTable[ui8ExpNextState].pFunStateFunction(i8StMacIndex, ui8ExpNextState); 
0261C:  CLRF   xC8
0261E:  MOVFF  ABA,AC7
02622:  CLRF   xCA
02624:  MOVLW  0C
02626:  MOVWF  xC9
02628:  MOVLB  0
0262A:  CALL   05BA
0262E:  MOVF   01,W
02630:  ADDLW  44
02632:  MOVLB  A
02634:  MOVWF  xBB
02636:  MOVLW  00
02638:  ADDWFC 02,W
0263A:  MOVWF  xBC
0263C:  MOVLW  0A
0263E:  ADDWF  xBB,W
02640:  MOVWF  01
02642:  MOVLW  00
02644:  ADDWFC xBC,W
02646:  MOVWF  03
02648:  MOVF   01,W
0264A:  ADDWF  xAD,W
0264C:  MOVWF  01
0264E:  MOVF   xAE,W
02650:  ADDWFC 03,F
02652:  MOVFF  01,ABB
02656:  MOVFF  03,ABC
0265A:  MOVFF  03,FEA
0265E:  MOVFF  01,FE9
02662:  MOVFF  AAF,ABF
02666:  MOVFF  ABA,AC0
0266A:  MOVLB  0
0266C:  CALL   031C
....................              
....................             pstStateMachine->m_i8PrevState = ui8ExpNextState; 
02670:  MOVLW  C6
02672:  MOVLB  A
02674:  ADDWF  xAD,W
02676:  MOVWF  FE9
02678:  MOVLW  00
0267A:  ADDWFC xAE,W
0267C:  MOVWF  FEA
0267E:  MOVFF  ABA,FEF
....................              
....................             //if (pstStateMachine->m_ui32StateDIFilter == 0x7000007) 
....................             //{ 
....................             //    output_bit(PIN_OUT_DO_07, 0); 
....................             //    g_unDOState.m_stAllDOBits.m_ui1HWDOCn07 = 0; 
....................             //}     
....................             // Stape 3a: Update last state value 
....................             pstStateMachine->m_ui32LastDIState = ui32DIState; 
02682:  MOVLW  BC
02684:  ADDWF  xAD,W
02686:  MOVWF  FE9
02688:  MOVLW  00
0268A:  ADDWFC xAE,W
0268C:  MOVWF  FEA
0268E:  MOVFF  AB0,FEF
02692:  MOVFF  AB1,FEC
02696:  MOVFF  AB2,FEC
0269A:  MOVFF  AB3,FEC
....................              
....................             break; 
0269E:  GOTO   26AC
....................              
....................         } 
026A2:  GOTO   26A6
....................         else 
....................         { 
....................             // Next State is not matching 
....................             // ERROR 
....................         } 
026A6:  INCF   xB6,F
026A8:  GOTO   252C
....................     } 
....................  
....................  
....................     // If Expected State does not match 
....................     if (i8ExpNxtState == MAX_NO_OF_EXP_NXT_STATES) 
026AC:  MOVF   xB6,W
026AE:  SUBLW  04
026B0:  BTFSS  FD8.2
026B2:  GOTO   26CC
....................     { 
....................         // Handle Error 
....................         return HandleStateError(pstStateMachine); 
026B6:  MOVFF  AAE,ABC
026BA:  MOVFF  AAD,ABB
026BE:  MOVLB  0
026C0:  CALL   21C6
026C4:  MOVF   01,W
026C6:  MOVLB  A
026C8:  GOTO   26D0
....................     } 
....................  
....................     return VI_RETN_SUCCESS; 
026CC:  MOVLW  00
026CE:  MOVWF  01
026D0:  MOVLB  0
026D2:  GOTO   2A8A (RETURN)
.................... } 
....................  
.................... void InitilizeStates() 
.................... { 
....................     g_unDIState.m_ui32AllDIs = 0xFFFFFFFF; 
*
00C10:  SETF   1C
00C12:  SETF   1B
00C14:  SETF   1A
00C16:  SETF   19
....................     g_unDOState.m_ui16AllDOs = 0xFFFF; 
00C18:  SETF   1E
00C1A:  SETF   1D
00C1C:  GOTO   28B8 (RETURN)
.................... } 
....................      
....................  
.................... #endif /* _VI_STATE_MACHINE_H_ */ 
....................  
....................  
....................  
....................  
.................... //#ifndef _VM_STATE_MACHINE_H_ 
.................... //#define _VM_STATE_MACHINE_H_ 
.................... // 
.................... //#include "vmDigitalIOConfig.h" 
.................... ///*************************** Inclusion files **********************************/ 
.................... // 
.................... //#define FLAG_STATE_CHANGED           1 
.................... //#define FLAG_STATE_NOT_CHANGED       0 
.................... //#define MAX_NUMBER_OF_STATE_MACHINES 5 
.................... //#define MIN_NUMBER_OF_STATE_MACHINES 1 
.................... //#define MAX_NUMBER_OF_STATE          8 
.................... //#define MAX_NO_OF_EXP_NXT_STATES     4 
.................... // 
.................... //#define STATE_MACHINE_0   0 
.................... //#define STATE_MACHINE_1   1 
.................... //#define STATE_MACHINE_2   2 
.................... //#define STATE_MACHINE_3   3 
.................... //#define STATE_MACHINE_4   4 
.................... // 
.................... ////#define TIMER_FLAG_SUCTION_WAIT_ON   1 
.................... ////#define TIMER_FLAG_SUCTION_WAIT_OFF  0 
.................... ////#define COUNTER_SUCTION_WAIT         300 
.................... // 
.................... //// Return codes 
.................... //#define VI_RETN_SUCCESS               0 
.................... // 
.................... //#define STATE_NOTHING 0 
.................... //#define STATE_01 1 
.................... //#define STATE_02 2 
.................... //#define STATE_03 3 
.................... //#define STATE_04 4 
.................... //#define STATE_05 5 
.................... //#define STATE_06 6 
.................... //#define STATE_07 7 
.................... //#define STATE_08 8 
.................... //#define STATE_09 9 
.................... //#define STATE_10 10 
.................... //#define STATE_11 11 
.................... //#define STATE_12 12 
.................... //#define STATE_13 13 
.................... //#define STATE_14 14 
.................... //#define STATE_15 15 
.................... //#define STATE_16 16 
.................... //#define STATE_17 17 
.................... //#define STATE_18 18 
.................... //#define STATE_19 19 
.................... // 
.................... //#define STATE_CONTINUE_OFF 0 
.................... //#define STATE_CONTINUE_ON  1 
.................... // 
.................... // 
.................... //int8 g_ui8NumberOfActiveMachines; //= MIN_NUMBER_OF_STATE_MACHINES; 
.................... // 
.................... // 
.................... // 
.................... //typedef struct _ST_STATE_INDEX_TABLE_NODE 
.................... //{ 
.................... //    int32 m_ui32DIState;      // Populate the DI State after applying the State DI Filter 
.................... //    int16 m_ui16DOState;      // Populate the DO State after applying the State DO Filter 
.................... //} ST_STATE_INDEX_TABLE_NODE; 
.................... // 
.................... // 
.................... //typedef unsigned int8(*PTR_STATE_FUNCTION)(int8, int8); 
.................... ////typedef unsigned int8(*PTR_STATE_FUNCTION)(void); 
.................... // 
.................... //typedef struct _ST_STATE_LOOKUP_TABLE_NODE 
.................... //{ 
.................... //    int32              m_ui32DIState;      // Populate the DI State after applying the State DI Filter 
.................... //    int16              m_ui16DOState;      // Populate the DO State after applying the State DO Filter 
.................... //    int8               m_i8ArrExpNextState[MAX_NO_OF_EXP_NXT_STATES]; 
.................... //    PTR_STATE_FUNCTION pFunStateFunction; 
.................... //     
.................... //} ST_STATE_LOOKUP_TABLE_NODE; 
.................... // 
.................... // 
.................... //typedef struct _ST_STATE_MACHINE 
.................... //{ 
.................... //    unsigned int32               m_ui32StateDIFilter; 
.................... //    unsigned int16               m_ui16StateDOFilter; 
.................... //    unsigned int16               m_uiStateCounterFilter; 
.................... //    ST_STATE_INDEX_TABLE_NODE    m_stArrStateIndexTable[MAX_NUMBER_OF_STATE]; 
.................... //    ST_STATE_LOOKUP_TABLE_NODE   m_stArrStateLookupTable[MAX_NUMBER_OF_STATE]; 
.................... //    // Temporary Values 
.................... //    unsigned int32               m_ui32LastDIState; 
.................... //    unsigned int16               m_ui16LastDOState; 
.................... // 
.................... //    //int8                       m_iExpNxtStates; 
.................... //    int8                         m_i8ArrCurExpNextState[MAX_NO_OF_EXP_NXT_STATES];    // Expected Next States 
.................... //    int8                         m_i8PrevState; 
.................... //    int8                         m_fContinue; 
.................... //} ST_STATE_MACHINE; 
.................... // 
.................... // 
.................... ////================= All Variable Declarations Start ==========================// 
.................... ////UN_ALL_DIS      g_unAllDIs; 
.................... ////UN_ALL_DOS      g_unDOState; 
.................... ////UN_ALL_COUNTERS g_unAllCounters; 
.................... // 
.................... //unsigned int32 g_ui32AllDIsPreviousState      = 0;      //TODO This should be overwrite by Board Initialization 
.................... //unsigned int16 g_ui32AllDOsCurrentState       = 0;      //TODO This should be overwrite by Board Initialization 
.................... //unsigned int16 g_ui32AllDOsPreviousState      = 0;      //TODO This should be overwrite by Board Initialization 
.................... //unsigned int16 g_ui32AllCountersCurrentState  = 0;      //TODO This should be overwrite by Board Initialization 
.................... //unsigned int16 g_ui32AllCountersPreviousState = 0;      //TODO This should be overwrite by Board Initialization 
.................... // 
.................... //unsigned int8  g_uiStateChange = FLAG_STATE_NOT_CHANGED; 
.................... //unsigned int8  g_fSuctionWait = 0;  
.................... //unsigned int16 g_ui16TimerCount = 0;  
.................... ////================= All Variable Declarations End ============================// 
.................... // 
.................... //// Timer Function for DI Polling 
.................... ///*void PollingInterrupt() 
.................... //{ 
.................... //    // Step 1 : Poll all DIs 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn00 = input(PIN_IN_DI_00); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn01 = input(PIN_IN_DI_01); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn02 = input(PIN_IN_DI_02); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn03 = input(PIN_IN_DI_03); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn04 = input(PIN_IN_DI_04); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn05 = input(PIN_IN_DI_05); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn06 = input(PIN_IN_DI_06); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn07 = input(PIN_IN_DI_07); 
.................... // 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn08 = input(PIN_IN_DI_08); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn09 = input(PIN_IN_DI_09); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn10 = input(PIN_IN_DI_10); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn11 = input(PIN_IN_DI_11); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn12 = input(PIN_IN_DI_12); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn13 = input(PIN_IN_DI_13); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn14 = input(PIN_IN_DI_14); 
.................... //    unsigned int8 ui8Test =  
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn15 = input(PIN_IN_DI_15); 
.................... // 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn16 = input(PIN_IN_DI_16); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn17 = input(PIN_IN_DI_17); 
.................... // 
.................... //    // Step 2: Check for any state change 
.................... //    // Check ALL DI States Changes and all DO State Changes 
.................... //    if (g_unAllDIs.m_ui32AllDIs == g_ui32AllDIsPreviousState && 
.................... //        g_unDOState.m_ui16AllDOs == g_ui32AllDOsPreviousState) 
.................... //    { 
.................... //        g_uiStateChange = FLAG_STATE_NOT_CHANGED; 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        g_uiStateChange = FLAG_STATE_CHANGED; 
.................... //        g_ui32AllDIsPreviousState = g_unAllDIs.m_ui32AllDIs; 
.................... //        g_ui32AllDOsPreviousState = g_unDOState.m_ui16AllDOs; 
.................... //    } 
.................... // 
.................... // 
.................... //    if (g_fSuctionWait == TIMER_FLAG_SUCTION_WAIT_ON) 
.................... //    { 
.................... //        g_ui16TimerCount++; 
.................... //    } 
.................... // 
.................... //}*/ 
.................... // 
.................... //void ExecuteALLDOs(void) 
.................... //{ 
.................... //    delay_us(10); 
.................... //    output_bit(PIN_OUT_DO_00, g_unDOState.m_stAllDOBits.m_ui1HWDOCn00); 
.................... //    output_bit(PIN_OUT_DO_01, g_unDOState.m_stAllDOBits.m_ui1HWDOCn01); 
.................... //    output_bit(PIN_OUT_DO_02, g_unDOState.m_stAllDOBits.m_ui1HWDOCn02); 
.................... //    output_bit(PIN_OUT_DO_03, g_unDOState.m_stAllDOBits.m_ui1HWDOCn03); 
.................... //    output_bit(PIN_OUT_DO_04, g_unDOState.m_stAllDOBits.m_ui1HWDOCn04); 
.................... //    output_bit(PIN_OUT_DO_05, g_unDOState.m_stAllDOBits.m_ui1HWDOCn05); 
.................... //    output_bit(PIN_OUT_DO_06, g_unDOState.m_stAllDOBits.m_ui1HWDOCn06); 
.................... //    output_bit(PIN_OUT_DO_07, g_unDOState.m_stAllDOBits.m_ui1HWDOCn07);    
.................... //} 
.................... //     
.................... //int8 HandleStateError(ST_STATE_MACHINE *pstStateMachine) 
.................... //{ 
.................... //    int8 iStateIdx = 1; 
.................... //    // Check for all the states and find suitable state 
.................... //    for (iStateIdx = 1; iStateIdx < MAX_NUMBER_OF_STATE; iStateIdx++) 
.................... //    { 
.................... //         
.................... //    }     
.................... //    return 0; 
.................... //} 
.................... // 
.................... // 
.................... //int8 CheckState(ST_STATE_MACHINE *pstStateMachine, int8 i8StMacIndex) 
.................... //{ 
.................... //    unsigned int32 ui32DIState   = 0; 
.................... //    unsigned int16 ui16DOState   = 0; 
.................... //    int8           i8ExpNxtState = 0; 
.................... //    int8           i8TempState   = 0; 
.................... //    ST_STATE_LOOKUP_TABLE_NODE* pStLookUptableNode = 0; 
.................... //    unsigned int8 ui8ExpNextState = 0; 
.................... //     
.................... //    // Step 1: Apply DI and DO Filter 
.................... //    //ui32DIState = g_unDIState.m_ui32AllDIs & pstStateMachine->m_ui32StateDIFilter; 
.................... //    //ui16DOState = g_unDOState.m_ui16AllDOs & pstStateMachine->m_ui16StateDOFilter; 
.................... //    
.................... //    // Step 2: Check with DO State Filter 
.................... //    // If Any change not found then Return 
.................... //    if (!(ui32DIState ^ pstStateMachine->m_ui32LastDIState) && pstStateMachine->m_fContinue == STATE_CONTINUE_OFF) 
.................... //    { 
.................... //        // No Change 
.................... //        // So Return 0 
.................... //        return 0; 
.................... //    } 
.................... //    // Step 3: IF Change found then do the following: 
.................... //    //     a. Update last state value 
.................... //    //     b. Check if the State is matching with the expected next state 
.................... //    //     c. If YES then call State function 
.................... //    //     d. If the State is not matching then perform Error Handling 
.................... //     
.................... //    // Stape 3a: Update last state value 
.................... //    //pstStateMachine->m_ui32LastDIState = ui32DIState; 
.................... // 
.................... //    // Step 3b: Check if the State is matching with the expected next states 
.................... //    for (i8ExpNxtState = 0; i8ExpNxtState < MAX_NO_OF_EXP_NXT_STATES; i8ExpNxtState++) 
.................... //    {        
.................... //        //pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8PrevState].; 
.................... //        //if (pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8ArrCurExpNextState[i8ExpNxtState]].m_ui32DIState ^ ui32DIState) 
.................... //        //if (0 == (pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8ArrCurExpNextState[i8ExpNxtState]].m_ui32DIState ^ ui32DIState)) 
.................... //        ui8ExpNextState = pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8PrevState].m_i8ArrExpNextState[i8ExpNxtState]; 
.................... //        if (ui8ExpNextState == STATE_NOTHING) 
.................... //        { 
.................... //            // No State Matched, this is an Error 
.................... //            // Handle Error 
.................... //            return HandleStateError(pstStateMachine); 
.................... //        }     
.................... //         
.................... //        if (0 == (pstStateMachine->m_stArrStateLookupTable[ui8ExpNextState].m_ui32DIState ^ ui32DIState)) 
.................... //        {    
.................... //            // State Is matching 
.................... //            // Call State Function 
.................... //            pstStateMachine->m_stArrStateLookupTable[ui8ExpNextState].pFunStateFunction(i8StMacIndex, ui8ExpNextState); 
.................... //             
.................... //            pstStateMachine->m_i8PrevState = ui8ExpNextState; 
.................... //             
.................... //            //if (pstStateMachine->m_ui32StateDIFilter == 0x7000007) 
.................... //            //{ 
.................... //            //    output_bit(PIN_OUT_DO_07, 0); 
.................... //            //    g_unDOState.m_stAllDOBits.m_ui1HWDOCn07 = 0; 
.................... //            //}     
.................... //            // Stape 3a: Update last state value 
.................... //            pstStateMachine->m_ui32LastDIState = ui32DIState; 
.................... //             
.................... //            break; 
.................... //             
.................... //        } 
.................... //        else 
.................... //        { 
.................... //            // Next State is not matching 
.................... //            // ERROR 
.................... //        } 
.................... //    } 
.................... // 
.................... // 
.................... //    // If Expected State does not match 
.................... //    if (i8ExpNxtState == MAX_NO_OF_EXP_NXT_STATES) 
.................... //    { 
.................... //        // Handle Error 
.................... //        return HandleStateError(pstStateMachine); 
.................... //    } 
.................... // 
.................... //    return VI_RETN_SUCCESS; 
.................... //} 
.................... // 
.................... //void InitilizeStates() 
.................... //{ 
.................... //   // g_unDIState.m_ui32AllDIs = 0xFFFFFFFF; 
.................... //   // g_unDOState.m_ui16AllDOs = 0xFFFF; 
.................... //} 
.................... //     
.................... // 
.................... //#endif /* _VM_STATE_MACHINE_H_ */ 
.................... // 
.................... // 
....................  
....................  
.................... #include "vmTimerConfig.h" 
....................  
.................... #ifndef _VM_TIMER_CONFIG_H_ 
.................... #define _VM_TIMER_CONFIG_H_ 
....................  
.................... #include "vmSystemConfig.h" 
....................  
.................... #ifndef _VI_SYSTEM_CONFIG_H_ 
.................... #define _VI_SYSTEM_CONFIG_H_ 
....................  
.................... //****************** Inclusion Files *************************** 
.................... #include "18F46K80.h" 
.................... #include "vmPINConfig.h" 
....................  
.................... //****************** Component Configuration ******************** 
....................  
.................... //optimization level. 
.................... #pragma opt 8 
....................   
.................... //********* CPU Settings ******************************************* 
....................  
.................... #pragma device HIGH_INTS=TRUE 
.................... #pragma fuses NOPLLEN,ECH,WDT1024,NOPROTECT,NOBROWNOUT,NOFCMEN,NOIESO,NOPUT /* WDT1024 => 1024 * 4 ms = 4096 mS Watchdog Timer */ /* For Field Mode */ 
....................  
.................... #pragma use delay(clock=20000000,restart_wdt) 
....................  
....................  
.................... //******** Serial Interface ************ 
.................... //#pragma use rs232(stream=RS485, xmit=PIN_RS485_XMIT, rcv=PIN_RS485_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
.................... #pragma use rs232(stream=ARD_RS232, xmit=PIN_LAN_COMM_XMIT, rcv=PIN_LAN_COMM_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
....................  
.................... //#define unsigned int8 BYTE 
.................... #ifndef M0_ADC_MODULE 
.................... #define M0_ADC_MODULE 1 
.................... #endif 
....................  
.................... #endif /* _VI_SYSTEM_CONFIG_H_ */ 
....................  
.................... #include "vmStateMachineForIMW_M0.h" 
.................... #ifndef _VM_STATE_MACHINE_FOR_IMW_M0_H_ 
.................... #define _VM_STATE_MACHINE_FOR_IMW_M0_H_ 
....................  
.................... #include "vmSystemConfig.h" 
....................  
.................... #ifndef _VI_SYSTEM_CONFIG_H_ 
.................... #define _VI_SYSTEM_CONFIG_H_ 
....................  
.................... //****************** Inclusion Files *************************** 
.................... #include "18F46K80.h" 
.................... #include "vmPINConfig.h" 
....................  
.................... //****************** Component Configuration ******************** 
....................  
.................... //optimization level. 
.................... #pragma opt 8 
....................   
.................... //********* CPU Settings ******************************************* 
....................  
.................... #pragma device HIGH_INTS=TRUE 
.................... #pragma fuses NOPLLEN,ECH,WDT1024,NOPROTECT,NOBROWNOUT,NOFCMEN,NOIESO,NOPUT /* WDT1024 => 1024 * 4 ms = 4096 mS Watchdog Timer */ /* For Field Mode */ 
....................  
.................... #pragma use delay(clock=20000000,restart_wdt) 
....................  
....................  
.................... //******** Serial Interface ************ 
.................... //#pragma use rs232(stream=RS485, xmit=PIN_RS485_XMIT, rcv=PIN_RS485_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
.................... #pragma use rs232(stream=ARD_RS232, xmit=PIN_LAN_COMM_XMIT, rcv=PIN_LAN_COMM_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
....................  
.................... //#define unsigned int8 BYTE 
.................... #ifndef M0_ADC_MODULE 
.................... #define M0_ADC_MODULE 1 
.................... #endif 
....................  
.................... #endif /* _VI_SYSTEM_CONFIG_H_ */ 
....................  
.................... #include "vmStateMachine.h" 
.................... #ifndef _VI_STATE_MACHINE_H_ 
.................... #define _VI_STATE_MACHINE_H_ 
....................  
.................... #include "vmDigitalIOConfig.h" 
.................... /*************************** Inclusion files **********************************/ 
....................  
.................... #define FLAG_STATE_CHANGED           1 
.................... #define FLAG_STATE_NOT_CHANGED       0 
.................... #define MAX_NUMBER_OF_STATE_MACHINES 5 
.................... #define MIN_NUMBER_OF_STATE_MACHINES 1 
.................... #define MAX_NUMBER_OF_STATE          10 
.................... #define MAX_NO_OF_EXP_NXT_STATES     4 
....................  
.................... #define STATE_MACHINE_0              0 
.................... #define STATE_MACHINE_1              1 
.................... #define STATE_MACHINE_2              2 
.................... #define STATE_MACHINE_3              3 
.................... #define STATE_MACHINE_4              4 
....................  
.................... //#define TIMER_FLAG_SUCTION_WAIT_ON   1 
.................... //#define TIMER_FLAG_SUCTION_WAIT_OFF  0 
.................... //#define COUNTER_SUCTION_WAIT         300 
....................  
.................... // Return codes 
.................... #define VI_RETN_SUCCESS               0 
....................  
.................... #define STATE_NOTHING 0 
.................... #define STATE_01 1 
.................... #define STATE_02 2 
.................... #define STATE_03 3 
.................... #define STATE_04 4 
.................... #define STATE_05 5 
.................... #define STATE_06 6 
.................... #define STATE_07 7 
.................... #define STATE_08 8 
.................... #define STATE_09 9 
.................... #define STATE_10 10 
.................... #define STATE_11 11 
.................... #define STATE_12 12 
.................... #define STATE_13 13 
.................... #define STATE_14 14 
.................... #define STATE_15 15 
.................... #define STATE_16 16 
.................... #define STATE_17 17 
.................... #define STATE_18 18 
.................... #define STATE_19 19 
....................  
.................... #define STATE_CONTINUE_OFF 0 
.................... #define STATE_CONTINUE_ON  1 
....................  
.................... /*typedef struct _ST_ALL_DI_STATE_BIT 
.................... { 
....................     unsigned int8 m_ui1SWDICn07: 1; 
....................     unsigned int8 m_ui1SWDICn06: 1; 
....................     unsigned int8 m_ui1SWDICn05: 1; 
....................     unsigned int8 m_ui1SWDICn04: 1; 
....................     unsigned int8 m_ui1SWDICn03: 1; 
....................     unsigned int8 m_ui1SWDICn02: 1; 
....................     unsigned int8 m_ui1SWDICn01: 1; 
....................     unsigned int8 m_ui1SWDICn00: 1; 
....................  
....................     unsigned int8 m_ui1GDICn05: 1; 
....................     unsigned int8 m_ui1GDICn04: 1; 
....................     unsigned int8 m_ui1GDICn03: 1; 
....................     unsigned int8 m_ui1GDICn02: 1; 
....................     unsigned int8 m_ui1GDICn01: 1; 
....................     unsigned int8 m_ui1GDICn00: 1; 
....................  
....................     unsigned int8 m_ui1HWDICn17: 1; 
....................     unsigned int8 m_ui1HWDICn16: 1; 
....................     unsigned int8 m_ui1HWDICn15: 1; 
....................     unsigned int8 m_ui1HWDICn14: 1; 
....................     unsigned int8 m_ui1HWDICn13: 1; 
....................     unsigned int8 m_ui1HWDICn12: 1; 
....................     unsigned int8 m_ui1HWDICn11: 1; 
....................     unsigned int8 m_ui1HWDICn10: 1; 
....................     unsigned int8 m_ui1HWDICn09: 1; 
....................     unsigned int8 m_ui1HWDICn08: 1; 
....................     unsigned int8 m_ui1HWDICn07: 1; 
....................     unsigned int8 m_ui1HWDICn06: 1; 
....................     unsigned int8 m_ui1HWDICn05: 1; 
....................     unsigned int8 m_ui1HWDICn04: 1; 
....................     unsigned int8 m_ui1HWDICn03: 1; 
....................     unsigned int8 m_ui1HWDICn02: 1; 
....................     unsigned int8 m_ui1HWDICn01: 1; 
....................     unsigned int8 m_ui1HWDICn00: 1; 
....................  
.................... } ST_ALL_DI_STATE_BIT; 
....................  
.................... typedef ST_ALL_DI_STATE_BIT ST_ALL_DIS; 
.................... typedef union _UN_ALL_DIS 
.................... { 
.................... 	unsigned int8      m_bArr[4]; 
....................     unsigned int32     m_ui32AllDIs; 
....................     ST_ALL_DIS         m_stAllDIBits; 
.................... } UN_ALL_DIS; 
....................  
.................... typedef struct _ST_ALL_DO_STATE_BIT 
.................... { 
....................     unsigned int8 m_ui1SRDOCn07: 1; 
....................     unsigned int8 m_ui1SRDOCn06: 1; 
....................     unsigned int8 m_ui1SRDOCn05: 1; 
....................     unsigned int8 m_ui1SRDOCn04: 1; 
....................     unsigned int8 m_ui1SRDOCn03: 1; 
....................     unsigned int8 m_ui1SRDOCn02: 1; 
....................     unsigned int8 m_ui1SRDOCn01: 1; 
....................     unsigned int8 m_ui1SRDOCn00: 1; 
....................  
....................     unsigned int8 m_ui1HWDOCn07: 1; 
....................     unsigned int8 m_ui1HWDOCn06: 1; 
....................     unsigned int8 m_ui1HWDOCn05: 1; 
....................     unsigned int8 m_ui1HWDOCn04: 1; 
....................     unsigned int8 m_ui1HWDOCn03: 1; 
....................     unsigned int8 m_ui1HWDOCn02: 1; 
....................     unsigned int8 m_ui1HWDOCn01: 1; 
....................     unsigned int8 m_ui1HWDOCn00: 1; 
.................... } ST_ALL_DO_STATE_BIT; 
....................  
.................... typedef ST_ALL_DO_STATE_BIT ST_ALL_DOS; 
.................... typedef union _UN_ALL_DOS 
.................... { 
....................     unsigned int8     m_bArr[2]; 
....................     unsigned int16    m_ui16AllDOs; 
....................     ST_ALL_DOS        m_stAllDOBits; 
.................... } UN_ALL_DOS; 
....................  
.................... typedef struct _ST_ALL_COUNTER_STATE_BIT 
.................... { 
....................     unsigned int8 m_ui3Counter0: 3; 
....................     unsigned int8 m_ui3Counter1: 3; 
....................     unsigned int8 m_ui2Counter2: 2; 
....................  
....................     unsigned int8 m_ui2Counter3: 2; 
....................     unsigned int8 m_ui2Counter4: 2; 
....................     unsigned int8 m_ui2Counter5: 2; 
....................     unsigned int8 m_ui2Counter6: 2; 
.................... } ST_ALL_COUNTER_STATE_BIT; 
....................  
.................... typedef ST_ALL_COUNTER_STATE_BIT ST_ALL_COUNTERS; 
.................... typedef union _UN_ALL_COUNTERS 
.................... { 
....................     unsigned int8     m_bArr[2]; 
....................     unsigned int16    m_ui16AllCounters; 
....................     ST_ALL_COUNTERS   m_stAllCounterBits; 
.................... } UN_ALL_COUNTERS; 
.................... */ 
....................  
.................... int8 g_ui8NumberOfActiveMachines; //= MIN_NUMBER_OF_STATE_MACHINES; 
....................  
....................  
....................  
.................... typedef struct _ST_STATE_INDEX_TABLE_NODE 
.................... { 
....................     int32 m_ui32DIState;      // Populate the DI State after applying the State DI Filter 
....................     int16 m_ui16DOState;      // Populate the DO State after applying the State DO Filter 
.................... } ST_STATE_INDEX_TABLE_NODE; 
....................  
....................  
.................... typedef unsigned int8(*PTR_STATE_FUNCTION)(int8, int8); 
.................... //typedef unsigned int8(*PTR_STATE_FUNCTION)(void); 
....................  
.................... typedef struct _ST_STATE_LOOKUP_TABLE_NODE 
.................... { 
....................     int32              m_ui32DIState;      // Populate the DI State after applying the State DI Filter 
....................     int16              m_ui16DOState;      // Populate the DO State after applying the State DO Filter 
....................     int8               m_i8ArrExpNextState[MAX_NO_OF_EXP_NXT_STATES]; 
....................     PTR_STATE_FUNCTION pFunStateFunction; 
....................      
.................... } ST_STATE_LOOKUP_TABLE_NODE; 
....................  
....................  
.................... typedef struct _ST_STATE_MACHINE 
.................... { 
....................     unsigned int32               m_ui32StateDIFilter; 
....................     unsigned int16               m_ui16StateDOFilter; 
....................     unsigned int16               m_uiStateCounterFilter; 
....................     ST_STATE_INDEX_TABLE_NODE    m_stArrStateIndexTable[MAX_NUMBER_OF_STATE]; 
....................     ST_STATE_LOOKUP_TABLE_NODE   m_stArrStateLookupTable[MAX_NUMBER_OF_STATE]; 
....................     // Temporary Values 
....................     unsigned int32               m_ui32LastDIState; 
....................     unsigned int16               m_ui16LastDOState; 
....................  
....................     //int8                       m_iExpNxtStates; 
....................     int8                         m_i8ArrCurExpNextState[MAX_NO_OF_EXP_NXT_STATES];    // Expected Next States 
....................     int8                         m_i8PrevState; 
....................     int8                         m_fContinue; 
.................... } ST_STATE_MACHINE; 
....................  
....................  
.................... //================= All Variable Declarations Start ==========================// 
.................... //UN_ALL_DIS      g_unAllDIs; 
.................... //UN_ALL_DOS      g_unDOState; 
.................... //UN_ALL_COUNTERS g_unAllCounters; 
....................  
.................... unsigned int32 g_ui32AllDIsPreviousState      = 0;      //TODO This should be overwrite by Board Initialization 
.................... unsigned int16 g_ui32AllDOsCurrentState       = 0;      //TODO This should be overwrite by Board Initialization 
.................... unsigned int16 g_ui32AllDOsPreviousState      = 0;      //TODO This should be overwrite by Board Initialization 
.................... unsigned int16 g_ui32AllCountersCurrentState  = 0;      //TODO This should be overwrite by Board Initialization 
.................... unsigned int16 g_ui32AllCountersPreviousState = 0;      //TODO This should be overwrite by Board Initialization 
....................  
.................... unsigned int8  g_uiStateChange = FLAG_STATE_NOT_CHANGED; 
.................... unsigned int8  g_fSuctionWait = 0;  
.................... unsigned int16 g_ui16TimerCount = 0;  
.................... //================= All Variable Declarations End ============================// 
....................  
.................... // Timer Function for DI Polling 
.................... /*void PollingInterrupt() 
.................... { 
....................     // Step 1 : Poll all DIs 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn00 = input(PIN_IN_DI_00); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn01 = input(PIN_IN_DI_01); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn02 = input(PIN_IN_DI_02); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn03 = input(PIN_IN_DI_03); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn04 = input(PIN_IN_DI_04); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn05 = input(PIN_IN_DI_05); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn06 = input(PIN_IN_DI_06); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn07 = input(PIN_IN_DI_07); 
....................  
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn08 = input(PIN_IN_DI_08); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn09 = input(PIN_IN_DI_09); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn10 = input(PIN_IN_DI_10); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn11 = input(PIN_IN_DI_11); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn12 = input(PIN_IN_DI_12); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn13 = input(PIN_IN_DI_13); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn14 = input(PIN_IN_DI_14); 
....................     unsigned int8 ui8Test =  
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn15 = input(PIN_IN_DI_15); 
....................  
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn16 = input(PIN_IN_DI_16); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn17 = input(PIN_IN_DI_17); 
....................  
....................     // Step 2: Check for any state change 
....................     // Check ALL DI States Changes and all DO State Changes 
....................     if (g_unAllDIs.m_ui32AllDIs == g_ui32AllDIsPreviousState && 
....................         g_unDOState.m_ui16AllDOs == g_ui32AllDOsPreviousState) 
....................     { 
....................         g_uiStateChange = FLAG_STATE_NOT_CHANGED; 
....................     } 
....................     else 
....................     { 
....................         g_uiStateChange = FLAG_STATE_CHANGED; 
....................         g_ui32AllDIsPreviousState = g_unAllDIs.m_ui32AllDIs; 
....................         g_ui32AllDOsPreviousState = g_unDOState.m_ui16AllDOs; 
....................     } 
....................  
....................  
....................     if (g_fSuctionWait == TIMER_FLAG_SUCTION_WAIT_ON) 
....................     { 
....................         g_ui16TimerCount++; 
....................     } 
....................  
.................... }*/ 
....................  
.................... void ExecuteALLDOs(void) 
.................... { 
....................     delay_us(10); 
....................     output_bit(PIN_OUT_DO_00, g_unDOState.m_stAllDOBits.m_ui1HWDOCn00); 
....................     output_bit(PIN_OUT_DO_01, g_unDOState.m_stAllDOBits.m_ui1HWDOCn01); 
....................     output_bit(PIN_OUT_DO_02, g_unDOState.m_stAllDOBits.m_ui1HWDOCn02); 
....................     output_bit(PIN_OUT_DO_03, g_unDOState.m_stAllDOBits.m_ui1HWDOCn03); 
....................     output_bit(PIN_OUT_DO_04, g_unDOState.m_stAllDOBits.m_ui1HWDOCn04); 
....................     output_bit(PIN_OUT_DO_05, g_unDOState.m_stAllDOBits.m_ui1HWDOCn05); 
....................     output_bit(PIN_OUT_DO_06, g_unDOState.m_stAllDOBits.m_ui1HWDOCn06); 
....................     output_bit(PIN_OUT_DO_07, g_unDOState.m_stAllDOBits.m_ui1HWDOCn07);    
.................... } 
....................      
.................... int8 HandleStateError(ST_STATE_MACHINE *pstStateMachine) 
.................... { 
....................     int8 iStateIdx = 1; 
....................     // Check for all the states and find suitable state 
....................     for (iStateIdx = 1; iStateIdx < MAX_NUMBER_OF_STATE; iStateIdx++) 
....................     { 
....................          
....................     }     
....................     return 0; 
.................... } 
....................  
....................  
.................... int8 CheckState(ST_STATE_MACHINE *pstStateMachine, int8 i8StMacIndex) 
.................... { 
....................     unsigned int32 ui32DIState   = 0; 
....................     unsigned int16 ui16DOState   = 0; 
....................     int8           i8ExpNxtState = 0; 
....................     int8           i8TempState   = 0; 
....................     ST_STATE_LOOKUP_TABLE_NODE* pStLookUptableNode = 0; 
....................     unsigned int8 ui8ExpNextState = 0; 
....................      
....................     // Step 1: Apply DI and DO Filter 
....................     ui32DIState = g_unDIState.m_ui32AllDIs & pstStateMachine->m_ui32StateDIFilter; 
....................     //ui16DOState = g_unDOState.m_ui16AllDOs & pstStateMachine->m_ui16StateDOFilter; 
....................     
....................     // Step 2: Check with DO State Filter 
....................     // If Any change not found then Return 
....................     if (!(ui32DIState ^ pstStateMachine->m_ui32LastDIState) && pstStateMachine->m_fContinue == STATE_CONTINUE_OFF) 
....................     { 
....................         // No Change 
....................         // So Return 0 
....................         return 0; 
....................     } 
....................     // Step 3: IF Change found then do the following: 
....................     //     a. Update last state value 
....................     //     b. Check if the State is matching with the expected next state 
....................     //     c. If YES then call State function 
....................     //     d. If the State is not matching then perform Error Handling 
....................      
....................     // Stape 3a: Update last state value 
....................     //pstStateMachine->m_ui32LastDIState = ui32DIState; 
....................  
....................     // Step 3b: Check if the State is matching with the expected next states 
....................     for (i8ExpNxtState = 0; i8ExpNxtState < MAX_NO_OF_EXP_NXT_STATES; i8ExpNxtState++) 
....................     {        
....................         //pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8PrevState].; 
....................         //if (pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8ArrCurExpNextState[i8ExpNxtState]].m_ui32DIState ^ ui32DIState) 
....................         //if (0 == (pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8ArrCurExpNextState[i8ExpNxtState]].m_ui32DIState ^ ui32DIState)) 
....................         ui8ExpNextState = pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8PrevState].m_i8ArrExpNextState[i8ExpNxtState]; 
....................         if (ui8ExpNextState == STATE_NOTHING) 
....................         { 
....................             // No State Matched, this is an Error 
....................             // Handle Error 
....................             return HandleStateError(pstStateMachine); 
....................         }     
....................          
....................         if (0 == (pstStateMachine->m_stArrStateLookupTable[ui8ExpNextState].m_ui32DIState ^ ui32DIState)) 
....................         {    
....................             // State Is matching 
....................             // Call State Function 
....................             pstStateMachine->m_stArrStateLookupTable[ui8ExpNextState].pFunStateFunction(i8StMacIndex, ui8ExpNextState); 
....................              
....................             pstStateMachine->m_i8PrevState = ui8ExpNextState; 
....................              
....................             //if (pstStateMachine->m_ui32StateDIFilter == 0x7000007) 
....................             //{ 
....................             //    output_bit(PIN_OUT_DO_07, 0); 
....................             //    g_unDOState.m_stAllDOBits.m_ui1HWDOCn07 = 0; 
....................             //}     
....................             // Stape 3a: Update last state value 
....................             pstStateMachine->m_ui32LastDIState = ui32DIState; 
....................              
....................             break; 
....................              
....................         } 
....................         else 
....................         { 
....................             // Next State is not matching 
....................             // ERROR 
....................         } 
....................     } 
....................  
....................  
....................     // If Expected State does not match 
....................     if (i8ExpNxtState == MAX_NO_OF_EXP_NXT_STATES) 
....................     { 
....................         // Handle Error 
....................         return HandleStateError(pstStateMachine); 
....................     } 
....................  
....................     return VI_RETN_SUCCESS; 
.................... } 
....................  
.................... void InitilizeStates() 
.................... { 
....................     g_unDIState.m_ui32AllDIs = 0xFFFFFFFF; 
....................     g_unDOState.m_ui16AllDOs = 0xFFFF; 
.................... } 
....................      
....................  
.................... #endif /* _VI_STATE_MACHINE_H_ */ 
....................  
....................  
....................  
....................  
.................... //#ifndef _VM_STATE_MACHINE_H_ 
.................... //#define _VM_STATE_MACHINE_H_ 
.................... // 
.................... //#include "vmDigitalIOConfig.h" 
.................... ///*************************** Inclusion files **********************************/ 
.................... // 
.................... //#define FLAG_STATE_CHANGED           1 
.................... //#define FLAG_STATE_NOT_CHANGED       0 
.................... //#define MAX_NUMBER_OF_STATE_MACHINES 5 
.................... //#define MIN_NUMBER_OF_STATE_MACHINES 1 
.................... //#define MAX_NUMBER_OF_STATE          8 
.................... //#define MAX_NO_OF_EXP_NXT_STATES     4 
.................... // 
.................... //#define STATE_MACHINE_0   0 
.................... //#define STATE_MACHINE_1   1 
.................... //#define STATE_MACHINE_2   2 
.................... //#define STATE_MACHINE_3   3 
.................... //#define STATE_MACHINE_4   4 
.................... // 
.................... ////#define TIMER_FLAG_SUCTION_WAIT_ON   1 
.................... ////#define TIMER_FLAG_SUCTION_WAIT_OFF  0 
.................... ////#define COUNTER_SUCTION_WAIT         300 
.................... // 
.................... //// Return codes 
.................... //#define VI_RETN_SUCCESS               0 
.................... // 
.................... //#define STATE_NOTHING 0 
.................... //#define STATE_01 1 
.................... //#define STATE_02 2 
.................... //#define STATE_03 3 
.................... //#define STATE_04 4 
.................... //#define STATE_05 5 
.................... //#define STATE_06 6 
.................... //#define STATE_07 7 
.................... //#define STATE_08 8 
.................... //#define STATE_09 9 
.................... //#define STATE_10 10 
.................... //#define STATE_11 11 
.................... //#define STATE_12 12 
.................... //#define STATE_13 13 
.................... //#define STATE_14 14 
.................... //#define STATE_15 15 
.................... //#define STATE_16 16 
.................... //#define STATE_17 17 
.................... //#define STATE_18 18 
.................... //#define STATE_19 19 
.................... // 
.................... //#define STATE_CONTINUE_OFF 0 
.................... //#define STATE_CONTINUE_ON  1 
.................... // 
.................... // 
.................... //int8 g_ui8NumberOfActiveMachines; //= MIN_NUMBER_OF_STATE_MACHINES; 
.................... // 
.................... // 
.................... // 
.................... //typedef struct _ST_STATE_INDEX_TABLE_NODE 
.................... //{ 
.................... //    int32 m_ui32DIState;      // Populate the DI State after applying the State DI Filter 
.................... //    int16 m_ui16DOState;      // Populate the DO State after applying the State DO Filter 
.................... //} ST_STATE_INDEX_TABLE_NODE; 
.................... // 
.................... // 
.................... //typedef unsigned int8(*PTR_STATE_FUNCTION)(int8, int8); 
.................... ////typedef unsigned int8(*PTR_STATE_FUNCTION)(void); 
.................... // 
.................... //typedef struct _ST_STATE_LOOKUP_TABLE_NODE 
.................... //{ 
.................... //    int32              m_ui32DIState;      // Populate the DI State after applying the State DI Filter 
.................... //    int16              m_ui16DOState;      // Populate the DO State after applying the State DO Filter 
.................... //    int8               m_i8ArrExpNextState[MAX_NO_OF_EXP_NXT_STATES]; 
.................... //    PTR_STATE_FUNCTION pFunStateFunction; 
.................... //     
.................... //} ST_STATE_LOOKUP_TABLE_NODE; 
.................... // 
.................... // 
.................... //typedef struct _ST_STATE_MACHINE 
.................... //{ 
.................... //    unsigned int32               m_ui32StateDIFilter; 
.................... //    unsigned int16               m_ui16StateDOFilter; 
.................... //    unsigned int16               m_uiStateCounterFilter; 
.................... //    ST_STATE_INDEX_TABLE_NODE    m_stArrStateIndexTable[MAX_NUMBER_OF_STATE]; 
.................... //    ST_STATE_LOOKUP_TABLE_NODE   m_stArrStateLookupTable[MAX_NUMBER_OF_STATE]; 
.................... //    // Temporary Values 
.................... //    unsigned int32               m_ui32LastDIState; 
.................... //    unsigned int16               m_ui16LastDOState; 
.................... // 
.................... //    //int8                       m_iExpNxtStates; 
.................... //    int8                         m_i8ArrCurExpNextState[MAX_NO_OF_EXP_NXT_STATES];    // Expected Next States 
.................... //    int8                         m_i8PrevState; 
.................... //    int8                         m_fContinue; 
.................... //} ST_STATE_MACHINE; 
.................... // 
.................... // 
.................... ////================= All Variable Declarations Start ==========================// 
.................... ////UN_ALL_DIS      g_unAllDIs; 
.................... ////UN_ALL_DOS      g_unDOState; 
.................... ////UN_ALL_COUNTERS g_unAllCounters; 
.................... // 
.................... //unsigned int32 g_ui32AllDIsPreviousState      = 0;      //TODO This should be overwrite by Board Initialization 
.................... //unsigned int16 g_ui32AllDOsCurrentState       = 0;      //TODO This should be overwrite by Board Initialization 
.................... //unsigned int16 g_ui32AllDOsPreviousState      = 0;      //TODO This should be overwrite by Board Initialization 
.................... //unsigned int16 g_ui32AllCountersCurrentState  = 0;      //TODO This should be overwrite by Board Initialization 
.................... //unsigned int16 g_ui32AllCountersPreviousState = 0;      //TODO This should be overwrite by Board Initialization 
.................... // 
.................... //unsigned int8  g_uiStateChange = FLAG_STATE_NOT_CHANGED; 
.................... //unsigned int8  g_fSuctionWait = 0;  
.................... //unsigned int16 g_ui16TimerCount = 0;  
.................... ////================= All Variable Declarations End ============================// 
.................... // 
.................... //// Timer Function for DI Polling 
.................... ///*void PollingInterrupt() 
.................... //{ 
.................... //    // Step 1 : Poll all DIs 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn00 = input(PIN_IN_DI_00); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn01 = input(PIN_IN_DI_01); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn02 = input(PIN_IN_DI_02); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn03 = input(PIN_IN_DI_03); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn04 = input(PIN_IN_DI_04); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn05 = input(PIN_IN_DI_05); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn06 = input(PIN_IN_DI_06); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn07 = input(PIN_IN_DI_07); 
.................... // 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn08 = input(PIN_IN_DI_08); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn09 = input(PIN_IN_DI_09); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn10 = input(PIN_IN_DI_10); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn11 = input(PIN_IN_DI_11); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn12 = input(PIN_IN_DI_12); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn13 = input(PIN_IN_DI_13); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn14 = input(PIN_IN_DI_14); 
.................... //    unsigned int8 ui8Test =  
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn15 = input(PIN_IN_DI_15); 
.................... // 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn16 = input(PIN_IN_DI_16); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn17 = input(PIN_IN_DI_17); 
.................... // 
.................... //    // Step 2: Check for any state change 
.................... //    // Check ALL DI States Changes and all DO State Changes 
.................... //    if (g_unAllDIs.m_ui32AllDIs == g_ui32AllDIsPreviousState && 
.................... //        g_unDOState.m_ui16AllDOs == g_ui32AllDOsPreviousState) 
.................... //    { 
.................... //        g_uiStateChange = FLAG_STATE_NOT_CHANGED; 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        g_uiStateChange = FLAG_STATE_CHANGED; 
.................... //        g_ui32AllDIsPreviousState = g_unAllDIs.m_ui32AllDIs; 
.................... //        g_ui32AllDOsPreviousState = g_unDOState.m_ui16AllDOs; 
.................... //    } 
.................... // 
.................... // 
.................... //    if (g_fSuctionWait == TIMER_FLAG_SUCTION_WAIT_ON) 
.................... //    { 
.................... //        g_ui16TimerCount++; 
.................... //    } 
.................... // 
.................... //}*/ 
.................... // 
.................... //void ExecuteALLDOs(void) 
.................... //{ 
.................... //    delay_us(10); 
.................... //    output_bit(PIN_OUT_DO_00, g_unDOState.m_stAllDOBits.m_ui1HWDOCn00); 
.................... //    output_bit(PIN_OUT_DO_01, g_unDOState.m_stAllDOBits.m_ui1HWDOCn01); 
.................... //    output_bit(PIN_OUT_DO_02, g_unDOState.m_stAllDOBits.m_ui1HWDOCn02); 
.................... //    output_bit(PIN_OUT_DO_03, g_unDOState.m_stAllDOBits.m_ui1HWDOCn03); 
.................... //    output_bit(PIN_OUT_DO_04, g_unDOState.m_stAllDOBits.m_ui1HWDOCn04); 
.................... //    output_bit(PIN_OUT_DO_05, g_unDOState.m_stAllDOBits.m_ui1HWDOCn05); 
.................... //    output_bit(PIN_OUT_DO_06, g_unDOState.m_stAllDOBits.m_ui1HWDOCn06); 
.................... //    output_bit(PIN_OUT_DO_07, g_unDOState.m_stAllDOBits.m_ui1HWDOCn07);    
.................... //} 
.................... //     
.................... //int8 HandleStateError(ST_STATE_MACHINE *pstStateMachine) 
.................... //{ 
.................... //    int8 iStateIdx = 1; 
.................... //    // Check for all the states and find suitable state 
.................... //    for (iStateIdx = 1; iStateIdx < MAX_NUMBER_OF_STATE; iStateIdx++) 
.................... //    { 
.................... //         
.................... //    }     
.................... //    return 0; 
.................... //} 
.................... // 
.................... // 
.................... //int8 CheckState(ST_STATE_MACHINE *pstStateMachine, int8 i8StMacIndex) 
.................... //{ 
.................... //    unsigned int32 ui32DIState   = 0; 
.................... //    unsigned int16 ui16DOState   = 0; 
.................... //    int8           i8ExpNxtState = 0; 
.................... //    int8           i8TempState   = 0; 
.................... //    ST_STATE_LOOKUP_TABLE_NODE* pStLookUptableNode = 0; 
.................... //    unsigned int8 ui8ExpNextState = 0; 
.................... //     
.................... //    // Step 1: Apply DI and DO Filter 
.................... //    //ui32DIState = g_unDIState.m_ui32AllDIs & pstStateMachine->m_ui32StateDIFilter; 
.................... //    //ui16DOState = g_unDOState.m_ui16AllDOs & pstStateMachine->m_ui16StateDOFilter; 
.................... //    
.................... //    // Step 2: Check with DO State Filter 
.................... //    // If Any change not found then Return 
.................... //    if (!(ui32DIState ^ pstStateMachine->m_ui32LastDIState) && pstStateMachine->m_fContinue == STATE_CONTINUE_OFF) 
.................... //    { 
.................... //        // No Change 
.................... //        // So Return 0 
.................... //        return 0; 
.................... //    } 
.................... //    // Step 3: IF Change found then do the following: 
.................... //    //     a. Update last state value 
.................... //    //     b. Check if the State is matching with the expected next state 
.................... //    //     c. If YES then call State function 
.................... //    //     d. If the State is not matching then perform Error Handling 
.................... //     
.................... //    // Stape 3a: Update last state value 
.................... //    //pstStateMachine->m_ui32LastDIState = ui32DIState; 
.................... // 
.................... //    // Step 3b: Check if the State is matching with the expected next states 
.................... //    for (i8ExpNxtState = 0; i8ExpNxtState < MAX_NO_OF_EXP_NXT_STATES; i8ExpNxtState++) 
.................... //    {        
.................... //        //pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8PrevState].; 
.................... //        //if (pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8ArrCurExpNextState[i8ExpNxtState]].m_ui32DIState ^ ui32DIState) 
.................... //        //if (0 == (pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8ArrCurExpNextState[i8ExpNxtState]].m_ui32DIState ^ ui32DIState)) 
.................... //        ui8ExpNextState = pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8PrevState].m_i8ArrExpNextState[i8ExpNxtState]; 
.................... //        if (ui8ExpNextState == STATE_NOTHING) 
.................... //        { 
.................... //            // No State Matched, this is an Error 
.................... //            // Handle Error 
.................... //            return HandleStateError(pstStateMachine); 
.................... //        }     
.................... //         
.................... //        if (0 == (pstStateMachine->m_stArrStateLookupTable[ui8ExpNextState].m_ui32DIState ^ ui32DIState)) 
.................... //        {    
.................... //            // State Is matching 
.................... //            // Call State Function 
.................... //            pstStateMachine->m_stArrStateLookupTable[ui8ExpNextState].pFunStateFunction(i8StMacIndex, ui8ExpNextState); 
.................... //             
.................... //            pstStateMachine->m_i8PrevState = ui8ExpNextState; 
.................... //             
.................... //            //if (pstStateMachine->m_ui32StateDIFilter == 0x7000007) 
.................... //            //{ 
.................... //            //    output_bit(PIN_OUT_DO_07, 0); 
.................... //            //    g_unDOState.m_stAllDOBits.m_ui1HWDOCn07 = 0; 
.................... //            //}     
.................... //            // Stape 3a: Update last state value 
.................... //            pstStateMachine->m_ui32LastDIState = ui32DIState; 
.................... //             
.................... //            break; 
.................... //             
.................... //        } 
.................... //        else 
.................... //        { 
.................... //            // Next State is not matching 
.................... //            // ERROR 
.................... //        } 
.................... //    } 
.................... // 
.................... // 
.................... //    // If Expected State does not match 
.................... //    if (i8ExpNxtState == MAX_NO_OF_EXP_NXT_STATES) 
.................... //    { 
.................... //        // Handle Error 
.................... //        return HandleStateError(pstStateMachine); 
.................... //    } 
.................... // 
.................... //    return VI_RETN_SUCCESS; 
.................... //} 
.................... // 
.................... //void InitilizeStates() 
.................... //{ 
.................... //   // g_unDIState.m_ui32AllDIs = 0xFFFFFFFF; 
.................... //   // g_unDOState.m_ui16AllDOs = 0xFFFF; 
.................... //} 
.................... //     
.................... // 
.................... //#endif /* _VM_STATE_MACHINE_H_ */ 
.................... // 
.................... // 
....................  
....................  
.................... #define STPR_1_EMPTY_ON              0 
.................... #define STPR_1_EMPTY_OFF             1 
.................... #define STPR_0_SET_TRANSFERED_ON     0 
.................... #define STPR_0_SET_TRANSFERED_OFF    1 
.................... #define STPR_1_SET_TRANSFERED_ON     0 
.................... #define STPR_1_SET_TRANSFERED_OFF    1 
.................... #define STPR_1_CAN_SET_COUNT_DONE    0 
.................... #define STPR_1_CAN_SET_COUNT_NOT_DONE 1 
.................... #define PUSHER_EMPTY_ON              0 
.................... #define PUSHER_EMPTY_OFF             1 
.................... #define PUSHER_0_TIME_OUT_ON         0 
.................... #define PUSHER_0_TIME_OUT_OFF        1 
.................... #define PUSHER_0_ALL_DONE            0 
.................... #define PUSHER_0_ALL_NOT_DONE        1 
.................... #define PUSHER_1_TIME_OUT_ON         0 
.................... #define PUSHER_1_TIME_OUT_OFF        1 
.................... #define PUSHER_1_ALL_DONE            0 
.................... #define PUSHER_1_ALL_NOT_DONE        1 
.................... #define STACKER_READY_ON             0 
.................... #define STACKER_READY_OFF            1 
.................... #define PUSHER_0_FIRST_PUSH_ON       0 
.................... #define PUSHER_0_FIRST_PUSH_OFF      1 
.................... #define PUSHER_1_FIRST_PUSH_ON       0 
.................... #define PUSHER_1_FIRST_PUSH_OFF      1 
....................  
....................  
.................... #define SPCL_FLAG_SM_1_START_TRANSFER_OFF 0 
.................... #define SPCL_FLAG_SM_1_START_TRANSFER_ON  1 
....................  
....................  
.................... #define NO_OF_ACTIVE_MACHINE        2 
....................  
.................... #define INITAIL_DI_STATE_ON_PWR_ON   0xFFFF3F5F 
.................... #define INITAIL_DO_STATE_ON_PWR_ON   0x3FFF 
.................... #define SAFE_MODE_DO_STATE           0x3FFF 
.................... #define PRE_PRODUCTION_DO_STATE      0xBFFF 
....................  
.................... //////////////////// State Machine 0 DI DO States Start //////////////////////// 
.................... #define 	STATE_SM0_HWDI_FILTER	0xD0000010 
.................... #define 	STATE_SM0_HWDI_01	0xD0000010 
.................... #define 	STATE_SM0_HWDI_02	0x50000010 
.................... #define 	STATE_SM0_HWDI_03	0x10000010 
.................... #define 	STATE_SM0_HWDI_04	0x90000010 
.................... #define 	STATE_SM0_HWDI_05	0xD0000010 
.................... #define 	STATE_SM0_HWDI_06	0x80000010 
.................... #define 	STATE_SM0_HWDI_07	0xC0000010 
.................... #define 	STATE_SM0_HWDI_08	0xD0000010 
.................... #define 	STATE_SM0_HWDI_09	0xD0000000 
.................... #define 	STATE_SM0_HWDI_10	0xD0000010 
....................  
.................... #define 	STATE_SM0_HWDO_FILTER	0x8000 
.................... #define 	STATE_SM0_HWDO_01	0x8000 
.................... #define 	STATE_SM0_HWDO_02	0x8000 
.................... #define 	STATE_SM0_HWDO_03	0x0000 
.................... #define 	STATE_SM0_HWDO_04	0x0000 
.................... #define 	STATE_SM0_HWDO_05	0x0000 
.................... #define 	STATE_SM0_HWDO_06	0x0000 
.................... #define 	STATE_SM0_HWDO_07	0x0000 
.................... #define 	STATE_SM0_HWDO_08	0x0000 
.................... #define 	STATE_SM0_HWDO_09	0x0000 
.................... #define 	STATE_SM0_HWDO_10	0x8000 
....................  
....................  
.................... //////////////////// State Machine 0 DI DO States End ////////////////////////// 
....................  
.................... //////////////////// State Machine 1 DI DO States Start //////////////////////// 
.................... #define 	STATE_SM1_HWDI_FILTER	0x08001800 
.................... #define 	STATE_SM1_HWDI_01	0x08000800 
.................... #define 	STATE_SM1_HWDI_02	0x00000800 
.................... #define 	STATE_SM1_HWDI_03	0x00001800 
.................... #define 	STATE_SM1_HWDI_04	0x08000000 
....................  
.................... #define 	STATE_SM1_HWDO_FILTER	0x4000 
.................... #define 	STATE_SM1_HWDO_01	0x4000 
.................... #define 	STATE_SM1_HWDO_02	0x0000 
.................... #define 	STATE_SM1_HWDO_03	0x4000 
.................... #define 	STATE_SM1_HWDO_04	0x4000 
....................  
.................... //#define 	STATE_SM1_HWDI_FILTER	0x0C001800 
.................... //#define 	STATE_SM1_HWDI_01	0x0C000800 
.................... //#define 	STATE_SM1_HWDI_02	0x08000800 
.................... //#define 	STATE_SM1_HWDI_03	0x04000800 
.................... //#define 	STATE_SM1_HWDI_04	0x04001800 
.................... //#define 	STATE_SM1_HWDI_05	0x00000800 
.................... //#define 	STATE_SM1_HWDI_06	0x0C000000 
.................... // 
.................... //#define 	STATE_SM1_HWDO_FILTER	0x4000 
.................... //#define 	STATE_SM1_HWDO_01	0x4000 
.................... //#define 	STATE_SM1_HWDO_02	0x4000 
.................... //#define 	STATE_SM1_HWDO_03	0x0000 
.................... //#define 	STATE_SM1_HWDO_04	0x4000 
.................... //#define 	STATE_SM1_HWDO_05	0x4000 
.................... //#define 	STATE_SM1_HWDO_06	0x4000 
.................... //////////////////// State Machine 1 DI DO States End ////////////////////////// 
....................  
.................... ST_STATE_MACHINE g_stArrStateMachines[NO_OF_ACTIVE_MACHINE]; 
....................  
.................... unsigned int8 g_fStateMac1StartCanTransfer = SPCL_FLAG_SM_1_START_TRANSFER_ON; 
....................  
....................  
....................  
.................... //void InitializeStateMachines() 
.................... //{ 
....................     //g_unDIState.m_ui32AllDIs = 0xFFFFFFFF; 
....................     //g_unDOState.m_ui16AllDOs = 0xFFFF; 
.................... //} 
.................... /* 
.................... // 01 : Home State 
.................... unsigned int8 StateFunc_GenericState(int8 i8StateMachine, int8 i8State) 
.................... { 
....................     // Take action 
....................     // Main intention is to not change values of other DO fields, except the fields under the state DO Filter 
....................     // Also only the changes will added to the original ALL DOs  
....................     unsigned int16 ui16Temp0 = 0; 
....................     unsigned int16 ui16Temp1 = 0; 
....................     //g_unAllDOs.m_ui16AllDOs = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState; 
....................      
....................     // Hold the Current DO Values to temp 
....................     ui16Temp0 = g_unDOState.m_ui16AllDOs; 
....................  
....................     // Bitwise AND with the State DO Filter with the Value to change 
....................     ui16Temp1 = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState & 
....................                 g_stArrStateMachines[i8StateMachine].m_ui16StateDOFilter; 
....................      
....................     // Finally Bitwise OR operation between original value to the temp 
....................     g_unDOState.m_ui16AllDOs = ui16Temp0 | ui16Temp1; 
....................  
....................     return 0; 
.................... }  
.................... */ 
.................... unsigned int8 StateFunc_GenericState_(int8 i8StateMachine, int8 i8State) 
.................... { 
....................  
....................         unsigned int16 ui8DO       = g_unDOState.m_ui16AllDOs; 
....................         unsigned int16 ui8Filter   = g_stArrStateMachines[i8StateMachine].m_ui16StateDOFilter; 
....................         unsigned int16 ui8Value    = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState; 
....................         unsigned int16 ui8BitValue = 0; 
....................          
....................         for(int i = 0; i < 16; i++) 
....................         { 
....................             if(1 == ((ui8Filter >> i)&0x0001)) 
....................             { 
....................                 ui8BitValue = ((ui8Value >> i)&0x0001); 
....................                 ui8DO = (ui8DO & (~(1 << i))) | (ui8BitValue << i); 
....................             } 
....................         } 
....................  
....................     g_unDOState.m_ui16AllDOs = ui8DO; 
....................     return 0; 
.................... }  
....................  
.................... unsigned int8 StateFunc_GenericState(int8 i8StateMachine, int8 i8State) 
.................... { 
....................     UN_ALL_DOS unFilter; 
....................     UN_ALL_DOS unValue; 
....................      
....................     unFilter.m_ui16AllDOs = g_stArrStateMachines[i8StateMachine].m_ui16StateDOFilter; 
*
021E6:  MOVLB  A
021E8:  CLRF   xC8
021EA:  MOVFF  ABF,AC7
021EE:  CLRF   xCA
021F0:  MOVLW  C8
021F2:  MOVWF  xC9
021F4:  MOVLB  0
021F6:  CALL   05BA
021FA:  MOVFF  01,AC5
021FE:  MOVLW  04
02200:  MOVLB  A
02202:  ADDWF  01,W
02204:  MOVWF  01
02206:  MOVLW  00
02208:  ADDWFC 02,W
0220A:  MOVWF  03
0220C:  MOVF   01,W
0220E:  ADDLW  62
02210:  MOVWF  FE9
02212:  MOVLW  01
02214:  ADDWFC 03,W
02216:  MOVWF  FEA
02218:  MOVFF  FEC,AC2
0221C:  MOVF   FED,F
0221E:  MOVFF  FEF,AC1
....................     unValue.m_ui16AllDOs  = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState; 
02222:  CLRF   xC8
02224:  MOVFF  ABF,AC7
02228:  CLRF   xCA
0222A:  MOVLW  C8
0222C:  MOVWF  xC9
0222E:  MOVLB  0
02230:  CALL   05BA
02234:  MOVFF  02,AC6
02238:  MOVFF  01,AC5
0223C:  MOVLW  44
0223E:  MOVLB  A
02240:  ADDWF  xC5,F
02242:  MOVLW  00
02244:  ADDWFC xC6,F
02246:  CLRF   xC8
02248:  MOVFF  AC0,AC7
0224C:  CLRF   xCA
0224E:  MOVLW  0C
02250:  MOVWF  xC9
02252:  MOVLB  0
02254:  CALL   05BA
02258:  MOVF   01,W
0225A:  MOVLB  A
0225C:  ADDWF  xC5,F
0225E:  MOVF   02,W
02260:  ADDWFC xC6,F
02262:  MOVLW  04
02264:  ADDWF  xC5,W
02266:  MOVWF  01
02268:  MOVLW  00
0226A:  ADDWFC xC6,W
0226C:  MOVWF  03
0226E:  MOVF   01,W
02270:  ADDLW  62
02272:  MOVWF  FE9
02274:  MOVLW  01
02276:  ADDWFC 03,W
02278:  MOVWF  FEA
0227A:  MOVFF  FEC,AC4
0227E:  MOVF   FED,F
02280:  MOVFF  FEF,AC3
....................      
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn00) g_unDOState.m_stAllDOBits.m_ui1HWDOCn00 = unValue.m_stAllDOBits.m_ui1HWDOCn00; 
02284:  BTFSS  xC2.7
02286:  GOTO   2290
0228A:  BCF    1E.7
0228C:  BTFSC  xC4.7
0228E:  BSF    1E.7
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn01) g_unDOState.m_stAllDOBits.m_ui1HWDOCn01 = unValue.m_stAllDOBits.m_ui1HWDOCn01; 
02290:  BTFSS  xC2.6
02292:  GOTO   229C
02296:  BCF    1E.6
02298:  BTFSC  xC4.6
0229A:  BSF    1E.6
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn02) g_unDOState.m_stAllDOBits.m_ui1HWDOCn02 = unValue.m_stAllDOBits.m_ui1HWDOCn02; 
0229C:  BTFSS  xC2.5
0229E:  GOTO   22A8
022A2:  BCF    1E.5
022A4:  BTFSC  xC4.5
022A6:  BSF    1E.5
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn03) g_unDOState.m_stAllDOBits.m_ui1HWDOCn03 = unValue.m_stAllDOBits.m_ui1HWDOCn03; 
022A8:  BTFSS  xC2.4
022AA:  GOTO   22B4
022AE:  BCF    1E.4
022B0:  BTFSC  xC4.4
022B2:  BSF    1E.4
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn04) g_unDOState.m_stAllDOBits.m_ui1HWDOCn04 = unValue.m_stAllDOBits.m_ui1HWDOCn04; 
022B4:  BTFSS  xC2.3
022B6:  GOTO   22C0
022BA:  BCF    1E.3
022BC:  BTFSC  xC4.3
022BE:  BSF    1E.3
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn05) g_unDOState.m_stAllDOBits.m_ui1HWDOCn05 = unValue.m_stAllDOBits.m_ui1HWDOCn05; 
022C0:  BTFSS  xC2.2
022C2:  GOTO   22CC
022C6:  BCF    1E.2
022C8:  BTFSC  xC4.2
022CA:  BSF    1E.2
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn06) g_unDOState.m_stAllDOBits.m_ui1HWDOCn06 = unValue.m_stAllDOBits.m_ui1HWDOCn06; 
022CC:  BTFSS  xC2.1
022CE:  GOTO   22D8
022D2:  BCF    1E.1
022D4:  BTFSC  xC4.1
022D6:  BSF    1E.1
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn07) g_unDOState.m_stAllDOBits.m_ui1HWDOCn07 = unValue.m_stAllDOBits.m_ui1HWDOCn07; 
022D8:  BTFSS  xC2.0
022DA:  GOTO   22E4
022DE:  BCF    1E.0
022E0:  BTFSC  xC4.0
022E2:  BSF    1E.0
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn00) g_unDOState.m_stAllDOBits.m_ui1SRDOCn00 = unValue.m_stAllDOBits.m_ui1SRDOCn00; 
022E4:  BTFSS  xC1.7
022E6:  GOTO   22F0
022EA:  BCF    1D.7
022EC:  BTFSC  xC3.7
022EE:  BSF    1D.7
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn01) g_unDOState.m_stAllDOBits.m_ui1SRDOCn01 = unValue.m_stAllDOBits.m_ui1SRDOCn01; 
022F0:  BTFSS  xC1.6
022F2:  GOTO   22FC
022F6:  BCF    1D.6
022F8:  BTFSC  xC3.6
022FA:  BSF    1D.6
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn02) g_unDOState.m_stAllDOBits.m_ui1SRDOCn02 = unValue.m_stAllDOBits.m_ui1SRDOCn02; 
022FC:  BTFSS  xC1.5
022FE:  GOTO   2308
02302:  BCF    1D.5
02304:  BTFSC  xC3.5
02306:  BSF    1D.5
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn03) g_unDOState.m_stAllDOBits.m_ui1SRDOCn03 = unValue.m_stAllDOBits.m_ui1SRDOCn03; 
02308:  BTFSS  xC1.4
0230A:  GOTO   2314
0230E:  BCF    1D.4
02310:  BTFSC  xC3.4
02312:  BSF    1D.4
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn04) g_unDOState.m_stAllDOBits.m_ui1SRDOCn04 = unValue.m_stAllDOBits.m_ui1SRDOCn04; 
02314:  BTFSS  xC1.3
02316:  GOTO   2320
0231A:  BCF    1D.3
0231C:  BTFSC  xC3.3
0231E:  BSF    1D.3
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn05) g_unDOState.m_stAllDOBits.m_ui1SRDOCn05 = unValue.m_stAllDOBits.m_ui1SRDOCn05; 
02320:  BTFSS  xC1.2
02322:  GOTO   232C
02326:  BCF    1D.2
02328:  BTFSC  xC3.2
0232A:  BSF    1D.2
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn06) g_unDOState.m_stAllDOBits.m_ui1SRDOCn06 = unValue.m_stAllDOBits.m_ui1SRDOCn06; 
0232C:  BTFSS  xC1.1
0232E:  GOTO   2338
02332:  BCF    1D.1
02334:  BTFSC  xC3.1
02336:  BSF    1D.1
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn07) g_unDOState.m_stAllDOBits.m_ui1SRDOCn07 = unValue.m_stAllDOBits.m_ui1SRDOCn07; 
02338:  BTFSS  xC1.0
0233A:  GOTO   2344
0233E:  BCF    1D.0
02340:  BTFSC  xC3.0
02342:  BSF    1D.0
02344:  MOVLB  0
02346:  RETURN 0
....................      
.................... }     
....................  
....................          
....................  
....................          
.................... // 02: Start to Pick 
.................... unsigned int8 StateFunc_State02() 
.................... { 
....................     // We got message from outer board that Stacker Ready and Hopper Ready 
....................     // Now PD will start moving downword 
....................     //g_unAllDOs.m_bArr[2] = 1; 
....................     //g_unAllDOs.m_bArr[3] = 0; 
....................     // Expected Next State Declaration 
....................     g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[0] = STATE_03; 
....................     g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[1] = STATE_03; 
....................     g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[2] = STATE_03; 
....................     g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[3] = STATE_03; 
....................     return 0; 
.................... } 
....................  
....................  
.................... void InitExpNextStateDefault() 
.................... { 
....................     int8 i8StMcCount = 0; 
....................     int8 i8StCount   = 0; 
....................     int8 i8ExpNxtCount = 0; 
....................     for (i8StMcCount = 0; i8StMcCount < NO_OF_ACTIVE_MACHINE; i8StMcCount++) 
....................     { 
....................         // For all Active Look up tables 
....................         for (i8StCount = 0; i8StCount < MAX_NUMBER_OF_STATE; i8StCount++) 
....................         { 
....................             for (i8ExpNxtCount = 0; i8ExpNxtCount < MAX_NO_OF_EXP_NXT_STATES; i8ExpNxtCount++) 
....................             { 
....................                 g_stArrStateMachines[i8StMcCount].m_stArrStateLookupTable[i8StCount].m_i8ArrExpNextState[i8ExpNxtCount] = STATE_NOTHING; 
....................             } 
....................         } 
....................     } 
.................... } 
....................  
.................... void PostProductionSafeMode() 
.................... { 
....................     g_unDOState.m_ui16AllDOs = 0xFFFF; 
....................      
....................     // 1. Stopper 0 is in Push State 
....................     // 2. Can Stopper 1 is in Push state 
....................     // 3. Pusher 0, Pusher 1 and Can Guide all is in drag state 
....................     g_unDOState.m_ui16AllDOs = SAFE_MODE_DO_STATE; 
....................     ExecuteALLDOs(); 
.................... } 
....................  
.................... void PowerOnDOStateInit() 
.................... { 
....................     g_unDOState.m_ui16AllDOs = 0xFFFF; 
....................      
....................     // 1. Stopper 0 is in drag State 
....................     // 2. Can Stopper 1 is in Push state 
....................     // 3. Pusher 0, Pusher 1 and Can Guide all is in drag state 
....................     g_unDOState.m_ui16AllDOs = INITAIL_DO_STATE_ON_PWR_ON; 
....................     ExecuteALLDOs(); 
.................... } 
....................  
.................... #endif /* _VI_STATE_MACHINE_FOR_CP_H_ */ 
....................  
....................  
.................... //#include "vmSystemConfig.h" 
.................... ////#include "vmStateMachine.h" 
.................... // 
.................... //#define STPR_1_EMPTY_ON              0 
.................... //#define STPR_1_EMPTY_OFF             1 
.................... //#define STPR_0_SET_TRANSFERED_ON     0 
.................... //#define STPR_0_SET_TRANSFERED_OFF    1 
.................... //#define STPR_1_SET_TRANSFERED_ON     0 
.................... //#define STPR_1_SET_TRANSFERED_OFF    1 
.................... //#define STPR_1_CAN_SET_COUNT_DONE    0 
.................... //#define STPR_1_CAN_SET_COUNT_NOT_DONE 1 
.................... //#define PUSHER_EMPTY_ON              0 
.................... //#define PUSHER_EMPTY_OFF             1 
.................... //#define PUSHER_0_TIME_OUT_ON         0 
.................... //#define PUSHER_0_TIME_OUT_OFF        1 
.................... //#define PUSHER_0_ALL_DONE            0 
.................... //#define PUSHER_0_ALL_NOT_DONE        1 
.................... //#define PUSHER_1_TIME_OUT_ON         0 
.................... //#define PUSHER_1_TIME_OUT_OFF        1 
.................... //#define PUSHER_1_ALL_DONE            0 
.................... //#define PUSHER_1_ALL_NOT_DONE        1 
.................... //#define STACKER_READY_ON             0 
.................... //#define STACKER_READY_OFF            1 
.................... //#define PUSHER_0_FIRST_PUSH_ON       0 
.................... //#define PUSHER_0_FIRST_PUSH_OFF      1 
.................... //#define PUSHER_1_FIRST_PUSH_ON       0 
.................... //#define PUSHER_1_FIRST_PUSH_OFF      1 
.................... // 
.................... // 
.................... //#define SPCL_FLAG_SM_1_START_TRANSFER_OFF 0 
.................... //#define SPCL_FLAG_SM_1_START_TRANSFER_ON  1 
.................... // 
.................... // 
.................... //#define NO_OF_ACTIVE_MACHINE        5 
.................... // 
.................... //#define INITAIL_DI_STATE_ON_PWR_ON   0xFFFF3F5F 
.................... //#define INITAIL_DO_STATE_ON_PWR_ON   0x3FFF 
.................... //#define SAFE_MODE_DO_STATE           0x3FFF 
.................... //#define PRE_PRODUCTION_DO_STATE      0xBFFF 
.................... // 
.................... //ST_STATE_MACHINE g_stArrStateMachines[NO_OF_ACTIVE_MACHINE]; 
.................... // 
.................... //unsigned int8 g_fStateMac1StartCanTransfer = SPCL_FLAG_SM_1_START_TRANSFER_ON; 
.................... // 
.................... // 
.................... // 
.................... ////void InitializeStateMachines() 
.................... ////{ 
.................... //    //g_unDIState.m_ui32AllDIs = 0xFFFFFFFF; 
.................... //    //g_unDOState.m_ui16AllDOs = 0xFFFF; 
.................... ////} 
.................... ///* 
.................... //// 01 : Home State 
.................... //unsigned int8 StateFunc_GenericState(int8 i8StateMachine, int8 i8State) 
.................... //{ 
.................... //    // Take action 
.................... //    // Main intention is to not change values of other DO fields, except the fields under the state DO Filter 
.................... //    // Also only the changes will added to the original ALL DOs  
.................... //    unsigned int16 ui16Temp0 = 0; 
.................... //    unsigned int16 ui16Temp1 = 0; 
.................... //    //g_unAllDOs.m_ui16AllDOs = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState; 
.................... //     
.................... //    // Hold the Current DO Values to temp 
.................... //    ui16Temp0 = g_unDOState.m_ui16AllDOs; 
.................... // 
.................... //    // Bitwise AND with the State DO Filter with the Value to change 
.................... //    ui16Temp1 = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState & 
.................... //                g_stArrStateMachines[i8StateMachine].m_ui16StateDOFilter; 
.................... //     
.................... //    // Finally Bitwise OR operation between original value to the temp 
.................... //    g_unDOState.m_ui16AllDOs = ui16Temp0 | ui16Temp1; 
.................... // 
.................... //    return 0; 
.................... //}  
.................... //*/ 
.................... //unsigned int8 StateFunc_GenericState_(int8 i8StateMachine, int8 i8State) 
.................... //{ 
.................... // 
.................... ////        unsigned int16 ui8DO       = g_unDOState.m_ui16AllDOs; 
.................... ////        unsigned int16 ui8Filter   = g_stArrStateMachines[i8StateMachine].m_ui16StateDOFilter; 
.................... ////        unsigned int16 ui8Value    = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState; 
.................... ////        unsigned int16 ui8BitValue = 0; 
.................... ////         
.................... ////        for(int i = 0; i < 16; i++) 
.................... ////        { 
.................... ////            if(1 == ((ui8Filter >> i)&0x0001)) 
.................... ////            { 
.................... ////                ui8BitValue = ((ui8Value >> i)&0x0001); 
.................... ////                ui8DO = (ui8DO & (~(1 << i))) | (ui8BitValue << i); 
.................... ////            } 
.................... ////        } 
.................... //// 
.................... ////    g_unDOState.m_ui16AllDOs = ui8DO; 
.................... ////    return 0; 
.................... //}  
.................... // 
.................... //unsigned int8 StateFunc_GenericState(int8 i8StateMachine, int8 i8State) 
.................... //{ 
.................... ////    UN_ALL_DOS unFilter; 
.................... ////    UN_ALL_DOS unValue; 
.................... ////     
.................... ////    unFilter.m_ui16AllDOs = g_stArrStateMachines[i8StateMachine].m_ui16StateDOFilter; 
.................... ////    unValue.m_ui16AllDOs  = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState; 
.................... ////     
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn00) g_unDOState.m_stAllDOBits.m_ui1HWDOCn00 = unValue.m_stAllDOBits.m_ui1HWDOCn00; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn01) g_unDOState.m_stAllDOBits.m_ui1HWDOCn01 = unValue.m_stAllDOBits.m_ui1HWDOCn01; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn02) g_unDOState.m_stAllDOBits.m_ui1HWDOCn02 = unValue.m_stAllDOBits.m_ui1HWDOCn02; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn03) g_unDOState.m_stAllDOBits.m_ui1HWDOCn03 = unValue.m_stAllDOBits.m_ui1HWDOCn03; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn04) g_unDOState.m_stAllDOBits.m_ui1HWDOCn04 = unValue.m_stAllDOBits.m_ui1HWDOCn04; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn05) g_unDOState.m_stAllDOBits.m_ui1HWDOCn05 = unValue.m_stAllDOBits.m_ui1HWDOCn05; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn06) g_unDOState.m_stAllDOBits.m_ui1HWDOCn06 = unValue.m_stAllDOBits.m_ui1HWDOCn06; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn07) g_unDOState.m_stAllDOBits.m_ui1HWDOCn07 = unValue.m_stAllDOBits.m_ui1HWDOCn07; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn00) g_unDOState.m_stAllDOBits.m_ui1SRDOCn00 = unValue.m_stAllDOBits.m_ui1SRDOCn00; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn01) g_unDOState.m_stAllDOBits.m_ui1SRDOCn01 = unValue.m_stAllDOBits.m_ui1SRDOCn01; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn02) g_unDOState.m_stAllDOBits.m_ui1SRDOCn02 = unValue.m_stAllDOBits.m_ui1SRDOCn02; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn03) g_unDOState.m_stAllDOBits.m_ui1SRDOCn03 = unValue.m_stAllDOBits.m_ui1SRDOCn03; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn04) g_unDOState.m_stAllDOBits.m_ui1SRDOCn04 = unValue.m_stAllDOBits.m_ui1SRDOCn04; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn05) g_unDOState.m_stAllDOBits.m_ui1SRDOCn05 = unValue.m_stAllDOBits.m_ui1SRDOCn05; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn06) g_unDOState.m_stAllDOBits.m_ui1SRDOCn06 = unValue.m_stAllDOBits.m_ui1SRDOCn06; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn07) g_unDOState.m_stAllDOBits.m_ui1SRDOCn07 = unValue.m_stAllDOBits.m_ui1SRDOCn07; 
.................... ////     
.................... //}     
.................... // 
.................... //         
.................... // 
.................... //         
.................... //// 02: Start to Pick 
.................... //unsigned int8 StateFunc_State02() 
.................... //{ 
.................... //    // We got message from outer board that Stacker Ready and Hopper Ready 
.................... //    // Now PD will start moving downword 
.................... //    //g_unAllDOs.m_bArr[2] = 1; 
.................... //    //g_unAllDOs.m_bArr[3] = 0; 
.................... //    // Expected Next State Declaration 
.................... //    g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[0] = STATE_03; 
.................... //    g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[1] = STATE_03; 
.................... //    g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[2] = STATE_03; 
.................... //    g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[3] = STATE_03; 
.................... //    return 0; 
.................... //} 
.................... // 
.................... // 
.................... //void InitExpNextStateDefault() 
.................... //{ 
.................... //    int8 i8StMcCount = 0; 
.................... //    int8 i8StCount   = 0; 
.................... //    int8 i8ExpNxtCount = 0; 
.................... //    for (i8StMcCount = 0; i8StMcCount < NO_OF_ACTIVE_MACHINE; i8StMcCount++) 
.................... //    { 
.................... //        // For all Active Look up tables 
.................... //        for (i8StCount = 0; i8StCount < MAX_NUMBER_OF_STATE; i8StCount++) 
.................... //        { 
.................... //            for (i8ExpNxtCount = 0; i8ExpNxtCount < MAX_NO_OF_EXP_NXT_STATES; i8ExpNxtCount++) 
.................... //            { 
.................... //                g_stArrStateMachines[i8StMcCount].m_stArrStateLookupTable[i8StCount].m_i8ArrExpNextState[i8ExpNxtCount] = STATE_NOTHING; 
.................... //            } 
.................... //        } 
.................... //    } 
.................... //} 
.................... // 
.................... //void PostProductionSafeMode() 
.................... //{ 
.................... //    //g_unDOState.m_ui16AllDOs = 0xFFFF; 
.................... //     
.................... //    // 1. Stopper 0 is in Push State 
.................... //    // 2. Can Stopper 1 is in Push state 
.................... //    // 3. Pusher 0, Pusher 1 and Can Guide all is in drag state 
.................... //    //g_unDOState.m_ui16AllDOs = SAFE_MODE_DO_STATE; 
.................... //    //ExecuteALLDOs(); 
.................... //} 
.................... // 
.................... //void PowerOnDOStateInit() 
.................... //{ 
.................... //   // g_unDOState.m_ui16AllDOs = 0xFFFF; 
.................... //     
.................... //    // 1. Stopper 0 is in drag State 
.................... //    // 2. Can Stopper 1 is in Push state 
.................... //    // 3. Pusher 0, Pusher 1 and Can Guide all is in drag state 
.................... //   // g_unDOState.m_ui16AllDOs = INITAIL_DO_STATE_ON_PWR_ON; 
.................... //    //ExecuteALLDOs(); 
.................... //} 
.................... // 
.................... //#endif /* _VM_STATE_MACHINE_FOR_IMW_M0_H_ */ 
....................  
.................... #include "vmDigitalIOConfig.h" 
.................... #ifndef _VM_DIGITAL_IO_CONFIG_H_ 
.................... #define _VM_DIGITAL_IO_CONFIG_H_ 
....................  
.................... //***************************************************************************** 
.................... // Below -> Data Structure for Digital Input Output *************************** 
.................... //***************************************************************************** 
.................... typedef struct _ST_ALL_DI_STATE_BIT 
.................... { 
....................     unsigned int8 m_ui1SWDICn07: 1; 
....................     unsigned int8 m_ui1SWDICn06: 1; 
....................     unsigned int8 m_ui1SWDICn05: 1; 
....................     unsigned int8 m_ui1SWDICn04: 1; 
....................     unsigned int8 m_ui1SWDICn03: 1; 
....................     unsigned int8 m_ui1SWDICn02: 1; 
....................     unsigned int8 m_ui1SWDICn01: 1; 
....................     unsigned int8 m_ui1SWDICn00: 1; 
....................  
....................     unsigned int8 m_ui1GDICn05: 1; 
....................     unsigned int8 m_ui1GDICn04: 1; 
....................     unsigned int8 m_ui1GDICn03: 1; 
....................     unsigned int8 m_ui1GDICn02: 1; 
....................     unsigned int8 m_ui1GDICn01: 1; 
....................     unsigned int8 m_ui1GDICn00: 1; 
....................  
....................     unsigned int8 m_ui1HWDICn17: 1; 
....................     unsigned int8 m_ui1HWDICn16: 1; 
....................     unsigned int8 m_ui1HWDICn15: 1; 
....................     unsigned int8 m_ui1HWDICn14: 1; 
....................     unsigned int8 m_ui1HWDICn13: 1; 
....................     unsigned int8 m_ui1HWDICn12: 1; 
....................     unsigned int8 m_ui1HWDICn11: 1; 
....................     unsigned int8 m_ui1HWDICn10: 1; 
....................     unsigned int8 m_ui1HWDICn09: 1; 
....................     unsigned int8 m_ui1HWDICn08: 1; 
....................     unsigned int8 m_ui1HWDICn07: 1; 
....................     unsigned int8 m_ui1HWDICn06: 1; 
....................     unsigned int8 m_ui1HWDICn05: 1; 
....................     unsigned int8 m_ui1HWDICn04: 1; 
....................     unsigned int8 m_ui1HWDICn03: 1; 
....................     unsigned int8 m_ui1HWDICn02: 1; 
....................     unsigned int8 m_ui1HWDICn01: 1; 
....................     unsigned int8 m_ui1HWDICn00: 1; 
.................... } ST_ALL_DI_STATE_BIT; 
....................  
.................... typedef union _UN_ALL_DIS 
.................... { 
.................... 	unsigned int8       m_bArr[4]; 
....................     unsigned int32      m_ui32AllDIs; 
....................     ST_ALL_DI_STATE_BIT m_stAllDIBits; 
.................... } UN_ALL_DIS; 
....................  
....................  
.................... typedef struct _ST_ALL_DO_STATE_BIT 
.................... { 
....................     unsigned int8 m_ui1SRDOCn07: 1; 
....................     unsigned int8 m_ui1SRDOCn06: 1; 
....................     unsigned int8 m_ui1SRDOCn05: 1; 
....................     unsigned int8 m_ui1SRDOCn04: 1; 
....................     unsigned int8 m_ui1SRDOCn03: 1; 
....................     unsigned int8 m_ui1SRDOCn02: 1; 
....................     unsigned int8 m_ui1SRDOCn01: 1; 
....................     unsigned int8 m_ui1SRDOCn00: 1; 
....................  
....................     unsigned int8 m_ui1HWDOCn07: 1; 
....................     unsigned int8 m_ui1HWDOCn06: 1; 
....................     unsigned int8 m_ui1HWDOCn05: 1; 
....................     unsigned int8 m_ui1HWDOCn04: 1; 
....................     unsigned int8 m_ui1HWDOCn03: 1; 
....................     unsigned int8 m_ui1HWDOCn02: 1; 
....................     unsigned int8 m_ui1HWDOCn01: 1; 
....................     unsigned int8 m_ui1HWDOCn00: 1; 
.................... } ST_ALL_DO_STATE_BIT; 
....................  
.................... typedef union _UN_ALL_DOS 
.................... { 
....................     unsigned int8       m_bArr[2]; 
....................     unsigned int16      m_ui16AllDOs; 
....................     ST_ALL_DO_STATE_BIT m_stAllDOBits; 
.................... } UN_ALL_DOS; 
....................  
.................... typedef struct _ST_ALL_COUNTER_STATE_BIT 
.................... { 
....................     unsigned int8 m_ui3Counter0: 3; 
....................     unsigned int8 m_ui3Counter1: 3; 
....................     unsigned int8 m_ui2Counter2: 2; 
....................  
....................     unsigned int8 m_ui2Counter3: 2; 
....................     unsigned int8 m_ui2Counter4: 2; 
....................     unsigned int8 m_ui2Counter5: 2; 
....................     unsigned int8 m_ui2Counter6: 2; 
.................... } ST_ALL_COUNTER_STATE_BIT; 
....................  
.................... typedef union _UN_ALL_COUNTERS 
.................... { 
....................     unsigned int8              m_bArr[2]; 
....................     unsigned int16             m_ui16AllCounters; 
....................     ST_ALL_COUNTER_STATE_BIT   m_stAllCounterBits; 
.................... } UN_ALL_COUNTERS; 
....................  
.................... //***************************************************************************** 
.................... // Above -> Data Structure for Digital Input Output *************************** 
.................... //***************************************************************************** 
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
.................... UN_ALL_DIS      g_unDIState; 
.................... UN_ALL_DOS      g_unDOState; 
.................... UN_ALL_COUNTERS g_unAllCounters; 
.................... UN_ALL_DIS      g_unDIStateFilter; 
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //*****************************************************************************  
....................  
.................... #endif /* _VI_DIGITAL_IO_CONFIG_H_ */ 
....................  
.................... //typedef struct _ST_ALL_DI_STATE_BIT 
.................... //{ 
.................... //    unsigned int8 m_ui1HWDICn15: 1; 
.................... //    unsigned int8 m_ui1HWDICn14: 1; 
.................... //    unsigned int8 m_ui1HWDICn13: 1; 
.................... //    unsigned int8 m_ui1HWDICn12: 1; 
.................... //    unsigned int8 m_ui1HWDICn11: 1; 
.................... //    unsigned int8 m_ui1HWDICn10: 1; 
.................... //    unsigned int8 m_ui1HWDICn09: 1; 
.................... //    unsigned int8 m_ui1HWDICn08: 1; 
.................... // 
.................... //    unsigned int8 m_ui1HWDICn07: 1; 
.................... //    unsigned int8 m_ui1HWDICn06: 1; 
.................... //    unsigned int8 m_ui1HWDICn05: 1; 
.................... //    unsigned int8 m_ui1HWDICn04: 1; 
.................... //    unsigned int8 m_ui1HWDICn03: 1; 
.................... //    unsigned int8 m_ui1HWDICn02: 1; 
.................... //    unsigned int8 m_ui1HWDICn01: 1; 
.................... //    unsigned int8 m_ui1HWDICn00: 1; 
.................... //}ST_ALL_DI_STATE_BIT; 
.................... // 
.................... //typedef union _UN_ALL_DIS 
.................... //{ 
.................... //	unsigned int8       m_bArr[2]; 
.................... //    unsigned int16      m_ui16AllDIs; 
.................... //    ST_ALL_DI_STATE_BIT m_stAllDIBits; 
.................... //} UN_ALL_DIS; 
.................... // 
.................... //typedef struct _ST_ALL_DO_STATE_BIT 
.................... //{ 
.................... //    unsigned int8 m_ui1HWDOCn07: 1; 
.................... //    unsigned int8 m_ui1HWDOCn06: 1; 
.................... //    unsigned int8 m_ui1HWDOCn05: 1; 
.................... //    unsigned int8 m_ui1HWDOCn04: 1; 
.................... //    unsigned int8 m_ui1HWDOCn03: 1; 
.................... //    unsigned int8 m_ui1HWDOCn02: 1; 
.................... //    unsigned int8 m_ui1HWDOCn01: 1; 
.................... //    unsigned int8 m_ui1HWDOCn00: 1; 
.................... // 
.................... //}ST_ALL_DO_STATE_BIT; 
.................... // 
.................... //typedef union _UN_ALL_DOS 
.................... //{ 
.................... //    unsigned int8     m_ui8AllDOs; 
.................... //    ST_ALL_DO_STATE_BIT m_stAllDOBits; 
.................... //} UN_ALL_DOS; 
.................... // 
.................... ////***************************************************************************** 
.................... //// Above -> Data Structure for Digital Input Output *************************** 
.................... ////***************************************************************************** 
.................... // 
.................... // 
.................... ////***************************************************************************** 
.................... //// Below -> Global Variable Declaration *************************************** 
.................... ////***************************************************************************** 
.................... //UN_ALL_DIS      g_unDICurrState; 
.................... //UN_ALL_DOS      g_unDOCurrState; 
.................... // 
.................... //UN_ALL_DIS      g_unDIPrevState; 
.................... //UN_ALL_DOS      g_unDOPrevState; 
.................... // 
.................... //UN_ALL_DIS      g_unDIStateFilter; 
.................... ////***************************************************************************** 
.................... //// Above -> Global Variable Declaration *************************************** 
.................... ////*****************************************************************************  
....................  
.................... //#endif /* _VM_DIGITAL_IO_CONFIG_H_ */ 
....................  
.................... #include "vmADCManager.h" 
.................... /*  
....................  * File:   vmADCManager.h 
....................  * Author: Amit 
....................  * 
....................  * Created on December 12, 2018, 11:38 PM 
....................  */ 
....................  
.................... #ifndef VM_ADCMANAGER_H 
.................... #define	VM_ADCMANAGER_H 
....................  
.................... #include "vmCalibration.h" 
.................... /*  
....................  * File:   vmCalibration.h 
....................  * Author: Amit 
....................  * 
....................  * Created on December 9, 2018, 7:55 PM 
....................  */ 
....................  
.................... #ifndef VM_CALIBRATION_H 
.................... #define	VM_CALIBRATION_H 
....................  
.................... #define SIZE_CALIB_TABLE              11 // Only for the values 0, 1000, 2000, 3000, 4000, 
....................                                             // 5000, 6000, 7000, 8000, 9000 and 10000 
.................... #define EEPROM_START_ADDRESS_CALIB    0 
.................... #define MAX_CALIB_RESET_PASS          3 
....................  
.................... #define 	CALIB_ADC_VAL_0000	43302 
.................... #define 	CALIB_ADC_VAL_1000	44550 
.................... #define 	CALIB_ADC_VAL_2000	45780 
.................... #define 	CALIB_ADC_VAL_3000	47005 
.................... #define 	CALIB_ADC_VAL_4000	48238 
.................... #define 	CALIB_ADC_VAL_5000	49471 
.................... #define 	CALIB_ADC_VAL_6000	50716 
.................... #define 	CALIB_ADC_VAL_7000	51963 
.................... #define 	CALIB_ADC_VAL_8000	53203 
.................... #define 	CALIB_ADC_VAL_9000	54435 
.................... #define 	CALIB_ADC_VAL_10000	55676 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... typedef struct _ST_CALIB_NODE 
.................... { 
....................     int16          m_i16CalibPoint; 
....................     unsigned int32 m_ui32CalibValue; 
.................... } ST_CALIB_NODE; 
....................  
.................... // Node for dynamic error calculations 
.................... typedef struct _ST_DYNAMIC_ERR_NODE 
.................... { 
....................     int16           m_i16WeightPoint; 
....................     unsigned int8   m_ui8ErrValue; 
.................... } ST_DYNAMIC_ERR_NODE; 
....................  
.................... // Parse Union for Calib Point 
.................... typedef union _UN_CALIB_POINT 
.................... { 
....................     unsigned int16 m_un16CalibPoint; 
....................     unsigned int8  m_un8Arr[2]; 
.................... } UN_CALIB_POINT; 
....................  
.................... // Parse Union for Calib Value 
.................... typedef union _UN_CALIB_VALUE 
.................... { 
....................     unsigned int32 m_un32Value; 
....................     unsigned int8  m_un8Arr[4]; 
.................... } UN_CALIB_VALUE; 
....................  
....................  
.................... ST_CALIB_NODE g_stCalibTable[SIZE_CALIB_TABLE]; 
.................... ST_CALIB_NODE g_stTempCalibTable[SIZE_CALIB_TABLE]; 
.................... ST_DYNAMIC_ERR_NODE g_stDynamicErrTable[SIZE_CALIB_TABLE]; 
....................  
.................... // Update Single Calibration Point in EEPROM 
.................... void UpdateCalibPointInRAM(unsigned int16 ui16CalibPoint, unsigned int32 ui32CalibValue) 
.................... { 
....................     // Check if the Calibration Point value is 0 or in Multiple of 1000 or not 
....................     if (!(ui16CalibPoint == 0 || ui16CalibPoint % 1000 == 0)) 
....................     { 
....................         return; 
....................     } 
....................      
....................     // We are only considering 0, or values which are multiple of 1000 
....................     // Now need to check that the value should not be greater than 10000, 
....................     // as we are only considering 10KG of max calibration 
....................     if (ui16CalibPoint > 10000) 
....................     { 
....................         return; 
....................     } 
....................      
....................     // Here we are considering only the following values as calibration point 
....................     // 0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000 and 10000 
....................     // That is only 11 values 
....................     if (!ui16CalibPoint) 
....................     { 
....................         g_stCalibTable[0].m_ui32CalibValue = ui32CalibValue; 
....................     } 
....................     else 
....................     { 
....................         g_stCalibTable[ui16CalibPoint/1000].m_ui32CalibValue = ui32CalibValue; 
....................     } 
.................... } 
....................  
.................... // Update entire table in RAM into EEPROM 
.................... void UpdateCalibTableInEEPROM() 
.................... { 
....................     int iLoopCount = 0; 
....................     unsigned int16 ui16StartAddress = EEPROM_START_ADDRESS_CALIB; 
....................     UN_CALIB_POINT unTempCalibPoint; 
....................     UN_CALIB_VALUE unTempCalibValue; 
....................     unsigned int8  ui8Byte0 = 0; 
....................     unsigned int8  ui8Byte1 = 0; 
....................     unsigned int8  ui8Byte2 = 0; 
....................     unsigned int8  ui8Byte3 = 0; 
....................     unsigned int8  ui8Temp  = 0; 
....................      
....................     for (iLoopCount = 0; iLoopCount < SIZE_CALIB_TABLE; iLoopCount++) 
....................     { 
....................         // Calib Point while in int16 is stored in byte array as  |b1|a1| 
....................         // Calib Value while in int32 is stored in byte array as  |d2|c2|b2|a2| 
....................         // In EEPROM it should be like |a1|b1+c2|a2|b2| 
....................          
....................         // Step 1 : Parse Calib Point and Calib Value 
....................         unTempCalibPoint.m_un16CalibPoint = g_stCalibTable[iLoopCount].m_i16CalibPoint; 
....................         unTempCalibValue.m_un32Value      = g_stCalibTable[iLoopCount].m_ui32CalibValue; 
....................          
....................         // Step2 : Prepare EEPROM Data 0 
....................         ui8Byte0 = unTempCalibPoint.m_un8Arr[0]; 
....................          
....................         ui8Byte1 = unTempCalibPoint.m_un8Arr[1]; 
....................          
....................         // Shift the byte to accommodate high part two bit of value 
....................         ui8Byte1 = ui8Byte1 << 2; 
....................         // Get the High Part 2 bit of of Calib Value 
....................         ui8Temp = unTempCalibValue.m_un8Arr[2]; 
....................         // Make sure that only two bit will present and rest is 0 
....................         ui8Temp = ui8Temp << 6; 
....................         ui8Temp = ui8Temp >> 6; 
....................          
....................         // Now Marge two byte to get the second byte 
....................         ui8Byte1 = ui8Byte1 | ui8Temp; 
....................          
....................         // Step 3: Get the third and 4th Bytes 
....................         ui8Byte2 = unTempCalibValue.m_un8Arr[0]; 
....................         ui8Byte3 = unTempCalibValue.m_un8Arr[1]; 
....................          
....................         // Step 4 : Write to EEPROM 
....................         WriteEEPROMInt8((ui16StartAddress + (4*iLoopCount) + 0), ui8Byte0); 
....................         WriteEEPROMInt8((ui16StartAddress + (4*iLoopCount) + 1), ui8Byte1); 
....................         WriteEEPROMInt8((ui16StartAddress + (4*iLoopCount) + 2), ui8Byte2); 
....................         WriteEEPROMInt8((ui16StartAddress + (4*iLoopCount) + 3), ui8Byte3); 
....................     } 
.................... } 
....................  
.................... // Update entire table in RAM into EEPROM 
.................... void UpdateCalibPointInEEPROM() 
.................... { 
....................      
.................... } 
....................  
.................... void IBCSendCalibTable() 
.................... { 
....................     int8           i8LoopCount1      = 0; 
....................     int8           i8LoopCount2      = 1; 
....................     unsigned int16 ui16StartAddress  = EEPROM_START_ADDRESS_CALIB; 
....................     unsigned int16 ui16EEPROMAddress = EEPROM_START_ADDRESS_CALIB; 
....................     ST_IBC_DATA_NODE stIBCDataNode; 
....................      
....................     for (i8LoopCount1 = 0; i8LoopCount1 < SIZE_CALIB_TABLE; i8LoopCount1++) 
....................     { 
....................         // Step 1: First Stuff the IBC Command in the First Byte 
....................         //stIBCDataNode.g_ui8ArrIBCData[0] = IBC_CMD_SET_CALIB_POINT; 
....................          
....................         // Step 2: Stuff 4 Data Bytes from EEPROM 
....................         for (i8LoopCount2 = 1; i8LoopCount2 < IBC_MSG_BYTE_COUNT; i8LoopCount2++) 
....................         { 
....................             stIBCDataNode.g_ui8ArrIBCData[i8LoopCount2] = 
....................                    ReadEEPROMInt8(ui16StartAddress +  
....................                                  (i8LoopCount1 * (IBC_MSG_BYTE_COUNT - 1)) + 
....................                                  (i8LoopCount2 - 1)); 
....................         } 
....................          
....................         // Step 3: Put it into the IBC Send QUEUE 
....................         //InsertSendQueue(&stIBCDataNode); 
....................         InsertIBCMsgQueue(&g_stIBCSendQueue, &stIBCDataNode); 
....................         //delay_ms(100);  //TODO Just for Testing 
....................     } 
.................... } 
....................  
.................... // Get Calibration Table From EEPROM 
.................... void PrepareCalibTable() 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     unsigned int16 ui16TempCalibPoint = 0; 
....................     unsigned int32 ui32TempCalibValue = 0; 
....................     unsigned int8 ui8Data0 = 0; 
....................     unsigned int8 ui8Data1 = 0; 
....................     unsigned int8 ui8Data2 = 0; 
....................     unsigned int8 ui8Data3 = 0; 
....................     unsigned int8 ui8Temp  = 0; 
....................      
....................     unsigned int16 ui16CalibTableStartAddress = 0;   //TODO Set the Calibration Table Start Address 
....................      
....................     // Read from EEPROM and set Calibration Table 
....................     for (i8LoopCount = 0; i8LoopCount < SIZE_CALIB_TABLE; i8LoopCount++) 
....................     { 
....................         // Get data from EEPROM 
....................         // First 14 bit stores the Calibration Point Second 18 bit stores the Value 
....................         ui8Data0 = ReadEEPROMInt8(ui16CalibTableStartAddress + ((i8LoopCount *4) + 0)); 
....................         ui8Data1 = ReadEEPROMInt8(ui16CalibTableStartAddress + ((i8LoopCount *4) + 1)); 
....................         ui8Data2 = ReadEEPROMInt8(ui16CalibTableStartAddress + ((i8LoopCount *4) + 2)); 
....................         ui8Data3 = ReadEEPROMInt8(ui16CalibTableStartAddress + ((i8LoopCount *4) + 3)); 
....................          
....................         // Set the Calibration Point 
....................         ui16TempCalibPoint = ui8Data1; 
....................         ui16TempCalibPoint = ui16TempCalibPoint >> 2; 
....................         g_stCalibTable[i8LoopCount].m_i16CalibPoint = ui16TempCalibPoint; 
....................         g_stCalibTable[i8LoopCount].m_i16CalibPoint = g_stCalibTable[i8LoopCount].m_i16CalibPoint << 8; 
....................         g_stCalibTable[i8LoopCount].m_i16CalibPoint = g_stCalibTable[i8LoopCount].m_i16CalibPoint | ui8Data0; 
....................          
....................         // Set the Calibration Value 
....................         ui8Temp = ui8Data1; 
....................         ui8Temp = ui8Temp << 6; 
....................         ui8Temp = ui8Temp >> 6; 
....................         g_stCalibTable[i8LoopCount].m_ui32CalibValue = ui8Temp; 
....................         g_stCalibTable[i8LoopCount].m_ui32CalibValue = g_stCalibTable[i8LoopCount].m_ui32CalibValue << 16; 
....................          
....................         ui32TempCalibValue = ui8Data3; 
....................         ui32TempCalibValue = ui32TempCalibValue << 8; 
....................         g_stCalibTable[i8LoopCount].m_ui32CalibValue = g_stCalibTable[i8LoopCount].m_ui32CalibValue | ui32TempCalibValue; 
....................          
....................         ui32TempCalibValue = ui8Data2; 
....................         g_stCalibTable[i8LoopCount].m_ui32CalibValue = g_stCalibTable[i8LoopCount].m_ui32CalibValue | ui32TempCalibValue; 
....................          
....................     } 
.................... } 
....................  
....................  
.................... // TESTING Start 
.................... void PrepareTestCalibTable() 
.................... { 
....................     g_stCalibTable[0].m_i16CalibPoint  = 0; 
....................     g_stCalibTable[0].m_ui32CalibValue = CALIB_ADC_VAL_0000;  //41925 
....................      
....................     g_stCalibTable[1].m_i16CalibPoint  = 1000; 
....................     g_stCalibTable[1].m_ui32CalibValue = CALIB_ADC_VAL_1000;  //43081 
....................      
....................     g_stCalibTable[2].m_i16CalibPoint  = 2000; 
....................     g_stCalibTable[2].m_ui32CalibValue = CALIB_ADC_VAL_2000;  //44233 
....................      
....................     g_stCalibTable[3].m_i16CalibPoint  = 3000; 
....................     g_stCalibTable[3].m_ui32CalibValue = CALIB_ADC_VAL_3000;  //45379 
....................      
....................     g_stCalibTable[4].m_i16CalibPoint  = 4000; 
....................     g_stCalibTable[4].m_ui32CalibValue = CALIB_ADC_VAL_4000;  //46538 
....................      
....................     g_stCalibTable[5].m_i16CalibPoint  = 5000; 
....................     g_stCalibTable[5].m_ui32CalibValue = CALIB_ADC_VAL_5000;  //47686 
....................      
....................     g_stCalibTable[6].m_i16CalibPoint  = 6000; 
....................     g_stCalibTable[6].m_ui32CalibValue = CALIB_ADC_VAL_6000;  //48842 
....................      
....................     g_stCalibTable[7].m_i16CalibPoint  = 7000; 
....................     g_stCalibTable[7].m_ui32CalibValue = CALIB_ADC_VAL_7000;  //49992 
....................      
....................     g_stCalibTable[8].m_i16CalibPoint  = 8000; 
....................     g_stCalibTable[8].m_ui32CalibValue = CALIB_ADC_VAL_8000;  //51151 
....................      
....................     g_stCalibTable[9].m_i16CalibPoint  = 9000; 
....................     g_stCalibTable[9].m_ui32CalibValue = CALIB_ADC_VAL_9000;  //52303 
....................      
....................     g_stCalibTable[10].m_i16CalibPoint  = 10000; 
....................     g_stCalibTable[10].m_ui32CalibValue = CALIB_ADC_VAL_10000; //53456 
.................... } 
....................  
.................... // In RAM Only 
.................... void PrepareTempCalibTable(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................      
....................     // Prepare table 
....................     for (i8LoopCount = 0; i8LoopCount < SIZE_CALIB_TABLE; i8LoopCount++) 
....................     { 
....................         g_stTempCalibTable[i8LoopCount].m_i16CalibPoint = g_stCalibTable[i8LoopCount].m_i16CalibPoint; 
....................         g_stTempCalibTable[i8LoopCount].m_ui32CalibValue = g_stCalibTable[i8LoopCount].m_ui32CalibValue; 
....................     } 
.................... } 
....................  
.................... void ResetCalibTable(int16 i16TareValue) 
*
01E76:  MOVLB  A
01E78:  CLRF   xB3
.................... { 
....................     int8 i8LoopCount = 0; 
....................      
....................     for (i8LoopCount = 0; i8LoopCount < SIZE_CALIB_TABLE; i8LoopCount++) 
01E7A:  CLRF   xB3
01E7C:  MOVF   xB3,W
01E7E:  SUBLW  0A
01E80:  BTFSS  FD8.0
01E82:  GOTO   1ED8
....................     { 
....................         g_stCalibTable[i8LoopCount].m_ui32CalibValue += i16TareValue; 
01E86:  MOVF   xB3,W
01E88:  MULLW  06
01E8A:  MOVF   FF3,W
01E8C:  CLRF   xB5
01E8E:  MOVWF  xB4
01E90:  MOVLW  02
01E92:  ADDWF  xB4,W
01E94:  MOVWF  01
01E96:  MOVLW  00
01E98:  ADDWFC xB5,W
01E9A:  MOVWF  03
01E9C:  MOVF   01,W
01E9E:  ADDLW  F3
01EA0:  MOVWF  FE9
01EA2:  MOVLW  02
01EA4:  ADDWFC 03,W
01EA6:  MOVWF  FEA
01EA8:  MOVF   xB1,W
01EAA:  ADDWF  FEF,W
01EAC:  MOVWF  00
01EAE:  MOVF   xB2,W
01EB0:  ADDWFC FEC,W
01EB2:  MOVWF  01
01EB4:  MOVLW  00
01EB6:  ADDWFC FEC,W
01EB8:  MOVWF  02
01EBA:  MOVLW  00
01EBC:  ADDWFC FEC,W
01EBE:  MOVF   FED,F
01EC0:  MOVF   FED,F
01EC2:  MOVF   FED,F
01EC4:  MOVFF  00,FEF
01EC8:  MOVFF  01,FEC
01ECC:  MOVFF  02,FEC
01ED0:  MOVWF  FEC
01ED2:  INCF   xB3,F
01ED4:  GOTO   1E7C
....................     } 
01ED8:  MOVLB  0
01EDA:  GOTO   2056 (RETURN)
.................... } 
....................  
.................... void PrepareTestCalibTableX(unsigned int16 ui16X) 
.................... { 
....................     g_stCalibTable[0].m_i16CalibPoint  = 0; 
....................     g_stCalibTable[0].m_ui32CalibValue = 165 + ui16X; 
....................      
....................     g_stCalibTable[1].m_i16CalibPoint  = 1000; 
....................     g_stCalibTable[1].m_ui32CalibValue = 1005 + ui16X; 
....................      
....................     g_stCalibTable[2].m_i16CalibPoint  = 2000; 
....................     g_stCalibTable[2].m_ui32CalibValue = 2005 + ui16X; 
....................      
....................     g_stCalibTable[3].m_i16CalibPoint  = 3000; 
....................     g_stCalibTable[3].m_ui32CalibValue = 3005 + ui16X; 
....................      
....................     g_stCalibTable[4].m_i16CalibPoint  = 4000; 
....................     g_stCalibTable[4].m_ui32CalibValue = 4005 + ui16X; 
....................      
....................     g_stCalibTable[5].m_i16CalibPoint  = 5000; 
....................     g_stCalibTable[5].m_ui32CalibValue = 5005 + ui16X; 
....................      
....................     g_stCalibTable[6].m_i16CalibPoint  = 6000; 
....................     g_stCalibTable[6].m_ui32CalibValue = 6005 + ui16X; 
....................      
....................     g_stCalibTable[7].m_i16CalibPoint  = 7000; 
....................     g_stCalibTable[7].m_ui32CalibValue = 7005 + ui16X; 
....................      
....................     g_stCalibTable[8].m_i16CalibPoint  = 8000; 
....................     g_stCalibTable[8].m_ui32CalibValue = 8005 + ui16X; 
....................      
....................     g_stCalibTable[9].m_i16CalibPoint  = 9000 + ui16X; 
....................     g_stCalibTable[9].m_ui32CalibValue = 9005; 
....................      
....................     g_stCalibTable[10].m_i16CalibPoint  = 10000; 
....................     g_stCalibTable[10].m_ui32CalibValue = 10005 + ui16X; 
.................... } 
.................... // TESTING End 
.................... #endif	/* VM_CALIBRATION_H */ 
....................  
....................  
.................... #include "vmM0ADCModuleCommon.h" 
.................... /*  
....................  * File:   vmM0ADCModuleCommon.h 
....................  * Author: OEM 
....................  * 
....................  * Created on December 13, 2018, 4:59 PM 
....................  */ 
....................  
.................... #ifndef VM_M0_ADC_MODULE_COMMON_H 
.................... #define	VM_M0_ADC_MODULE_COMMON_H 
....................  
.................... #define BOX_ACCEPTED               1 
.................... #define BOX_REJECTED               0 
.................... //#define BOX_REJECTED_UNDR_WT       0 
.................... //#define BOX_REJECTED_OVR_WT        2 
....................  
.................... #define SYS_MODE_NOTHING   0 
.................... #define SYS_MODE_HOME      1 
.................... #define SYS_MODE_CALIB     2 
.................... #define SYS_MODE_PRE_PROD  3 
.................... #define SYS_MODE_PROD      4 
.................... #define SYS_MODE_POST_PROD 5 
....................  
.................... #define IBC_INTERMEDIATE_DATA_SEND_ON  1 
.................... #define IBC_INTERMEDIATE_DATA_SEND_OFF 0 
....................  
.................... #define ADC_MEAN_DATA_INTERMEDIATE_WEIGHT   31 
.................... #define ADC_MEAN_DATA_INTERMEDIATE_TARE     32 
.................... #define ADC_MEAN_DATA_FINAL_WEIGHT          33 
.................... #define ADC_MEAN_DATA_FINAL_TARE            34 
.................... #define ADC_MEAN_DATA_CALIB_WEIGHT          35 
.................... #define ADC_MEAN_DATA_NOTHING               36 
....................  
.................... unsigned int8 g_ui8ADCMeanDataState = ADC_MEAN_DATA_NOTHING; 
....................  
.................... #define FLAG_WT_CALCULATION_DONE     1 
.................... #define FLAG_WT_CALCULATION_NOT_DONE 0 
....................  
.................... unsigned int8 g_fWtCalculationState = FLAG_WT_CALCULATION_NOT_DONE; 
....................  
.................... #define IBC_RESET_CALIB_OFF    0 
.................... #define IBC_RESET_CALIB_ON     1 
....................  
.................... #define HMI_REJECTION_AUTO_CALIB_MODE   0 
.................... #define HMI_REJECTION_FIXED_CALIB_MODE  1 
....................  
....................  
.................... unsigned int16 g_ui16CurrentBoxCount   = 0;     // Total Box Passed Sofar 
.................... unsigned int16 g_ui16RejectionStatus   = BOX_REJECTED; 
.................... unsigned int8  g_ui8SystemMode         = SYS_MODE_NOTHING; 
.................... unsigned int8  g_fIntermediateDataSend = IBC_INTERMEDIATE_DATA_SEND_OFF; 
.................... unsigned int16 g_ui16DynamicTareValue   = 0; 
.................... unsigned int32 g_ui32DynamicTareADCValue   = 0; 
....................  
.................... unsigned int16 g_ui16PrevDynamicTareValue = 0; 
.................... int32          g_i32StaticTareValue    = 0;  // TODO Should keep in EEPROM 
.................... unsigned int8  g_fResetCalibStatus     = IBC_RESET_CALIB_OFF; 
.................... int16          g_i16CalibResetValue     = 0; 
.................... int16          g_i16CalibResetSumValue  = 0; 
.................... int32          g_i32ADCSumValue         = 0; 
.................... int32          g_i32ADCAvgValue         = 0; 
.................... unsigned int16 g_ui16ADCCalibValueEEPROM = 0; 
.................... unsigned int16 g_ui16CalibPointEEPROM    = 0; 
.................... int16          g_i16CalibResetPrevValue = 0; 
.................... int16          g_i16DynamicErrValue     = 0; 
.................... int16          g_i16CurBoxWeight        = 0; 
.................... int8           g_fRejectionMode         = HMI_REJECTION_FIXED_CALIB_MODE; 
....................  
.................... typedef struct _ST_CUR_BATCH_INFO 
.................... { 
....................     int16 m_i16AvgWeight; 
....................     int16 m_i16PositiveTol; 
....................     int16 m_i16NegativeTol; 
.................... } ST_CUR_BATCH_INFO; 
....................  
.................... ST_CUR_BATCH_INFO g_stCurBatchInfo; 
....................  
.................... #endif	/* VM_M0_ADC_MODULE_COMMON_H */ 
....................  
....................  
.................... #include "vmAverageWeightCalculation.h" 
.................... /*  
....................  * File:   vmAverageWeightCalculation.h 
....................  * Author: OEM 
....................  * 
....................  * Created on December 20, 2018, 11:50 AM 
....................  */ 
....................  
.................... #ifndef VM_AVERAGE_WEIGHT_CALCULATION_H 
.................... #define	VM_AVERAGE_WEIGHT_CALCULATION_H 
....................  
.................... #define SIZE_AVG_WT_ARR                 50 
.................... #define MAX_DEVIATIION_FROM_AVG_WT      1000  // We are considering +- 1000gm weight deviation 
.................... #define MAX_DEVIATION_FOR_BATCH_CHANGE  850   // If Current weight 850gm deviated from last average weight then we consider batch must be changed. 
....................                                               // In that case we reset the queue. 
....................  
.................... typedef struct _ST_AVG_WT_QUEUE 
.................... { 
....................     int16 m_i16Arr[SIZE_AVG_WT_ARR]; 
....................     int8  m_i8Rear; 
....................     int8  m_i8Length; 
....................     int8  m_i8QueueFull; 
....................     int16 m_i16CurAvg; 
....................     int16 m_i16LstAvg; 
.................... } ST_AVG_WT_QUEUE; 
....................  
.................... ST_AVG_WT_QUEUE g_stAvgWtQueue; 
....................  
.................... void InitializeAvgWtQueue() 
*
00662:  MOVLB  A
00664:  CLRF   xAC
.................... { 
....................     unsigned int8 ui8LoopCount = 0; 
....................     g_stAvgWtQueue.m_i8Rear     = -1; 
00666:  MOVLB  4
00668:  SETF   x2E
....................     g_stAvgWtQueue.m_i8Length   = SIZE_AVG_WT_ARR; 
0066A:  MOVLW  32
0066C:  MOVWF  x2F
....................     g_stAvgWtQueue.m_i16CurAvg  = 0; 
0066E:  CLRF   x32
00670:  CLRF   x31
....................     g_stAvgWtQueue.m_i8QueueFull = 0; 
00672:  CLRF   x30
....................      
....................     // Initialize array member. 
....................     for(ui8LoopCount = 0; ui8LoopCount < SIZE_AVG_WT_ARR; ui8LoopCount++) 
00674:  MOVLB  A
00676:  CLRF   xAC
00678:  MOVF   xAC,W
0067A:  SUBLW  31
0067C:  BTFSS  FD8.0
0067E:  GOTO   069E
....................     { 
....................         g_stAvgWtQueue.m_i16Arr[ui8LoopCount] = 0; 
00682:  BCF    FD8.0
00684:  RLCF   xAC,W
00686:  CLRF   03
00688:  ADDLW  CA
0068A:  MOVWF  FE9
0068C:  MOVLW  03
0068E:  ADDWFC 03,W
00690:  MOVWF  FEA
00692:  CLRF   FEC
00694:  MOVF   FED,F
00696:  CLRF   FEF
00698:  INCF   xAC,F
0069A:  GOTO   0678
....................     } 
0069E:  MOVLB  0
006A0:  GOTO   07A0 (RETURN)
.................... } 
....................  
.................... void ResetAvgWtQueue(int8 i8Length) 
.................... { 
....................     if (i8Length <= SIZE_AVG_WT_ARR) 
....................     { 
....................         g_stAvgWtQueue.m_i8Length = i8Length; 
....................     } 
....................     else 
....................     { 
....................         g_stAvgWtQueue.m_i8Length = SIZE_AVG_WT_ARR; 
....................     } 
.................... } 
....................  
.................... void InsertAvgWtQueue(int16 i16LastWeight) 
*
0157A:  MOVLB  A
0157C:  CLRF   xAD
0157E:  CLRF   xAE
01580:  CLRF   xB2
01582:  CLRF   xB1
01584:  CLRF   xB0
01586:  CLRF   xAF
.................... { 
....................     int8  i8LoopCount = 0; 
....................     int8  i8MaxEntry  = 0; 
....................     int32 i32Sum      = 0; 
....................      
....................     // Check the weight deviation from Selected SKU Average Weight 
....................     if (i16LastWeight > (g_stCurBatchInfo.m_i16AvgWeight + MAX_DEVIATIION_FROM_AVG_WT) || 
....................         i16LastWeight < (g_stCurBatchInfo.m_i16AvgWeight - MAX_DEVIATIION_FROM_AVG_WT)) 
01588:  MOVLW  E8
0158A:  MOVLB  3
0158C:  ADDWF  xC4,W
0158E:  MOVWF  01
01590:  MOVLW  03
01592:  ADDWFC xC5,W
01594:  MOVWF  03
01596:  MOVF   03,W
01598:  MOVLB  A
0159A:  SUBWF  xAC,W
0159C:  BTFSS  FD8.0
0159E:  GOTO   15B2
015A2:  BTFSS  FD8.2
015A4:  GOTO   15E0
015A8:  MOVF   xAB,W
015AA:  SUBWF  01,W
015AC:  BTFSS  FD8.0
015AE:  GOTO   15E0
015B2:  MOVLW  E8
015B4:  MOVLB  3
015B6:  SUBWF  xC4,W
015B8:  MOVWF  00
015BA:  MOVLW  03
015BC:  SUBWFB xC5,W
015BE:  MOVWF  03
015C0:  MOVFF  00,01
015C4:  MOVLB  A
015C6:  MOVF   xAC,W
015C8:  SUBWF  03,W
015CA:  BTFSS  FD8.0
015CC:  GOTO   15E4
015D0:  BTFSS  FD8.2
015D2:  GOTO   15E0
015D6:  MOVF   01,W
015D8:  SUBWF  xAB,W
015DA:  BTFSC  FD8.0
015DC:  GOTO   15E4
....................     { 
....................         // The weight is out of range, we are not inserting this weight into Average weight queue  
....................         return; 
015E0:  GOTO   1726
....................     } 
....................      
....................     // Increment Rear 
....................     g_stAvgWtQueue.m_i8Rear++; 
015E4:  MOVLB  4
015E6:  INCF   x2E,F
....................      
....................     // Check if the current weight is a new batch weight. 
....................     if(i16LastWeight >= g_stAvgWtQueue.m_i16LstAvg + MAX_DEVIATION_FOR_BATCH_CHANGE) 
015E8:  MOVLW  52
015EA:  ADDWF  x33,W
015EC:  MOVWF  01
015EE:  MOVLW  03
015F0:  ADDWFC x34,W
015F2:  MOVWF  03
015F4:  MOVF   03,W
015F6:  MOVLB  A
015F8:  SUBWF  xAC,W
015FA:  BTFSS  FD8.0
015FC:  GOTO   1616
01600:  BTFSS  FD8.2
01602:  GOTO   1610
01606:  MOVF   01,W
01608:  SUBWF  xAB,W
0160A:  BTFSS  FD8.0
0160C:  GOTO   1616
....................     { 
....................         g_stAvgWtQueue.m_i8Rear = 0; 
01610:  MOVLB  4
01612:  CLRF   x2E
01614:  MOVLB  A
....................     } 
....................      
....................     // Check queue length according to auto/fixed calibration mode. 
....................     // If in auto calibration mode then data will be inserted upto user input stored avg queue length. 
....................     if(HMI_REJECTION_AUTO_CALIB_MODE == g_fRejectionMode) 
01616:  MOVLB  3
01618:  MOVF   xC3,F
0161A:  BTFSS  FD8.2
0161C:  GOTO   1638
....................     { 
....................         if (g_stAvgWtQueue.m_i8Rear >= g_stAvgWtQueue.m_i8Length) 
01620:  MOVLB  4
01622:  MOVF   x2F,W
01624:  SUBWF  x2E,W
01626:  BTFSS  FD8.0
01628:  GOTO   1632
....................         { 
....................             g_stAvgWtQueue.m_i8Rear      = 0; 
0162C:  CLRF   x2E
....................             // Update state Queue Full 
....................             g_stAvgWtQueue.m_i8QueueFull = 1; 
0162E:  MOVLW  01
01630:  MOVWF  x30
....................         } 
....................     } 
01632:  GOTO   164A
01636:  MOVLB  3
....................     // Otherwise in fixed calibration mode data will be inserted upto queue's original length. 
....................     else 
....................     { 
....................         if (g_stAvgWtQueue.m_i8Rear >= SIZE_AVG_WT_ARR) 
01638:  MOVLB  4
0163A:  MOVF   x2E,W
0163C:  SUBLW  31
0163E:  BTFSC  FD8.0
01640:  GOTO   164A
....................         { 
....................             g_stAvgWtQueue.m_i8Rear      = 0; 
01644:  CLRF   x2E
....................             // Update state Queue Full 
....................             g_stAvgWtQueue.m_i8QueueFull = 1; 
01646:  MOVLW  01
01648:  MOVWF  x30
....................         } 
....................     } 
....................      
....................     // Insert into Queue 
....................     g_stAvgWtQueue.m_i16Arr[g_stAvgWtQueue.m_i8Rear] = i16LastWeight; 
0164A:  BCF    FD8.0
0164C:  RLCF   x2E,W
0164E:  CLRF   03
01650:  ADDLW  CA
01652:  MOVWF  FE9
01654:  MOVLW  03
01656:  ADDWFC 03,W
01658:  MOVWF  FEA
0165A:  MOVFF  AAC,FEC
0165E:  MOVF   FED,F
01660:  MOVFF  AAB,FEF
....................      
....................     // Get the Max entry in queue 
....................     if (1 == g_stAvgWtQueue.m_i8QueueFull) 
01664:  DECFSZ x30,W
01666:  GOTO   1690
....................     { 
....................         if(HMI_REJECTION_AUTO_CALIB_MODE == g_fRejectionMode) 
0166A:  MOVLB  3
0166C:  MOVF   xC3,F
0166E:  BTFSS  FD8.2
01670:  GOTO   1682
....................         {     
....................             // Set maximum counted data for average calculation. 
....................             i8MaxEntry = g_stAvgWtQueue.m_i8Length; 
01674:  MOVFF  42F,AAE
....................              
....................             // Reset queue full flag. 
....................             g_stAvgWtQueue.m_i8QueueFull = 0; 
01678:  MOVLB  4
0167A:  CLRF   x30
....................         } 
0167C:  GOTO   168C
01680:  MOVLB  3
....................         else 
....................         { 
....................             // Set maximum counted data for average calculation. 
....................             i8MaxEntry = SIZE_AVG_WT_ARR; 
01682:  MOVLW  32
01684:  MOVLB  A
01686:  MOVWF  xAE
....................              
....................             // Reset queue full flag. 
....................             g_stAvgWtQueue.m_i8QueueFull = 0; 
01688:  MOVLB  4
0168A:  CLRF   x30
....................         } 
....................     } 
0168C:  GOTO   169A
....................     else 
....................     { 
....................         i8MaxEntry = g_stAvgWtQueue.m_i8Rear + 1; 
01690:  MOVLW  01
01692:  ADDWF  x2E,W
01694:  MOVLB  A
01696:  MOVWF  xAE
01698:  MOVLB  4
....................     } 
....................      
....................     // Get the summation of queue values    
....................     for (i8LoopCount = 0; i8LoopCount < i8MaxEntry; i8LoopCount++) 
0169A:  MOVLB  A
0169C:  CLRF   xAD
0169E:  MOVF   xAE,W
016A0:  SUBWF  xAD,W
016A2:  BTFSC  FD8.0
016A4:  GOTO   16D2
....................     { 
....................         i32Sum += g_stAvgWtQueue.m_i16Arr[i8LoopCount]; 
016A8:  BCF    FD8.0
016AA:  RLCF   xAD,W
016AC:  CLRF   03
016AE:  ADDLW  CA
016B0:  MOVWF  FE9
016B2:  MOVLW  03
016B4:  ADDWFC 03,W
016B6:  MOVWF  FEA
016B8:  MOVFF  FEC,03
016BC:  MOVF   FED,F
016BE:  MOVF   FEF,W
016C0:  ADDWF  xAF,F
016C2:  MOVF   03,W
016C4:  ADDWFC xB0,F
016C6:  MOVLW  00
016C8:  ADDWFC xB1,F
016CA:  ADDWFC xB2,F
016CC:  INCF   xAD,F
016CE:  GOTO   169E
....................     } 
....................      
....................     g_stAvgWtQueue.m_i16CurAvg = (int16)(i32Sum / (int32)i8MaxEntry); 
016D2:  MOVFF  AAE,00
016D6:  CLRF   01
016D8:  CLRF   02
016DA:  CLRF   03
016DC:  MOVFF  03,AB6
016E0:  MOVFF  02,AB5
016E4:  MOVFF  01,AB4
016E8:  MOVFF  AAE,AB3
016EC:  BCF    FD8.1
016EE:  MOVFF  AB2,AC8
016F2:  MOVFF  AB1,AC7
016F6:  MOVFF  AB0,AC6
016FA:  MOVFF  AAF,AC5
016FE:  MOVFF  03,ACC
01702:  MOVFF  02,ACB
01706:  MOVFF  01,ACA
0170A:  MOVFF  AAE,AC9
0170E:  MOVLB  0
01710:  CALL   0CC2
01714:  MOVFF  01,432
01718:  MOVFF  00,431
....................      
....................     // Store the current average in last average of all CBBs. 
....................     g_stAvgWtQueue.m_i16LstAvg = g_stAvgWtQueue.m_i16CurAvg; 
0171C:  MOVFF  432,434
01720:  MOVFF  431,433
01724:  MOVLB  A
01726:  MOVLB  0
01728:  GOTO   1926 (RETURN)
.................... } 
....................  
.................... void IBCSendProdModeAvgData() 
0172C:  MOVLB  A
0172E:  CLRF   xB0
.................... { 
....................     ST_IBC_DATA_NODE stIBCDataNode; 
....................     int8 i8LoopCount = 0; 
....................      
....................  
....................     // Prepare IBC Data Node 
....................     g_unIBCProdModeAvg.m_stAvgData.m_i16Padding  = 0; 
01730:  CLRF   4B
01732:  CLRF   4A
....................     g_unIBCProdModeAvg.m_stAvgData.m_i16CurAvg   = g_stAvgWtQueue.m_i16CurAvg; 
01734:  MOVFF  432,49
01738:  MOVFF  431,48
....................      
....................     // Stuff IBC Command 
....................     stIBCDataNode.g_ui8ArrIBCData[0] = IBC_CMD_PROD_AVG_WT_DATA; 
0173C:  MOVLW  77
0173E:  MOVWF  xAB
....................     for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
01740:  MOVLW  01
01742:  MOVWF  xB0
01744:  MOVF   xB0,W
01746:  SUBLW  04
01748:  BTFSS  FD8.0
0174A:  GOTO   1784
....................     { 
....................         stIBCDataNode.g_ui8ArrIBCData[i8LoopCount] = g_unIBCProdModeAvg.m_ui8Arr[i8LoopCount - 1]; 
0174E:  CLRF   03
01750:  MOVF   xB0,W
01752:  ADDLW  AB
01754:  MOVWF  01
01756:  MOVLW  0A
01758:  ADDWFC 03,F
0175A:  MOVFF  03,AB2
0175E:  MOVLW  01
01760:  SUBWF  xB0,W
01762:  CLRF   03
01764:  ADDLW  48
01766:  MOVWF  FE9
01768:  MOVLW  00
0176A:  ADDWFC 03,W
0176C:  MOVWF  FEA
0176E:  MOVFF  FEF,AB3
01772:  MOVFF  AB2,FEA
01776:  MOVFF  01,FE9
0177A:  MOVFF  AB3,FEF
0177E:  INCF   xB0,F
01780:  GOTO   1744
....................     } 
....................      
....................     // Send to IBC Insert 
....................     //InsertSendQueue(&stIBCDataNode); 
....................     InsertIBCMsgQueue(&g_stIBCSendQueue, &stIBCDataNode); 
01784:  CLRF   xB8
01786:  MOVLW  B5
01788:  MOVWF  xB7
0178A:  MOVLW  0A
0178C:  MOVWF  xBA
0178E:  MOVLW  AB
01790:  MOVWF  xB9
01792:  MOVLB  0
01794:  CALL   112E
01798:  GOTO   192A (RETURN)
.................... } 
.................... #endif	/* VM_AVERAGE_WEIGHT_CALCULATION_H */ 
....................  
....................  
.................... #include "vmEEPROMConfig_Britania.h" 
.................... #ifndef _VM_EEPROM_CONFIG_BRITANIA_H_ 
.................... #define _VM_EEPROM_CONFIG_BRITANIA_H_ 
....................  
.................... #include "vmEEPROMConfig.h" 
.................... #ifndef _VM_EEPROM_CONFIG_H_ 
.................... #define _VM_EEPROM_CONFIG_H_ 
....................  
.................... #rom int 0xf00000={1,2,3,4} 
....................  
.................... void WriteEEPROMInt8( unsigned int16 uiAddress, unsigned int8 uiValue ) 
.................... { 
....................     write_eeprom(uiAddress,uiValue); 
.................... } 
....................  
.................... void WriteEEPROMInt16( unsigned int16 uiAddress, unsigned int16 uiValue ) 
.................... { 
....................     unsigned int8 uiTemp = 0; 
....................  
....................     // Write first byte. 
....................     uiTemp = uiValue>>8; 
....................     write_eeprom(uiAddress,uiTemp); 
....................     // Increment write address. 
....................     uiAddress++; 
....................     // Write second byte. 
....................     uiTemp = 0; 
....................     uiTemp = uiValue & 0x00FF; 
....................     write_eeprom(uiAddress,uiTemp); 
.................... } 
....................  
.................... unsigned int8 ReadEEPROMInt8( unsigned int16 uiAddress ) 
.................... { 
....................     unsigned int8 uiValue = 0; 
....................  
....................     uiValue = read_eeprom(uiAddress); 
....................  
....................     return uiValue; 
.................... } 
....................  
.................... unsigned int16 ReadEEPROMInt16( unsigned int16 uiAddress ) 
.................... { 
....................     unsigned int16 uiValue = 0; 
....................     unsigned int16 uiTemp  = 0; 
....................  
....................     // Read first byte. 
....................     uiTemp = read_eeprom(uiAddress); 
....................     uiValue = uiTemp << 8; 
....................     // Increment read address. 
....................     uiAddress++; 
....................     // Read second byte. 
....................     uiTemp = read_eeprom(uiAddress); 
....................     uiValue = uiValue | uiTemp; 
....................  
....................     return uiValue; 
.................... } 
....................  
.................... #endif /* _VM_EEPROM_CONFIG_H_ */ 
....................  
.................... #include "vmCalibration.h" 
.................... /*  
....................  * File:   vmCalibration.h 
....................  * Author: Amit 
....................  * 
....................  * Created on December 9, 2018, 7:55 PM 
....................  */ 
....................  
.................... #ifndef VM_CALIBRATION_H 
.................... #define	VM_CALIBRATION_H 
....................  
.................... #define SIZE_CALIB_TABLE              11 // Only for the values 0, 1000, 2000, 3000, 4000, 
....................                                             // 5000, 6000, 7000, 8000, 9000 and 10000 
.................... #define EEPROM_START_ADDRESS_CALIB    0 
.................... #define MAX_CALIB_RESET_PASS          3 
....................  
.................... #define 	CALIB_ADC_VAL_0000	43302 
.................... #define 	CALIB_ADC_VAL_1000	44550 
.................... #define 	CALIB_ADC_VAL_2000	45780 
.................... #define 	CALIB_ADC_VAL_3000	47005 
.................... #define 	CALIB_ADC_VAL_4000	48238 
.................... #define 	CALIB_ADC_VAL_5000	49471 
.................... #define 	CALIB_ADC_VAL_6000	50716 
.................... #define 	CALIB_ADC_VAL_7000	51963 
.................... #define 	CALIB_ADC_VAL_8000	53203 
.................... #define 	CALIB_ADC_VAL_9000	54435 
.................... #define 	CALIB_ADC_VAL_10000	55676 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... typedef struct _ST_CALIB_NODE 
.................... { 
....................     int16          m_i16CalibPoint; 
....................     unsigned int32 m_ui32CalibValue; 
.................... } ST_CALIB_NODE; 
....................  
.................... // Node for dynamic error calculations 
.................... typedef struct _ST_DYNAMIC_ERR_NODE 
.................... { 
....................     int16           m_i16WeightPoint; 
....................     unsigned int8   m_ui8ErrValue; 
.................... } ST_DYNAMIC_ERR_NODE; 
....................  
.................... // Parse Union for Calib Point 
.................... typedef union _UN_CALIB_POINT 
.................... { 
....................     unsigned int16 m_un16CalibPoint; 
....................     unsigned int8  m_un8Arr[2]; 
.................... } UN_CALIB_POINT; 
....................  
.................... // Parse Union for Calib Value 
.................... typedef union _UN_CALIB_VALUE 
.................... { 
....................     unsigned int32 m_un32Value; 
....................     unsigned int8  m_un8Arr[4]; 
.................... } UN_CALIB_VALUE; 
....................  
....................  
.................... ST_CALIB_NODE g_stCalibTable[SIZE_CALIB_TABLE]; 
.................... ST_CALIB_NODE g_stTempCalibTable[SIZE_CALIB_TABLE]; 
.................... ST_DYNAMIC_ERR_NODE g_stDynamicErrTable[SIZE_CALIB_TABLE]; 
....................  
.................... // Update Single Calibration Point in EEPROM 
.................... void UpdateCalibPointInRAM(unsigned int16 ui16CalibPoint, unsigned int32 ui32CalibValue) 
.................... { 
....................     // Check if the Calibration Point value is 0 or in Multiple of 1000 or not 
....................     if (!(ui16CalibPoint == 0 || ui16CalibPoint % 1000 == 0)) 
....................     { 
....................         return; 
....................     } 
....................      
....................     // We are only considering 0, or values which are multiple of 1000 
....................     // Now need to check that the value should not be greater than 10000, 
....................     // as we are only considering 10KG of max calibration 
....................     if (ui16CalibPoint > 10000) 
....................     { 
....................         return; 
....................     } 
....................      
....................     // Here we are considering only the following values as calibration point 
....................     // 0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000 and 10000 
....................     // That is only 11 values 
....................     if (!ui16CalibPoint) 
....................     { 
....................         g_stCalibTable[0].m_ui32CalibValue = ui32CalibValue; 
....................     } 
....................     else 
....................     { 
....................         g_stCalibTable[ui16CalibPoint/1000].m_ui32CalibValue = ui32CalibValue; 
....................     } 
.................... } 
....................  
.................... // Update entire table in RAM into EEPROM 
.................... void UpdateCalibTableInEEPROM() 
.................... { 
....................     int iLoopCount = 0; 
....................     unsigned int16 ui16StartAddress = EEPROM_START_ADDRESS_CALIB; 
....................     UN_CALIB_POINT unTempCalibPoint; 
....................     UN_CALIB_VALUE unTempCalibValue; 
....................     unsigned int8  ui8Byte0 = 0; 
....................     unsigned int8  ui8Byte1 = 0; 
....................     unsigned int8  ui8Byte2 = 0; 
....................     unsigned int8  ui8Byte3 = 0; 
....................     unsigned int8  ui8Temp  = 0; 
....................      
....................     for (iLoopCount = 0; iLoopCount < SIZE_CALIB_TABLE; iLoopCount++) 
....................     { 
....................         // Calib Point while in int16 is stored in byte array as  |b1|a1| 
....................         // Calib Value while in int32 is stored in byte array as  |d2|c2|b2|a2| 
....................         // In EEPROM it should be like |a1|b1+c2|a2|b2| 
....................          
....................         // Step 1 : Parse Calib Point and Calib Value 
....................         unTempCalibPoint.m_un16CalibPoint = g_stCalibTable[iLoopCount].m_i16CalibPoint; 
....................         unTempCalibValue.m_un32Value      = g_stCalibTable[iLoopCount].m_ui32CalibValue; 
....................          
....................         // Step2 : Prepare EEPROM Data 0 
....................         ui8Byte0 = unTempCalibPoint.m_un8Arr[0]; 
....................          
....................         ui8Byte1 = unTempCalibPoint.m_un8Arr[1]; 
....................          
....................         // Shift the byte to accommodate high part two bit of value 
....................         ui8Byte1 = ui8Byte1 << 2; 
....................         // Get the High Part 2 bit of of Calib Value 
....................         ui8Temp = unTempCalibValue.m_un8Arr[2]; 
....................         // Make sure that only two bit will present and rest is 0 
....................         ui8Temp = ui8Temp << 6; 
....................         ui8Temp = ui8Temp >> 6; 
....................          
....................         // Now Marge two byte to get the second byte 
....................         ui8Byte1 = ui8Byte1 | ui8Temp; 
....................          
....................         // Step 3: Get the third and 4th Bytes 
....................         ui8Byte2 = unTempCalibValue.m_un8Arr[0]; 
....................         ui8Byte3 = unTempCalibValue.m_un8Arr[1]; 
....................          
....................         // Step 4 : Write to EEPROM 
....................         WriteEEPROMInt8((ui16StartAddress + (4*iLoopCount) + 0), ui8Byte0); 
....................         WriteEEPROMInt8((ui16StartAddress + (4*iLoopCount) + 1), ui8Byte1); 
....................         WriteEEPROMInt8((ui16StartAddress + (4*iLoopCount) + 2), ui8Byte2); 
....................         WriteEEPROMInt8((ui16StartAddress + (4*iLoopCount) + 3), ui8Byte3); 
....................     } 
.................... } 
....................  
.................... // Update entire table in RAM into EEPROM 
.................... void UpdateCalibPointInEEPROM() 
.................... { 
....................      
.................... } 
....................  
.................... void IBCSendCalibTable() 
.................... { 
....................     int8           i8LoopCount1      = 0; 
....................     int8           i8LoopCount2      = 1; 
....................     unsigned int16 ui16StartAddress  = EEPROM_START_ADDRESS_CALIB; 
....................     unsigned int16 ui16EEPROMAddress = EEPROM_START_ADDRESS_CALIB; 
....................     ST_IBC_DATA_NODE stIBCDataNode; 
....................      
....................     for (i8LoopCount1 = 0; i8LoopCount1 < SIZE_CALIB_TABLE; i8LoopCount1++) 
....................     { 
....................         // Step 1: First Stuff the IBC Command in the First Byte 
....................         //stIBCDataNode.g_ui8ArrIBCData[0] = IBC_CMD_SET_CALIB_POINT; 
....................          
....................         // Step 2: Stuff 4 Data Bytes from EEPROM 
....................         for (i8LoopCount2 = 1; i8LoopCount2 < IBC_MSG_BYTE_COUNT; i8LoopCount2++) 
....................         { 
....................             stIBCDataNode.g_ui8ArrIBCData[i8LoopCount2] = 
....................                    ReadEEPROMInt8(ui16StartAddress +  
....................                                  (i8LoopCount1 * (IBC_MSG_BYTE_COUNT - 1)) + 
....................                                  (i8LoopCount2 - 1)); 
....................         } 
....................          
....................         // Step 3: Put it into the IBC Send QUEUE 
....................         //InsertSendQueue(&stIBCDataNode); 
....................         InsertIBCMsgQueue(&g_stIBCSendQueue, &stIBCDataNode); 
....................         //delay_ms(100);  //TODO Just for Testing 
....................     } 
.................... } 
....................  
.................... // Get Calibration Table From EEPROM 
.................... void PrepareCalibTable() 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     unsigned int16 ui16TempCalibPoint = 0; 
....................     unsigned int32 ui32TempCalibValue = 0; 
....................     unsigned int8 ui8Data0 = 0; 
....................     unsigned int8 ui8Data1 = 0; 
....................     unsigned int8 ui8Data2 = 0; 
....................     unsigned int8 ui8Data3 = 0; 
....................     unsigned int8 ui8Temp  = 0; 
....................      
....................     unsigned int16 ui16CalibTableStartAddress = 0;   //TODO Set the Calibration Table Start Address 
....................      
....................     // Read from EEPROM and set Calibration Table 
....................     for (i8LoopCount = 0; i8LoopCount < SIZE_CALIB_TABLE; i8LoopCount++) 
....................     { 
....................         // Get data from EEPROM 
....................         // First 14 bit stores the Calibration Point Second 18 bit stores the Value 
....................         ui8Data0 = ReadEEPROMInt8(ui16CalibTableStartAddress + ((i8LoopCount *4) + 0)); 
....................         ui8Data1 = ReadEEPROMInt8(ui16CalibTableStartAddress + ((i8LoopCount *4) + 1)); 
....................         ui8Data2 = ReadEEPROMInt8(ui16CalibTableStartAddress + ((i8LoopCount *4) + 2)); 
....................         ui8Data3 = ReadEEPROMInt8(ui16CalibTableStartAddress + ((i8LoopCount *4) + 3)); 
....................          
....................         // Set the Calibration Point 
....................         ui16TempCalibPoint = ui8Data1; 
....................         ui16TempCalibPoint = ui16TempCalibPoint >> 2; 
....................         g_stCalibTable[i8LoopCount].m_i16CalibPoint = ui16TempCalibPoint; 
....................         g_stCalibTable[i8LoopCount].m_i16CalibPoint = g_stCalibTable[i8LoopCount].m_i16CalibPoint << 8; 
....................         g_stCalibTable[i8LoopCount].m_i16CalibPoint = g_stCalibTable[i8LoopCount].m_i16CalibPoint | ui8Data0; 
....................          
....................         // Set the Calibration Value 
....................         ui8Temp = ui8Data1; 
....................         ui8Temp = ui8Temp << 6; 
....................         ui8Temp = ui8Temp >> 6; 
....................         g_stCalibTable[i8LoopCount].m_ui32CalibValue = ui8Temp; 
....................         g_stCalibTable[i8LoopCount].m_ui32CalibValue = g_stCalibTable[i8LoopCount].m_ui32CalibValue << 16; 
....................          
....................         ui32TempCalibValue = ui8Data3; 
....................         ui32TempCalibValue = ui32TempCalibValue << 8; 
....................         g_stCalibTable[i8LoopCount].m_ui32CalibValue = g_stCalibTable[i8LoopCount].m_ui32CalibValue | ui32TempCalibValue; 
....................          
....................         ui32TempCalibValue = ui8Data2; 
....................         g_stCalibTable[i8LoopCount].m_ui32CalibValue = g_stCalibTable[i8LoopCount].m_ui32CalibValue | ui32TempCalibValue; 
....................          
....................     } 
.................... } 
....................  
....................  
.................... // TESTING Start 
.................... void PrepareTestCalibTable() 
.................... { 
....................     g_stCalibTable[0].m_i16CalibPoint  = 0; 
....................     g_stCalibTable[0].m_ui32CalibValue = CALIB_ADC_VAL_0000;  //41925 
....................      
....................     g_stCalibTable[1].m_i16CalibPoint  = 1000; 
....................     g_stCalibTable[1].m_ui32CalibValue = CALIB_ADC_VAL_1000;  //43081 
....................      
....................     g_stCalibTable[2].m_i16CalibPoint  = 2000; 
....................     g_stCalibTable[2].m_ui32CalibValue = CALIB_ADC_VAL_2000;  //44233 
....................      
....................     g_stCalibTable[3].m_i16CalibPoint  = 3000; 
....................     g_stCalibTable[3].m_ui32CalibValue = CALIB_ADC_VAL_3000;  //45379 
....................      
....................     g_stCalibTable[4].m_i16CalibPoint  = 4000; 
....................     g_stCalibTable[4].m_ui32CalibValue = CALIB_ADC_VAL_4000;  //46538 
....................      
....................     g_stCalibTable[5].m_i16CalibPoint  = 5000; 
....................     g_stCalibTable[5].m_ui32CalibValue = CALIB_ADC_VAL_5000;  //47686 
....................      
....................     g_stCalibTable[6].m_i16CalibPoint  = 6000; 
....................     g_stCalibTable[6].m_ui32CalibValue = CALIB_ADC_VAL_6000;  //48842 
....................      
....................     g_stCalibTable[7].m_i16CalibPoint  = 7000; 
....................     g_stCalibTable[7].m_ui32CalibValue = CALIB_ADC_VAL_7000;  //49992 
....................      
....................     g_stCalibTable[8].m_i16CalibPoint  = 8000; 
....................     g_stCalibTable[8].m_ui32CalibValue = CALIB_ADC_VAL_8000;  //51151 
....................      
....................     g_stCalibTable[9].m_i16CalibPoint  = 9000; 
....................     g_stCalibTable[9].m_ui32CalibValue = CALIB_ADC_VAL_9000;  //52303 
....................      
....................     g_stCalibTable[10].m_i16CalibPoint  = 10000; 
....................     g_stCalibTable[10].m_ui32CalibValue = CALIB_ADC_VAL_10000; //53456 
.................... } 
....................  
.................... // In RAM Only 
.................... void PrepareTempCalibTable(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................      
....................     // Prepare table 
....................     for (i8LoopCount = 0; i8LoopCount < SIZE_CALIB_TABLE; i8LoopCount++) 
....................     { 
....................         g_stTempCalibTable[i8LoopCount].m_i16CalibPoint = g_stCalibTable[i8LoopCount].m_i16CalibPoint; 
....................         g_stTempCalibTable[i8LoopCount].m_ui32CalibValue = g_stCalibTable[i8LoopCount].m_ui32CalibValue; 
....................     } 
.................... } 
....................  
.................... void ResetCalibTable(int16 i16TareValue) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................      
....................     for (i8LoopCount = 0; i8LoopCount < SIZE_CALIB_TABLE; i8LoopCount++) 
....................     { 
....................         g_stCalibTable[i8LoopCount].m_ui32CalibValue += i16TareValue; 
....................     } 
.................... } 
....................  
.................... void PrepareTestCalibTableX(unsigned int16 ui16X) 
.................... { 
....................     g_stCalibTable[0].m_i16CalibPoint  = 0; 
....................     g_stCalibTable[0].m_ui32CalibValue = 165 + ui16X; 
....................      
....................     g_stCalibTable[1].m_i16CalibPoint  = 1000; 
....................     g_stCalibTable[1].m_ui32CalibValue = 1005 + ui16X; 
....................      
....................     g_stCalibTable[2].m_i16CalibPoint  = 2000; 
....................     g_stCalibTable[2].m_ui32CalibValue = 2005 + ui16X; 
....................      
....................     g_stCalibTable[3].m_i16CalibPoint  = 3000; 
....................     g_stCalibTable[3].m_ui32CalibValue = 3005 + ui16X; 
....................      
....................     g_stCalibTable[4].m_i16CalibPoint  = 4000; 
....................     g_stCalibTable[4].m_ui32CalibValue = 4005 + ui16X; 
....................      
....................     g_stCalibTable[5].m_i16CalibPoint  = 5000; 
....................     g_stCalibTable[5].m_ui32CalibValue = 5005 + ui16X; 
....................      
....................     g_stCalibTable[6].m_i16CalibPoint  = 6000; 
....................     g_stCalibTable[6].m_ui32CalibValue = 6005 + ui16X; 
....................      
....................     g_stCalibTable[7].m_i16CalibPoint  = 7000; 
....................     g_stCalibTable[7].m_ui32CalibValue = 7005 + ui16X; 
....................      
....................     g_stCalibTable[8].m_i16CalibPoint  = 8000; 
....................     g_stCalibTable[8].m_ui32CalibValue = 8005 + ui16X; 
....................      
....................     g_stCalibTable[9].m_i16CalibPoint  = 9000 + ui16X; 
....................     g_stCalibTable[9].m_ui32CalibValue = 9005; 
....................      
....................     g_stCalibTable[10].m_i16CalibPoint  = 10000; 
....................     g_stCalibTable[10].m_ui32CalibValue = 10005 + ui16X; 
.................... } 
.................... // TESTING End 
.................... #endif	/* VM_CALIBRATION_H */ 
....................  
....................  
....................  
.................... //#define EEPROM_ADDRESS_FOR_0_GM       200 
.................... #define EEPROM_ADDRESS_FOR_LCF          100 
.................... //#define CALIB_PONT_DIV_FACTOR         1000 
.................... //#define CALIB_POINT_MULT_FACTOR       4 
....................  
.................... ////void WriteDataToEEPROM(unsigned int16 ui16CalibPointEEPROM, unsigned int16 ui16ADCCalibValueEEPROM) 
.................... ////{ 
.................... ////    unsigned int16 ui16EEPROMStartAddress = 0; 
.................... ////     
.................... ////    // Calculate EEPROM Write Address for each calibration point  
.................... ////    if(!ui16CalibPointEEPROM) 
.................... ////    { 
.................... ////        ui16EEPROMStartAddress = EEPROM_ADDRESS_FOR_0_GM; 
.................... ////    } 
.................... ////    else 
.................... ////    { 
.................... ////        ui16EEPROMStartAddress = EEPROM_ADDRESS_FOR_0_GM + ((ui16CalibPointEEPROM / CALIB_PONT_DIV_FACTOR) * CALIB_POINT_MULT_FACTOR); 
.................... ////    } 
.................... ////     
.................... ////    // Write Calib point to EEPROM 
.................... ////    WriteEEPROMInt16(ui16EEPROMStartAddress, ui16CalibPointEEPROM); 
.................... ////    // Increment address 
.................... ////    ui16EEPROMStartAddress += 2; 
.................... ////    // Write calib value to EEPROM 
.................... ////    WriteEEPROMInt16(ui16EEPROMStartAddress, ui16ADCCalibValueEEPROM); 
.................... ////    
.................... ////} 
....................  
.................... ////void ReadCalibTableFromEEPROM(void) 
.................... ////{ 
.................... ////    unsigned int16 ui16EEPROMStartAddress = 0; 
.................... ////    unsigned int16 ui16EEPROMPoint        = 0; 
.................... ////    unsigned int16 ui16EEPROMValue        = 0; 
.................... ////    unsigned int8 ui8LoopCount = 0; 
.................... ////     
.................... ////    // Write calib value for 0gm predefined 
.................... ////    g_stCalibTable[0].m_i16CalibPoint = 0; 
.................... ////    g_stCalibTable[0].m_ui32CalibValue = 41925; 
.................... ////     
.................... ////    for (ui8LoopCount = 1; ui8LoopCount < SIZE_CALIB_TABLE; ui8LoopCount++) 
.................... ////    { 
.................... ////        // Calculate EEPROM Write Address for each calibration point 
.................... ////        ui16EEPROMStartAddress = EEPROM_ADDRESS_FOR_0_GM + (ui8LoopCount * CALIB_POINT_MULT_FACTOR); 
.................... //// 
.................... ////        // Read calib point from EEPROM  
.................... ////        ui16EEPROMPoint = ReadEEPROMInt16(ui16EEPROMStartAddress); 
.................... ////        // Assign calibration point in calib table 
.................... ////        g_stCalibTable[ui8LoopCount].m_i16CalibPoint = ui16EEPROMPoint; 
.................... ////        // Increment address 
.................... ////        ui16EEPROMStartAddress += 2; 
.................... ////        // Read calib value from EEPROM 
.................... ////        ui16EEPROMValue = ReadEEPROMInt16(ui16EEPROMStartAddress); 
.................... ////        // Assign calib value in calib table 
.................... ////        g_stCalibTable[ui8LoopCount].m_ui32CalibValue = ui16EEPROMValue; 
.................... ////    } 
.................... ////} 
....................  
.................... ////void WriteDynamicErrToEEPROM(int16 i16DynamicErrValue) 
.................... ////{ 
.................... ////    unsigned int16 ui16DynamicErrValue = 0; 
.................... ////     
.................... ////    ui16DynamicErrValue = (unsigned int16)i16DynamicErrValue; 
.................... //// 
.................... ////    //WriteEEPROMInt16(EEPROM_ADRESS_FOR_DYNAMIC_ERR, ui16DynamicErrValue); 
.................... ////     
.................... ////    return; 
.................... ////} 
....................  
.................... void WriteLCFToEEPROM(int16 i16CurrLoadCellFactor) 
*
01E50:  MOVLB  A
01E52:  CLRF   xB4
01E54:  CLRF   xB3
.................... { 
....................     unsigned int16 ui16CurrLoadCellFactor = 0; 
....................      
....................     // cast the receive parameter in unsugned. 
....................     ui16CurrLoadCellFactor = (unsigned int16)i16CurrLoadCellFactor; 
01E56:  MOVFF  AB2,AB4
01E5A:  MOVFF  AB1,AB3
....................      
....................     // Store data in EEPROM. 
....................     WriteEEPROMInt16(EEPROM_ADDRESS_FOR_LCF,ui16CurrLoadCellFactor); 
01E5E:  CLRF   xB6
01E60:  MOVLW  64
01E62:  MOVWF  xB5
01E64:  MOVFF  AB4,AB8
01E68:  MOVFF  AB3,AB7
01E6C:  MOVLB  0
01E6E:  GOTO   1DD4
01E72:  GOTO   202A (RETURN)
.................... } 
....................  
.................... int16 ReadLCFFromEEPROM(void) 
*
00730:  MOVLB  A
00732:  CLRF   xAD
00734:  CLRF   xAC
.................... { 
....................     unsigned int16 ui16RetrieveLCF = 0; 
....................      
....................     // Retrieve stored LCF from EEPROM. 
....................     ui16RetrieveLCF = ReadEEPROMInt16(EEPROM_ADDRESS_FOR_LCF); 
00736:  CLRF   xAF
00738:  MOVLW  64
0073A:  MOVWF  xAE
0073C:  MOVLB  0
0073E:  GOTO   06C8
00742:  MOVFF  02,AAD
00746:  MOVFF  01,AAC
....................      
....................     return((int16)ui16RetrieveLCF); 
0074A:  MOVLB  A
0074C:  MOVFF  AAC,01
00750:  MOVFF  AAD,02
00754:  MOVLB  0
00756:  GOTO   080C (RETURN)
.................... } 
....................  
.................... //int16 ReadDynamicERRValueFromEEPROM() 
.................... //{ 
.................... //    int16          i16DynamicErrValue  = 0; 
.................... //    unsigned int16 ui16DynamicERRValue = 0; 
.................... // 
.................... //    ui16DynamicERRValue = ReadEEPROMInt16(EEPROM_ADRESS_FOR_DYNAMIC_ERR); 
.................... //     
.................... ////    if (ui16DynamicERRValue > 0x8000) 
.................... ////    { 
.................... ////        ui16DynamicERRValue = ui16DynamicERRValue << 1; 
.................... ////        ui16DynamicERRValue = ui16DynamicERRValue >> 1; 
.................... ////         
.................... ////        i16DynamicErrValue = (int16)ui16DynamicERRValue; 
.................... ////        i16DynamicErrValue = 0 - i16DynamicErrValue; 
.................... ////    } 
.................... ////    else 
.................... ////    { 
.................... ////        i16DynamicErrValue =  (int16)ui16DynamicERRValue; 
.................... ////    } 
.................... //    i16DynamicErrValue =  (int16)ui16DynamicERRValue; 
.................... //    return i16DynamicErrValue; 
.................... //} 
....................  
.................... //// TESTING 
.................... //void TestEEPROMData(void) 
.................... //{ 
.................... //    unsigned int16 ui16TempCalibPoint = 0; 
.................... //    unsigned int16 ui16TempCalibValue = 41926; 
.................... //    int8           i8LoopCount        = 0; 
.................... //     
.................... //    for (i8LoopCount = 1; i8LoopCount < SIZE_CALIB_TABLE; i8LoopCount++) 
.................... //    { 
.................... //       ui16TempCalibPoint= ui16TempCalibPoint + 1000; 
.................... //       ui16TempCalibValue = ui16TempCalibValue + 1156; 
.................... //       WriteDataToEEPROM(ui16TempCalibPoint, ui16TempCalibValue); 
.................... //    }     
.................... //} 
....................  
.................... //void ResetCalibTable(void) 
.................... //{ 
.................... //    unsigned int8 ui8LoopCount = 0; 
.................... //     
.................... //    for (ui8LoopCount = 0; ui8LoopCount < SIZE_CALIB_TABLE; ui8LoopCount++) 
.................... //    { 
.................... //        g_stCalibTable[ui8LoopCount].m_i16CalibPoint = 0; 
.................... //        g_stCalibTable[ui8LoopCount].m_ui32CalibValue = 0; 
.................... //    } 
.................... //} 
....................  
.................... #endif /* _VM_EEPROM_CONFIG_BRITANIA_H_ */ 
....................  
....................  
.................... #define LOAD_CELL_FACTOR       818 
.................... //#define ADC_SCANNING_START     0 
.................... //#define ADC_SCANNING_RUNNING   1 
.................... //#define ADC_SCANNING_STOP      2 
.................... #define ADC_SCAN_ON            1 
.................... #define ADC_SCAN_OFF           0 
....................  
.................... #define TIMER_IGNORE_ON  1 
.................... #define TIMER_IGNORE_OFF 0 
....................  
.................... int8 g_fIgnore_TIMER = TIMER_IGNORE_OFF; 
....................  
....................  
.................... #define COLLECT_DYNAMIC_TARE_DATA      3 
.................... #define COLLECT_WEIGHING_DATA          4 
.................... #define COLLECT_NOTHING                5 
....................  
.................... #define SIZE_DATA_QUEUE              200 
.................... #define MAX_TARE_MULTIPLAYER         100 
....................  
.................... #define ADC_DATA_NOT_READY             0 
.................... #define ADC_DATA_READY                 1 
....................  
.................... #define ADC_DATA_Q_VALUES_TRIMMING_PERCNTG     30 
....................  
.................... #define ADC_MEAN_CALCULATION_START    0 
.................... #define ADC_MEAN_CALCULATION_STOP     1 
.................... #define ADC_MEAN_CALCULATION_RUNNING  2 
.................... #define ADC_MEAN_CALCULATION_DONE     3 
....................  
.................... unsigned int8 g_ui8ADCMeanCalState = ADC_MEAN_CALCULATION_STOP; 
.................... unsigned int32 g_ui32ADCCurMeanValue = 0; 
.................... unsigned int32 g_ui32ADCCurSum       = 0; 
.................... unsigned int16 g_ui16ADCSumLoopCount = 0; 
.................... int16          g_i16LoadCellFactor   = 0; 
....................  
....................  
....................  
.................... typedef struct _ST_ADC_DATA_QUEUE 
.................... { 
....................     unsigned int32 m_ui32Arr[SIZE_DATA_QUEUE]; 
....................     int16          m_i16Rear; 
....................     unsigned int8  m_ui8Multiplier; 
....................     unsigned int32 m_ui32Sum; 
....................     int8           m_i8CollectionState; 
.................... } ST_ADC_DATA_QUEUE; 
....................  
.................... typedef struct _ST_MEAN_SHIFT_VALUE 
.................... { 
.................... 	unsigned int8 ui8ActualIndex ; 
.................... 	unsigned int8 ui8MeanShiftValue; 
.................... }ST_MEAN_SHIFT_VALUE; 
....................  
.................... unsigned int8  g_ui8ADCScanningStatus   = ADC_SCAN_OFF; 
.................... unsigned int32 g_ui32ADCValue           = 0; 
.................... unsigned int8  g_ui8DataCollectionState = COLLECT_NOTHING; 
.................... unsigned int8  g_fADCDataReadyStatus    = ADC_DATA_NOT_READY; 
.................... unsigned int8 g_ui8CurMaxDataCount    = 0; 
....................  
.................... ST_ADC_DATA_QUEUE g_stADCDataQ; 
.................... unsigned int16    g_ui16NoOfADCData   = 0; 
.................... unsigned int32    g_ui32ADCAvg        = 0; 
....................  
.................... //unsigned int8       g_ui8ArrSortedTemp[SIZE_DATA_QUEUE]          = {0}; 
.................... //ST_MEAN_SHIFT_VALUE g_ui16ArrMeanShiftVal[SIZE_DATA_QUEUE]       = {0}; 
.................... //ST_MEAN_SHIFT_VALUE g_ui16ArrSortedMeanShiftVal[SIZE_DATA_QUEUE] = {0}; 
....................  
.................... void ResetADCDataQ(int8 i8CollectionState); 
.................... unsigned int32 GetADCMeanValue(); 
.................... unsigned int32 GetTareData(); 
.................... int16          GetWeighingData(unsigned int32); 
.................... //void           IBCSendWeighingData(); 
.................... //void           IBCSendTareData(); 
.................... void           IBCSendTareData(unsigned int32); 
....................  
.................... void ResetADCDataQ(int8 i8CollectionState) 
.................... { 
....................     g_stADCDataQ.m_i16Rear           = -1; 
*
006A4:  MOVLB  7
006A6:  SETF   x6C
006A8:  SETF   x6B
....................     g_stADCDataQ.m_ui32Sum           = 0; 
006AA:  CLRF   x71
006AC:  CLRF   x70
006AE:  CLRF   x6F
006B0:  CLRF   x6E
....................     g_stADCDataQ.m_ui8Multiplier     = 0; 
006B2:  CLRF   x6D
....................     g_stADCDataQ.m_i8CollectionState = i8CollectionState; 
006B4:  MOVFF  ABF,772
....................      
....................     //CHANGE_RUNNING_AVG START 
....................     g_ui16NoOfADCData = 0; 
006B8:  CLRF   x74
006BA:  CLRF   x73
....................     g_ui32ADCAvg      = 0; 
006BC:  CLRF   x78
006BE:  CLRF   x77
006C0:  CLRF   x76
006C2:  CLRF   x75
006C4:  MOVLB  0
006C6:  RETURN 0
....................     //CHANGE_RUNNING_AVG END 
.................... } 
....................  
.................... unsigned int32 GetADCMeanValue() 
.................... { 
....................     unsigned int8  ui8LoopCount     = 0; 
....................     unsigned int32 ui32DataSum      = 0; 
....................     //unsigned int32 ui32ADCMean      = 0; 
....................      
....................     // There is no Data then return 0 
....................     if (-1 == g_stADCDataQ.m_i16Rear) 
....................     { 
....................         return 0; 
....................     } 
....................     // Check the value of the Multiplier 
....................     if (g_stADCDataQ.m_ui8Multiplier) 
....................     { 
....................         g_ui8CurMaxDataCount = SIZE_DATA_QUEUE; 
....................     } 
....................     else 
....................     { 
....................         g_ui8CurMaxDataCount = g_stADCDataQ.m_i16Rear + 1; 
....................     } 
....................     //output_high(PIN_OUT_DO_02); 
....................     // Get the mean Value 
....................     for (ui8LoopCount = 0; ui8LoopCount < g_ui8CurMaxDataCount; ui8LoopCount++) 
....................     { 
....................         ui32DataSum += g_stADCDataQ.m_ui32Arr[ui8LoopCount]; 
....................         //ui32DataSum += 65500; 
....................         //output_toggle(PIN_OUT_DO_02); 
....................     } 
....................     //output_low(PIN_OUT_DO_02); 
....................     // TESTING Start 
....................     // Reset Data Queue 
....................     //ResetADCDataQ(COLLECT_NOTHING);  //TODO It should not be here, Reset should be done from State Machine 
....................     // TESTING End 
....................     // Now return Mean Value 
....................     return(ui32DataSum / g_ui8CurMaxDataCount); 
.................... } 
....................  
.................... unsigned int8 StartADCSplitAvg() 
.................... { 
....................     g_ui32ADCCurMeanValue = 0; 
*
00C6A:  MOVLB  4
00C6C:  CLRF   x3A
00C6E:  CLRF   x39
00C70:  CLRF   x38
00C72:  CLRF   x37
....................     g_ui32ADCCurSum       = 0; 
00C74:  CLRF   x3E
00C76:  CLRF   x3D
00C78:  CLRF   x3C
00C7A:  CLRF   x3B
....................     g_ui8CurMaxDataCount  = 0; 
00C7C:  CLRF   x4A
....................     g_ui16ADCSumLoopCount = 0; 
00C7E:  CLRF   x40
00C80:  CLRF   x3F
....................      
....................     // There is no Data then return 0 
....................     if (-1 == g_stADCDataQ.m_i16Rear) 
00C82:  MOVLB  7
00C84:  INCFSZ x6B,W
00C86:  GOTO   0C9C
00C8A:  INCFSZ x6C,W
00C8C:  GOTO   0C9C
....................     { 
....................         g_ui8ADCMeanCalState  = ADC_MEAN_CALCULATION_DONE; 
00C90:  MOVLW  03
00C92:  MOVLB  4
00C94:  MOVWF  x36
....................         return; 
00C96:  GOTO   0CBC
00C9A:  MOVLB  7
....................     } 
....................     // Check the value of the Multiplier 
....................     if (g_stADCDataQ.m_ui8Multiplier) 
00C9C:  MOVF   x6D,F
00C9E:  BTFSC  FD8.2
00CA0:  GOTO   0CB0
....................     { 
....................         g_ui8CurMaxDataCount = SIZE_DATA_QUEUE; 
00CA4:  MOVLW  C8
00CA6:  MOVLB  4
00CA8:  MOVWF  x4A
....................     } 
00CAA:  GOTO   0CB8
00CAE:  MOVLB  7
....................     else 
....................     { 
....................         g_ui8CurMaxDataCount = g_stADCDataQ.m_i16Rear + 1; 
00CB0:  MOVLW  01
00CB2:  ADDWF  x6B,W
00CB4:  MOVLB  4
00CB6:  MOVWF  x4A
....................     } 
....................      
....................     g_ui8ADCMeanCalState  = ADC_MEAN_CALCULATION_RUNNING; 
00CB8:  MOVLW  02
00CBA:  MOVWF  x36
00CBC:  MOVLB  0
00CBE:  GOTO   28FA (RETURN)
.................... ////    if(g_stADCDataQ.m_i8CollectionState == COLLECT_DYNAMIC_TARE_DATA) 
.................... ////    { 
.................... ////        g_ui16ADCSumLoopCount = 20; 
.................... ////    } 
.................... } 
....................  
.................... void GetADCSplitSum() 
.................... { 
....................   
....................     if (g_ui16ADCSumLoopCount < g_ui8CurMaxDataCount) 
*
00D6E:  MOVLB  4
00D70:  MOVF   x40,F
00D72:  BTFSS  FD8.2
00D74:  GOTO   0DC8
00D78:  MOVF   x4A,W
00D7A:  SUBWF  x3F,W
00D7C:  BTFSC  FD8.0
00D7E:  GOTO   0DC8
....................     { 
....................         g_ui32ADCCurSum += g_stADCDataQ.m_ui32Arr[g_ui16ADCSumLoopCount]; 
00D82:  RLCF   x3F,W
00D84:  MOVWF  02
00D86:  RLCF   x40,W
00D88:  MOVWF  03
00D8A:  RLCF   02,F
00D8C:  RLCF   03,F
00D8E:  MOVLW  FC
00D90:  ANDWF  02,F
00D92:  MOVF   02,W
00D94:  ADDLW  4B
00D96:  MOVWF  FE9
00D98:  MOVLW  04
00D9A:  ADDWFC 03,W
00D9C:  MOVWF  FEA
00D9E:  MOVFF  FEF,00
00DA2:  MOVFF  FEC,01
00DA6:  MOVFF  FEC,02
00DAA:  MOVFF  FEC,03
00DAE:  MOVF   00,W
00DB0:  ADDWF  x3B,F
00DB2:  MOVF   01,W
00DB4:  ADDWFC x3C,F
00DB6:  MOVF   02,W
00DB8:  ADDWFC x3D,F
00DBA:  MOVF   03,W
00DBC:  ADDWFC x3E,F
....................         // Increment Loop Count 
....................         g_ui16ADCSumLoopCount++; 
00DBE:  INCF   x3F,F
00DC0:  BTFSC  FD8.2
00DC2:  INCF   x40,F
....................     } 
00DC4:  GOTO   0E14
....................     else if (g_ui16ADCSumLoopCount >= g_ui8CurMaxDataCount) 
00DC8:  MOVF   x40,F
00DCA:  BTFSS  FD8.2
00DCC:  GOTO   0DDA
00DD0:  MOVF   x4A,W
00DD2:  SUBWF  x3F,W
00DD4:  BTFSS  FD8.0
00DD6:  GOTO   0E14
....................     { 
....................         // Calculate the mean 
....................         g_ui32ADCCurMeanValue = g_ui32ADCCurSum / g_ui8CurMaxDataCount; 
00DDA:  BCF    FD8.1
00DDC:  MOVFF  43E,AC8
00DE0:  MOVFF  43D,AC7
00DE4:  MOVFF  43C,AC6
00DE8:  MOVFF  43B,AC5
00DEC:  MOVLB  A
00DEE:  CLRF   xCC
00DF0:  CLRF   xCB
00DF2:  CLRF   xCA
00DF4:  MOVFF  44A,AC9
00DF8:  MOVLB  0
00DFA:  CALL   0CC2
00DFE:  MOVFF  03,43A
00E02:  MOVFF  02,439
00E06:  MOVFF  01,438
00E0A:  MOVFF  00,437
....................          
....................         // Update State 
....................         g_ui8ADCMeanCalState  = ADC_MEAN_CALCULATION_DONE; 
00E0E:  MOVLW  03
00E10:  MOVLB  4
00E12:  MOVWF  x36
....................     } 
00E14:  MOVLB  0
00E16:  GOTO   290C (RETURN)
.................... ////    else 
.................... ////    { 
.................... ////        // This will occur whe 
.................... ////        g_ui32ADCCurMeanValue = 0; 
.................... ////    }     
....................      
.................... } 
....................  
.................... unsigned int32 GetADCSplitAvg() 
.................... { 
....................      
.................... } 
....................  
.................... void SortADCDataQ(void) 
.................... { 
....................     unsigned int8 ui8LoopCount = 0; 
....................     unsigned int8 ui8LoopCount1 = 0; 
....................     unsigned int8 ui8CurrMaxDataCount = 0; 
....................     unsigned int32 ui32Temp = 0; 
....................      
....................     // There is no Data then return 0 
....................     if (-1 == g_stADCDataQ.m_i16Rear) 
....................     { 
....................         return ; 
....................     } 
....................     // Check the value of the Multiplier 
....................     if (g_stADCDataQ.m_ui8Multiplier) 
....................     { 
....................         ui8CurrMaxDataCount = SIZE_DATA_QUEUE; 
....................     } 
....................     else 
....................     { 
....................         ui8CurrMaxDataCount = g_stADCDataQ.m_i16Rear + 1; 
....................     } 
....................      
....................     // Loop through the array to sort ADC data..Using Bubble Sort. 
....................     for(ui8LoopCount = 0; ui8LoopCount < (ui8CurrMaxDataCount - 1); ui8LoopCount++) 
....................     { 
....................         for(ui8LoopCount1 = ui8LoopCount + 1; ui8LoopCount1 < ui8CurrMaxDataCount; ui8LoopCount1++) 
....................         { 
....................             if(g_stADCDataQ.m_ui32Arr[ui8LoopCount] > g_stADCDataQ.m_ui32Arr[ui8LoopCount1]) 
....................             { 
....................                 ui32Temp = g_stADCDataQ.m_ui32Arr[ui8LoopCount1]; 
....................                 g_stADCDataQ.m_ui32Arr[ui8LoopCount1] = g_stADCDataQ.m_ui32Arr[ui8LoopCount]; 
....................                 g_stADCDataQ.m_ui32Arr[ui8LoopCount] = ui32Temp; 
....................             } 
....................         } 
....................     }     
....................      
.................... } 
....................  
.................... unsigned int32 GetADCMeanT(void) 
.................... { 
....................     unsigned int32 ui8CountL = 0; 
....................     unsigned int32 ui8CountH = 0; 
....................     unsigned int8 ui8CurrMaxDataCount = 0; 
....................     unsigned int8 ui8LoopCount =  0; 
....................     unsigned int32 ui32DataSum = 0; 
....................      
....................     // Check the value of the Multiplier 
....................     if (g_stADCDataQ.m_ui8Multiplier) 
....................     { 
....................         ui8CurrMaxDataCount = SIZE_DATA_QUEUE; 
....................     } 
....................     else 
....................     { 
....................         ui8CurrMaxDataCount = g_stADCDataQ.m_i16Rear + 1; 
....................     } 
....................      
....................     ui8CountL = ((ui8CurrMaxDataCount * ADC_DATA_Q_VALUES_TRIMMING_PERCNTG) / 100); 
....................     ui8CountH = (ui8CurrMaxDataCount - ui8CountL); 
....................      
....................     // Get the mean Value 
....................     for (ui8LoopCount = ui8CountL; ui8LoopCount < ui8CountH; ui8LoopCount++) 
....................     { 
....................         ui32DataSum += g_stADCDataQ.m_ui32Arr[ui8LoopCount]; 
....................     } 
....................      
....................     return (ui32DataSum / (ui8CountH - ui8CountL)); 
....................      
.................... } 
....................  
.................... //unsigned int16 GetStatisticalWeight() 
.................... //{ 
.................... //    unsigned int8  ui8LoopCount         = 0; 
.................... //    unsigned int8  ui8LoopCount1        = 0; 
.................... //    unsigned int16 ui16CurMean          = GetADCMeanValue(); 
.................... //    unsigned int8  ui8CurArrLength      = 0; 
.................... //    unsigned int16 ui16TempValue        = 0; 
.................... //    unsigned int8 ui8TempIndex            = 0; 
.................... //    unsigned int16 ui16CurSmallestShift = 0; 
.................... //    unsigned int16  ui16BestMeanShiftValues = 0; 
.................... //    int16    i16DynamicErrorValue         = 0; 
.................... //    unsigned int16 ui16Temp               = 0; 
.................... //    unsigned int16 ui16prevSum        	  = 0;				  
.................... //    unsigned int32 ui32Sum      		  = 0; 
.................... //    unsigned int32 ui32Mean      		  = 0; 
.................... //    unsigned int16 ui16LoopInit           = 0;  
.................... //     
.................... //    //  
.................... //    if (SIZE_LDCDISP_VALUE != g_ui8CountLdCDValue) 
.................... //    { 
.................... //        g_ui8CountLdCDValue = g_ui8WtLdCDIdx; 
.................... //    } 
.................... //     
.................... //    do 
.................... //    { 
.................... //        // Create the Mean Shift Array. 
.................... //        for (ui8LoopCount = 0; ui8LoopCount < g_ui8CountLdCDValue; ui8LoopCount++)  
.................... //        { 
.................... //            if (ui16CurMean >= g_ui16ArrCurLdCDValue[ui8LoopCount]) 
.................... //            { 
.................... //                g_ui16ArrMeanShiftVal[ui8LoopCount].ui8MeanShiftValue = ui16CurMean - g_ui16ArrCurLdCDValue[ui8LoopCount]; 
.................... //                g_ui16ArrMeanShiftVal[ui8LoopCount].ui8ActualIndex = ui8LoopCount; 
.................... //            } 
.................... //            else 
.................... //            { 
.................... //                g_ui16ArrMeanShiftVal[ui8LoopCount].ui8MeanShiftValue = g_ui16ArrCurLdCDValue[ui8LoopCount] - ui16CurMean; 
.................... //                g_ui16ArrMeanShiftVal[ui8LoopCount].ui8ActualIndex = ui8LoopCount; 
.................... //            } 
.................... //        } 
.................... // 
.................... //		// copy mean shift array into another array for sorting. 
.................... //		memcpy(g_ui16ArrSortedMeanShiftVal, g_ui16ArrMeanShiftVal, SIZE_LDCDISP_VALUE * sizeof(ST_MEAN_SHIFT_VALUE));  
.................... //		 
.................... //        // Now Sort This Mean Difference Table 
.................... //        for (ui8LoopCount = 0; ui8LoopCount < (g_ui8CountLdCDValue - 1); ui8LoopCount++)  
.................... //        { 
.................... //            for (ui8LoopCount1 = ui8LoopCount + 1; ui8LoopCount1 < g_ui8CountLdCDValue; ui8LoopCount1++)  
.................... //            { 
.................... //                if (g_ui16ArrSortedMeanShiftVal[ui8LoopCount].ui8MeanShiftValue > g_ui16ArrSortedMeanShiftVal[ui8LoopCount1].ui8MeanShiftValue ) 
.................... //                {  
.................... //                    // For error checking of smallest number. 
.................... //                    ui8TempIndex++; 
.................... //                     
.................... //                    // Upgrade the Sort Table 
.................... //                    //g_ui8ArrSortedTemp[ui8LoopCount] = ui8LoopCount1; 
.................... //                     
.................... //                    // swaping the numbers in ascending order. 
.................... //                    ui16TempValue = g_ui16ArrSortedMeanShiftVal[ui8LoopCount1].ui8MeanShiftValue; 
.................... //                    ui8TempIndex  = g_ui16ArrSortedMeanShiftVal[ui8LoopCount1].ui8ActualIndex; 
.................... //                    g_ui16ArrSortedMeanShiftVal[ui8LoopCount1].ui8MeanShiftValue = g_ui16ArrSortedMeanShiftVal[ui8LoopCount].ui8MeanShiftValue; 
.................... //                    g_ui16ArrSortedMeanShiftVal[ui8LoopCount1].ui8ActualIndex    = g_ui16ArrSortedMeanShiftVal[ui8LoopCount].ui8ActualIndex; 
.................... //                    g_ui16ArrSortedMeanShiftVal[ui8LoopCount].ui8MeanShiftValue  = ui16TempValue; 
.................... //                    g_ui16ArrSortedMeanShiftVal[ui8LoopCount].ui8ActualIndex     = ui8TempIndex; 
.................... //                } 
.................... //            } 
.................... // 
.................... //        } 
.................... //        // Now we are having the Mean Shift sorted Array 
.................... //        // Now we will take best 30% of total fetched weights from mean shift array. 
.................... //         
.................... //        ui16BestMeanShiftValues = ((unsigned int16)g_ui8CountLdCDValue * LDCD_FILTER_MEAN);     //((unsigned int16)g_ui8CountLdCDValue) 
.................... //        ui16BestMeanShiftValues = (ui16BestMeanShiftValues / 100); 
.................... //        //ui16CurMean = g_ui16ArrCurLdCDValue[g_ui8ArrSortedTemp[0]]; 
.................... //        //ui8CurArrLength--; 
.................... //        ui16LoopInit = (SIZE_LDCDISP_VALUE - ui16BestMeanShiftValues) / 2; // We are trying to get the middle portion 
.................... //        ui16LoopInit = 0; 
.................... //        // Calculate Mean of best 30% values deviated from mean. 
.................... //        for (ui8LoopCount = ui16LoopInit; ui8LoopCount < (ui16LoopInit + ui16BestMeanShiftValues); ui8LoopCount++) 
.................... //        { 
.................... //        	// Calculate sum. 
.................... //       		ui32Sum = ui32Sum + g_ui16ArrCurLdCDValue[g_ui16ArrSortedMeanShiftVal[ui8LoopCount].ui8ActualIndex]; 
.................... //        } 
.................... //        // Calculate Mean with left sum value if any. 
.................... //    	 ui32Mean = (ui32Sum / ui16BestMeanShiftValues); 
.................... //    	 ui16CurMean = (unsigned int16) (ui32Mean & 0x00007FFF); 
.................... //           
.................... //    } while (0); // Do it once.																		 
.................... //     
.................... //    // Flush Load Cell Weighing Value Array. 
.................... //    memset (g_ui16ArrCurLdCDValue, 0, (2 * SIZE_LDCDISP_VALUE));  
.................... //    // Reset Counter. 
.................... //    g_ui8CountLdCDValue = 0; 
.................... //    g_ui8WtLdCDIdx      = 0; 
.................... //     
.................... //    // Eliminate Dynamic Error. 
.................... //    // Fetch Dynamic error value. 
.................... //    i16DynamicErrorValue = DynamicErrorCalculation(); 
.................... //     
.................... //    // Check if positive error is there or negative.//************************************************ 
.................... //    if(i16DynamicErrorValue < 0x8000) 
.................... //    { 
.................... //	    // For positive error substract dynamic error from current mean. 
.................... //    	ui16CurMean = (ui16CurMean - i16DynamicErrorValue); 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //	    // For negative error add dynamic error with current mean. 
.................... //    	ui16CurMean = ui16CurMean + (~i16DynamicErrorValue + 1); 
.................... //    } 
.................... //     
.................... //     
.................... //    // So last mean Value is the actual value. 
.................... //    return ui16CurMean; 
.................... //} 
....................  
.................... unsigned int32 GetStatisticalMean() 
.................... { 
....................      
.................... } 
....................  
.................... int16 GetCalibratedWeight(unsigned int32 ui32ADCMean) 
*
00E7C:  MOVLB  A
00E7E:  CLRF   xBC
00E80:  CLRF   xBB
00E82:  CLRF   xC0
00E84:  CLRF   xBF
00E86:  CLRF   xBE
00E88:  CLRF   xBD
00E8A:  CLRF   xC4
00E8C:  CLRF   xC3
00E8E:  CLRF   xC2
00E90:  CLRF   xC1
.................... { 
....................     int16 i16ActualWeight = 0; 
....................     int32    i32Temp = 0; 
....................     unsigned int32 ui32DiffValue = 0; 
....................      
....................     // Check Which one is greater 
....................     if (g_ui32DynamicTareADCValue > ui32ADCMean) 
00E92:  MOVF   xBA,W
00E94:  MOVLB  3
00E96:  SUBWF  xA5,W
00E98:  BTFSS  FD8.0
00E9A:  GOTO   0FB8
00E9E:  BTFSS  FD8.2
00EA0:  GOTO   0EDE
00EA4:  MOVLB  A
00EA6:  MOVF   xB9,W
00EA8:  MOVLB  3
00EAA:  SUBWF  xA4,W
00EAC:  BTFSS  FD8.0
00EAE:  GOTO   0FB8
00EB2:  BTFSS  FD8.2
00EB4:  GOTO   0EDE
00EB8:  MOVLB  A
00EBA:  MOVF   xB8,W
00EBC:  MOVLB  3
00EBE:  SUBWF  xA3,W
00EC0:  BTFSS  FD8.0
00EC2:  GOTO   0FB8
00EC6:  BTFSS  FD8.2
00EC8:  GOTO   0EDE
00ECC:  MOVF   xA2,W
00ECE:  MOVLB  A
00ED0:  SUBWF  xB7,W
00ED2:  BTFSS  FD8.0
00ED4:  BRA    0EDC
00ED6:  MOVLB  3
00ED8:  GOTO   0FB8
00EDC:  MOVLB  3
....................     { 
....................         // Should not be 
....................         ui32DiffValue = g_ui32DynamicTareADCValue - ui32ADCMean; 
00EDE:  MOVLB  A
00EE0:  MOVF   xB7,W
00EE2:  MOVLB  3
00EE4:  SUBWF  xA2,W
00EE6:  MOVLB  A
00EE8:  MOVWF  xC1
00EEA:  MOVF   xB8,W
00EEC:  MOVLB  3
00EEE:  SUBWFB xA3,W
00EF0:  MOVLB  A
00EF2:  MOVWF  xC2
00EF4:  MOVF   xB9,W
00EF6:  MOVLB  3
00EF8:  SUBWFB xA4,W
00EFA:  MOVLB  A
00EFC:  MOVWF  xC3
00EFE:  MOVF   xBA,W
00F00:  MOVLB  3
00F02:  SUBWFB xA5,W
00F04:  MOVLB  A
00F06:  MOVWF  xC4
....................         i32Temp = (int32)ui32DiffValue * (int32)g_i16LoadCellFactor; 
00F08:  MOVFF  441,00
00F0C:  MOVFF  442,01
00F10:  CLRF   02
00F12:  CLRF   03
00F14:  MOVFF  03,AC8
00F18:  MOVFF  02,AC7
00F1C:  MOVFF  442,AC6
00F20:  MOVFF  441,AC5
00F24:  MOVFF  AC4,ACC
00F28:  MOVFF  AC3,ACB
00F2C:  MOVFF  AC2,ACA
00F30:  MOVFF  AC1,AC9
00F34:  MOVFF  03,AD0
00F38:  MOVFF  02,ACF
00F3C:  MOVFF  442,ACE
00F40:  MOVFF  441,ACD
00F44:  MOVLB  0
00F46:  CALL   0E1A
00F4A:  MOVFF  03,AC0
00F4E:  MOVFF  02,ABF
00F52:  MOVFF  01,ABE
00F56:  MOVFF  00,ABD
....................         i32Temp /= 1000; 
00F5A:  BCF    FD8.1
00F5C:  MOVFF  AC0,AC8
00F60:  MOVFF  ABF,AC7
00F64:  MOVFF  ABE,AC6
00F68:  MOVFF  ABD,AC5
00F6C:  MOVLB  A
00F6E:  CLRF   xCC
00F70:  CLRF   xCB
00F72:  MOVLW  03
00F74:  MOVWF  xCA
00F76:  MOVLW  E8
00F78:  MOVWF  xC9
00F7A:  MOVLB  0
00F7C:  CALL   0CC2
00F80:  MOVFF  03,AC0
00F84:  MOVFF  02,ABF
00F88:  MOVFF  01,ABE
00F8C:  MOVFF  00,ABD
....................         i16ActualWeight = (int16)i32Temp; 
00F90:  MOVFF  ABE,ABC
00F94:  MOVFF  ABD,ABB
....................         i16ActualWeight = ~i16ActualWeight + 1; 
00F98:  MOVLB  A
00F9A:  MOVFF  ABB,AC5
00F9E:  COMF   xC5,F
00FA0:  MOVFF  ABC,AC6
00FA4:  COMF   xC6,F
00FA6:  MOVLW  01
00FA8:  ADDWF  xC5,W
00FAA:  MOVWF  xBB
00FAC:  MOVLW  00
00FAE:  ADDWFC xC6,W
00FB0:  MOVWF  xBC
....................     } 
00FB2:  GOTO   1070
00FB6:  MOVLB  3
....................     else 
....................     { 
....................         ui32DiffValue = ui32ADCMean - g_ui32DynamicTareADCValue; 
00FB8:  MOVF   xA2,W
00FBA:  MOVLB  A
00FBC:  SUBWF  xB7,W
00FBE:  MOVWF  xC1
00FC0:  MOVLB  3
00FC2:  MOVF   xA3,W
00FC4:  MOVLB  A
00FC6:  SUBWFB xB8,W
00FC8:  MOVWF  xC2
00FCA:  MOVLB  3
00FCC:  MOVF   xA4,W
00FCE:  MOVLB  A
00FD0:  SUBWFB xB9,W
00FD2:  MOVWF  xC3
00FD4:  MOVLB  3
00FD6:  MOVF   xA5,W
00FD8:  MOVLB  A
00FDA:  SUBWFB xBA,W
00FDC:  MOVWF  xC4
....................         i32Temp = (int32)ui32DiffValue * (int32)g_i16LoadCellFactor; 
00FDE:  MOVFF  441,00
00FE2:  MOVFF  442,01
00FE6:  CLRF   02
00FE8:  CLRF   03
00FEA:  MOVFF  03,AC8
00FEE:  MOVFF  02,AC7
00FF2:  MOVFF  442,AC6
00FF6:  MOVFF  441,AC5
00FFA:  MOVFF  AC4,ACC
00FFE:  MOVFF  AC3,ACB
01002:  MOVFF  AC2,ACA
01006:  MOVFF  AC1,AC9
0100A:  MOVFF  03,AD0
0100E:  MOVFF  02,ACF
01012:  MOVFF  442,ACE
01016:  MOVFF  441,ACD
0101A:  MOVLB  0
0101C:  CALL   0E1A
01020:  MOVFF  03,AC0
01024:  MOVFF  02,ABF
01028:  MOVFF  01,ABE
0102C:  MOVFF  00,ABD
....................         i32Temp /= 1000; 
01030:  BCF    FD8.1
01032:  MOVFF  AC0,AC8
01036:  MOVFF  ABF,AC7
0103A:  MOVFF  ABE,AC6
0103E:  MOVFF  ABD,AC5
01042:  MOVLB  A
01044:  CLRF   xCC
01046:  CLRF   xCB
01048:  MOVLW  03
0104A:  MOVWF  xCA
0104C:  MOVLW  E8
0104E:  MOVWF  xC9
01050:  MOVLB  0
01052:  CALL   0CC2
01056:  MOVFF  03,AC0
0105A:  MOVFF  02,ABF
0105E:  MOVFF  01,ABE
01062:  MOVFF  00,ABD
....................         i16ActualWeight = (int16)i32Temp; 
01066:  MOVFF  ABE,ABC
0106A:  MOVFF  ABD,ABB
0106E:  MOVLB  A
....................          
....................     } 
....................      
....................     return i16ActualWeight; 
01070:  MOVFF  ABB,01
01074:  MOVFF  ABC,02
01078:  MOVLB  0
0107A:  RETURN 0
.................... } 
....................  
.................... //int16 GetCalibratedWeight(unsigned int32 ui32ADCMean) 
.................... //{ 
.................... //    int16 i16ActualWeight = 0; 
.................... //    int8  i8LoopCount     = 0; 
.................... //    int16    i16Temp = 0; 
.................... //    int32    i32Temp = 0; 
.................... //    unsigned int16 ui16DiffValue = 0; 
.................... //    unsigned int16 ui16Factor = 0; // Usually 1000, just to get better value we are using scale of 100 
.................... //     
.................... //     
.................... //    //g_stCalibTable[SIZE_CALIB_TABLE]; 
.................... //    // Check if the Value falls within the Calibration Table or not 
.................... //    if (ui32ADCMean < g_stCalibTable[0].m_ui32CalibValue) 
.................... //    { 
.................... // 
.................... //        // Value is in negative range 
.................... //        ui16DiffValue = (g_stCalibTable[1].m_ui32CalibValue - g_stCalibTable[0].m_ui32CalibValue); 
.................... //        // Get the Factor 
.................... //        ui16Factor = 10000 / ui16DiffValue; 
.................... // 
.................... //        i16Temp = ((g_stCalibTable[0].m_ui32CalibValue - ui32ADCMean) * ui16Factor) -  
.................... //                  (g_stCalibTable[0].m_i16CalibPoint * 10); 
.................... //        i16ActualWeight = (int16)i16Temp/10; 
.................... //        i16ActualWeight = ~i16ActualWeight;  // As this is a negative value 
.................... //         
.................... // 
.................... // 
.................... //    } 
.................... //    if (ui32ADCMean > g_stCalibTable[SIZE_CALIB_TABLE - 1].m_ui32CalibValue) 
.................... //    { 
.................... //        // Value is greater than Calibtable range 
.................... //        ui16DiffValue = (g_stCalibTable[SIZE_CALIB_TABLE - 1].m_ui32CalibValue - g_stCalibTable[SIZE_CALIB_TABLE - 2].m_ui32CalibValue); 
.................... //        ui16Factor = 10000 / ui16DiffValue; 
.................... //         
.................... //        i32Temp = (int32)(g_stCalibTable[SIZE_CALIB_TABLE - 1].m_i16CalibPoint) * (int32)(10); 
.................... //        i32Temp += ((ui32ADCMean - g_stCalibTable[SIZE_CALIB_TABLE - 1].m_ui32CalibValue) * (int32)(ui16Factor)); 
.................... //                    
.................... //        i32Temp /= 10; 
.................... //        i16ActualWeight = (int16)i32Temp; 
.................... //         
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        // Value within Calibration Table Range 
.................... //        // Seek Table 
.................... //        for (i8LoopCount = 1; i8LoopCount < SIZE_CALIB_TABLE; i8LoopCount++) 
.................... //        { 
.................... //            if (g_stCalibTable[i8LoopCount].m_ui32CalibValue == ui32ADCMean) 
.................... //            { 
.................... //                i16ActualWeight = g_stCalibTable[i8LoopCount].m_i16CalibPoint; 
.................... //                break; 
.................... //            } 
.................... //            else if (g_stCalibTable[i8LoopCount].m_ui32CalibValue > ui32ADCMean) 
.................... //            { 
.................... //                break; 
.................... //            } 
.................... //        } 
.................... // 
.................... //        if (!i16ActualWeight) 
.................... //        { 
.................... //            // Calculate weight 
.................... //            ui16DiffValue = (g_stCalibTable[i8LoopCount].m_ui32CalibValue - g_stCalibTable[i8LoopCount - 1].m_ui32CalibValue); 
.................... //            ui16Factor = 10000/ui16DiffValue; 
.................... // 
.................... //            i32Temp  = (int32)(g_stCalibTable[i8LoopCount - 1].m_i16CalibPoint * (int32)(10)); 
.................... //            i32Temp  += ((ui32ADCMean - g_stCalibTable[i8LoopCount - 1].m_ui32CalibValue)*(int32)ui16Factor); 
.................... //            i32Temp /= 10; 
.................... //            i16ActualWeight = (int16)i32Temp; 
.................... //        } 
.................... //         
.................... //    } 
.................... //     
.................... //    return i16ActualWeight; 
.................... //} 
....................  
.................... int16 GetWeighingData(unsigned int32 ui32ADCMean) 
0107C:  MOVLB  A
0107E:  CLRF   xB0
01080:  CLRF   xAF
01082:  CLRF   xB2
01084:  CLRF   xB1
01086:  CLRF   xB4
01088:  CLRF   xB3
.................... { 
....................     int16 i16CalibratedWeight = 0; 
....................     unsigned int16 ui16TempTareWeight   = 0; 
....................     unsigned int16 ui16TempDynErrValue  = 0;     
....................      
....................     i16CalibratedWeight = GetCalibratedWeight(ui32ADCMean); 
0108A:  MOVFF  AAE,ABA
0108E:  MOVFF  AAD,AB9
01092:  MOVFF  AAC,AB8
01096:  MOVFF  AAB,AB7
0109A:  MOVLB  0
0109C:  CALL   0E7C
010A0:  MOVFF  02,AB0
010A4:  MOVFF  01,AAF
....................      
.................... ////////    // Deduct Dynamic Tare Value 
.................... ////////    ui16TempTareWeight = g_ui16DynamicTareValue; 
.................... ////////    if (g_ui16DynamicTareValue > 0x8000) 
.................... ////////    { 
.................... //////////        ui16TempTareWeight = ui16TempTareWeight << 1; 
.................... //////////        ui16TempTareWeight = ui16TempTareWeight >> 1; 
.................... ////////        ui16TempTareWeight = ~ui16TempTareWeight + 1; 
.................... ////////         
.................... ////////        i16CalibratedWeight += (int16)ui16TempTareWeight; 
.................... ////////    } 
.................... ////////    else 
.................... ////////    { 
.................... ////////        i16CalibratedWeight -= (int16)ui16TempTareWeight; 
.................... ////////    } 
....................  
.................... //AMIT 
.................... ////////    // Deduct Dynamic Error Value 
.................... ////////    ui16TempDynErrValue = (unsigned int16)g_i16DynamicErrValue; 
.................... ////////    if (g_i16DynamicErrValue > 0x8000) 
.................... ////////    { 
.................... //////////        ui16TempDynErrValue = ui16TempDynErrValue << 1; 
.................... //////////        ui16TempDynErrValue = ui16TempDynErrValue >> 1; 
.................... ////////        ui16TempDynErrValue = ~ui16TempDynErrValue + 1; 
.................... ////////         
.................... ////////        i16CalibratedWeight += (int16)ui16TempDynErrValue; 
.................... ////////    } 
.................... ////////    else 
.................... ////////    { 
.................... ////////        i16CalibratedWeight -= (int16)ui16TempDynErrValue; 
.................... ////////    } 
....................      
....................     return i16CalibratedWeight; 
010A8:  MOVLB  A
010AA:  MOVFF  AAF,01
010AE:  MOVFF  AB0,02
010B2:  MOVLB  0
010B4:  RETURN 0
.................... } 
....................  
.................... //int16 GetWeighingData(unsigned int32 ui32ADCMean) 
.................... //{ 
.................... //    int16 i16CalibratedWeight = 0; 
.................... //    unsigned int16 ui16TempTareWeight   = 0; 
.................... //    unsigned int16 ui16TempDynErrValue  = 0;     
.................... //     
.................... //    //unsigned int32 ui32ADCMean = GetADCMeanValue(); 
.................... //    i16CalibratedWeight = GetCalibratedWeight(ui32ADCMean); 
.................... //     
.................... //    // Deduct Dynamic Tare Value 
.................... //    ui16TempTareWeight = g_ui16DynamicTareValue; 
.................... //    if (g_ui16DynamicTareValue > 0x8000) 
.................... //    { 
.................... ////        ui16TempTareWeight = ui16TempTareWeight << 1; 
.................... ////        ui16TempTareWeight = ui16TempTareWeight >> 1; 
.................... //        ui16TempTareWeight = ~ui16TempTareWeight + 1; 
.................... //         
.................... //        i16CalibratedWeight += (int16)ui16TempTareWeight; 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        i16CalibratedWeight -= (int16)ui16TempTareWeight; 
.................... //    } 
.................... // 
.................... //    // Deduct Dynamic Error Value 
.................... //    ui16TempDynErrValue = (unsigned int16)g_i16DynamicErrValue; 
.................... //    if (g_i16DynamicErrValue > 0x8000) 
.................... //    { 
.................... ////        ui16TempDynErrValue = ui16TempDynErrValue << 1; 
.................... ////        ui16TempDynErrValue = ui16TempDynErrValue >> 1; 
.................... //        ui16TempDynErrValue = ~ui16TempDynErrValue + 1; 
.................... //         
.................... //        i16CalibratedWeight += (int16)ui16TempDynErrValue; 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        i16CalibratedWeight -= (int16)ui16TempDynErrValue; 
.................... //    } 
.................... //     
.................... //    return i16CalibratedWeight; 
.................... //} 
....................  
....................  
....................  
....................  
.................... void IBCSendWeighingData(int16 i16BoxWeight, unsigned int16 ui16BoxCount) 
*
0144A:  MOVLB  A
0144C:  CLRF   xB4
0144E:  CLRF   xB6
01450:  CLRF   xB5
.................... { 
....................     ST_IBC_DATA_NODE stIBCDataNode; 
....................     int8             i8LoopCount         = 0; 
....................     int16            i16AvgWeight        = 0; 
....................  
....................     // Check for Rejection in Fixed Calib Mode 
....................     if (HMI_REJECTION_FIXED_CALIB_MODE == g_fRejectionMode) 
01452:  MOVLB  3
01454:  DECFSZ xC3,W
01456:  GOTO   1466
....................     { 
....................         i16AvgWeight = g_stCurBatchInfo.m_i16AvgWeight; 
0145A:  MOVFF  3C5,AB6
0145E:  MOVFF  3C4,AB5
....................     } 
01462:  GOTO   146E
....................     else 
....................     { 
....................         i16AvgWeight = g_stAvgWtQueue.m_i16CurAvg; 
01466:  MOVFF  432,AB6
0146A:  MOVFF  431,AB5
....................     } 
....................      
....................     // Now Check if the Weight is within tolerance limit or not 
....................     if (i16BoxWeight > (i16AvgWeight + g_stCurBatchInfo.m_i16PositiveTol) ||  
....................         i16BoxWeight < (i16AvgWeight - g_stCurBatchInfo.m_i16NegativeTol)) 
0146E:  MOVF   xC6,W
01470:  MOVLB  A
01472:  ADDWF  xB5,W
01474:  MOVWF  01
01476:  MOVLB  3
01478:  MOVF   xC7,W
0147A:  MOVLB  A
0147C:  ADDWFC xB6,W
0147E:  MOVWF  03
01480:  MOVF   03,W
01482:  SUBWF  xAC,W
01484:  BTFSS  FD8.0
01486:  GOTO   149A
0148A:  BTFSS  FD8.2
0148C:  GOTO   14CC
01490:  MOVF   xAB,W
01492:  SUBWF  01,W
01494:  BTFSS  FD8.0
01496:  GOTO   14CC
0149A:  MOVLB  3
0149C:  MOVF   xC8,W
0149E:  MOVLB  A
014A0:  SUBWF  xB5,W
014A2:  MOVWF  00
014A4:  MOVLB  3
014A6:  MOVF   xC9,W
014A8:  MOVLB  A
014AA:  SUBWFB xB6,W
014AC:  MOVWF  03
014AE:  MOVFF  00,01
014B2:  MOVF   xAC,W
014B4:  SUBWF  03,W
014B6:  BTFSS  FD8.0
014B8:  GOTO   14DA
014BC:  BTFSS  FD8.2
014BE:  GOTO   14CC
014C2:  MOVF   01,W
014C4:  SUBWF  xAB,W
014C6:  BTFSC  FD8.0
014C8:  GOTO   14DA
....................     { 
....................         g_ui16RejectionStatus = BOX_REJECTED; 
014CC:  MOVLB  3
014CE:  CLRF   x9D
014D0:  CLRF   x9C
....................         // Set Rejection State ON 
....................         g_unDIState.m_stAllDIBits.m_ui1GDICn01 = BOX_REJECTED; 
014D2:  BCF    1A.4
....................     } 
014D4:  GOTO   14E4
014D8:  MOVLB  A
....................     else 
....................     { 
....................         g_ui16RejectionStatus = BOX_ACCEPTED; 
014DA:  MOVLB  3
014DC:  CLRF   x9D
014DE:  MOVLW  01
014E0:  MOVWF  x9C
....................         // Set Rejection State OFF 
....................         g_unDIState.m_stAllDIBits.m_ui1GDICn01 = BOX_ACCEPTED; 
014E2:  BSF    1A.4
....................     } 
....................      
.................... //    // Now Check if the Weight is within tolerance limit or not. 
.................... //    // The under weight and over weight rejection is also segregated here and accordingly send the status to server. 
.................... //    if (i16BoxWeight > (i16AvgWeight + g_stCurBatchInfo.m_i16PositiveTol))  
.................... //         
.................... //    { 
.................... //        g_ui16RejectionStatus = BOX_REJECTED_OVR_WT; 
.................... //        // Set Rejection State ON 
.................... //        g_unDIState.m_stAllDIBits.m_ui1GDICn01 = BOX_REJECTED_UNDR_WT; // Here under weight is used only to maintain #define value to actuate rejection DO. 
.................... //    } 
.................... //    else if(i16BoxWeight < (i16AvgWeight - g_stCurBatchInfo.m_i16NegativeTol)) 
.................... //    { 
.................... //        g_ui16RejectionStatus = BOX_REJECTED_UNDR_WT; 
.................... //        // Set Rejection State ON 
.................... //        g_unDIState.m_stAllDIBits.m_ui1GDICn01 = BOX_REJECTED_UNDR_WT; 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        g_ui16RejectionStatus = BOX_ACCEPTED; 
.................... //        // Set Rejection State OFF 
.................... //        g_unDIState.m_stAllDIBits.m_ui1GDICn01 = BOX_ACCEPTED; 
.................... //    } 
....................      
....................     // Prepare IBC Data Node 
....................     g_unIBCProdModeWtData.m_stWeighingData.m_ui16BoxCount = ui16BoxCount; 
014E4:  MOVFF  AAE,31
014E8:  MOVFF  AAD,30
....................     g_unIBCProdModeWtData.m_stWeighingData.m_ui16BoxCount <<= 1; 
014EC:  BCF    FD8.0
014EE:  RLCF   30,F
014F0:  RLCF   31,F
....................     g_unIBCProdModeWtData.m_stWeighingData.m_ui16BoxCount 
....................             = g_unIBCProdModeWtData.m_stWeighingData.m_ui16BoxCount | g_ui16RejectionStatus; 
014F2:  MOVF   x9C,W
014F4:  IORWF  30,F
014F6:  MOVF   x9D,W
014F8:  IORWF  31,F
....................      
....................     g_unIBCProdModeWtData.m_stWeighingData.m_i16BoxWeight = i16BoxWeight; 
014FA:  MOVFF  AAC,33
014FE:  MOVFF  AAB,32
....................      
....................      
.................... //    // Prepare IBC Data Node 
.................... //    g_unIBCProdModeWtData.m_stWeighingData.m_ui16BoxCount = ui16BoxCount; 
.................... //    g_unIBCProdModeWtData.m_stWeighingData.m_ui16BoxCount <<= 2; 
.................... //    g_unIBCProdModeWtData.m_stWeighingData.m_ui16BoxCount 
.................... //            = g_unIBCProdModeWtData.m_stWeighingData.m_ui16BoxCount | g_ui16RejectionStatus; 
.................... //     
.................... //    g_unIBCProdModeWtData.m_stWeighingData.m_i16BoxWeight = i16BoxWeight; 
....................      
....................     // Stuff IBC Command 
....................     stIBCDataNode.g_ui8ArrIBCData[0] = IBC_CMD_PROD_WEIGH_DATA; 
01502:  MOVLW  72
01504:  MOVLB  A
01506:  MOVWF  xAF
....................     for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
01508:  MOVLW  01
0150A:  MOVWF  xB4
0150C:  MOVF   xB4,W
0150E:  SUBLW  04
01510:  BTFSS  FD8.0
01512:  GOTO   154C
....................     { 
....................         stIBCDataNode.g_ui8ArrIBCData[i8LoopCount] = g_unIBCProdModeWtData.m_ui8Arr[i8LoopCount - 1]; 
01516:  CLRF   03
01518:  MOVF   xB4,W
0151A:  ADDLW  AF
0151C:  MOVWF  01
0151E:  MOVLW  0A
01520:  ADDWFC 03,F
01522:  MOVFF  03,AB8
01526:  MOVLW  01
01528:  SUBWF  xB4,W
0152A:  CLRF   03
0152C:  ADDLW  30
0152E:  MOVWF  FE9
01530:  MOVLW  00
01532:  ADDWFC 03,W
01534:  MOVWF  FEA
01536:  MOVFF  FEF,AB9
0153A:  MOVFF  AB8,FEA
0153E:  MOVFF  01,FE9
01542:  MOVFF  AB9,FEF
01546:  INCF   xB4,F
01548:  GOTO   150C
....................     } 
....................      
....................     // Send to IBC Insert 
....................     //InsertSendQueue(&stIBCDataNode); 
....................     InsertIBCMsgQueue(&g_stIBCSendQueue, &stIBCDataNode); 
0154C:  CLRF   xB8
0154E:  MOVLW  B5
01550:  MOVWF  xB7
01552:  MOVLW  0A
01554:  MOVWF  xBA
01556:  MOVLW  AF
01558:  MOVWF  xB9
0155A:  MOVLB  0
0155C:  CALL   112E
....................     InsertIBCMsgQueue(&g_stIBCSendQueue, &stIBCDataNode); 
01560:  MOVLB  A
01562:  CLRF   xB8
01564:  MOVLW  B5
01566:  MOVWF  xB7
01568:  MOVLW  0A
0156A:  MOVWF  xBA
0156C:  MOVLW  AF
0156E:  MOVWF  xB9
01570:  MOVLB  0
01572:  CALL   112E
01576:  GOTO   191A (RETURN)
....................     //InsertIBCMsgQueue(&g_stIBCSendQueue, &stIBCDataNode); 
.................... } 
....................  
.................... void IBCSendWtInterMidData(int16 i16BoxWeight) 
*
01322:  MOVLB  A
01324:  CLRF   xB2
01326:  CLRF   xB4
01328:  CLRF   xB3
.................... { 
....................     ST_IBC_DATA_NODE stIBCDataNode; 
....................     int8             i8LoopCount         = 0; 
....................     int16            i16AvgWeight        = 0; 
....................     
....................      
....................     // Prepare IBC Data Node 
....................     g_unIBCProdModeWtData.m_stWeighingData.m_ui16BoxCount = 0; 
0132A:  CLRF   31
0132C:  CLRF   30
....................      
....................     g_unIBCProdModeWtData.m_stWeighingData.m_i16BoxWeight = i16BoxWeight; 
0132E:  MOVFF  AAC,33
01332:  MOVFF  AAB,32
....................      
....................     // Stuff IBC Command 
....................     stIBCDataNode.g_ui8ArrIBCData[0] = IBC_CMD_PROD_INTMD_DATA; 
01336:  MOVLW  7A
01338:  MOVWF  xAD
....................     for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
0133A:  MOVLW  01
0133C:  MOVWF  xB2
0133E:  MOVF   xB2,W
01340:  SUBLW  04
01342:  BTFSS  FD8.0
01344:  GOTO   137E
....................     { 
....................         stIBCDataNode.g_ui8ArrIBCData[i8LoopCount] = g_unIBCProdModeWtData.m_ui8Arr[i8LoopCount - 1]; 
01348:  CLRF   03
0134A:  MOVF   xB2,W
0134C:  ADDLW  AD
0134E:  MOVWF  01
01350:  MOVLW  0A
01352:  ADDWFC 03,F
01354:  MOVFF  03,AB6
01358:  MOVLW  01
0135A:  SUBWF  xB2,W
0135C:  CLRF   03
0135E:  ADDLW  30
01360:  MOVWF  FE9
01362:  MOVLW  00
01364:  ADDWFC 03,W
01366:  MOVWF  FEA
01368:  MOVFF  FEF,AB7
0136C:  MOVFF  AB6,FEA
01370:  MOVFF  01,FE9
01374:  MOVFF  AB7,FEF
01378:  INCF   xB2,F
0137A:  GOTO   133E
....................     } 
....................      
....................     // Send to IBC Insert 
....................     //InsertSendQueue(&stIBCDataNode); 
....................     InsertIBCMsgQueue(&g_stIBCSendQueue, &stIBCDataNode); 
0137E:  CLRF   xB8
01380:  MOVLW  B5
01382:  MOVWF  xB7
01384:  MOVLW  0A
01386:  MOVWF  xBA
01388:  MOVLW  AD
0138A:  MOVWF  xB9
0138C:  MOVLB  0
0138E:  CALL   112E
01392:  GOTO   18BA (RETURN)
.................... } 
....................  
.................... void IBCSendTareData(unsigned int32 ui32ADCMean) 
01396:  MOVLB  A
01398:  CLRF   xB4
0139A:  CLRF   xB6
0139C:  CLRF   xB5
.................... { 
....................     ST_IBC_DATA_NODE stIBCDataNode; 
....................     int8 i8LoopCount = 0; 
....................     int16  i16TempDynTare = 0; 
....................  
....................     i16TempDynTare = GetCalibratedWeight(ui32ADCMean); 
0139E:  MOVFF  AAE,ABA
013A2:  MOVFF  AAD,AB9
013A6:  MOVFF  AAC,AB8
013AA:  MOVFF  AAB,AB7
013AE:  MOVLB  0
013B0:  CALL   0E7C
013B4:  MOVFF  02,AB6
013B8:  MOVFF  01,AB5
....................          
.................... //    // Update Dynamic Tare only if there are more than 200 data available in DataQ 
.................... //    if (ADC_MEAN_DATA_FINAL_TARE  == g_ui8ADCMeanDataState && g_stADCDataQ.m_ui8Multiplier > 0) 
.................... //    { 
.................... //        g_ui16DynamicTareValue   = i16TempDynTare; 
.................... //        g_ui32DynamicTareADCValue = ui32ADCMean; 
.................... //    } 
....................      
....................     // Update Dynamic Tare only if there are more than 200 data available in DataQ 
....................     if (g_stADCDataQ.m_ui8Multiplier > 0) 
013BC:  MOVLB  7
013BE:  MOVF   x6D,F
013C0:  BTFSC  FD8.2
013C2:  GOTO   13DE
....................     { 
....................         g_ui16DynamicTareValue   = i16TempDynTare; 
013C6:  MOVFF  AB6,3A1
013CA:  MOVFF  AB5,3A0
....................         g_ui32DynamicTareADCValue = ui32ADCMean; 
013CE:  MOVFF  AAE,3A5
013D2:  MOVFF  AAD,3A4
013D6:  MOVFF  AAC,3A3
013DA:  MOVFF  AAB,3A2
....................     } 
....................     // Prepare IBC Data Node 
....................     g_unIBCProdModeTrData.m_stTareData.m_i16Padding  = 0; 
013DE:  CLRF   35
013E0:  CLRF   34
....................     g_unIBCProdModeTrData.m_stTareData.m_i16TareData = i16TempDynTare; 
013E2:  MOVFF  AB6,37
013E6:  MOVFF  AB5,36
....................      
....................     // Stuff IBC Command 
....................     stIBCDataNode.g_ui8ArrIBCData[0] = IBC_CMD_PROD_TARE_DATA; 
013EA:  MOVLW  76
013EC:  MOVLB  A
013EE:  MOVWF  xAF
....................  
....................     for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
013F0:  MOVLW  01
013F2:  MOVWF  xB4
013F4:  MOVF   xB4,W
013F6:  SUBLW  04
013F8:  BTFSS  FD8.0
013FA:  GOTO   1434
....................     { 
....................         stIBCDataNode.g_ui8ArrIBCData[i8LoopCount] = g_unIBCProdModeTrData.m_ui8Arr[i8LoopCount - 1]; 
013FE:  CLRF   03
01400:  MOVF   xB4,W
01402:  ADDLW  AF
01404:  MOVWF  01
01406:  MOVLW  0A
01408:  ADDWFC 03,F
0140A:  MOVFF  03,AB8
0140E:  MOVLW  01
01410:  SUBWF  xB4,W
01412:  CLRF   03
01414:  ADDLW  34
01416:  MOVWF  FE9
01418:  MOVLW  00
0141A:  ADDWFC 03,W
0141C:  MOVWF  FEA
0141E:  MOVFF  FEF,AB9
01422:  MOVFF  AB8,FEA
01426:  MOVFF  01,FE9
0142A:  MOVFF  AB9,FEF
0142E:  INCF   xB4,F
01430:  GOTO   13F4
....................     } 
....................  
....................     // Send to IBC Insert 
....................     //InsertSendQueue(&stIBCDataNode); 
....................     InsertIBCMsgQueue(&g_stIBCSendQueue, &stIBCDataNode); 
01434:  CLRF   xB8
01436:  MOVLW  B5
01438:  MOVWF  xB7
0143A:  MOVLW  0A
0143C:  MOVWF  xBA
0143E:  MOVLW  AF
01440:  MOVWF  xB9
01442:  MOVLB  0
01444:  CALL   112E
01448:  RETURN 0
.................... } 
....................  
.................... //void IBCSendTareData(unsigned int32 ui32ADCMean) 
.................... //{ 
.................... //    ST_IBC_DATA_NODE stIBCDataNode; 
.................... //    int8 i8LoopCount = 0; 
.................... //    unsigned int32 ui32TempDynTare = 0; 
.................... //    // Sort the values of data queue. 
.................... //    //SortADCDataQ(); 
.................... //     
.................... //    //ui32ADCMean = GetADCMeanValue(); 
.................... //      
.................... //    ui32TempDynTare = GetCalibratedWeight(ui32ADCMean); 
.................... //         
.................... //    // Update Dynamic Tare 
.................... //    if (ADC_MEAN_DATA_FINAL_TARE  == g_ui8ADCMeanDataState) 
.................... //    { 
.................... //        g_ui16DynamicTareValue   = ui32TempDynTare; 
.................... //        g_ui32DynamicTareADCValue = ui32ADCMean; 
.................... //    } 
.................... //    // Prepare IBC Data Node 
.................... //    g_unIBCProdModeTrData.m_stTareData.m_i16Padding  = 0; 
.................... //    g_unIBCProdModeTrData.m_stTareData.m_i16TareData = ui32TempDynTare; 
.................... //     
.................... //    // Stuff IBC Command 
.................... //    stIBCDataNode.g_ui8ArrIBCData[0] = IBC_CMD_PROD_TARE_DATA; 
.................... // 
.................... //    for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //    { 
.................... //        stIBCDataNode.g_ui8ArrIBCData[i8LoopCount] = g_unIBCProdModeTrData.m_ui8Arr[i8LoopCount - 1]; 
.................... //    } 
.................... // 
.................... //    // Send to IBC Insert 
.................... //    //InsertSendQueue(&stIBCDataNode); 
.................... //    InsertIBCMsgQueue(&g_stIBCSendQueue, &stIBCDataNode); 
.................... //} 
....................  
.................... void IBCSendCalibResetData(unsigned int32 ui32ADCMean) 
*
0179C:  MOVLB  A
0179E:  CLRF   xB4
.................... { 
....................     ST_IBC_DATA_NODE stIBCDataNode; 
....................     int8 i8LoopCount = 0; 
....................      
....................     //CHANGE_RUNNING_AVG START 
....................      
....................     // 1. Send Dynamic Tare ADC Value : g_ui32DynamicTareADCValue 
....................     // 2. Send Current Dynamic Weight : ui32ADCMean 
....................      
....................     // Set dynamic tare ADC value and weight ADC value in variables. 
....................     g_unIBCResetCalibTare.m_stIBCResetCalibTare.m_ui32CalibADCForTare = g_ui32DynamicTareADCValue; 
017A0:  MOVFF  3A5,53
017A4:  MOVFF  3A4,52
017A8:  MOVFF  3A3,51
017AC:  MOVFF  3A2,50
....................     g_unIBCResetCalibWeight.m_stIBCResetCalibWeight.m_ui32CalibADCForWeight = ui32ADCMean; 
017B0:  MOVFF  AAE,57
017B4:  MOVFF  AAD,56
017B8:  MOVFF  AAC,55
017BC:  MOVFF  AAB,54
....................      
....................     // Stuff IBC Command. 
....................     // 1. Dynamic Tare ADC value. 
....................     stIBCDataNode.g_ui8ArrIBCData[0] = IBC_CMD_RESET_CALIB_POINT_TARE; 
017C0:  MOVLW  67
017C2:  MOVWF  xAF
....................     for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
017C4:  MOVLW  01
017C6:  MOVWF  xB4
017C8:  MOVF   xB4,W
017CA:  SUBLW  04
017CC:  BTFSS  FD8.0
017CE:  GOTO   1808
....................     { 
....................         stIBCDataNode.g_ui8ArrIBCData[i8LoopCount] = g_unIBCResetCalibTare.m_ui8Arr[i8LoopCount - 1]; 
017D2:  CLRF   03
017D4:  MOVF   xB4,W
017D6:  ADDLW  AF
017D8:  MOVWF  01
017DA:  MOVLW  0A
017DC:  ADDWFC 03,F
017DE:  MOVFF  03,AB6
017E2:  MOVLW  01
017E4:  SUBWF  xB4,W
017E6:  CLRF   03
017E8:  ADDLW  50
017EA:  MOVWF  FE9
017EC:  MOVLW  00
017EE:  ADDWFC 03,W
017F0:  MOVWF  FEA
017F2:  MOVFF  FEF,AB7
017F6:  MOVFF  AB6,FEA
017FA:  MOVFF  01,FE9
017FE:  MOVFF  AB7,FEF
01802:  INCF   xB4,F
01804:  GOTO   17C8
....................     } 
....................      
....................     // Insert in IBC queue. 
....................     InsertIBCMsgQueue(&g_stIBCSendQueue, &stIBCDataNode); 
01808:  CLRF   xB8
0180A:  MOVLW  B5
0180C:  MOVWF  xB7
0180E:  MOVLW  0A
01810:  MOVWF  xBA
01812:  MOVLW  AF
01814:  MOVWF  xB9
01816:  MOVLB  0
01818:  CALL   112E
....................      
....................     // 2. Current Dynamic Weight ADC value. 
....................     stIBCDataNode.g_ui8ArrIBCData[0] = IBC_CMD_RESET_CALIB_POINT_WEIGHT; 
0181C:  MOVLW  69
0181E:  MOVLB  A
01820:  MOVWF  xAF
....................     for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
01822:  MOVLW  01
01824:  MOVWF  xB4
01826:  MOVF   xB4,W
01828:  SUBLW  04
0182A:  BTFSS  FD8.0
0182C:  GOTO   1866
....................     { 
....................         stIBCDataNode.g_ui8ArrIBCData[i8LoopCount] = g_unIBCResetCalibWeight.m_ui8Arr[i8LoopCount - 1]; 
01830:  CLRF   03
01832:  MOVF   xB4,W
01834:  ADDLW  AF
01836:  MOVWF  01
01838:  MOVLW  0A
0183A:  ADDWFC 03,F
0183C:  MOVFF  03,AB6
01840:  MOVLW  01
01842:  SUBWF  xB4,W
01844:  CLRF   03
01846:  ADDLW  54
01848:  MOVWF  FE9
0184A:  MOVLW  00
0184C:  ADDWFC 03,W
0184E:  MOVWF  FEA
01850:  MOVFF  FEF,AB7
01854:  MOVFF  AB6,FEA
01858:  MOVFF  01,FE9
0185C:  MOVFF  AB7,FEF
01860:  INCF   xB4,F
01862:  GOTO   1826
....................     } 
....................      
....................     // Insert in IBC queue. 
....................     InsertIBCMsgQueue(&g_stIBCSendQueue, &stIBCDataNode); 
01866:  CLRF   xB8
01868:  MOVLW  B5
0186A:  MOVWF  xB7
0186C:  MOVLW  0A
0186E:  MOVWF  xBA
01870:  MOVLW  AF
01872:  MOVWF  xB9
01874:  MOVLB  0
01876:  CALL   112E
....................      
....................     // Reset start calibration flag. 
....................     g_fResetCalibStatus = IBC_RESET_CALIB_OFF; 
0187A:  MOVLB  3
0187C:  CLRF   xAC
0187E:  MOVLB  0
01880:  GOTO   198A (RETURN)
....................  
.................... } 
....................  
.................... //void IBCSendCalibResetData(unsigned int32 ui32ADCMean) 
.................... //{ 
.................... //    ST_IBC_DATA_NODE stIBCDataNode; 
.................... //    int8 i8LoopCount = 0; 
.................... //     
.................... //    //CHANGE_RUNNING_AVG START 
.................... //    // Sort the values of data queue. 
.................... //    //SortADCDataQ(); 
.................... //     
.................... //    //unsigned int32 ui32ADCMean = GetADCMeanT(); 
.................... //     
.................... //    //CHANGE_RUNNING_AVG END 
.................... //     
.................... //    // Update Calib Reset Value 
.................... //    g_i16CalibResetValue = GetCalibratedWeight(ui32ADCMean); 
.................... //     
.................... //    // Deduct the Dynamic Tare Value 
.................... //    g_i16CalibResetValue -= g_ui16DynamicTareValue; 
.................... //     
.................... //    // Prepare IBC Data Node 
.................... //    g_i16CalibResetSumValue += g_i16CalibResetValue; 
.................... //    g_unIBCResetCalibAck.m_stIBCResetCalibPoint.m_i16PassCount++; 
.................... //    g_unIBCResetCalibAck.m_stIBCResetCalibPoint.m_i16CalibValue = 
.................... //            (g_i16CalibResetSumValue/g_unIBCResetCalibAck.m_stIBCResetCalibPoint.m_i16PassCount); 
.................... //     
.................... //    // Calculate Calib value for particular calib pont 
.................... //    g_i32ADCSumValue += ui32ADCMean; 
.................... //    g_i32ADCAvgValue = (g_i32ADCSumValue/g_unIBCResetCalibAck.m_stIBCResetCalibPoint.m_i16PassCount); 
.................... // 
.................... //    // Stuff IBC Command 
.................... //    stIBCDataNode.g_ui8ArrIBCData[0] = IBC_CMD_RESET_CALIB_POINT_ACK; 
.................... //    for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //    { 
.................... //        stIBCDataNode.g_ui8ArrIBCData[i8LoopCount] = g_unIBCResetCalibAck.m_ui8Arr[i8LoopCount - 1]; 
.................... //    } 
.................... //     
.................... //    // Send to IBC Insert 
.................... //    //InsertSendQueue(&stIBCDataNode); 
.................... //    InsertIBCMsgQueue(&g_stIBCSendQueue, &stIBCDataNode); 
.................... //     
.................... //    if (MAX_CALIB_RESET_PASS == g_unIBCResetCalibAck.m_stIBCResetCalibPoint.m_i16PassCount) 
.................... //    { 
.................... //        // Set Dynamic Err Adjustment Value 
.................... //        g_i16DynamicErrValue = g_unIBCResetCalibAck.m_stIBCResetCalibPoint.m_i16CalibValue - 
.................... //                g_unIBCResetCalib.m_stIBCResetCalibPoint.m_i16CalibPoint; 
.................... //         
.................... // 
.................... //        // Set Dynamic Error Value to EEPROM 
.................... //        //WriteDynamicErrToEEPROM(g_i16DynamicErrValue); 
.................... // 
.................... //        // Reset all temp values 
.................... //        g_i16CalibResetSumValue     = 0; 
.................... //        g_i16CalibResetValue        = 0; 
.................... //        g_i32ADCSumValue            = 0; 
.................... //        g_i32ADCAvgValue            = 0; 
.................... //        g_ui16CalibPointEEPROM      = 0; 
.................... //        g_ui16ADCCalibValueEEPROM   = 0; 
.................... //        g_unIBCResetCalibAck.m_stIBCResetCalibPoint.m_i16CalibValue = 0; 
.................... //        g_unIBCResetCalibAck.m_stIBCResetCalibPoint.m_i16PassCount  = 0; 
.................... //         
.................... //        g_fResetCalibStatus = IBC_RESET_CALIB_OFF; 
.................... //    } 
.................... //} 
....................  
.................... void UpdateNewCalibTable(void) 
.................... { 
....................     int8  i8LoopCount = 0; 
....................     unsigned int16 ui16CalibValueEEPROM = 0; 
....................     unsigned int16 ui16CalibPointEEPROM = 0; 
....................      
....................     // Loop through the entire calibration table 
....................     for (i8LoopCount = 0; i8LoopCount < SIZE_CALIB_TABLE; i8LoopCount++) 
....................     { 
....................         // Update in RAM 
....................         g_stCalibTable[i8LoopCount].m_i16CalibPoint = g_stTempCalibTable[i8LoopCount].m_i16CalibPoint; 
....................         g_stCalibTable[i8LoopCount].m_ui32CalibValue = g_stTempCalibTable[i8LoopCount].m_ui32CalibValue; 
....................          
....................         // Update in EEPROM 
....................         ui16CalibValueEEPROM = (unsigned int16)g_stTempCalibTable[i8LoopCount].m_ui32CalibValue; 
....................         ui16CalibPointEEPROM = (unsigned int16)g_stTempCalibTable[i8LoopCount].m_i16CalibPoint; 
....................         //WriteDataToEEPROM(ui16CalibPointEEPROM, ui16CalibValueEEPROM); 
....................     } 
.................... } 
....................  
....................  
.................... void AfterADCMeanCalculationDone() 
.................... { 
....................     // Intermediate Data Send for Weight 
....................     if (ADC_MEAN_DATA_INTERMEDIATE_WEIGHT == g_ui8ADCMeanDataState) 
01884:  MOVLB  3
01886:  MOVF   x98,W
01888:  SUBLW  1F
0188A:  BTFSS  FD8.2
0188C:  GOTO   18BC
....................     { 
....................         // ADC Mean Calculation Done 
....................         g_i16CurBoxWeight = GetWeighingData(g_ui32ADCCurMeanValue); 
01890:  MOVFF  43A,AAE
01894:  MOVFF  439,AAD
01898:  MOVFF  438,AAC
0189C:  MOVFF  437,AAB
018A0:  MOVLB  0
018A2:  CALL   107C
018A6:  MOVFF  02,3C2
018AA:  MOVFF  01,3C1
....................         IBCSendWtInterMidData(g_i16CurBoxWeight); 
018AE:  MOVFF  3C2,AAC
018B2:  MOVFF  3C1,AAB
018B6:  GOTO   1322
018BA:  MOVLB  3
....................     } 
....................     // Intermediate Data Send for Tare 
....................     if (ADC_MEAN_DATA_INTERMEDIATE_TARE == g_ui8ADCMeanDataState) 
018BC:  MOVF   x98,W
018BE:  SUBLW  20
018C0:  BTFSS  FD8.2
018C2:  GOTO   18DE
....................     { 
....................         //output_toggle(PIN_OUT_DO_02); 
....................         // ADC Mean Calculation Done 
....................         IBCSendTareData(g_ui32ADCCurMeanValue); 
018C6:  MOVFF  43A,AAE
018CA:  MOVFF  439,AAD
018CE:  MOVFF  438,AAC
018D2:  MOVFF  437,AAB
018D6:  MOVLB  0
018D8:  CALL   1396
018DC:  MOVLB  3
....................         //output_toggle(PIN_OUT_DO_02); 
....................     } 
....................  
....................     // Final Weight Calculation 
....................     if (ADC_MEAN_DATA_FINAL_WEIGHT == g_ui8ADCMeanDataState) 
018DE:  MOVF   x98,W
018E0:  SUBLW  21
018E2:  BTFSS  FD8.2
018E4:  GOTO   193C
....................     { 
....................         // ADC Mean Calculation Done 
....................         // Step 3: Send Final Tare data to IBC 
....................         //output_toggle(PIN_OUT_DO_02); 
....................         g_i16CurBoxWeight = GetWeighingData(g_ui32ADCCurMeanValue); 
018E8:  MOVFF  43A,AAE
018EC:  MOVFF  439,AAD
018F0:  MOVFF  438,AAC
018F4:  MOVFF  437,AAB
018F8:  MOVLB  0
018FA:  CALL   107C
018FE:  MOVFF  02,3C2
01902:  MOVFF  01,3C1
....................         //output_toggle(PIN_OUT_DO_02); 
....................         IBCSendWeighingData(g_i16CurBoxWeight, g_ui16CurrentBoxCount); 
01906:  MOVFF  3C2,AAC
0190A:  MOVFF  3C1,AAB
0190E:  MOVFF  39B,AAE
01912:  MOVFF  39A,AAD
01916:  GOTO   144A
....................  
....................         // Step 4: Insert Last Box Data to Average Queue 
....................         InsertAvgWtQueue(g_i16CurBoxWeight); 
0191A:  MOVFF  3C2,AAC
0191E:  MOVFF  3C1,AAB
01922:  GOTO   157A
....................  
....................         // Step 5: Send Current average Weight through IBC 
....................         IBCSendProdModeAvgData(); 
01926:  GOTO   172C
....................  
....................         // Step 6: Reset ADC Data Queue 
....................         ResetADCDataQ(COLLECT_NOTHING); 
0192A:  MOVLW  05
0192C:  MOVLB  A
0192E:  MOVWF  xBF
01930:  MOVLB  0
01932:  CALL   06A4
....................  
....................         g_fWtCalculationState = FLAG_WT_CALCULATION_DONE; 
01936:  MOVLW  01
01938:  MOVLB  3
0193A:  MOVWF  x99
....................     } 
....................  
....................     // Final Tare Value Set 
....................     if (ADC_MEAN_DATA_FINAL_TARE  == g_ui8ADCMeanDataState) 
0193C:  MOVF   x98,W
0193E:  SUBLW  22
01940:  BTFSS  FD8.2
01942:  GOTO   196A
....................     { 
....................         // ADC Mean Calculation Done 
....................         IBCSendTareData(g_ui32ADCCurMeanValue); 
01946:  MOVFF  43A,AAE
0194A:  MOVFF  439,AAD
0194E:  MOVFF  438,AAC
01952:  MOVFF  437,AAB
01956:  MOVLB  0
01958:  CALL   1396
....................         ResetADCDataQ(COLLECT_NOTHING); 
0195C:  MOVLW  05
0195E:  MOVLB  A
01960:  MOVWF  xBF
01962:  MOVLB  0
01964:  CALL   06A4
01968:  MOVLB  3
....................     } 
....................      
....................     if (ADC_MEAN_DATA_CALIB_WEIGHT  == g_ui8ADCMeanDataState) 
0196A:  MOVF   x98,W
0196C:  SUBLW  23
0196E:  BTFSS  FD8.2
01970:  GOTO   1998
....................     { 
....................         // ADC Mean Calculation Done 
....................         IBCSendCalibResetData(g_ui32ADCCurMeanValue); 
01974:  MOVFF  43A,AAE
01978:  MOVFF  439,AAD
0197C:  MOVFF  438,AAC
01980:  MOVFF  437,AAB
01984:  MOVLB  0
01986:  GOTO   179C
....................         ResetADCDataQ(COLLECT_NOTHING); 
0198A:  MOVLW  05
0198C:  MOVLB  A
0198E:  MOVWF  xBF
01990:  MOVLB  0
01992:  CALL   06A4
01996:  MOVLB  3
....................     } 
....................      
....................     // Reset Flags 
....................     g_ui8ADCMeanCalState  = ADC_MEAN_CALCULATION_STOP; 
01998:  MOVLW  01
0199A:  MOVLB  4
0199C:  MOVWF  x36
....................     g_ui8ADCMeanDataState = ADC_MEAN_DATA_NOTHING; 
0199E:  MOVLW  24
019A0:  MOVLB  3
019A2:  MOVWF  x98
019A4:  MOVLB  0
019A6:  GOTO   291E (RETURN)
.................... } 
.................... #endif	/* VM_ADCMANAGER_H */ 
....................  
....................  
.................... #include "../Common/vmIBCConfig.h" 
.................... #ifndef _VI_IBC_CONFIG_H_ 
.................... #define _VI_IBC_CONFIG_H_ 
....................  
.................... #include "vmSystemConfig.h" 
.................... #include "vmCRCConfig.h" 
.................... #include "vmDigitalIOConfig.h" 
.................... //#include "ctype.h" 
.................... #include "vmPINConfig.h" 
.................... #include "vmIBCGlobal.h" 
....................  
.................... #define IBC_MSG_BYTE_COUNT                       5 
.................... #define IBC_DATA_BITS_LENGTH                     10 
.................... #define IBC_DATA_BYTES_LENGTH                    10 
.................... #define IBC_BOARD_ID                             1 
....................  
.................... #define IBC_BAUD_RATE_9600                       20 
.................... #define IBC_BAUD_RATE_19200                      21 
....................  
.................... #define T1_DIV_PRESCALE                          T1_DIV_BY_8 
.................... #define T3_DIV_PRESCALE                          T3_DIV_BY_8 
....................  
.................... #define IBC_TX_1_BT_LOAD_VALUE_9600              (0xFFFF - 0x0041 + 1) 
.................... #define IBC_TX_1_BT_LOAD_VALUE_19200             (0xFFFF - 0x0021 + 1) 
....................  
.................... #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL_9600       (0xFFFF - 0x0062 + 1) // For 9600 
.................... #define IBC_RX_BIT_TIME_T1LOAD_VAL_9600           (0xFFFF - 0x0041 + 1) // For 9600 
....................  
.................... #ifdef M1_COMM_MODULE 
....................     #define IBC_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)  // 78us Instead of 104us we load 91.2 for per bit time. 
.................... #else 
....................     #define IBC_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)//   IBC_RX_BIT_TIME_T1LOAD_VAL_9600  // 104 us 
.................... #endif 
.................... //#define IBC_RX_1_BT_CUSTOMISED_VAL_9600           (0xFFFF - 0x0031 + 1)  // Instead of 104us we load 78 us for per bit time. 
.................... #define IBC_RX_BIT_TIME_1_2_T1LOAD_VAL_9600       (0xFFFF - 0x004E + 1) 
.................... #define IBC_RX_BIT_TIME_1_3_T1LOAD_VAL_9600       (0xFFFF - 0x0051 + 1) 
.................... #define IBC_RX_BIT_TIME_1_4_T1LOAD_VAL_9600       (0xFFFF - 0x005B + 1) 
....................  
....................  
.................... #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL_19200     (0xFFFF - 0x0031 + 1) // For 19200 
.................... #define IBC_RX_BIT_TIME_T1LOAD_VAL_19200         (0xFFFF - 0x0041 + 1) // For 19200 
....................  
.................... #define SIZE_IBC_SEND_BYTE_SEGMENT                15  //1+3+8+3, 1 Start Bit, 3 Sequence Bits, 8 bits of Data and 3 Stop Bits; Total 15bits in one segment/ custised byte 
....................  
.................... #define IBC_TIMER_0_CRITICAL_ON                   0 
.................... #define IBC_TIMER_0_CRITICAL_OFF                  1 
....................  
.................... //***************************************************************************** 
.................... // Below -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
.................... typedef struct _ST_INT_BOARD_ALL_BITS 
.................... { 
....................     unsigned int8 m_ui1IBCRcvbit_0: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_1: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_2: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_3: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_4: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_5: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_6: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_7: 1; 
.................... } ST_INT_BOARD_ALL_BITS; 
....................  
.................... //typedef union _UN_INT_BOARD_BYTE_TYPE 
.................... //{ 
.................... //    unsigned int8          m_ui8Byte; 
.................... //    ST_INT_BOARD_ALL_BITS  m_stByte; 
.................... //    char				   m_chData;	 
.................... //} UN_INT_BOARD_BYTE_TYPE; 
....................  
.................... typedef struct _ST_INT_BOARD_DATA 
.................... { 
....................     char 			m_boardData[IBC_DATA_BITS_LENGTH]; 
....................     unsigned int8  	m_boardID; 
.................... } ST_INT_BOARD_DATA; 
....................  
....................  
.................... //***************************************************************************** 
.................... // Above -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Interboard Communication  RX #  From M1_COMM ********************** 
.................... //***************************************************************************** 
....................  
.................... // Below -> Multiple Baud Rate Settings. 
....................  
.................... #ifdef IBC_BOUD_RATE_1000 
....................     #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL   (0xFFFF - 0x0EA6 + 1) 
....................     #define IBC_RX_BIT_TIME_T1LOAD_VAL       (0xFFFF - 0x09C4 + 1) 
.................... #endif 
....................  
.................... #ifdef IBC_BOUD_RATE_9600 
....................     #define IBC_RX_TIME_DELAY_1_5_BIT           156  
....................     #define IBC_RX_TIME_DELAY_1_BIT             104 
....................     #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL   (0xFFFF - 0x0062 + 1) 
....................     #define IBC_RX_BIT_TIME_T1LOAD_VAL       (0xFFFF - 0x0041 + 1) 
.................... #endif 
....................  
.................... #ifdef IBC_BOUD_RATE_19200 
....................     #define IBC_RX_TIME_DELAY_1_5_VAL           78  
....................     #define IBC_RX_TIME_DELAY_1_VAL             52 
....................     #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL   (0xFFFF - 0x0031 + 1) 
....................     #define IBC_RX_BIT_TIME_T1LOAD_VAL       (0xFFFF - 0x0021 + 1) 
.................... #endif 
....................  
.................... // Above -> Multiple Baud Rate Settings. 
....................  
.................... // Initialize IBC Data Set, Should be called from main()) 
.................... //void InitIBCDataSet() 
.................... //{ 
.................... //    g_unTempRxData1.m_uiByte = 0; 
.................... //} 
....................  
.................... typedef struct _ST_IBC_RCV_BYTE_NODE 
.................... { 
....................  
....................     unsigned int8 m_ui8SeqBit0 :1; 
....................     unsigned int8 m_ui8SeqBit1 :1; 
....................     unsigned int8 m_ui8SeqBit2 :1; 
....................     unsigned int8 m_ui8Padding :5; 
....................      
....................     unsigned int8 m_ui8DataBit0 :1; 
....................     unsigned int8 m_ui8DataBit1 :1; 
....................     unsigned int8 m_ui8DataBit2 :1; 
....................     unsigned int8 m_ui8DataBit3 :1; 
....................     unsigned int8 m_ui8DataBit4 :1; 
....................     unsigned int8 m_ui8DataBit5 :1; 
....................     unsigned int8 m_ui8DataBit6 :1; 
....................     unsigned int8 m_ui8DataBit7 :1; 
.................... } ST_IBC_RCV_BYTE_NODE; 
....................  
.................... typedef union _UN_IBC_RCV_BYTE_NODE 
.................... { 
....................     ST_IBC_RCV_BYTE_NODE m_stIBCNode; 
....................     unsigned int8        m_ui8Arr[2]; 
.................... } UN_IBC_RCV_BYTE_NODE; 
....................  
....................  
....................  
.................... typedef struct _ST_IBC_DATA_NODE 
.................... { 
....................     unsigned int8 g_ui8ArrIBCData[IBC_MSG_BYTE_COUNT]; 
.................... } ST_IBC_DATA_NODE; 
....................  
.................... #define SIZE_IBC_DATA_SEND_QUEUE 15 
....................  
.................... //typedef struct _ST_IBC_DATA_SEND_QUEUE 
.................... //{ 
.................... //    ST_IBC_DATA_NODE m_stArrIBCDataNode[SIZE_IBC_DATA_SEND_QUEUE]; 
.................... //    int8             m_i8Front; 
.................... //    int8             m_i8Rear; 
.................... //} ST_IBC_DATA_SEND_QUEUE; 
....................  
.................... typedef struct _ST_IBC_MSG_QUEUE 
.................... { 
....................     ST_IBC_DATA_NODE m_stArrIBCDataNode[SIZE_IBC_DATA_SEND_QUEUE]; 
....................     int8             m_i8Front; 
....................     int8             m_i8Rear; 
.................... } ST_IBC_MSG_QUEUE; 
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... //UN_INT_BOARD_BYTE_TYPE    g_unIBCRcvData; 
.................... unsigned int8             g_ui8IBCRcvBitCount = 0; 
.................... unsigned int8             g_ui8IBCTxBitCount  = 0; 
....................  
.................... // TESTING 
.................... unsigned int8             g_ui8IBCDataToSend = 0xA5; 
.................... unsigned int8             g_fIBCCommStatus   = 0; 
....................  
.................... ST_IBC_DATA_NODE          g_stIBCRcvData; 
.................... ST_IBC_DATA_NODE          g_stIBCSendData; 
.................... unsigned int8             g_ui8ArrSendSingleMSG[IBC_MSG_BYTE_COUNT*(SIZE_IBC_SEND_BYTE_SEGMENT)] = {0}; // 
.................... unsigned int8             g_fIBCDataReceived = 0; 
....................  
.................... //ST_IBC_DATA_SEND_QUEUE    g_stIBCDataSendQueue; 
.................... unsigned int8             g_fIBCSendBusy = 0; 
.................... UN_IBC_RCV_BYTE_NODE      g_unIBCRcvByteNode; 
....................  
.................... ST_IBC_MSG_QUEUE          g_stIBCSendQueue; 
.................... ST_IBC_MSG_QUEUE          g_stIBCRcvQueue; 
....................  
.................... unsigned int8             g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... ////////// 
.................... //////////void InitializeDataSendQueue() 
.................... //////////{ 
.................... //////////    int iLoopCount1 = 0; 
.................... //////////    int iLoopCount2 = 0; 
.................... //////////    g_stIBCDataSendQueue.m_i8Front = g_stIBCDataSendQueue.m_i8Rear = -1; 
.................... //////////     
.................... //////////    for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBC_DATA_SEND_QUEUE; iLoopCount1++) 
.................... //////////    { 
.................... //////////        for (iLoopCount2 = 0; iLoopCount2 < IBC_MSG_BYTE_COUNT; iLoopCount2++) 
.................... //////////        { 
.................... //////////           g_stIBCDataSendQueue.m_stArrIBCDataNode[iLoopCount1].g_ui8ArrIBCData[iLoopCount2] = 0; 
.................... //////////        } 
.................... //////////    } 
.................... //////////} 
.................... ////////// 
.................... //////////void CopySendData(int8 i8Location, ST_IBC_DATA_NODE* pstIBCData) 
.................... //////////{ 
.................... //////////    int8 i8LoopCount = 0; 
.................... //////////     
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        g_stIBCDataSendQueue.m_stArrIBCDataNode[i8Location].g_ui8ArrIBCData[i8LoopCount] = pstIBCData->g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////    } 
.................... //////////} 
.................... ////////// 
.................... //////////void CopyFromSendQueue(int8 i8Location, ST_IBC_DATA_NODE** ppstIBCData) 
.................... //////////{ 
.................... //////////    int8 i8LoopCount = 0; 
.................... //////////     
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        *ppstIBCData->g_ui8ArrIBCData[i8LoopCount] = g_stIBCDataSendQueue.m_stArrIBCDataNode[i8Location].g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////    } 
.................... //////////} 
.................... /* Function to create Circular queue */ 
.................... //////////void InsertSendQueue(ST_IBC_DATA_NODE* pstIBCData)  
.................... //////////{ 
.................... //////////    if (!pstIBCData) 
.................... //////////    { 
.................... //////////        return; 
.................... //////////    } 
.................... //////////     
.................... //////////    if ((g_stIBCDataSendQueue.m_i8Front == 0 && g_stIBCDataSendQueue.m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1) ||  
.................... //////////            (g_stIBCDataSendQueue.m_i8Front == g_stIBCDataSendQueue.m_i8Rear + 1))  
.................... //////////    {  
.................... //////////        //printf("\nQueue is Full");  
.................... //////////        return;  
.................... //////////    } 
.................... //////////   
.................... //////////    else if (g_stIBCDataSendQueue.m_i8Front == -1) /* Insert First Element */ 
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Front = g_stIBCDataSendQueue.m_i8Rear = 0; 
.................... //////////         
.................... //////////        // Insert Data 
.................... //////////        //arr[g_stIBCDataSendQueue.m_i8Rear] = value; 
.................... //////////        CopySendData(g_stIBCDataSendQueue.m_i8Rear, pstIBCData); 
.................... //////////    }  
.................... //////////   
.................... //////////    else if (g_stIBCDataSendQueue.m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1 && g_stIBCDataSendQueue.m_i8Front != 0)  
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Rear = 0;  
.................... //////////        CopySendData(g_stIBCDataSendQueue.m_i8Rear, pstIBCData);  
.................... //////////    }  
.................... //////////   
.................... //////////    else 
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Rear++;  
.................... //////////        CopySendData(g_stIBCDataSendQueue.m_i8Rear, pstIBCData); 
.................... //////////    }  
.................... //////////}  
....................  
.................... //////////void DeleteQueue(ST_IBC_DATA_NODE* pstIBCData)  
.................... //////////{  
.................... //////////    int8 i8LoopCount = 0; 
.................... ////////// 
.................... //////////    if (g_stIBCDataSendQueue.m_i8Front == -1) 
.................... //////////    {  
.................... //////////        //printf("\nQueue is Empty");  
.................... //////////        return;  
.................... //////////    }  
.................... //////////   
.................... //////////    //int data = arr[g_stIBCDataSendQueue.m_i8Front]; 
.................... //////////    //CopyFromSendQueue(g_stIBCDataSendQueue.m_i8Front, &pstIBCData); 
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        pstIBCData->g_ui8ArrIBCData[i8LoopCount] = g_stIBCDataSendQueue.m_stArrIBCDataNode[g_stIBCDataSendQueue.m_i8Front].g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////    } 
.................... //////////     
.................... //////////    //arr[g_stIBCDataSendQueue.m_i8Front] = -1;  
.................... //////////    if (g_stIBCDataSendQueue.m_i8Front == g_stIBCDataSendQueue.m_i8Rear)  
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Front = -1;  
.................... //////////        g_stIBCDataSendQueue.m_i8Rear = -1;  
.................... //////////    }  
.................... //////////    else if (g_stIBCDataSendQueue.m_i8Front == SIZE_IBC_DATA_SEND_QUEUE-1)  
.................... //////////        g_stIBCDataSendQueue.m_i8Front = 0;  
.................... //////////    else 
.................... //////////        g_stIBCDataSendQueue.m_i8Front++;  
.................... //////////   
.................... //////////    return; 
.................... //////////}  
.................... ////////// 
.................... //////////int8 IsMSGAvailableInIBCSendQueue() 
.................... //////////{ 
.................... //////////    if (g_stIBCDataSendQueue.m_i8Front == -1) 
.................... //////////    { 
.................... //////////        return 0; 
.................... //////////    } 
.................... //////////     
.................... //////////    return 1; 
.................... //////////} 
.................... ////////// 
.................... //////////void SendIBCMSG() 
.................... //////////{ 
.................... //////////    int8          i8LoopCount    = 0; 
.................... //////////    unsigned int8 ui8Sequence    = 0; 
.................... //////////    unsigned int8 ui8TempData    = 0; 
.................... //////////     
.................... //////////    // Initialize the Send Array 
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount] = 0; 
.................... //////////    } 
.................... ////////// 
.................... //////////    // Get Node from Queue 
.................... //////////    DeleteQueue(&g_stIBCSendData); 
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        // Step 1: First Stuff 1 Start Bit 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 0] = 0;   // Start Bit Always 0 
.................... //////////         
.................... //////////        // Step 2: Now Stuff 3 bit Message Byte Sequence Number 
.................... //////////         
.................... //////////        // Stuff the 1st Sequence Bit 
.................... //////////        ui8Sequence = i8LoopCount; 
.................... //////////        ui8Sequence = ui8Sequence << 7; 
.................... //////////        ui8Sequence = ui8Sequence >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 1] = ui8Sequence; 
.................... //////////         
.................... //////////        // Stuff the 2nd Sequence Bit  
.................... //////////        ui8Sequence = i8LoopCount; 
.................... //////////        ui8Sequence = ui8Sequence << 6; 
.................... //////////        ui8Sequence = ui8Sequence >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 2] = ui8Sequence; 
.................... //////////         
.................... //////////        // Stuff the 3rd Bit 
.................... //////////        ui8Sequence = i8LoopCount; 
.................... //////////        ui8Sequence = ui8Sequence << 5; 
.................... //////////        ui8Sequence = ui8Sequence >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 3] = ui8Sequence; 
.................... //////////         
.................... //////////        // Step 3: Now Stuff 8 bit Data 
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 7; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 4] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 6; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 5] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 5; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 6] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 4; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 7] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 3; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 8] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 2; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 9] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 1; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 10] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 11] = ui8TempData; 
.................... //////////         
.................... //////////        // Step 4: Stuff three Stop Bits 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 12] = 1;  // Stop bit is 1 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 13] = 1; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 14] = 1; 
.................... //////////    } 
.................... //////////     
.................... //////////    // So message stuffing is done now start the send timer 
.................... //////////    // Initialize send counter. 
.................... //////////    g_ui8IBCTxBitCount = 0; 
.................... //////////     
.................... //////////    // TESTING Start 
.................... ////////////    g_ui8ArrSendSingleMSG[0] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[1] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[2] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[3] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[4] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[5] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[6] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[7] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[8] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[9] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[10] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[11] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[12] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[13] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[14] = 1;     
.................... //////////    // TESTING End 
.................... //////////     
.................... //////////    // Start Timer3 that handle bit by bit sending. 
.................... //////////    // Set Timer3 as per Bit Time Value. 
.................... //////////    setup_timer_3(T3_INTERNAL | T3_DIV_PRESCALE); 
.................... //////////    set_timer3(IBC_TX_1_BT_LOAD_VALUE_9600); 
.................... //////////     
.................... //////////    clear_interrupt(INT_TIMER3); 
.................... //////////    enable_interrupts(INT_TIMER3); 
.................... //////////} 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving START /////////////// 
....................  
.................... void InitializeDataQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue) 
.................... { 
....................     int iLoopCount1 = 0; 
....................     int iLoopCount2 = 0; 
....................     pstIBCMSGQueue->m_i8Front = pstIBCMSGQueue->m_i8Rear = -1; 
....................      
....................     for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBC_DATA_SEND_QUEUE; iLoopCount1++) 
....................     { 
....................         for (iLoopCount2 = 0; iLoopCount2 < IBC_MSG_BYTE_COUNT; iLoopCount2++) 
....................         { 
....................            pstIBCMSGQueue->m_stArrIBCDataNode[iLoopCount1].g_ui8ArrIBCData[iLoopCount2] = 0; 
....................         } 
....................     } 
.................... } 
....................  
.................... void CopyIBCMsg(ST_IBC_DATA_NODE* pstIBCSource, ST_IBC_DATA_NODE* pstIBCDDest) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................      
....................     for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         pstIBCDDest->g_ui8ArrIBCData[i8LoopCount] = pstIBCSource->g_ui8ArrIBCData[i8LoopCount]; 
....................     } 
.................... } 
....................  
.................... /* Function to create Circular queue */ 
.................... void InsertIBCMsgQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue, ST_IBC_DATA_NODE* pstIBCData)  
.................... { 
....................     if (!pstIBCData) 
....................     { 
....................         return; 
....................     } 
....................      
....................     if ((pstIBCMSGQueue->m_i8Front == 0 && pstIBCMSGQueue->m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1) ||  
....................             (pstIBCMSGQueue->m_i8Rear == (pstIBCMSGQueue->m_i8Front-1)%(SIZE_IBC_DATA_SEND_QUEUE-1)))  
....................     {  
....................         //printf("\nQueue is Full");  
....................         return; 
....................     } 
....................    
....................     else if (pstIBCMSGQueue->m_i8Front == -1) /* Insert First Element */ 
....................     {  
....................         pstIBCMSGQueue->m_i8Front = pstIBCMSGQueue->m_i8Rear = 0; 
....................          
....................         // Insert Data 
....................         //arr[g_stIBCDataSendQueue.m_i8Rear] = value; 
....................         CopyIBCMsg(pstIBCData, &(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else if (pstIBCMSGQueue->m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1 && pstIBCMSGQueue->m_i8Front != 0)  
....................     {  
....................         pstIBCMSGQueue->m_i8Rear = 0;  
....................         CopyIBCMsg(pstIBCData, &(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else 
....................     {  
....................         pstIBCMSGQueue->m_i8Rear++;  
....................         CopyIBCMsg(pstIBCData, &(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Rear])); 
....................     }  
.................... }  
....................  
.................... void DeleteIBCMsgQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue, ST_IBC_DATA_NODE* pstIBCData)  
.................... { 
....................     if (pstIBCMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBCMsg(&(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Front]), pstIBCData); 
....................  
....................     if (pstIBCMSGQueue->m_i8Front == pstIBCMSGQueue->m_i8Rear)  
....................     {  
....................         pstIBCMSGQueue->m_i8Front = -1;  
....................         pstIBCMSGQueue->m_i8Rear = -1;  
....................     }  
....................     else if (pstIBCMSGQueue->m_i8Front == SIZE_IBC_DATA_SEND_QUEUE-1)  
....................         pstIBCMSGQueue->m_i8Front = 0;  
....................     else 
....................         pstIBCMSGQueue->m_i8Front++;  
....................    
....................     return; 
.................... } 
....................  
....................  
.................... int8 IsMSGInIBCQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue) 
.................... { 
....................     if (pstIBCMSGQueue->m_i8Front == -1) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................     return 1; 
.................... } 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving END ///////////////// 
.................... void SendIBCMSGFromQ() 
.................... { 
....................     int8          i8LoopCount    = 0; 
....................     unsigned int8 ui8Sequence    = 0; 
....................     unsigned int8 ui8TempData    = 0; 
....................  
....................     // Initialize the Send Array 
....................     for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount] = 0; 
....................     } 
....................  
....................     // Get Node from Queue 
....................     DeleteIBCMsgQueue(&g_stIBCSendQueue, &g_stIBCSendData); 
....................     for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         // Step 1: First Stuff 1 Start Bit 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 0] = 0;   // Start Bit Always 0 
....................          
....................         // Step 2: Now Stuff 3 bit Message Byte Sequence Number 
....................          
....................         // Stuff the 1st Sequence Bit 
....................         ui8Sequence = i8LoopCount; 
....................         ui8Sequence = ui8Sequence << 7; 
....................         ui8Sequence = ui8Sequence >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 1] = ui8Sequence; 
....................          
....................         // Stuff the 2nd Sequence Bit  
....................         ui8Sequence = i8LoopCount; 
....................         ui8Sequence = ui8Sequence << 6; 
....................         ui8Sequence = ui8Sequence >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 2] = ui8Sequence; 
....................          
....................         // Stuff the 3rd Bit 
....................         ui8Sequence = i8LoopCount; 
....................         ui8Sequence = ui8Sequence << 5; 
....................         ui8Sequence = ui8Sequence >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 3] = ui8Sequence; 
....................          
....................         // Step 3: Now Stuff 8 bit Data 
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 7; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 4] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 6; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 5] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 5; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 6] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 4; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 7] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 3; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 8] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 2; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 9] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 1; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 10] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 11] = ui8TempData; 
....................          
....................         // Step 4: Stuff three Stop Bits 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 12] = 1;  // Stop bit is 1 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 13] = 1; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 14] = 1; 
....................          
.................... ////////        // TESTING Start 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 0] = 0;   
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 1] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 2] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 3] = 1;  
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 4] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 5] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 6] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 7] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 8] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 9] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 10] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 11] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 12] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 13] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 14] = 1; 
.................... ////////        // TESTING End 
....................     } 
....................      
....................      
.................... ////    // TESTING Start 
.................... ////    g_ui8ArrSendSingleMSG[0] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[1] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[2] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[3] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[4] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[5] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[6] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[7] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[8] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[9] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[10] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[11] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[12] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[13] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[14] = 1;     
.................... ////    // TESTING End 
....................          
....................     // So message stuffing is done now start the send timer 
....................     // Initialize send counter. 
....................     g_ui8IBCTxBitCount = 0; 
....................      
....................     // Hold the IBC Send Lock 
....................     g_fIBCSendLockStatus = IBC_SEND_LOCK; 
....................     // Start Timer3 that handle bit by bit sending. 
....................     // Set Timer3 as per Bit Time Value. 
....................     setup_timer_3(T3_INTERNAL | T3_DIV_PRESCALE); 
....................     set_timer3(IBC_TX_1_BT_LOAD_VALUE_9600); 
....................      
....................     // Before Sending Data in IBC Run Timer0 in Time Critical. This we are doing 
....................     // just because we have seen the IBC Send Receive is affecting while Timer 0 
....................     // is executing, hence the IBC data send receive is not sampled at proper time 
....................     g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_ON; 
....................      
....................     clear_interrupt(INT_TIMER3); 
....................     enable_interrupts(INT_TIMER3); 
.................... } 
....................  
.................... void IBCProcessRcvMsg() 
.................... { 
....................     // I 
.................... } 
....................  
.................... #INT_TIMER3    // Used for IBC Send 
.................... void IBC_Tx_ISR(void) 
.................... { 
....................     // Send IBC bits 
....................     output_bit(PIN_IBC_XMIT, g_ui8ArrSendSingleMSG[g_ui8IBCTxBitCount++]); 
....................     // Reset Timer3 at 1Bit Time value. 
....................     set_timer3(IBC_TX_1_BT_LOAD_VALUE_9600); 
....................     clear_interrupt( INT_TIMER3 ); 
....................  
....................     // Check if IBC Sending completed 
....................     if ((IBC_MSG_BYTE_COUNT*SIZE_IBC_SEND_BYTE_SEGMENT) == g_ui8IBCTxBitCount) 
....................     { 
....................         // First release Timer0 Critical run lock 
....................         g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
....................          
....................         // Release Send Busy status 
....................         g_fIBCSendBusy     = 0; 
....................          
....................         // Send Stop bit forever 
....................         output_bit(PIN_IBC_XMIT, 1); 
....................  
....................         // Reset Tx counter 
....................         g_ui8IBCTxBitCount = 0; 
....................         // Reset IBC Send checking status flag. 
....................         //g_fIBCCommStatus = 0; 
....................         // Disable Timer 
....................         setup_timer_3 (T3_DISABLED); 
....................         disable_interrupts(INT_TIMER3); 
....................         // Clear Timer1 interrupt 
....................         clear_interrupt(INT_TIMER3); 
....................          
....................         // Release IBC Send Lock 
....................         g_fIBCSendLockStatus = IBC_SEND_UNLOCK; 
....................     } 
....................      
....................     // TESTING 
....................     //output_toggle(PIN_IN_EXT_DI_00); 
....................   
.................... } 
....................  
....................  
....................  
.................... /* 
....................     Timer1 is used to handle IBC Received bytes. 
....................  and Timer3 is used to handle IBC sent bytes. 
....................  */ 
.................... #ifdef M1_COMM_MODULE 
.................... #INT_EXT1  
.................... #else 
.................... #INT_EXT3 
.................... #endif 
.................... void IBC_Rx_ISR(void) 
.................... { 
....................    
....................     // Initialize Rx Bit Counter. 
....................    	g_ui8IBCRcvBitCount = 0; 
....................     g_unIBCRcvByteNode.m_ui8Arr[0] = 0; 
....................     g_unIBCRcvByteNode.m_ui8Arr[1] = 0; 
....................    	 
....................     // Setup Timer1 at 1.5 Bit Time.                   // Here we are using DIV_BY_8. 
....................     setup_timer_1( T1_INTERNAL | T1_DIV_PRESCALE ); // CPU Ext Clock is 20MHz, 20/4 => 5MHz is Peripheral Clock 
....................                                                 // => T1_DIV_BY_2 => 5/2 = 2.5MHz => (1/2.5)us = 0.4us 
....................                                                 // To Get 1Ms quanta = (1000us/0.4) = 2500 => 0x09C4 
....................                                                 // So, The timer will start counting from (0xFFFF - 0x09C4 + 1) 
....................                                                 // To Get 1.5Ms quanta = (1500us/0.4) = 3750 => 0x0EA6 
....................                                                 // So, The timer will start counting from (0xFFFF - 0x0EA6 + 1)  
....................      
.................... #ifdef M1_COMM_MODULE 
....................     set_timer1( IBC_RX_BIT_TIME_1_4_T1LOAD_VAL_9600);  
.................... #else 
....................     set_timer1( IBC_RX_BIT_TIME_1_5_T1LOAD_VAL_9600); 
.................... #endif 
....................      
....................     // Before Sending Data in IBC Run Timer0 in Time Critical. This we are doing 
....................     // just because we have seen the IBC Send Receive is affecting while Timer 0 
....................     // is executing, hence the IBC data send receive is not sampled at proper time 
....................     g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_ON; 
....................      
....................     clear_interrupt( INT_TIMER1 ); 
....................     enable_interrupts( INT_TIMER1 ); 
....................      
....................     // Clear and Disable External Interrupt 1  
.................... #ifdef M1_COMM_MODULE 
....................     clear_interrupt(INT_EXT1); 
....................     disable_interrupts(INT_EXT1);  
.................... #else 
....................     clear_interrupt(INT_EXT3); 
....................     disable_interrupts(INT_EXT3); 
.................... #endif 
....................      
....................     // TESTING Start 
.................... #ifdef M1_COMM_MODULE 
....................     //output_high(PIN_IN_EXT_DI_00); 
.................... #endif 
....................     // TESTING End 
.................... } 
....................  
.................... // TESTING Start 
.................... int8 g_i8RcvByteCount = 0; 
.................... // TESTING End 
....................  
.................... #INT_TIMER1           // This is for Receive                 
.................... void IBC_Rx_Sampling_ISR(void) 
.................... {  
.................... ////////    // TESTING Start 
.................... ////////#ifdef M1_COMM_MODULE 
.................... ////////    //output_toggle(PIN_IN_EXT_DI_00); 
.................... ////////#else 
.................... ////////    output_toggle(PIN_A5); 
.................... ////////#endif 
.................... ////////    // TESTING End 
....................      
....................     // Increment Rx Bit Counter for each received bit. 
....................    	g_ui8IBCRcvBitCount++; 
.................... 	 
....................     // Check Rx Bit Counter and read Bits 
....................     switch(g_ui8IBCRcvBitCount) 
....................     { 
....................         case 1: // Sequence Bit 0  
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8SeqBit0 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 2: // Sequence Bit 1 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8SeqBit1 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 3: // Sequence Bit 2 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8SeqBit2 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 4: // Data Bit Bit 0 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit0 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 5: // Bit 4 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit1 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 6: // Bit 5 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit2 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 7: // Bit 6 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit3 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 8: // Bit 7 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit4 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................          	set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................          	clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................              
....................              
....................         case 9: // Bit 8 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit5 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_1_BT_CUSTOMISED_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 10: // Bit 9 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit6 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_1_BT_CUSTOMISED_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 11: // Bit 10 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit7 = input(PIN_IBC_RCV); 
....................              
....................             // We have received all data so now we can release Timer0 Critical Run 
....................             g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
....................              
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_1_BT_CUSTOMISED_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................              
....................         case 12: // STOP Bit 
....................             // Check if the Stop Bit is High. 
....................             if(1 == input(PIN_IBC_RCV)) // Stop bit detected 
....................             { 
....................                 // Byte received successfully 
....................                 // Save received byte to the Message Array 1 
....................                 //g_arruiIBCRxMsg1[g_uiIBCRxByteCount1 - 1] = g_unTempRxData1.m_uiByte; 
....................             } 
....................             else 
....................             {  
....................                 // Handle error. 
....................                 // Framing error. 
....................                 // Set Flag tracking Framing Error. 
....................                 //g_uiIBCRxFramingErr1 = 1; 
....................                 //g_uiIBCSTXReceived1  = 0; 
....................             } 
....................             // Disable Timer1. 
....................             setup_timer_1 (T1_DISABLED); 
....................             disable_interrupts(INT_TIMER1);  
....................             // Clear Timer1 interrupt. 
....................             clear_interrupt(INT_TIMER1);  
....................   
....................              
....................             g_i8RcvByteCount++; 
....................             if (5 == g_i8RcvByteCount) 
....................             { 
....................                 g_i8RcvByteCount = 0; 
....................             } 
....................             // Now check the Byte Sequence 
....................             g_stIBCRcvData.g_ui8ArrIBCData[g_unIBCRcvByteNode.m_ui8Arr[0]] = g_unIBCRcvByteNode.m_ui8Arr[1]; 
....................              
....................             if ((IBC_MSG_BYTE_COUNT - 1) == g_unIBCRcvByteNode.m_ui8Arr[0]) 
....................             { 
....................                 // The complete 5 byte data has been received 
....................                 // Now we can process the data 
....................                 g_fIBCDataReceived = 1; 
....................                  
....................                 // Insert Message into IBC Receive Queue 
.................... ////////                InsertIBCMsgQueue(&g_stIBCRcvQueue, &g_stIBCRcvData);   
....................             } 
....................             // Reset Rx Bit Counter. 
....................             g_ui8IBCRcvBitCount = 0; 
....................              
....................             // Enable External Interrupt to detect next byte. 
.................... #ifdef M1_COMM_MODULE 
....................             ext_int_edge(1, H_TO_L);  
....................             clear_interrupt(INT_EXT1); 
....................             enable_interrupts(INT_EXT1); 
.................... #else 
....................             ext_int_edge(3, H_TO_L);  
....................             clear_interrupt(INT_EXT3); 
....................             enable_interrupts(INT_EXT3); 
.................... #endif 
....................             break; 
....................  
....................         default: 
....................             // Framing error. 
....................             // Set Flag tracking Framing Error. 
....................             //g_uiIBCRxFramingErr1 = 1; 
....................              
....................             // First release Timer0 Critical run lock 
....................             g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
....................              
....................             // Disable Timer1. 
....................             setup_timer_1 (T1_DISABLED); 
....................             disable_interrupts(INT_TIMER1);  
....................             // Clear Timer1 interrupt. 
....................             clear_interrupt(INT_TIMER1);  
....................              
....................             // Reset Rx Bit Counter 1. 
....................             g_ui8IBCRcvBitCount = 0; 
....................              
....................             // Enable External Interrupt 0 to detect next start bit. 
....................             ext_int_edge(1, H_TO_L);  
....................             clear_interrupt(INT_EXT1); 
....................             enable_interrupts(INT_EXT1); 
....................             break; 
....................     } 
....................      
.................... } 
....................  
....................  
....................  
.................... #endif /* _VI_IBC_CONFIG_H_ */ 
....................  
....................  
....................  
....................  
.................... #define T0_DIV_PRESCALE                 RTCC_DIV_8 
.................... #define TIMER_0_VALUE_LOAD_FOR_1MS      (0xFFFF - 0x0271 + 1) 
.................... #define ALL_TIMER_TEST_VAL_FOR_100_US   (0xFFFF - 0x003F + 1) 
.................... #define ALL_TIMER_TEST_VAL_FOR_70_US    (0xFFFF - 0x002C + 1) 
....................  
....................  
.................... #define FLAG_DI_STATE_NOT_CHANGED    1 
.................... #define FLAG_DI_STATE_CHANGED        0 
.................... #define ADC_READ_ON                  10 
.................... #define ADC_READ_OFF                 11 
....................  
.................... //#define DELAY_PUSHER               400 
.................... //#define DELAY_CAN_STPR_1           2000 
.................... //#define DELAY_CAN_PUSHER_1_TIMER_2 500 
.................... //#define DELAY_START_CAN_PLACER     20 
.................... #define DELAY_INTRMDAT_DATA_SEND     300 
.................... #define DELAY_REJECT_PUSHER_BACK     1000 
.................... #define PUSHER_DELAY_START_ON          0 
.................... #define PUSHER_DELAY_START_OFF         1 
....................  
.................... #define BOX_LEFT_DELAY_START           0 
.................... #define BOX_LEFT_DELAY_END             1 
.................... #define AFTER_BOX_LEFT_DELAY_TIME      500 
....................  
.................... // TESTING Start 
.................... #define DELAY_GET_ADC_DATA           500 
.................... unsigned int16 g_uiCountSendADCData = 0; 
.................... // TESTING End 
....................  
....................  
.................... unsigned int8  g_fDIChangeState =  FLAG_DI_STATE_NOT_CHANGED; 
.................... unsigned int8  g_fADCCurrState  =  ADC_READ_OFF; 
.................... unsigned int16 g_ui16IntmidDataSendTikCount = 0; 
.................... unsigned int16 g_uiPusherDelayTikCount      = 0; 
.................... int8 g_fPusherDelayStatus = PUSHER_DELAY_START_OFF; 
.................... int8 g_fRejectPusherPrevState = 1; 
.................... //unsigned int8  g_fBeforeHomeStateDelayStatus = BOX_LEFT_DELAY_END; 
.................... unsigned int16  g_ui16AfterBoxLeftDelayTimeCounter = 0; 
....................  
.................... //***************************************************************************** 
.................... // Below -> 1MS Timer Initialization Functions ******************************** 
.................... //***************************************************************************** 
.................... // Init Polling Timer. 
.................... void InitDigitalIOPollingTimer(void) 
.................... { 
....................     // Setup Timer0 at 1 ms Time. 
....................     setup_timer_0( RTCC_INTERNAL | T0_DIV_PRESCALE ); 
*
00C56:  MOVLW  82
00C58:  MOVWF  FD5
....................     set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS );  // TODO => Need to change the value load in timer 
00C5A:  MOVLW  FD
00C5C:  MOVWF  FD7
00C5E:  MOVLW  8F
00C60:  MOVWF  FD6
....................     // Enable Timer0. 
....................     clear_interrupt( INT_TIMER0 ); 
00C62:  BCF    FF2.2
....................     enable_interrupts( INT_TIMER0 ); 
00C64:  BSF    FF2.5
00C66:  GOTO   28C8 (RETURN)
.................... } 
....................  
.................... //////// TESTING Start 
.................... //////void InitTIMER1(void) 
.................... //////{ 
.................... //////     // Setup Timer0 at 1 ms Time. 
.................... //////    setup_timer_1( T1_INTERNAL | T1_DIV_BY_8 ); 
.................... //////    set_timer0( ALL_TIMER_TEST_VAL_FOR_70_US ); 
.................... //////    // Enable Timer0. 
.................... //////    clear_interrupt( INT_TIMER1 ); 
.................... //////    enable_interrupts( INT_TIMER1 ); 
.................... //////} 
.................... ////// 
.................... //////void InitTIMER3(void) 
.................... //////{ 
.................... //////     // Setup Timer0 at 1 ms Time. 
.................... //////    setup_timer_3( T3_INTERNAL | T3_DIV_BY_8 ); 
.................... //////    set_timer0( ALL_TIMER_TEST_VAL_FOR_70_US ); 
.................... //////    // Enable Timer0. 
.................... //////    clear_interrupt( INT_TIMER3 ); 
.................... //////    enable_interrupts( INT_TIMER3 ); 
.................... //////} 
.................... ////// 
.................... //////// TESTING End. 
.................... //***************************************************************************** 
.................... // Above -> 1MS Timer Initialization Functions ******************************** 
.................... //***************************************************************************** 
....................  
.................... //void ExecuteALLDOs(void) 
.................... //{ 
.................... //    delay_us(10); 
.................... //    output_bit(PIN_OUT_DO_00, g_unDOCurrState.m_stAllDOBits.m_ui1HWDOCn00); 
.................... //    output_bit(PIN_OUT_DO_01, g_unDOCurrState.m_stAllDOBits.m_ui1HWDOCn01); 
.................... //    output_bit(PIN_OUT_DO_02, g_unDOCurrState.m_stAllDOBits.m_ui1HWDOCn02); 
.................... //    output_bit(PIN_OUT_DO_03, g_unDOCurrState.m_stAllDOBits.m_ui1HWDOCn03); 
.................... //    output_bit(PIN_OUT_DO_04, g_unDOCurrState.m_stAllDOBits.m_ui1HWDOCn04); 
.................... //    output_bit(PIN_OUT_DO_05, g_unDOCurrState.m_stAllDOBits.m_ui1HWDOCn05); 
.................... //    output_bit(PIN_OUT_DO_06, g_unDOCurrState.m_stAllDOBits.m_ui1HWDOCn06); 
.................... //    output_bit(PIN_OUT_DO_07, g_unDOCurrState.m_stAllDOBits.m_ui1HWDOCn07);    
.................... //} 
....................  
....................       
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> 1MS Timer Implementation ****************************************** 
.................... //***************************************************************************** 
....................  
.................... #INT_TIMER0 
.................... void DigitalIOPolling_isr(void) 
.................... { 
....................     //output_high(PIN_OUT_DO_02); 
....................     if (g_fIgnore_TIMER == TIMER_IGNORE_ON) 
*
003BC:  MOVLB  4
003BE:  DECFSZ x35,W
003C0:  GOTO   03C8
....................     { 
....................         return; 
003C4:  GOTO   05B2
....................     } 
.................... ////////    if (IBC_TIMER_0_CRITICAL_ON == g_ui8fTimer0State) 
.................... ////////    { 
.................... ////////        // Reset Timer0. 
.................... ////////        set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS ); 
.................... ////////        clear_interrupt( INT_TIMER0 ); 
.................... ////////         
.................... ////////        return; 
.................... ////////    }     
....................     // Step 3: Check if the ADC is ready with data or not 
....................     // Check if ADC is ready 
....................     if (ADC_SCAN_ON == g_ui8ADCScanningStatus && ADC_DATA_READY == g_fADCDataReadyStatus) 
003C8:  DECFSZ x43,W
003CA:  GOTO   042E
003CE:  DECFSZ x49,W
003D0:  GOTO   042E
....................     { 
....................         // Increment the Counter 
....................         g_stADCDataQ.m_i16Rear++; 
003D4:  MOVLB  7
003D6:  INCF   x6B,F
003D8:  BTFSC  FD8.2
003DA:  INCF   x6C,F
....................         if (g_stADCDataQ.m_i16Rear >= SIZE_DATA_QUEUE) 
003DC:  MOVF   x6C,F
003DE:  BTFSS  FD8.2
003E0:  GOTO   03EE
003E4:  MOVF   x6B,W
003E6:  SUBLW  C7
003E8:  BTFSC  FD8.0
003EA:  GOTO   03F6
....................         { 
....................             g_stADCDataQ.m_i16Rear       = 0; 
003EE:  CLRF   x6C
003F0:  CLRF   x6B
....................             g_stADCDataQ.m_ui8Multiplier = 1; 
003F2:  MOVLW  01
003F4:  MOVWF  x6D
....................         } 
....................  
....................         g_stADCDataQ.m_ui32Arr[g_stADCDataQ.m_i16Rear] = g_ui32ADCValue; 
003F6:  RLCF   x6B,W
003F8:  MOVWF  02
003FA:  RLCF   x6C,W
003FC:  MOVWF  03
003FE:  RLCF   02,F
00400:  RLCF   03,F
00402:  MOVLW  FC
00404:  ANDWF  02,F
00406:  MOVF   02,W
00408:  ADDLW  4B
0040A:  MOVWF  FE9
0040C:  MOVLW  04
0040E:  ADDWFC 03,W
00410:  MOVWF  FEA
00412:  MOVFF  444,FEF
00416:  MOVFF  445,FEC
0041A:  MOVFF  446,FEC
0041E:  MOVFF  447,FEC
....................  
....................         // Reset Temp ADC Variable 
....................         g_ui32ADCValue = 0; 
00422:  MOVLB  4
00424:  CLRF   x47
00426:  CLRF   x46
00428:  CLRF   x45
0042A:  CLRF   x44
....................         // Reset Data Ready Status 
....................         g_fADCDataReadyStatus = ADC_DATA_NOT_READY; 
0042C:  CLRF   x49
....................     } 
....................      
....................     // Check for Box after box left delay status. 
....................     if(BOX_LEFT_DELAY_START == g_unDIState.m_stAllDIBits.m_ui1GDICn03) 
0042E:  BTFSC  1A.2
00430:  GOTO   0460
....................     { 
....................         // Delay time count start. 
....................         if(++g_ui16AfterBoxLeftDelayTimeCounter >= AFTER_BOX_LEFT_DELAY_TIME) 
00434:  MOVLB  7
00436:  INCF   x83,F
00438:  BTFSC  FD8.2
0043A:  INCF   x84,F
0043C:  MOVF   x84,W
0043E:  SUBLW  00
00440:  BTFSC  FD8.0
00442:  GOTO   045E
00446:  XORLW  FF
00448:  BTFSS  FD8.2
0044A:  GOTO   0458
0044E:  MOVF   x83,W
00450:  SUBLW  F3
00452:  BTFSC  FD8.0
00454:  GOTO   045E
....................         { 
....................             // Reset counter. 
....................             g_ui16AfterBoxLeftDelayTimeCounter = 0; 
00458:  CLRF   x84
0045A:  CLRF   x83
....................              
....................             // Update flag status. 
....................             g_unDIState.m_stAllDIBits.m_ui1GDICn03 = BOX_LEFT_DELAY_END; 
0045C:  BSF    1A.2
0045E:  MOVLB  4
....................              
....................         } 
....................     } 
....................      
....................     if (IBC_TIMER_0_CRITICAL_ON == g_ui8fTimer0State) 
00460:  MOVLB  1
00462:  MOVF   x4F,F
00464:  BTFSS  FD8.2
00466:  GOTO   047C
....................     { 
....................         // Reset Timer0. 
....................         set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS ); 
0046A:  MOVLW  FD
0046C:  MOVWF  FD7
0046E:  MOVLW  8F
00470:  MOVWF  FD6
....................         clear_interrupt( INT_TIMER0 ); 
00472:  BCF    FF2.2
....................          
....................         return; 
00474:  MOVLB  4
00476:  GOTO   05B2
0047A:  MOVLB  1
....................     } 
....................     // ############################### Non Critical ############################### 
....................      
....................     // Digital Input (DI) Polling Start 
....................     g_unDIState.m_stAllDIBits.m_ui1HWDICn00 = input(PIN_IN_DI_00); 
0047C:  BSF    F95.4
0047E:  BCF    1C.7
00480:  BTFSC  F83.4
00482:  BSF    1C.7
....................     g_unDIState.m_stAllDIBits.m_ui1HWDICn01 = input(PIN_IN_DI_01); 
00484:  BSF    F93.0
00486:  BCF    1C.6
00488:  BTFSC  F81.0
0048A:  BSF    1C.6
....................     g_unDIState.m_stAllDIBits.m_ui1HWDICn02 = 1;//input(PIN_IN_DI_02); 
0048C:  BSF    1C.5
....................     g_unDIState.m_stAllDIBits.m_ui1HWDICn03 = input(PIN_IN_DI_03); 
0048E:  BSF    F93.2
00490:  BCF    1C.4
00492:  BTFSC  F81.2
00494:  BSF    1C.4
....................     g_unDIState.m_stAllDIBits.m_ui1HWDICn04 = input(PIN_IN_DI_04); 
00496:  BSF    F93.4
00498:  BCF    1C.3
0049A:  BTFSC  F81.4
0049C:  BSF    1C.3
....................     g_unDIState.m_stAllDIBits.m_ui1HWDICn05 = 1; //input(PIN_IN_DI_05); 
0049E:  BSF    1C.2
....................     g_unDIState.m_stAllDIBits.m_ui1HWDICn06 = 1; //input(PIN_IN_DI_06); 
004A0:  BSF    1C.1
....................     g_unDIState.m_stAllDIBits.m_ui1HWDICn07 = 1; //input(PIN_IN_DI_07); 
004A2:  BSF    1C.0
....................  
....................     // TESTING Start 
....................     //g_unDIState.m_stAllDIBits.m_ui1HWDICn05 = 1; 
....................     // TESTING End 
....................  
....................     // Step 2: Check for any state change 
....................     // Check ALL DI States Changes and all DO State Changes 
....................     if (g_unDIState.m_ui32AllDIs == g_ui32AllDIsPreviousState && 
....................         g_unDOState.m_ui16AllDOs == g_ui32AllDOsPreviousState) 
004A4:  MOVF   x52,W
004A6:  SUBWF  19,W
004A8:  BTFSS  FD8.2
004AA:  GOTO   04E6
004AE:  MOVF   x53,W
004B0:  SUBWF  1A,W
004B2:  BTFSS  FD8.2
004B4:  GOTO   04E6
004B8:  MOVF   x54,W
004BA:  SUBWF  1B,W
004BC:  BTFSS  FD8.2
004BE:  GOTO   04E6
004C2:  MOVF   x55,W
004C4:  SUBWF  1C,W
004C6:  BTFSS  FD8.2
004C8:  GOTO   04E6
004CC:  MOVF   x58,W
004CE:  SUBWF  1D,W
004D0:  BTFSS  FD8.2
004D2:  GOTO   04E6
004D6:  MOVF   x59,W
004D8:  SUBWF  1E,W
004DA:  BTFSS  FD8.2
004DC:  GOTO   04E6
....................     { 
....................         g_uiStateChange = FLAG_STATE_NOT_CHANGED; 
004E0:  CLRF   x5E
....................     } 
004E2:  GOTO   051E
....................     else 
....................     { 
....................         // Change in DO state noticed 
....................         if(g_unDOState.m_ui16AllDOs != g_ui32AllDOsPreviousState) 
004E6:  MOVF   x58,W
004E8:  SUBWF  1D,W
004EA:  BTFSS  FD8.2
004EC:  GOTO   04FA
004F0:  MOVF   x59,W
004F2:  SUBWF  1E,W
004F4:  BTFSC  FD8.2
004F6:  GOTO   0502
....................         { 
....................             // Execute all DOs 
....................             ExecuteALLDOs(); 
004FA:  MOVLB  0
004FC:  GOTO   032A
00500:  MOVLB  1
....................         } 
....................          
....................         g_uiStateChange = FLAG_STATE_CHANGED; 
00502:  MOVLW  01
00504:  MOVWF  x5E
....................         g_ui32AllDIsPreviousState = g_unDIState.m_ui32AllDIs; 
00506:  MOVFF  1C,155
0050A:  MOVFF  1B,154
0050E:  MOVFF  1A,153
00512:  MOVFF  19,152
....................         g_ui32AllDOsPreviousState = g_unDOState.m_ui16AllDOs; 
00516:  MOVFF  1E,159
0051A:  MOVFF  1D,158
....................     } 
....................  
....................  
....................  
....................  
....................     //---------------------------------------------------- 
....................     // Extra Timers Start 
....................     //---------------------------------------------------- 
....................     if (COLLECT_DYNAMIC_TARE_DATA == g_stADCDataQ.m_i8CollectionState || 
....................         COLLECT_WEIGHING_DATA     == g_stADCDataQ.m_i8CollectionState) 
0051E:  MOVLB  7
00520:  MOVF   x72,W
00522:  SUBLW  03
00524:  BTFSC  FD8.2
00526:  GOTO   0534
0052A:  MOVF   x72,W
0052C:  SUBLW  04
0052E:  BTFSS  FD8.2
00530:  GOTO   0572
....................     { 
....................         // Increment tick count 
....................         if (g_ui16IntmidDataSendTikCount++ >= DELAY_INTRMDAT_DATA_SEND) 
00534:  MOVFF  77E,03
00538:  MOVF   x7D,W
0053A:  INCF   x7D,F
0053C:  BTFSC  FD8.2
0053E:  INCF   x7E,F
00540:  MOVLB  A
00542:  MOVWF  xD7
00544:  MOVF   03,W
00546:  MOVWF  xD8
00548:  SUBLW  00
0054A:  BTFSC  FD8.0
0054C:  GOTO   0570
00550:  XORLW  FF
00552:  BTFSS  FD8.2
00554:  GOTO   0562
00558:  MOVF   xD7,W
0055A:  SUBLW  2B
0055C:  BTFSC  FD8.0
0055E:  GOTO   0570
....................         { 
....................             // Reset Counter 
....................             g_ui16IntmidDataSendTikCount = 0; 
00562:  MOVLB  7
00564:  CLRF   x7E
00566:  CLRF   x7D
....................  
....................             g_fIntermediateDataSend = IBC_INTERMEDIATE_DATA_SEND_ON;  
00568:  MOVLW  01
0056A:  MOVLB  3
0056C:  MOVWF  x9F
0056E:  MOVLB  A
00570:  MOVLB  7
....................         } 
....................     } 
....................     //---------------------------------------------------- 
....................     // Extra Timers End 
....................     //----------------------------------------------------     
....................  
....................     if (PUSHER_DELAY_START_ON == g_fPusherDelayStatus) 
00572:  MOVF   x81,F
00574:  BTFSS  FD8.2
00576:  GOTO   05A6
....................     { 
....................         g_uiPusherDelayTikCount++; 
0057A:  INCF   x7F,F
0057C:  BTFSC  FD8.2
0057E:  INCF   x80,F
....................         if (g_uiPusherDelayTikCount >= DELAY_REJECT_PUSHER_BACK) 
00580:  MOVF   x80,W
00582:  SUBLW  02
00584:  BTFSC  FD8.0
00586:  GOTO   05A6
0058A:  XORLW  FF
0058C:  BTFSS  FD8.2
0058E:  GOTO   059C
00592:  MOVF   x7F,W
00594:  SUBLW  E7
00596:  BTFSC  FD8.0
00598:  GOTO   05A6
....................         { 
....................             g_uiPusherDelayTikCount = 0; 
0059C:  CLRF   x80
0059E:  CLRF   x7F
....................             g_unDIState.m_stAllDIBits.m_ui1GDICn02 = 0; 
005A0:  BCF    1A.3
....................             //g_unDOState.m_stAllDOBits.m_ui1HWDOCn01 = 1; 
....................              
....................             g_fPusherDelayStatus = PUSHER_DELAY_START_OFF; 
005A2:  MOVLW  01
005A4:  MOVWF  x81
....................         } 
....................     } 
....................      
....................     //TESTING 
....................     //output_toggle(PIN_OUT_DO_03); 
....................      
....................     // Reset Timer0. 
....................     set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS );  // TODO =>  
005A6:  MOVLW  FD
005A8:  MOVWF  FD7
005AA:  MOVLW  8F
005AC:  MOVWF  FD6
....................     clear_interrupt( INT_TIMER0 ); 
005AE:  BCF    FF2.2
005B0:  MOVLB  4
.................... } 
....................  
....................  
.................... //////// TESTING Start 
.................... //////#INT_TIMER1 
.................... //////void timer_1_isr(void) 
.................... //////{ 
.................... //////    output_toggle(PIN_OUT_DO_04); 
.................... //////     
.................... //////     // Reset Timer1. 
.................... //////    set_timer1( ALL_TIMER_TEST_VAL_FOR_70_US ); 
.................... //////    clear_interrupt( INT_TIMER1 ); 
.................... //////} 
.................... ////// 
.................... ////// 
.................... //////#INT_TIMER3 
.................... //////void timer_3_isr(void) 
.................... //////{ 
.................... //////    output_toggle(PIN_OUT_DO_05); 
.................... //////     
.................... //////     // Reset Timer1. 
.................... //////    set_timer3( ALL_TIMER_TEST_VAL_FOR_70_US ); 
.................... //////    clear_interrupt( INT_TIMER3 ); 
.................... //////} 
.................... ////// //TESTING End 
....................  
....................  
.................... //***************************************************************************** 
.................... // Above -> 1MS Timer Implementation ****************************************** 
.................... //***************************************************************************** 
....................  
.................... #endif /* _VM_TIMER_CONFIG_H_ */ 
....................  
....................  
.................... #include "vmStateMachine_0.h" 
.................... #ifndef _VM_STATE_MACHINE_0_H_ 
.................... #define _VM_STATE_MACHINE_0_H_ 
....................  
.................... /*************************** Inclusion files **********************************/ 
.................... #include "vmSystemConfig.h" 
....................  
.................... #ifndef _VI_SYSTEM_CONFIG_H_ 
.................... #define _VI_SYSTEM_CONFIG_H_ 
....................  
.................... //****************** Inclusion Files *************************** 
.................... #include "18F46K80.h" 
.................... #include "vmPINConfig.h" 
....................  
.................... //****************** Component Configuration ******************** 
....................  
.................... //optimization level. 
.................... #pragma opt 8 
....................   
.................... //********* CPU Settings ******************************************* 
....................  
.................... #pragma device HIGH_INTS=TRUE 
.................... #pragma fuses NOPLLEN,ECH,WDT1024,NOPROTECT,NOBROWNOUT,NOFCMEN,NOIESO,NOPUT /* WDT1024 => 1024 * 4 ms = 4096 mS Watchdog Timer */ /* For Field Mode */ 
....................  
.................... #pragma use delay(clock=20000000,restart_wdt) 
....................  
....................  
.................... //******** Serial Interface ************ 
.................... //#pragma use rs232(stream=RS485, xmit=PIN_RS485_XMIT, rcv=PIN_RS485_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
.................... #pragma use rs232(stream=ARD_RS232, xmit=PIN_LAN_COMM_XMIT, rcv=PIN_LAN_COMM_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
....................  
.................... //#define unsigned int8 BYTE 
.................... #ifndef M0_ADC_MODULE 
.................... #define M0_ADC_MODULE 1 
.................... #endif 
....................  
.................... #endif /* _VI_SYSTEM_CONFIG_H_ */ 
....................  
.................... #include "vmStateMachineForIMW_M0.h" 
.................... #ifndef _VM_STATE_MACHINE_FOR_IMW_M0_H_ 
.................... #define _VM_STATE_MACHINE_FOR_IMW_M0_H_ 
....................  
.................... #include "vmSystemConfig.h" 
.................... #include "vmStateMachine.h" 
....................  
.................... #define STPR_1_EMPTY_ON              0 
.................... #define STPR_1_EMPTY_OFF             1 
.................... #define STPR_0_SET_TRANSFERED_ON     0 
.................... #define STPR_0_SET_TRANSFERED_OFF    1 
.................... #define STPR_1_SET_TRANSFERED_ON     0 
.................... #define STPR_1_SET_TRANSFERED_OFF    1 
.................... #define STPR_1_CAN_SET_COUNT_DONE    0 
.................... #define STPR_1_CAN_SET_COUNT_NOT_DONE 1 
.................... #define PUSHER_EMPTY_ON              0 
.................... #define PUSHER_EMPTY_OFF             1 
.................... #define PUSHER_0_TIME_OUT_ON         0 
.................... #define PUSHER_0_TIME_OUT_OFF        1 
.................... #define PUSHER_0_ALL_DONE            0 
.................... #define PUSHER_0_ALL_NOT_DONE        1 
.................... #define PUSHER_1_TIME_OUT_ON         0 
.................... #define PUSHER_1_TIME_OUT_OFF        1 
.................... #define PUSHER_1_ALL_DONE            0 
.................... #define PUSHER_1_ALL_NOT_DONE        1 
.................... #define STACKER_READY_ON             0 
.................... #define STACKER_READY_OFF            1 
.................... #define PUSHER_0_FIRST_PUSH_ON       0 
.................... #define PUSHER_0_FIRST_PUSH_OFF      1 
.................... #define PUSHER_1_FIRST_PUSH_ON       0 
.................... #define PUSHER_1_FIRST_PUSH_OFF      1 
....................  
....................  
.................... #define SPCL_FLAG_SM_1_START_TRANSFER_OFF 0 
.................... #define SPCL_FLAG_SM_1_START_TRANSFER_ON  1 
....................  
....................  
.................... #define NO_OF_ACTIVE_MACHINE        2 
....................  
.................... #define INITAIL_DI_STATE_ON_PWR_ON   0xFFFF3F5F 
.................... #define INITAIL_DO_STATE_ON_PWR_ON   0x3FFF 
.................... #define SAFE_MODE_DO_STATE           0x3FFF 
.................... #define PRE_PRODUCTION_DO_STATE      0xBFFF 
....................  
.................... //////////////////// State Machine 0 DI DO States Start //////////////////////// 
.................... #define 	STATE_SM0_HWDI_FILTER	0xD0000010 
.................... #define 	STATE_SM0_HWDI_01	0xD0000010 
.................... #define 	STATE_SM0_HWDI_02	0x50000010 
.................... #define 	STATE_SM0_HWDI_03	0x10000010 
.................... #define 	STATE_SM0_HWDI_04	0x90000010 
.................... #define 	STATE_SM0_HWDI_05	0xD0000010 
.................... #define 	STATE_SM0_HWDI_06	0x80000010 
.................... #define 	STATE_SM0_HWDI_07	0xC0000010 
.................... #define 	STATE_SM0_HWDI_08	0xD0000010 
.................... #define 	STATE_SM0_HWDI_09	0xD0000000 
.................... #define 	STATE_SM0_HWDI_10	0xD0000010 
....................  
.................... #define 	STATE_SM0_HWDO_FILTER	0x8000 
.................... #define 	STATE_SM0_HWDO_01	0x8000 
.................... #define 	STATE_SM0_HWDO_02	0x8000 
.................... #define 	STATE_SM0_HWDO_03	0x0000 
.................... #define 	STATE_SM0_HWDO_04	0x0000 
.................... #define 	STATE_SM0_HWDO_05	0x0000 
.................... #define 	STATE_SM0_HWDO_06	0x0000 
.................... #define 	STATE_SM0_HWDO_07	0x0000 
.................... #define 	STATE_SM0_HWDO_08	0x0000 
.................... #define 	STATE_SM0_HWDO_09	0x0000 
.................... #define 	STATE_SM0_HWDO_10	0x8000 
....................  
....................  
.................... //////////////////// State Machine 0 DI DO States End ////////////////////////// 
....................  
.................... //////////////////// State Machine 1 DI DO States Start //////////////////////// 
.................... #define 	STATE_SM1_HWDI_FILTER	0x08001800 
.................... #define 	STATE_SM1_HWDI_01	0x08000800 
.................... #define 	STATE_SM1_HWDI_02	0x00000800 
.................... #define 	STATE_SM1_HWDI_03	0x00001800 
.................... #define 	STATE_SM1_HWDI_04	0x08000000 
....................  
.................... #define 	STATE_SM1_HWDO_FILTER	0x4000 
.................... #define 	STATE_SM1_HWDO_01	0x4000 
.................... #define 	STATE_SM1_HWDO_02	0x0000 
.................... #define 	STATE_SM1_HWDO_03	0x4000 
.................... #define 	STATE_SM1_HWDO_04	0x4000 
....................  
.................... //#define 	STATE_SM1_HWDI_FILTER	0x0C001800 
.................... //#define 	STATE_SM1_HWDI_01	0x0C000800 
.................... //#define 	STATE_SM1_HWDI_02	0x08000800 
.................... //#define 	STATE_SM1_HWDI_03	0x04000800 
.................... //#define 	STATE_SM1_HWDI_04	0x04001800 
.................... //#define 	STATE_SM1_HWDI_05	0x00000800 
.................... //#define 	STATE_SM1_HWDI_06	0x0C000000 
.................... // 
.................... //#define 	STATE_SM1_HWDO_FILTER	0x4000 
.................... //#define 	STATE_SM1_HWDO_01	0x4000 
.................... //#define 	STATE_SM1_HWDO_02	0x4000 
.................... //#define 	STATE_SM1_HWDO_03	0x0000 
.................... //#define 	STATE_SM1_HWDO_04	0x4000 
.................... //#define 	STATE_SM1_HWDO_05	0x4000 
.................... //#define 	STATE_SM1_HWDO_06	0x4000 
.................... //////////////////// State Machine 1 DI DO States End ////////////////////////// 
....................  
.................... ST_STATE_MACHINE g_stArrStateMachines[NO_OF_ACTIVE_MACHINE]; 
....................  
.................... unsigned int8 g_fStateMac1StartCanTransfer = SPCL_FLAG_SM_1_START_TRANSFER_ON; 
....................  
....................  
....................  
.................... //void InitializeStateMachines() 
.................... //{ 
....................     //g_unDIState.m_ui32AllDIs = 0xFFFFFFFF; 
....................     //g_unDOState.m_ui16AllDOs = 0xFFFF; 
.................... //} 
.................... /* 
.................... // 01 : Home State 
.................... unsigned int8 StateFunc_GenericState(int8 i8StateMachine, int8 i8State) 
.................... { 
....................     // Take action 
....................     // Main intention is to not change values of other DO fields, except the fields under the state DO Filter 
....................     // Also only the changes will added to the original ALL DOs  
....................     unsigned int16 ui16Temp0 = 0; 
....................     unsigned int16 ui16Temp1 = 0; 
....................     //g_unAllDOs.m_ui16AllDOs = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState; 
....................      
....................     // Hold the Current DO Values to temp 
....................     ui16Temp0 = g_unDOState.m_ui16AllDOs; 
....................  
....................     // Bitwise AND with the State DO Filter with the Value to change 
....................     ui16Temp1 = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState & 
....................                 g_stArrStateMachines[i8StateMachine].m_ui16StateDOFilter; 
....................      
....................     // Finally Bitwise OR operation between original value to the temp 
....................     g_unDOState.m_ui16AllDOs = ui16Temp0 | ui16Temp1; 
....................  
....................     return 0; 
.................... }  
.................... */ 
.................... unsigned int8 StateFunc_GenericState_(int8 i8StateMachine, int8 i8State) 
.................... { 
....................  
....................         unsigned int16 ui8DO       = g_unDOState.m_ui16AllDOs; 
....................         unsigned int16 ui8Filter   = g_stArrStateMachines[i8StateMachine].m_ui16StateDOFilter; 
....................         unsigned int16 ui8Value    = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState; 
....................         unsigned int16 ui8BitValue = 0; 
....................          
....................         for(int i = 0; i < 16; i++) 
....................         { 
....................             if(1 == ((ui8Filter >> i)&0x0001)) 
....................             { 
....................                 ui8BitValue = ((ui8Value >> i)&0x0001); 
....................                 ui8DO = (ui8DO & (~(1 << i))) | (ui8BitValue << i); 
....................             } 
....................         } 
....................  
....................     g_unDOState.m_ui16AllDOs = ui8DO; 
....................     return 0; 
.................... }  
....................  
.................... unsigned int8 StateFunc_GenericState(int8 i8StateMachine, int8 i8State) 
.................... { 
....................     UN_ALL_DOS unFilter; 
....................     UN_ALL_DOS unValue; 
....................      
....................     unFilter.m_ui16AllDOs = g_stArrStateMachines[i8StateMachine].m_ui16StateDOFilter; 
....................     unValue.m_ui16AllDOs  = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState; 
....................      
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn00) g_unDOState.m_stAllDOBits.m_ui1HWDOCn00 = unValue.m_stAllDOBits.m_ui1HWDOCn00; 
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn01) g_unDOState.m_stAllDOBits.m_ui1HWDOCn01 = unValue.m_stAllDOBits.m_ui1HWDOCn01; 
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn02) g_unDOState.m_stAllDOBits.m_ui1HWDOCn02 = unValue.m_stAllDOBits.m_ui1HWDOCn02; 
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn03) g_unDOState.m_stAllDOBits.m_ui1HWDOCn03 = unValue.m_stAllDOBits.m_ui1HWDOCn03; 
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn04) g_unDOState.m_stAllDOBits.m_ui1HWDOCn04 = unValue.m_stAllDOBits.m_ui1HWDOCn04; 
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn05) g_unDOState.m_stAllDOBits.m_ui1HWDOCn05 = unValue.m_stAllDOBits.m_ui1HWDOCn05; 
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn06) g_unDOState.m_stAllDOBits.m_ui1HWDOCn06 = unValue.m_stAllDOBits.m_ui1HWDOCn06; 
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn07) g_unDOState.m_stAllDOBits.m_ui1HWDOCn07 = unValue.m_stAllDOBits.m_ui1HWDOCn07; 
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn00) g_unDOState.m_stAllDOBits.m_ui1SRDOCn00 = unValue.m_stAllDOBits.m_ui1SRDOCn00; 
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn01) g_unDOState.m_stAllDOBits.m_ui1SRDOCn01 = unValue.m_stAllDOBits.m_ui1SRDOCn01; 
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn02) g_unDOState.m_stAllDOBits.m_ui1SRDOCn02 = unValue.m_stAllDOBits.m_ui1SRDOCn02; 
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn03) g_unDOState.m_stAllDOBits.m_ui1SRDOCn03 = unValue.m_stAllDOBits.m_ui1SRDOCn03; 
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn04) g_unDOState.m_stAllDOBits.m_ui1SRDOCn04 = unValue.m_stAllDOBits.m_ui1SRDOCn04; 
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn05) g_unDOState.m_stAllDOBits.m_ui1SRDOCn05 = unValue.m_stAllDOBits.m_ui1SRDOCn05; 
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn06) g_unDOState.m_stAllDOBits.m_ui1SRDOCn06 = unValue.m_stAllDOBits.m_ui1SRDOCn06; 
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn07) g_unDOState.m_stAllDOBits.m_ui1SRDOCn07 = unValue.m_stAllDOBits.m_ui1SRDOCn07; 
....................      
.................... }     
....................  
....................          
....................  
....................          
.................... // 02: Start to Pick 
.................... unsigned int8 StateFunc_State02() 
.................... { 
....................     // We got message from outer board that Stacker Ready and Hopper Ready 
....................     // Now PD will start moving downword 
....................     //g_unAllDOs.m_bArr[2] = 1; 
....................     //g_unAllDOs.m_bArr[3] = 0; 
....................     // Expected Next State Declaration 
....................     g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[0] = STATE_03; 
....................     g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[1] = STATE_03; 
....................     g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[2] = STATE_03; 
....................     g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[3] = STATE_03; 
....................     return 0; 
.................... } 
....................  
....................  
.................... void InitExpNextStateDefault() 
.................... { 
....................     int8 i8StMcCount = 0; 
....................     int8 i8StCount   = 0; 
....................     int8 i8ExpNxtCount = 0; 
....................     for (i8StMcCount = 0; i8StMcCount < NO_OF_ACTIVE_MACHINE; i8StMcCount++) 
....................     { 
....................         // For all Active Look up tables 
....................         for (i8StCount = 0; i8StCount < MAX_NUMBER_OF_STATE; i8StCount++) 
....................         { 
....................             for (i8ExpNxtCount = 0; i8ExpNxtCount < MAX_NO_OF_EXP_NXT_STATES; i8ExpNxtCount++) 
....................             { 
....................                 g_stArrStateMachines[i8StMcCount].m_stArrStateLookupTable[i8StCount].m_i8ArrExpNextState[i8ExpNxtCount] = STATE_NOTHING; 
....................             } 
....................         } 
....................     } 
.................... } 
....................  
.................... void PostProductionSafeMode() 
.................... { 
....................     g_unDOState.m_ui16AllDOs = 0xFFFF; 
....................      
....................     // 1. Stopper 0 is in Push State 
....................     // 2. Can Stopper 1 is in Push state 
....................     // 3. Pusher 0, Pusher 1 and Can Guide all is in drag state 
....................     g_unDOState.m_ui16AllDOs = SAFE_MODE_DO_STATE; 
....................     ExecuteALLDOs(); 
.................... } 
....................  
.................... void PowerOnDOStateInit() 
.................... { 
....................     g_unDOState.m_ui16AllDOs = 0xFFFF; 
....................      
....................     // 1. Stopper 0 is in drag State 
....................     // 2. Can Stopper 1 is in Push state 
....................     // 3. Pusher 0, Pusher 1 and Can Guide all is in drag state 
....................     g_unDOState.m_ui16AllDOs = INITAIL_DO_STATE_ON_PWR_ON; 
....................     ExecuteALLDOs(); 
.................... } 
....................  
.................... #endif /* _VI_STATE_MACHINE_FOR_CP_H_ */ 
....................  
....................  
.................... //#include "vmSystemConfig.h" 
.................... ////#include "vmStateMachine.h" 
.................... // 
.................... //#define STPR_1_EMPTY_ON              0 
.................... //#define STPR_1_EMPTY_OFF             1 
.................... //#define STPR_0_SET_TRANSFERED_ON     0 
.................... //#define STPR_0_SET_TRANSFERED_OFF    1 
.................... //#define STPR_1_SET_TRANSFERED_ON     0 
.................... //#define STPR_1_SET_TRANSFERED_OFF    1 
.................... //#define STPR_1_CAN_SET_COUNT_DONE    0 
.................... //#define STPR_1_CAN_SET_COUNT_NOT_DONE 1 
.................... //#define PUSHER_EMPTY_ON              0 
.................... //#define PUSHER_EMPTY_OFF             1 
.................... //#define PUSHER_0_TIME_OUT_ON         0 
.................... //#define PUSHER_0_TIME_OUT_OFF        1 
.................... //#define PUSHER_0_ALL_DONE            0 
.................... //#define PUSHER_0_ALL_NOT_DONE        1 
.................... //#define PUSHER_1_TIME_OUT_ON         0 
.................... //#define PUSHER_1_TIME_OUT_OFF        1 
.................... //#define PUSHER_1_ALL_DONE            0 
.................... //#define PUSHER_1_ALL_NOT_DONE        1 
.................... //#define STACKER_READY_ON             0 
.................... //#define STACKER_READY_OFF            1 
.................... //#define PUSHER_0_FIRST_PUSH_ON       0 
.................... //#define PUSHER_0_FIRST_PUSH_OFF      1 
.................... //#define PUSHER_1_FIRST_PUSH_ON       0 
.................... //#define PUSHER_1_FIRST_PUSH_OFF      1 
.................... // 
.................... // 
.................... //#define SPCL_FLAG_SM_1_START_TRANSFER_OFF 0 
.................... //#define SPCL_FLAG_SM_1_START_TRANSFER_ON  1 
.................... // 
.................... // 
.................... //#define NO_OF_ACTIVE_MACHINE        5 
.................... // 
.................... //#define INITAIL_DI_STATE_ON_PWR_ON   0xFFFF3F5F 
.................... //#define INITAIL_DO_STATE_ON_PWR_ON   0x3FFF 
.................... //#define SAFE_MODE_DO_STATE           0x3FFF 
.................... //#define PRE_PRODUCTION_DO_STATE      0xBFFF 
.................... // 
.................... //ST_STATE_MACHINE g_stArrStateMachines[NO_OF_ACTIVE_MACHINE]; 
.................... // 
.................... //unsigned int8 g_fStateMac1StartCanTransfer = SPCL_FLAG_SM_1_START_TRANSFER_ON; 
.................... // 
.................... // 
.................... // 
.................... ////void InitializeStateMachines() 
.................... ////{ 
.................... //    //g_unDIState.m_ui32AllDIs = 0xFFFFFFFF; 
.................... //    //g_unDOState.m_ui16AllDOs = 0xFFFF; 
.................... ////} 
.................... ///* 
.................... //// 01 : Home State 
.................... //unsigned int8 StateFunc_GenericState(int8 i8StateMachine, int8 i8State) 
.................... //{ 
.................... //    // Take action 
.................... //    // Main intention is to not change values of other DO fields, except the fields under the state DO Filter 
.................... //    // Also only the changes will added to the original ALL DOs  
.................... //    unsigned int16 ui16Temp0 = 0; 
.................... //    unsigned int16 ui16Temp1 = 0; 
.................... //    //g_unAllDOs.m_ui16AllDOs = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState; 
.................... //     
.................... //    // Hold the Current DO Values to temp 
.................... //    ui16Temp0 = g_unDOState.m_ui16AllDOs; 
.................... // 
.................... //    // Bitwise AND with the State DO Filter with the Value to change 
.................... //    ui16Temp1 = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState & 
.................... //                g_stArrStateMachines[i8StateMachine].m_ui16StateDOFilter; 
.................... //     
.................... //    // Finally Bitwise OR operation between original value to the temp 
.................... //    g_unDOState.m_ui16AllDOs = ui16Temp0 | ui16Temp1; 
.................... // 
.................... //    return 0; 
.................... //}  
.................... //*/ 
.................... //unsigned int8 StateFunc_GenericState_(int8 i8StateMachine, int8 i8State) 
.................... //{ 
.................... // 
.................... ////        unsigned int16 ui8DO       = g_unDOState.m_ui16AllDOs; 
.................... ////        unsigned int16 ui8Filter   = g_stArrStateMachines[i8StateMachine].m_ui16StateDOFilter; 
.................... ////        unsigned int16 ui8Value    = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState; 
.................... ////        unsigned int16 ui8BitValue = 0; 
.................... ////         
.................... ////        for(int i = 0; i < 16; i++) 
.................... ////        { 
.................... ////            if(1 == ((ui8Filter >> i)&0x0001)) 
.................... ////            { 
.................... ////                ui8BitValue = ((ui8Value >> i)&0x0001); 
.................... ////                ui8DO = (ui8DO & (~(1 << i))) | (ui8BitValue << i); 
.................... ////            } 
.................... ////        } 
.................... //// 
.................... ////    g_unDOState.m_ui16AllDOs = ui8DO; 
.................... ////    return 0; 
.................... //}  
.................... // 
.................... //unsigned int8 StateFunc_GenericState(int8 i8StateMachine, int8 i8State) 
.................... //{ 
.................... ////    UN_ALL_DOS unFilter; 
.................... ////    UN_ALL_DOS unValue; 
.................... ////     
.................... ////    unFilter.m_ui16AllDOs = g_stArrStateMachines[i8StateMachine].m_ui16StateDOFilter; 
.................... ////    unValue.m_ui16AllDOs  = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState; 
.................... ////     
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn00) g_unDOState.m_stAllDOBits.m_ui1HWDOCn00 = unValue.m_stAllDOBits.m_ui1HWDOCn00; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn01) g_unDOState.m_stAllDOBits.m_ui1HWDOCn01 = unValue.m_stAllDOBits.m_ui1HWDOCn01; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn02) g_unDOState.m_stAllDOBits.m_ui1HWDOCn02 = unValue.m_stAllDOBits.m_ui1HWDOCn02; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn03) g_unDOState.m_stAllDOBits.m_ui1HWDOCn03 = unValue.m_stAllDOBits.m_ui1HWDOCn03; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn04) g_unDOState.m_stAllDOBits.m_ui1HWDOCn04 = unValue.m_stAllDOBits.m_ui1HWDOCn04; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn05) g_unDOState.m_stAllDOBits.m_ui1HWDOCn05 = unValue.m_stAllDOBits.m_ui1HWDOCn05; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn06) g_unDOState.m_stAllDOBits.m_ui1HWDOCn06 = unValue.m_stAllDOBits.m_ui1HWDOCn06; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn07) g_unDOState.m_stAllDOBits.m_ui1HWDOCn07 = unValue.m_stAllDOBits.m_ui1HWDOCn07; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn00) g_unDOState.m_stAllDOBits.m_ui1SRDOCn00 = unValue.m_stAllDOBits.m_ui1SRDOCn00; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn01) g_unDOState.m_stAllDOBits.m_ui1SRDOCn01 = unValue.m_stAllDOBits.m_ui1SRDOCn01; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn02) g_unDOState.m_stAllDOBits.m_ui1SRDOCn02 = unValue.m_stAllDOBits.m_ui1SRDOCn02; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn03) g_unDOState.m_stAllDOBits.m_ui1SRDOCn03 = unValue.m_stAllDOBits.m_ui1SRDOCn03; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn04) g_unDOState.m_stAllDOBits.m_ui1SRDOCn04 = unValue.m_stAllDOBits.m_ui1SRDOCn04; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn05) g_unDOState.m_stAllDOBits.m_ui1SRDOCn05 = unValue.m_stAllDOBits.m_ui1SRDOCn05; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn06) g_unDOState.m_stAllDOBits.m_ui1SRDOCn06 = unValue.m_stAllDOBits.m_ui1SRDOCn06; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn07) g_unDOState.m_stAllDOBits.m_ui1SRDOCn07 = unValue.m_stAllDOBits.m_ui1SRDOCn07; 
.................... ////     
.................... //}     
.................... // 
.................... //         
.................... // 
.................... //         
.................... //// 02: Start to Pick 
.................... //unsigned int8 StateFunc_State02() 
.................... //{ 
.................... //    // We got message from outer board that Stacker Ready and Hopper Ready 
.................... //    // Now PD will start moving downword 
.................... //    //g_unAllDOs.m_bArr[2] = 1; 
.................... //    //g_unAllDOs.m_bArr[3] = 0; 
.................... //    // Expected Next State Declaration 
.................... //    g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[0] = STATE_03; 
.................... //    g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[1] = STATE_03; 
.................... //    g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[2] = STATE_03; 
.................... //    g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[3] = STATE_03; 
.................... //    return 0; 
.................... //} 
.................... // 
.................... // 
.................... //void InitExpNextStateDefault() 
.................... //{ 
.................... //    int8 i8StMcCount = 0; 
.................... //    int8 i8StCount   = 0; 
.................... //    int8 i8ExpNxtCount = 0; 
.................... //    for (i8StMcCount = 0; i8StMcCount < NO_OF_ACTIVE_MACHINE; i8StMcCount++) 
.................... //    { 
.................... //        // For all Active Look up tables 
.................... //        for (i8StCount = 0; i8StCount < MAX_NUMBER_OF_STATE; i8StCount++) 
.................... //        { 
.................... //            for (i8ExpNxtCount = 0; i8ExpNxtCount < MAX_NO_OF_EXP_NXT_STATES; i8ExpNxtCount++) 
.................... //            { 
.................... //                g_stArrStateMachines[i8StMcCount].m_stArrStateLookupTable[i8StCount].m_i8ArrExpNextState[i8ExpNxtCount] = STATE_NOTHING; 
.................... //            } 
.................... //        } 
.................... //    } 
.................... //} 
.................... // 
.................... //void PostProductionSafeMode() 
.................... //{ 
.................... //    //g_unDOState.m_ui16AllDOs = 0xFFFF; 
.................... //     
.................... //    // 1. Stopper 0 is in Push State 
.................... //    // 2. Can Stopper 1 is in Push state 
.................... //    // 3. Pusher 0, Pusher 1 and Can Guide all is in drag state 
.................... //    //g_unDOState.m_ui16AllDOs = SAFE_MODE_DO_STATE; 
.................... //    //ExecuteALLDOs(); 
.................... //} 
.................... // 
.................... //void PowerOnDOStateInit() 
.................... //{ 
.................... //   // g_unDOState.m_ui16AllDOs = 0xFFFF; 
.................... //     
.................... //    // 1. Stopper 0 is in drag State 
.................... //    // 2. Can Stopper 1 is in Push state 
.................... //    // 3. Pusher 0, Pusher 1 and Can Guide all is in drag state 
.................... //   // g_unDOState.m_ui16AllDOs = INITAIL_DO_STATE_ON_PWR_ON; 
.................... //    //ExecuteALLDOs(); 
.................... //} 
.................... // 
.................... //#endif /* _VM_STATE_MACHINE_FOR_IMW_M0_H_ */ 
....................  
.................... #include "vmADCManager.h" 
.................... /*  
....................  * File:   vmADCManager.h 
....................  * Author: Amit 
....................  * 
....................  * Created on December 12, 2018, 11:38 PM 
....................  */ 
....................  
.................... #ifndef VM_ADCMANAGER_H 
.................... #define	VM_ADCMANAGER_H 
....................  
.................... #include "vmCalibration.h" 
.................... #include "vmM0ADCModuleCommon.h" 
.................... #include "vmAverageWeightCalculation.h" 
.................... #include "vmEEPROMConfig_Britania.h" 
....................  
.................... #define LOAD_CELL_FACTOR       818 
.................... //#define ADC_SCANNING_START     0 
.................... //#define ADC_SCANNING_RUNNING   1 
.................... //#define ADC_SCANNING_STOP      2 
.................... #define ADC_SCAN_ON            1 
.................... #define ADC_SCAN_OFF           0 
....................  
.................... #define TIMER_IGNORE_ON  1 
.................... #define TIMER_IGNORE_OFF 0 
....................  
.................... int8 g_fIgnore_TIMER = TIMER_IGNORE_OFF; 
....................  
....................  
.................... #define COLLECT_DYNAMIC_TARE_DATA      3 
.................... #define COLLECT_WEIGHING_DATA          4 
.................... #define COLLECT_NOTHING                5 
....................  
.................... #define SIZE_DATA_QUEUE              200 
.................... #define MAX_TARE_MULTIPLAYER         100 
....................  
.................... #define ADC_DATA_NOT_READY             0 
.................... #define ADC_DATA_READY                 1 
....................  
.................... #define ADC_DATA_Q_VALUES_TRIMMING_PERCNTG     30 
....................  
.................... #define ADC_MEAN_CALCULATION_START    0 
.................... #define ADC_MEAN_CALCULATION_STOP     1 
.................... #define ADC_MEAN_CALCULATION_RUNNING  2 
.................... #define ADC_MEAN_CALCULATION_DONE     3 
....................  
.................... unsigned int8 g_ui8ADCMeanCalState = ADC_MEAN_CALCULATION_STOP; 
.................... unsigned int32 g_ui32ADCCurMeanValue = 0; 
.................... unsigned int32 g_ui32ADCCurSum       = 0; 
.................... unsigned int16 g_ui16ADCSumLoopCount = 0; 
.................... int16          g_i16LoadCellFactor   = 0; 
....................  
....................  
....................  
.................... typedef struct _ST_ADC_DATA_QUEUE 
.................... { 
....................     unsigned int32 m_ui32Arr[SIZE_DATA_QUEUE]; 
....................     int16          m_i16Rear; 
....................     unsigned int8  m_ui8Multiplier; 
....................     unsigned int32 m_ui32Sum; 
....................     int8           m_i8CollectionState; 
.................... } ST_ADC_DATA_QUEUE; 
....................  
.................... typedef struct _ST_MEAN_SHIFT_VALUE 
.................... { 
.................... 	unsigned int8 ui8ActualIndex ; 
.................... 	unsigned int8 ui8MeanShiftValue; 
.................... }ST_MEAN_SHIFT_VALUE; 
....................  
.................... unsigned int8  g_ui8ADCScanningStatus   = ADC_SCAN_OFF; 
.................... unsigned int32 g_ui32ADCValue           = 0; 
.................... unsigned int8  g_ui8DataCollectionState = COLLECT_NOTHING; 
.................... unsigned int8  g_fADCDataReadyStatus    = ADC_DATA_NOT_READY; 
.................... unsigned int8 g_ui8CurMaxDataCount    = 0; 
....................  
.................... ST_ADC_DATA_QUEUE g_stADCDataQ; 
.................... unsigned int16    g_ui16NoOfADCData   = 0; 
.................... unsigned int32    g_ui32ADCAvg        = 0; 
....................  
.................... //unsigned int8       g_ui8ArrSortedTemp[SIZE_DATA_QUEUE]          = {0}; 
.................... //ST_MEAN_SHIFT_VALUE g_ui16ArrMeanShiftVal[SIZE_DATA_QUEUE]       = {0}; 
.................... //ST_MEAN_SHIFT_VALUE g_ui16ArrSortedMeanShiftVal[SIZE_DATA_QUEUE] = {0}; 
....................  
.................... void ResetADCDataQ(int8 i8CollectionState); 
.................... unsigned int32 GetADCMeanValue(); 
.................... unsigned int32 GetTareData(); 
.................... int16          GetWeighingData(unsigned int32); 
.................... //void           IBCSendWeighingData(); 
.................... //void           IBCSendTareData(); 
.................... void           IBCSendTareData(unsigned int32); 
....................  
.................... void ResetADCDataQ(int8 i8CollectionState) 
.................... { 
....................     g_stADCDataQ.m_i16Rear           = -1; 
....................     g_stADCDataQ.m_ui32Sum           = 0; 
....................     g_stADCDataQ.m_ui8Multiplier     = 0; 
....................     g_stADCDataQ.m_i8CollectionState = i8CollectionState; 
....................      
....................     //CHANGE_RUNNING_AVG START 
....................     g_ui16NoOfADCData = 0; 
....................     g_ui32ADCAvg      = 0; 
....................     //CHANGE_RUNNING_AVG END 
.................... } 
....................  
.................... unsigned int32 GetADCMeanValue() 
.................... { 
....................     unsigned int8  ui8LoopCount     = 0; 
....................     unsigned int32 ui32DataSum      = 0; 
....................     //unsigned int32 ui32ADCMean      = 0; 
....................      
....................     // There is no Data then return 0 
....................     if (-1 == g_stADCDataQ.m_i16Rear) 
....................     { 
....................         return 0; 
....................     } 
....................     // Check the value of the Multiplier 
....................     if (g_stADCDataQ.m_ui8Multiplier) 
....................     { 
....................         g_ui8CurMaxDataCount = SIZE_DATA_QUEUE; 
....................     } 
....................     else 
....................     { 
....................         g_ui8CurMaxDataCount = g_stADCDataQ.m_i16Rear + 1; 
....................     } 
....................     //output_high(PIN_OUT_DO_02); 
....................     // Get the mean Value 
....................     for (ui8LoopCount = 0; ui8LoopCount < g_ui8CurMaxDataCount; ui8LoopCount++) 
....................     { 
....................         ui32DataSum += g_stADCDataQ.m_ui32Arr[ui8LoopCount]; 
....................         //ui32DataSum += 65500; 
....................         //output_toggle(PIN_OUT_DO_02); 
....................     } 
....................     //output_low(PIN_OUT_DO_02); 
....................     // TESTING Start 
....................     // Reset Data Queue 
....................     //ResetADCDataQ(COLLECT_NOTHING);  //TODO It should not be here, Reset should be done from State Machine 
....................     // TESTING End 
....................     // Now return Mean Value 
....................     return(ui32DataSum / g_ui8CurMaxDataCount); 
.................... } 
....................  
.................... unsigned int8 StartADCSplitAvg() 
.................... { 
....................     g_ui32ADCCurMeanValue = 0; 
....................     g_ui32ADCCurSum       = 0; 
....................     g_ui8CurMaxDataCount  = 0; 
....................     g_ui16ADCSumLoopCount = 0; 
....................      
....................     // There is no Data then return 0 
....................     if (-1 == g_stADCDataQ.m_i16Rear) 
....................     { 
....................         g_ui8ADCMeanCalState  = ADC_MEAN_CALCULATION_DONE; 
....................         return; 
....................     } 
....................     // Check the value of the Multiplier 
....................     if (g_stADCDataQ.m_ui8Multiplier) 
....................     { 
....................         g_ui8CurMaxDataCount = SIZE_DATA_QUEUE; 
....................     } 
....................     else 
....................     { 
....................         g_ui8CurMaxDataCount = g_stADCDataQ.m_i16Rear + 1; 
....................     } 
....................      
....................     g_ui8ADCMeanCalState  = ADC_MEAN_CALCULATION_RUNNING; 
.................... ////    if(g_stADCDataQ.m_i8CollectionState == COLLECT_DYNAMIC_TARE_DATA) 
.................... ////    { 
.................... ////        g_ui16ADCSumLoopCount = 20; 
.................... ////    } 
.................... } 
....................  
.................... void GetADCSplitSum() 
.................... { 
....................   
....................     if (g_ui16ADCSumLoopCount < g_ui8CurMaxDataCount) 
....................     { 
....................         g_ui32ADCCurSum += g_stADCDataQ.m_ui32Arr[g_ui16ADCSumLoopCount]; 
....................         // Increment Loop Count 
....................         g_ui16ADCSumLoopCount++; 
....................     } 
....................     else if (g_ui16ADCSumLoopCount >= g_ui8CurMaxDataCount) 
....................     { 
....................         // Calculate the mean 
....................         g_ui32ADCCurMeanValue = g_ui32ADCCurSum / g_ui8CurMaxDataCount; 
....................          
....................         // Update State 
....................         g_ui8ADCMeanCalState  = ADC_MEAN_CALCULATION_DONE; 
....................     } 
.................... ////    else 
.................... ////    { 
.................... ////        // This will occur whe 
.................... ////        g_ui32ADCCurMeanValue = 0; 
.................... ////    }     
....................      
.................... } 
....................  
.................... unsigned int32 GetADCSplitAvg() 
.................... { 
....................      
.................... } 
....................  
.................... void SortADCDataQ(void) 
.................... { 
....................     unsigned int8 ui8LoopCount = 0; 
....................     unsigned int8 ui8LoopCount1 = 0; 
....................     unsigned int8 ui8CurrMaxDataCount = 0; 
....................     unsigned int32 ui32Temp = 0; 
....................      
....................     // There is no Data then return 0 
....................     if (-1 == g_stADCDataQ.m_i16Rear) 
....................     { 
....................         return ; 
....................     } 
....................     // Check the value of the Multiplier 
....................     if (g_stADCDataQ.m_ui8Multiplier) 
....................     { 
....................         ui8CurrMaxDataCount = SIZE_DATA_QUEUE; 
....................     } 
....................     else 
....................     { 
....................         ui8CurrMaxDataCount = g_stADCDataQ.m_i16Rear + 1; 
....................     } 
....................      
....................     // Loop through the array to sort ADC data..Using Bubble Sort. 
....................     for(ui8LoopCount = 0; ui8LoopCount < (ui8CurrMaxDataCount - 1); ui8LoopCount++) 
....................     { 
....................         for(ui8LoopCount1 = ui8LoopCount + 1; ui8LoopCount1 < ui8CurrMaxDataCount; ui8LoopCount1++) 
....................         { 
....................             if(g_stADCDataQ.m_ui32Arr[ui8LoopCount] > g_stADCDataQ.m_ui32Arr[ui8LoopCount1]) 
....................             { 
....................                 ui32Temp = g_stADCDataQ.m_ui32Arr[ui8LoopCount1]; 
....................                 g_stADCDataQ.m_ui32Arr[ui8LoopCount1] = g_stADCDataQ.m_ui32Arr[ui8LoopCount]; 
....................                 g_stADCDataQ.m_ui32Arr[ui8LoopCount] = ui32Temp; 
....................             } 
....................         } 
....................     }     
....................      
.................... } 
....................  
.................... unsigned int32 GetADCMeanT(void) 
.................... { 
....................     unsigned int32 ui8CountL = 0; 
....................     unsigned int32 ui8CountH = 0; 
....................     unsigned int8 ui8CurrMaxDataCount = 0; 
....................     unsigned int8 ui8LoopCount =  0; 
....................     unsigned int32 ui32DataSum = 0; 
....................      
....................     // Check the value of the Multiplier 
....................     if (g_stADCDataQ.m_ui8Multiplier) 
....................     { 
....................         ui8CurrMaxDataCount = SIZE_DATA_QUEUE; 
....................     } 
....................     else 
....................     { 
....................         ui8CurrMaxDataCount = g_stADCDataQ.m_i16Rear + 1; 
....................     } 
....................      
....................     ui8CountL = ((ui8CurrMaxDataCount * ADC_DATA_Q_VALUES_TRIMMING_PERCNTG) / 100); 
....................     ui8CountH = (ui8CurrMaxDataCount - ui8CountL); 
....................      
....................     // Get the mean Value 
....................     for (ui8LoopCount = ui8CountL; ui8LoopCount < ui8CountH; ui8LoopCount++) 
....................     { 
....................         ui32DataSum += g_stADCDataQ.m_ui32Arr[ui8LoopCount]; 
....................     } 
....................      
....................     return (ui32DataSum / (ui8CountH - ui8CountL)); 
....................      
.................... } 
....................  
.................... //unsigned int16 GetStatisticalWeight() 
.................... //{ 
.................... //    unsigned int8  ui8LoopCount         = 0; 
.................... //    unsigned int8  ui8LoopCount1        = 0; 
.................... //    unsigned int16 ui16CurMean          = GetADCMeanValue(); 
.................... //    unsigned int8  ui8CurArrLength      = 0; 
.................... //    unsigned int16 ui16TempValue        = 0; 
.................... //    unsigned int8 ui8TempIndex            = 0; 
.................... //    unsigned int16 ui16CurSmallestShift = 0; 
.................... //    unsigned int16  ui16BestMeanShiftValues = 0; 
.................... //    int16    i16DynamicErrorValue         = 0; 
.................... //    unsigned int16 ui16Temp               = 0; 
.................... //    unsigned int16 ui16prevSum        	  = 0;				  
.................... //    unsigned int32 ui32Sum      		  = 0; 
.................... //    unsigned int32 ui32Mean      		  = 0; 
.................... //    unsigned int16 ui16LoopInit           = 0;  
.................... //     
.................... //    //  
.................... //    if (SIZE_LDCDISP_VALUE != g_ui8CountLdCDValue) 
.................... //    { 
.................... //        g_ui8CountLdCDValue = g_ui8WtLdCDIdx; 
.................... //    } 
.................... //     
.................... //    do 
.................... //    { 
.................... //        // Create the Mean Shift Array. 
.................... //        for (ui8LoopCount = 0; ui8LoopCount < g_ui8CountLdCDValue; ui8LoopCount++)  
.................... //        { 
.................... //            if (ui16CurMean >= g_ui16ArrCurLdCDValue[ui8LoopCount]) 
.................... //            { 
.................... //                g_ui16ArrMeanShiftVal[ui8LoopCount].ui8MeanShiftValue = ui16CurMean - g_ui16ArrCurLdCDValue[ui8LoopCount]; 
.................... //                g_ui16ArrMeanShiftVal[ui8LoopCount].ui8ActualIndex = ui8LoopCount; 
.................... //            } 
.................... //            else 
.................... //            { 
.................... //                g_ui16ArrMeanShiftVal[ui8LoopCount].ui8MeanShiftValue = g_ui16ArrCurLdCDValue[ui8LoopCount] - ui16CurMean; 
.................... //                g_ui16ArrMeanShiftVal[ui8LoopCount].ui8ActualIndex = ui8LoopCount; 
.................... //            } 
.................... //        } 
.................... // 
.................... //		// copy mean shift array into another array for sorting. 
.................... //		memcpy(g_ui16ArrSortedMeanShiftVal, g_ui16ArrMeanShiftVal, SIZE_LDCDISP_VALUE * sizeof(ST_MEAN_SHIFT_VALUE));  
.................... //		 
.................... //        // Now Sort This Mean Difference Table 
.................... //        for (ui8LoopCount = 0; ui8LoopCount < (g_ui8CountLdCDValue - 1); ui8LoopCount++)  
.................... //        { 
.................... //            for (ui8LoopCount1 = ui8LoopCount + 1; ui8LoopCount1 < g_ui8CountLdCDValue; ui8LoopCount1++)  
.................... //            { 
.................... //                if (g_ui16ArrSortedMeanShiftVal[ui8LoopCount].ui8MeanShiftValue > g_ui16ArrSortedMeanShiftVal[ui8LoopCount1].ui8MeanShiftValue ) 
.................... //                {  
.................... //                    // For error checking of smallest number. 
.................... //                    ui8TempIndex++; 
.................... //                     
.................... //                    // Upgrade the Sort Table 
.................... //                    //g_ui8ArrSortedTemp[ui8LoopCount] = ui8LoopCount1; 
.................... //                     
.................... //                    // swaping the numbers in ascending order. 
.................... //                    ui16TempValue = g_ui16ArrSortedMeanShiftVal[ui8LoopCount1].ui8MeanShiftValue; 
.................... //                    ui8TempIndex  = g_ui16ArrSortedMeanShiftVal[ui8LoopCount1].ui8ActualIndex; 
.................... //                    g_ui16ArrSortedMeanShiftVal[ui8LoopCount1].ui8MeanShiftValue = g_ui16ArrSortedMeanShiftVal[ui8LoopCount].ui8MeanShiftValue; 
.................... //                    g_ui16ArrSortedMeanShiftVal[ui8LoopCount1].ui8ActualIndex    = g_ui16ArrSortedMeanShiftVal[ui8LoopCount].ui8ActualIndex; 
.................... //                    g_ui16ArrSortedMeanShiftVal[ui8LoopCount].ui8MeanShiftValue  = ui16TempValue; 
.................... //                    g_ui16ArrSortedMeanShiftVal[ui8LoopCount].ui8ActualIndex     = ui8TempIndex; 
.................... //                } 
.................... //            } 
.................... // 
.................... //        } 
.................... //        // Now we are having the Mean Shift sorted Array 
.................... //        // Now we will take best 30% of total fetched weights from mean shift array. 
.................... //         
.................... //        ui16BestMeanShiftValues = ((unsigned int16)g_ui8CountLdCDValue * LDCD_FILTER_MEAN);     //((unsigned int16)g_ui8CountLdCDValue) 
.................... //        ui16BestMeanShiftValues = (ui16BestMeanShiftValues / 100); 
.................... //        //ui16CurMean = g_ui16ArrCurLdCDValue[g_ui8ArrSortedTemp[0]]; 
.................... //        //ui8CurArrLength--; 
.................... //        ui16LoopInit = (SIZE_LDCDISP_VALUE - ui16BestMeanShiftValues) / 2; // We are trying to get the middle portion 
.................... //        ui16LoopInit = 0; 
.................... //        // Calculate Mean of best 30% values deviated from mean. 
.................... //        for (ui8LoopCount = ui16LoopInit; ui8LoopCount < (ui16LoopInit + ui16BestMeanShiftValues); ui8LoopCount++) 
.................... //        { 
.................... //        	// Calculate sum. 
.................... //       		ui32Sum = ui32Sum + g_ui16ArrCurLdCDValue[g_ui16ArrSortedMeanShiftVal[ui8LoopCount].ui8ActualIndex]; 
.................... //        } 
.................... //        // Calculate Mean with left sum value if any. 
.................... //    	 ui32Mean = (ui32Sum / ui16BestMeanShiftValues); 
.................... //    	 ui16CurMean = (unsigned int16) (ui32Mean & 0x00007FFF); 
.................... //           
.................... //    } while (0); // Do it once.																		 
.................... //     
.................... //    // Flush Load Cell Weighing Value Array. 
.................... //    memset (g_ui16ArrCurLdCDValue, 0, (2 * SIZE_LDCDISP_VALUE));  
.................... //    // Reset Counter. 
.................... //    g_ui8CountLdCDValue = 0; 
.................... //    g_ui8WtLdCDIdx      = 0; 
.................... //     
.................... //    // Eliminate Dynamic Error. 
.................... //    // Fetch Dynamic error value. 
.................... //    i16DynamicErrorValue = DynamicErrorCalculation(); 
.................... //     
.................... //    // Check if positive error is there or negative.//************************************************ 
.................... //    if(i16DynamicErrorValue < 0x8000) 
.................... //    { 
.................... //	    // For positive error substract dynamic error from current mean. 
.................... //    	ui16CurMean = (ui16CurMean - i16DynamicErrorValue); 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //	    // For negative error add dynamic error with current mean. 
.................... //    	ui16CurMean = ui16CurMean + (~i16DynamicErrorValue + 1); 
.................... //    } 
.................... //     
.................... //     
.................... //    // So last mean Value is the actual value. 
.................... //    return ui16CurMean; 
.................... //} 
....................  
.................... unsigned int32 GetStatisticalMean() 
.................... { 
....................      
.................... } 
....................  
.................... int16 GetCalibratedWeight(unsigned int32 ui32ADCMean) 
.................... { 
....................     int16 i16ActualWeight = 0; 
....................     int32    i32Temp = 0; 
....................     unsigned int32 ui32DiffValue = 0; 
....................      
....................     // Check Which one is greater 
....................     if (g_ui32DynamicTareADCValue > ui32ADCMean) 
....................     { 
....................         // Should not be 
....................         ui32DiffValue = g_ui32DynamicTareADCValue - ui32ADCMean; 
....................         i32Temp = (int32)ui32DiffValue * (int32)g_i16LoadCellFactor; 
....................         i32Temp /= 1000; 
....................         i16ActualWeight = (int16)i32Temp; 
....................         i16ActualWeight = ~i16ActualWeight + 1; 
....................     } 
....................     else 
....................     { 
....................         ui32DiffValue = ui32ADCMean - g_ui32DynamicTareADCValue; 
....................         i32Temp = (int32)ui32DiffValue * (int32)g_i16LoadCellFactor; 
....................         i32Temp /= 1000; 
....................         i16ActualWeight = (int16)i32Temp; 
....................          
....................     } 
....................      
....................     return i16ActualWeight; 
.................... } 
....................  
.................... //int16 GetCalibratedWeight(unsigned int32 ui32ADCMean) 
.................... //{ 
.................... //    int16 i16ActualWeight = 0; 
.................... //    int8  i8LoopCount     = 0; 
.................... //    int16    i16Temp = 0; 
.................... //    int32    i32Temp = 0; 
.................... //    unsigned int16 ui16DiffValue = 0; 
.................... //    unsigned int16 ui16Factor = 0; // Usually 1000, just to get better value we are using scale of 100 
.................... //     
.................... //     
.................... //    //g_stCalibTable[SIZE_CALIB_TABLE]; 
.................... //    // Check if the Value falls within the Calibration Table or not 
.................... //    if (ui32ADCMean < g_stCalibTable[0].m_ui32CalibValue) 
.................... //    { 
.................... // 
.................... //        // Value is in negative range 
.................... //        ui16DiffValue = (g_stCalibTable[1].m_ui32CalibValue - g_stCalibTable[0].m_ui32CalibValue); 
.................... //        // Get the Factor 
.................... //        ui16Factor = 10000 / ui16DiffValue; 
.................... // 
.................... //        i16Temp = ((g_stCalibTable[0].m_ui32CalibValue - ui32ADCMean) * ui16Factor) -  
.................... //                  (g_stCalibTable[0].m_i16CalibPoint * 10); 
.................... //        i16ActualWeight = (int16)i16Temp/10; 
.................... //        i16ActualWeight = ~i16ActualWeight;  // As this is a negative value 
.................... //         
.................... // 
.................... // 
.................... //    } 
.................... //    if (ui32ADCMean > g_stCalibTable[SIZE_CALIB_TABLE - 1].m_ui32CalibValue) 
.................... //    { 
.................... //        // Value is greater than Calibtable range 
.................... //        ui16DiffValue = (g_stCalibTable[SIZE_CALIB_TABLE - 1].m_ui32CalibValue - g_stCalibTable[SIZE_CALIB_TABLE - 2].m_ui32CalibValue); 
.................... //        ui16Factor = 10000 / ui16DiffValue; 
.................... //         
.................... //        i32Temp = (int32)(g_stCalibTable[SIZE_CALIB_TABLE - 1].m_i16CalibPoint) * (int32)(10); 
.................... //        i32Temp += ((ui32ADCMean - g_stCalibTable[SIZE_CALIB_TABLE - 1].m_ui32CalibValue) * (int32)(ui16Factor)); 
.................... //                    
.................... //        i32Temp /= 10; 
.................... //        i16ActualWeight = (int16)i32Temp; 
.................... //         
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        // Value within Calibration Table Range 
.................... //        // Seek Table 
.................... //        for (i8LoopCount = 1; i8LoopCount < SIZE_CALIB_TABLE; i8LoopCount++) 
.................... //        { 
.................... //            if (g_stCalibTable[i8LoopCount].m_ui32CalibValue == ui32ADCMean) 
.................... //            { 
.................... //                i16ActualWeight = g_stCalibTable[i8LoopCount].m_i16CalibPoint; 
.................... //                break; 
.................... //            } 
.................... //            else if (g_stCalibTable[i8LoopCount].m_ui32CalibValue > ui32ADCMean) 
.................... //            { 
.................... //                break; 
.................... //            } 
.................... //        } 
.................... // 
.................... //        if (!i16ActualWeight) 
.................... //        { 
.................... //            // Calculate weight 
.................... //            ui16DiffValue = (g_stCalibTable[i8LoopCount].m_ui32CalibValue - g_stCalibTable[i8LoopCount - 1].m_ui32CalibValue); 
.................... //            ui16Factor = 10000/ui16DiffValue; 
.................... // 
.................... //            i32Temp  = (int32)(g_stCalibTable[i8LoopCount - 1].m_i16CalibPoint * (int32)(10)); 
.................... //            i32Temp  += ((ui32ADCMean - g_stCalibTable[i8LoopCount - 1].m_ui32CalibValue)*(int32)ui16Factor); 
.................... //            i32Temp /= 10; 
.................... //            i16ActualWeight = (int16)i32Temp; 
.................... //        } 
.................... //         
.................... //    } 
.................... //     
.................... //    return i16ActualWeight; 
.................... //} 
....................  
.................... int16 GetWeighingData(unsigned int32 ui32ADCMean) 
.................... { 
....................     int16 i16CalibratedWeight = 0; 
....................     unsigned int16 ui16TempTareWeight   = 0; 
....................     unsigned int16 ui16TempDynErrValue  = 0;     
....................      
....................     i16CalibratedWeight = GetCalibratedWeight(ui32ADCMean); 
....................      
.................... ////////    // Deduct Dynamic Tare Value 
.................... ////////    ui16TempTareWeight = g_ui16DynamicTareValue; 
.................... ////////    if (g_ui16DynamicTareValue > 0x8000) 
.................... ////////    { 
.................... //////////        ui16TempTareWeight = ui16TempTareWeight << 1; 
.................... //////////        ui16TempTareWeight = ui16TempTareWeight >> 1; 
.................... ////////        ui16TempTareWeight = ~ui16TempTareWeight + 1; 
.................... ////////         
.................... ////////        i16CalibratedWeight += (int16)ui16TempTareWeight; 
.................... ////////    } 
.................... ////////    else 
.................... ////////    { 
.................... ////////        i16CalibratedWeight -= (int16)ui16TempTareWeight; 
.................... ////////    } 
....................  
.................... //AMIT 
.................... ////////    // Deduct Dynamic Error Value 
.................... ////////    ui16TempDynErrValue = (unsigned int16)g_i16DynamicErrValue; 
.................... ////////    if (g_i16DynamicErrValue > 0x8000) 
.................... ////////    { 
.................... //////////        ui16TempDynErrValue = ui16TempDynErrValue << 1; 
.................... //////////        ui16TempDynErrValue = ui16TempDynErrValue >> 1; 
.................... ////////        ui16TempDynErrValue = ~ui16TempDynErrValue + 1; 
.................... ////////         
.................... ////////        i16CalibratedWeight += (int16)ui16TempDynErrValue; 
.................... ////////    } 
.................... ////////    else 
.................... ////////    { 
.................... ////////        i16CalibratedWeight -= (int16)ui16TempDynErrValue; 
.................... ////////    } 
....................      
....................     return i16CalibratedWeight; 
.................... } 
....................  
.................... //int16 GetWeighingData(unsigned int32 ui32ADCMean) 
.................... //{ 
.................... //    int16 i16CalibratedWeight = 0; 
.................... //    unsigned int16 ui16TempTareWeight   = 0; 
.................... //    unsigned int16 ui16TempDynErrValue  = 0;     
.................... //     
.................... //    //unsigned int32 ui32ADCMean = GetADCMeanValue(); 
.................... //    i16CalibratedWeight = GetCalibratedWeight(ui32ADCMean); 
.................... //     
.................... //    // Deduct Dynamic Tare Value 
.................... //    ui16TempTareWeight = g_ui16DynamicTareValue; 
.................... //    if (g_ui16DynamicTareValue > 0x8000) 
.................... //    { 
.................... ////        ui16TempTareWeight = ui16TempTareWeight << 1; 
.................... ////        ui16TempTareWeight = ui16TempTareWeight >> 1; 
.................... //        ui16TempTareWeight = ~ui16TempTareWeight + 1; 
.................... //         
.................... //        i16CalibratedWeight += (int16)ui16TempTareWeight; 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        i16CalibratedWeight -= (int16)ui16TempTareWeight; 
.................... //    } 
.................... // 
.................... //    // Deduct Dynamic Error Value 
.................... //    ui16TempDynErrValue = (unsigned int16)g_i16DynamicErrValue; 
.................... //    if (g_i16DynamicErrValue > 0x8000) 
.................... //    { 
.................... ////        ui16TempDynErrValue = ui16TempDynErrValue << 1; 
.................... ////        ui16TempDynErrValue = ui16TempDynErrValue >> 1; 
.................... //        ui16TempDynErrValue = ~ui16TempDynErrValue + 1; 
.................... //         
.................... //        i16CalibratedWeight += (int16)ui16TempDynErrValue; 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        i16CalibratedWeight -= (int16)ui16TempDynErrValue; 
.................... //    } 
.................... //     
.................... //    return i16CalibratedWeight; 
.................... //} 
....................  
....................  
....................  
....................  
.................... void IBCSendWeighingData(int16 i16BoxWeight, unsigned int16 ui16BoxCount) 
.................... { 
....................     ST_IBC_DATA_NODE stIBCDataNode; 
....................     int8             i8LoopCount         = 0; 
....................     int16            i16AvgWeight        = 0; 
....................  
....................     // Check for Rejection in Fixed Calib Mode 
....................     if (HMI_REJECTION_FIXED_CALIB_MODE == g_fRejectionMode) 
....................     { 
....................         i16AvgWeight = g_stCurBatchInfo.m_i16AvgWeight; 
....................     } 
....................     else 
....................     { 
....................         i16AvgWeight = g_stAvgWtQueue.m_i16CurAvg; 
....................     } 
....................      
....................     // Now Check if the Weight is within tolerance limit or not 
....................     if (i16BoxWeight > (i16AvgWeight + g_stCurBatchInfo.m_i16PositiveTol) ||  
....................         i16BoxWeight < (i16AvgWeight - g_stCurBatchInfo.m_i16NegativeTol)) 
....................     { 
....................         g_ui16RejectionStatus = BOX_REJECTED; 
....................         // Set Rejection State ON 
....................         g_unDIState.m_stAllDIBits.m_ui1GDICn01 = BOX_REJECTED; 
....................     } 
....................     else 
....................     { 
....................         g_ui16RejectionStatus = BOX_ACCEPTED; 
....................         // Set Rejection State OFF 
....................         g_unDIState.m_stAllDIBits.m_ui1GDICn01 = BOX_ACCEPTED; 
....................     } 
....................      
.................... //    // Now Check if the Weight is within tolerance limit or not. 
.................... //    // The under weight and over weight rejection is also segregated here and accordingly send the status to server. 
.................... //    if (i16BoxWeight > (i16AvgWeight + g_stCurBatchInfo.m_i16PositiveTol))  
.................... //         
.................... //    { 
.................... //        g_ui16RejectionStatus = BOX_REJECTED_OVR_WT; 
.................... //        // Set Rejection State ON 
.................... //        g_unDIState.m_stAllDIBits.m_ui1GDICn01 = BOX_REJECTED_UNDR_WT; // Here under weight is used only to maintain #define value to actuate rejection DO. 
.................... //    } 
.................... //    else if(i16BoxWeight < (i16AvgWeight - g_stCurBatchInfo.m_i16NegativeTol)) 
.................... //    { 
.................... //        g_ui16RejectionStatus = BOX_REJECTED_UNDR_WT; 
.................... //        // Set Rejection State ON 
.................... //        g_unDIState.m_stAllDIBits.m_ui1GDICn01 = BOX_REJECTED_UNDR_WT; 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        g_ui16RejectionStatus = BOX_ACCEPTED; 
.................... //        // Set Rejection State OFF 
.................... //        g_unDIState.m_stAllDIBits.m_ui1GDICn01 = BOX_ACCEPTED; 
.................... //    } 
....................      
....................     // Prepare IBC Data Node 
....................     g_unIBCProdModeWtData.m_stWeighingData.m_ui16BoxCount = ui16BoxCount; 
....................     g_unIBCProdModeWtData.m_stWeighingData.m_ui16BoxCount <<= 1; 
....................     g_unIBCProdModeWtData.m_stWeighingData.m_ui16BoxCount 
....................             = g_unIBCProdModeWtData.m_stWeighingData.m_ui16BoxCount | g_ui16RejectionStatus; 
....................      
....................     g_unIBCProdModeWtData.m_stWeighingData.m_i16BoxWeight = i16BoxWeight; 
....................      
....................      
.................... //    // Prepare IBC Data Node 
.................... //    g_unIBCProdModeWtData.m_stWeighingData.m_ui16BoxCount = ui16BoxCount; 
.................... //    g_unIBCProdModeWtData.m_stWeighingData.m_ui16BoxCount <<= 2; 
.................... //    g_unIBCProdModeWtData.m_stWeighingData.m_ui16BoxCount 
.................... //            = g_unIBCProdModeWtData.m_stWeighingData.m_ui16BoxCount | g_ui16RejectionStatus; 
.................... //     
.................... //    g_unIBCProdModeWtData.m_stWeighingData.m_i16BoxWeight = i16BoxWeight; 
....................      
....................     // Stuff IBC Command 
....................     stIBCDataNode.g_ui8ArrIBCData[0] = IBC_CMD_PROD_WEIGH_DATA; 
....................     for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         stIBCDataNode.g_ui8ArrIBCData[i8LoopCount] = g_unIBCProdModeWtData.m_ui8Arr[i8LoopCount - 1]; 
....................     } 
....................      
....................     // Send to IBC Insert 
....................     //InsertSendQueue(&stIBCDataNode); 
....................     InsertIBCMsgQueue(&g_stIBCSendQueue, &stIBCDataNode); 
....................     InsertIBCMsgQueue(&g_stIBCSendQueue, &stIBCDataNode); 
....................     //InsertIBCMsgQueue(&g_stIBCSendQueue, &stIBCDataNode); 
.................... } 
....................  
.................... void IBCSendWtInterMidData(int16 i16BoxWeight) 
.................... { 
....................     ST_IBC_DATA_NODE stIBCDataNode; 
....................     int8             i8LoopCount         = 0; 
....................     int16            i16AvgWeight        = 0; 
....................     
....................      
....................     // Prepare IBC Data Node 
....................     g_unIBCProdModeWtData.m_stWeighingData.m_ui16BoxCount = 0; 
....................      
....................     g_unIBCProdModeWtData.m_stWeighingData.m_i16BoxWeight = i16BoxWeight; 
....................      
....................     // Stuff IBC Command 
....................     stIBCDataNode.g_ui8ArrIBCData[0] = IBC_CMD_PROD_INTMD_DATA; 
....................     for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         stIBCDataNode.g_ui8ArrIBCData[i8LoopCount] = g_unIBCProdModeWtData.m_ui8Arr[i8LoopCount - 1]; 
....................     } 
....................      
....................     // Send to IBC Insert 
....................     //InsertSendQueue(&stIBCDataNode); 
....................     InsertIBCMsgQueue(&g_stIBCSendQueue, &stIBCDataNode); 
.................... } 
....................  
.................... void IBCSendTareData(unsigned int32 ui32ADCMean) 
.................... { 
....................     ST_IBC_DATA_NODE stIBCDataNode; 
....................     int8 i8LoopCount = 0; 
....................     int16  i16TempDynTare = 0; 
....................  
....................     i16TempDynTare = GetCalibratedWeight(ui32ADCMean); 
....................          
.................... //    // Update Dynamic Tare only if there are more than 200 data available in DataQ 
.................... //    if (ADC_MEAN_DATA_FINAL_TARE  == g_ui8ADCMeanDataState && g_stADCDataQ.m_ui8Multiplier > 0) 
.................... //    { 
.................... //        g_ui16DynamicTareValue   = i16TempDynTare; 
.................... //        g_ui32DynamicTareADCValue = ui32ADCMean; 
.................... //    } 
....................      
....................     // Update Dynamic Tare only if there are more than 200 data available in DataQ 
....................     if (g_stADCDataQ.m_ui8Multiplier > 0) 
....................     { 
....................         g_ui16DynamicTareValue   = i16TempDynTare; 
....................         g_ui32DynamicTareADCValue = ui32ADCMean; 
....................     } 
....................     // Prepare IBC Data Node 
....................     g_unIBCProdModeTrData.m_stTareData.m_i16Padding  = 0; 
....................     g_unIBCProdModeTrData.m_stTareData.m_i16TareData = i16TempDynTare; 
....................      
....................     // Stuff IBC Command 
....................     stIBCDataNode.g_ui8ArrIBCData[0] = IBC_CMD_PROD_TARE_DATA; 
....................  
....................     for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         stIBCDataNode.g_ui8ArrIBCData[i8LoopCount] = g_unIBCProdModeTrData.m_ui8Arr[i8LoopCount - 1]; 
....................     } 
....................  
....................     // Send to IBC Insert 
....................     //InsertSendQueue(&stIBCDataNode); 
....................     InsertIBCMsgQueue(&g_stIBCSendQueue, &stIBCDataNode); 
.................... } 
....................  
.................... //void IBCSendTareData(unsigned int32 ui32ADCMean) 
.................... //{ 
.................... //    ST_IBC_DATA_NODE stIBCDataNode; 
.................... //    int8 i8LoopCount = 0; 
.................... //    unsigned int32 ui32TempDynTare = 0; 
.................... //    // Sort the values of data queue. 
.................... //    //SortADCDataQ(); 
.................... //     
.................... //    //ui32ADCMean = GetADCMeanValue(); 
.................... //      
.................... //    ui32TempDynTare = GetCalibratedWeight(ui32ADCMean); 
.................... //         
.................... //    // Update Dynamic Tare 
.................... //    if (ADC_MEAN_DATA_FINAL_TARE  == g_ui8ADCMeanDataState) 
.................... //    { 
.................... //        g_ui16DynamicTareValue   = ui32TempDynTare; 
.................... //        g_ui32DynamicTareADCValue = ui32ADCMean; 
.................... //    } 
.................... //    // Prepare IBC Data Node 
.................... //    g_unIBCProdModeTrData.m_stTareData.m_i16Padding  = 0; 
.................... //    g_unIBCProdModeTrData.m_stTareData.m_i16TareData = ui32TempDynTare; 
.................... //     
.................... //    // Stuff IBC Command 
.................... //    stIBCDataNode.g_ui8ArrIBCData[0] = IBC_CMD_PROD_TARE_DATA; 
.................... // 
.................... //    for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //    { 
.................... //        stIBCDataNode.g_ui8ArrIBCData[i8LoopCount] = g_unIBCProdModeTrData.m_ui8Arr[i8LoopCount - 1]; 
.................... //    } 
.................... // 
.................... //    // Send to IBC Insert 
.................... //    //InsertSendQueue(&stIBCDataNode); 
.................... //    InsertIBCMsgQueue(&g_stIBCSendQueue, &stIBCDataNode); 
.................... //} 
....................  
.................... void IBCSendCalibResetData(unsigned int32 ui32ADCMean) 
.................... { 
....................     ST_IBC_DATA_NODE stIBCDataNode; 
....................     int8 i8LoopCount = 0; 
....................      
....................     //CHANGE_RUNNING_AVG START 
....................      
....................     // 1. Send Dynamic Tare ADC Value : g_ui32DynamicTareADCValue 
....................     // 2. Send Current Dynamic Weight : ui32ADCMean 
....................      
....................     // Set dynamic tare ADC value and weight ADC value in variables. 
....................     g_unIBCResetCalibTare.m_stIBCResetCalibTare.m_ui32CalibADCForTare = g_ui32DynamicTareADCValue; 
....................     g_unIBCResetCalibWeight.m_stIBCResetCalibWeight.m_ui32CalibADCForWeight = ui32ADCMean; 
....................      
....................     // Stuff IBC Command. 
....................     // 1. Dynamic Tare ADC value. 
....................     stIBCDataNode.g_ui8ArrIBCData[0] = IBC_CMD_RESET_CALIB_POINT_TARE; 
....................     for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         stIBCDataNode.g_ui8ArrIBCData[i8LoopCount] = g_unIBCResetCalibTare.m_ui8Arr[i8LoopCount - 1]; 
....................     } 
....................      
....................     // Insert in IBC queue. 
....................     InsertIBCMsgQueue(&g_stIBCSendQueue, &stIBCDataNode); 
....................      
....................     // 2. Current Dynamic Weight ADC value. 
....................     stIBCDataNode.g_ui8ArrIBCData[0] = IBC_CMD_RESET_CALIB_POINT_WEIGHT; 
....................     for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         stIBCDataNode.g_ui8ArrIBCData[i8LoopCount] = g_unIBCResetCalibWeight.m_ui8Arr[i8LoopCount - 1]; 
....................     } 
....................      
....................     // Insert in IBC queue. 
....................     InsertIBCMsgQueue(&g_stIBCSendQueue, &stIBCDataNode); 
....................      
....................     // Reset start calibration flag. 
....................     g_fResetCalibStatus = IBC_RESET_CALIB_OFF; 
....................  
.................... } 
....................  
.................... //void IBCSendCalibResetData(unsigned int32 ui32ADCMean) 
.................... //{ 
.................... //    ST_IBC_DATA_NODE stIBCDataNode; 
.................... //    int8 i8LoopCount = 0; 
.................... //     
.................... //    //CHANGE_RUNNING_AVG START 
.................... //    // Sort the values of data queue. 
.................... //    //SortADCDataQ(); 
.................... //     
.................... //    //unsigned int32 ui32ADCMean = GetADCMeanT(); 
.................... //     
.................... //    //CHANGE_RUNNING_AVG END 
.................... //     
.................... //    // Update Calib Reset Value 
.................... //    g_i16CalibResetValue = GetCalibratedWeight(ui32ADCMean); 
.................... //     
.................... //    // Deduct the Dynamic Tare Value 
.................... //    g_i16CalibResetValue -= g_ui16DynamicTareValue; 
.................... //     
.................... //    // Prepare IBC Data Node 
.................... //    g_i16CalibResetSumValue += g_i16CalibResetValue; 
.................... //    g_unIBCResetCalibAck.m_stIBCResetCalibPoint.m_i16PassCount++; 
.................... //    g_unIBCResetCalibAck.m_stIBCResetCalibPoint.m_i16CalibValue = 
.................... //            (g_i16CalibResetSumValue/g_unIBCResetCalibAck.m_stIBCResetCalibPoint.m_i16PassCount); 
.................... //     
.................... //    // Calculate Calib value for particular calib pont 
.................... //    g_i32ADCSumValue += ui32ADCMean; 
.................... //    g_i32ADCAvgValue = (g_i32ADCSumValue/g_unIBCResetCalibAck.m_stIBCResetCalibPoint.m_i16PassCount); 
.................... // 
.................... //    // Stuff IBC Command 
.................... //    stIBCDataNode.g_ui8ArrIBCData[0] = IBC_CMD_RESET_CALIB_POINT_ACK; 
.................... //    for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //    { 
.................... //        stIBCDataNode.g_ui8ArrIBCData[i8LoopCount] = g_unIBCResetCalibAck.m_ui8Arr[i8LoopCount - 1]; 
.................... //    } 
.................... //     
.................... //    // Send to IBC Insert 
.................... //    //InsertSendQueue(&stIBCDataNode); 
.................... //    InsertIBCMsgQueue(&g_stIBCSendQueue, &stIBCDataNode); 
.................... //     
.................... //    if (MAX_CALIB_RESET_PASS == g_unIBCResetCalibAck.m_stIBCResetCalibPoint.m_i16PassCount) 
.................... //    { 
.................... //        // Set Dynamic Err Adjustment Value 
.................... //        g_i16DynamicErrValue = g_unIBCResetCalibAck.m_stIBCResetCalibPoint.m_i16CalibValue - 
.................... //                g_unIBCResetCalib.m_stIBCResetCalibPoint.m_i16CalibPoint; 
.................... //         
.................... // 
.................... //        // Set Dynamic Error Value to EEPROM 
.................... //        //WriteDynamicErrToEEPROM(g_i16DynamicErrValue); 
.................... // 
.................... //        // Reset all temp values 
.................... //        g_i16CalibResetSumValue     = 0; 
.................... //        g_i16CalibResetValue        = 0; 
.................... //        g_i32ADCSumValue            = 0; 
.................... //        g_i32ADCAvgValue            = 0; 
.................... //        g_ui16CalibPointEEPROM      = 0; 
.................... //        g_ui16ADCCalibValueEEPROM   = 0; 
.................... //        g_unIBCResetCalibAck.m_stIBCResetCalibPoint.m_i16CalibValue = 0; 
.................... //        g_unIBCResetCalibAck.m_stIBCResetCalibPoint.m_i16PassCount  = 0; 
.................... //         
.................... //        g_fResetCalibStatus = IBC_RESET_CALIB_OFF; 
.................... //    } 
.................... //} 
....................  
.................... void UpdateNewCalibTable(void) 
.................... { 
....................     int8  i8LoopCount = 0; 
....................     unsigned int16 ui16CalibValueEEPROM = 0; 
....................     unsigned int16 ui16CalibPointEEPROM = 0; 
....................      
....................     // Loop through the entire calibration table 
....................     for (i8LoopCount = 0; i8LoopCount < SIZE_CALIB_TABLE; i8LoopCount++) 
....................     { 
....................         // Update in RAM 
....................         g_stCalibTable[i8LoopCount].m_i16CalibPoint = g_stTempCalibTable[i8LoopCount].m_i16CalibPoint; 
....................         g_stCalibTable[i8LoopCount].m_ui32CalibValue = g_stTempCalibTable[i8LoopCount].m_ui32CalibValue; 
....................          
....................         // Update in EEPROM 
....................         ui16CalibValueEEPROM = (unsigned int16)g_stTempCalibTable[i8LoopCount].m_ui32CalibValue; 
....................         ui16CalibPointEEPROM = (unsigned int16)g_stTempCalibTable[i8LoopCount].m_i16CalibPoint; 
....................         //WriteDataToEEPROM(ui16CalibPointEEPROM, ui16CalibValueEEPROM); 
....................     } 
.................... } 
....................  
....................  
.................... void AfterADCMeanCalculationDone() 
.................... { 
....................     // Intermediate Data Send for Weight 
....................     if (ADC_MEAN_DATA_INTERMEDIATE_WEIGHT == g_ui8ADCMeanDataState) 
....................     { 
....................         // ADC Mean Calculation Done 
....................         g_i16CurBoxWeight = GetWeighingData(g_ui32ADCCurMeanValue); 
....................         IBCSendWtInterMidData(g_i16CurBoxWeight); 
....................     } 
....................     // Intermediate Data Send for Tare 
....................     if (ADC_MEAN_DATA_INTERMEDIATE_TARE == g_ui8ADCMeanDataState) 
....................     { 
....................         //output_toggle(PIN_OUT_DO_02); 
....................         // ADC Mean Calculation Done 
....................         IBCSendTareData(g_ui32ADCCurMeanValue); 
....................         //output_toggle(PIN_OUT_DO_02); 
....................     } 
....................  
....................     // Final Weight Calculation 
....................     if (ADC_MEAN_DATA_FINAL_WEIGHT == g_ui8ADCMeanDataState) 
....................     { 
....................         // ADC Mean Calculation Done 
....................         // Step 3: Send Final Tare data to IBC 
....................         //output_toggle(PIN_OUT_DO_02); 
....................         g_i16CurBoxWeight = GetWeighingData(g_ui32ADCCurMeanValue); 
....................         //output_toggle(PIN_OUT_DO_02); 
....................         IBCSendWeighingData(g_i16CurBoxWeight, g_ui16CurrentBoxCount); 
....................  
....................         // Step 4: Insert Last Box Data to Average Queue 
....................         InsertAvgWtQueue(g_i16CurBoxWeight); 
....................  
....................         // Step 5: Send Current average Weight through IBC 
....................         IBCSendProdModeAvgData(); 
....................  
....................         // Step 6: Reset ADC Data Queue 
....................         ResetADCDataQ(COLLECT_NOTHING); 
....................  
....................         g_fWtCalculationState = FLAG_WT_CALCULATION_DONE; 
....................     } 
....................  
....................     // Final Tare Value Set 
....................     if (ADC_MEAN_DATA_FINAL_TARE  == g_ui8ADCMeanDataState) 
....................     { 
....................         // ADC Mean Calculation Done 
....................         IBCSendTareData(g_ui32ADCCurMeanValue); 
....................         ResetADCDataQ(COLLECT_NOTHING); 
....................     } 
....................      
....................     if (ADC_MEAN_DATA_CALIB_WEIGHT  == g_ui8ADCMeanDataState) 
....................     { 
....................         // ADC Mean Calculation Done 
....................         IBCSendCalibResetData(g_ui32ADCCurMeanValue); 
....................         ResetADCDataQ(COLLECT_NOTHING); 
....................     } 
....................      
....................     // Reset Flags 
....................     g_ui8ADCMeanCalState  = ADC_MEAN_CALCULATION_STOP; 
....................     g_ui8ADCMeanDataState = ADC_MEAN_DATA_NOTHING; 
.................... } 
.................... #endif	/* VM_ADCMANAGER_H */ 
....................  
....................  
.................... #include "vmAverageWeightCalculation.h" 
.................... /*  
....................  * File:   vmAverageWeightCalculation.h 
....................  * Author: OEM 
....................  * 
....................  * Created on December 20, 2018, 11:50 AM 
....................  */ 
....................  
005B2:  BCF    FF2.2
005B4:  MOVLB  0
005B6:  GOTO   0094
.................... #ifndef VM_AVERAGE_WEIGHT_CALCULATION_H 
.................... #define	VM_AVERAGE_WEIGHT_CALCULATION_H 
....................  
.................... #define SIZE_AVG_WT_ARR                 50 
.................... #define MAX_DEVIATIION_FROM_AVG_WT      1000  // We are considering +- 1000gm weight deviation 
.................... #define MAX_DEVIATION_FOR_BATCH_CHANGE  850   // If Current weight 850gm deviated from last average weight then we consider batch must be changed. 
....................                                               // In that case we reset the queue. 
....................  
.................... typedef struct _ST_AVG_WT_QUEUE 
.................... { 
....................     int16 m_i16Arr[SIZE_AVG_WT_ARR]; 
....................     int8  m_i8Rear; 
....................     int8  m_i8Length; 
....................     int8  m_i8QueueFull; 
....................     int16 m_i16CurAvg; 
....................     int16 m_i16LstAvg; 
.................... } ST_AVG_WT_QUEUE; 
....................  
.................... ST_AVG_WT_QUEUE g_stAvgWtQueue; 
....................  
.................... void InitializeAvgWtQueue() 
.................... { 
....................     unsigned int8 ui8LoopCount = 0; 
....................     g_stAvgWtQueue.m_i8Rear     = -1; 
....................     g_stAvgWtQueue.m_i8Length   = SIZE_AVG_WT_ARR; 
....................     g_stAvgWtQueue.m_i16CurAvg  = 0; 
....................     g_stAvgWtQueue.m_i8QueueFull = 0; 
....................      
....................     // Initialize array member. 
....................     for(ui8LoopCount = 0; ui8LoopCount < SIZE_AVG_WT_ARR; ui8LoopCount++) 
....................     { 
....................         g_stAvgWtQueue.m_i16Arr[ui8LoopCount] = 0; 
....................     } 
.................... } 
....................  
.................... void ResetAvgWtQueue(int8 i8Length) 
.................... { 
....................     if (i8Length <= SIZE_AVG_WT_ARR) 
....................     { 
....................         g_stAvgWtQueue.m_i8Length = i8Length; 
....................     } 
....................     else 
....................     { 
....................         g_stAvgWtQueue.m_i8Length = SIZE_AVG_WT_ARR; 
....................     } 
.................... } 
....................  
.................... void InsertAvgWtQueue(int16 i16LastWeight) 
.................... { 
....................     int8  i8LoopCount = 0; 
....................     int8  i8MaxEntry  = 0; 
....................     int32 i32Sum      = 0; 
....................      
....................     // Check the weight deviation from Selected SKU Average Weight 
....................     if (i16LastWeight > (g_stCurBatchInfo.m_i16AvgWeight + MAX_DEVIATIION_FROM_AVG_WT) || 
....................         i16LastWeight < (g_stCurBatchInfo.m_i16AvgWeight - MAX_DEVIATIION_FROM_AVG_WT)) 
....................     { 
....................         // The weight is out of range, we are not inserting this weight into Average weight queue  
....................         return; 
....................     } 
....................      
....................     // Increment Rear 
....................     g_stAvgWtQueue.m_i8Rear++; 
....................      
....................     // Check if the current weight is a new batch weight. 
....................     if(i16LastWeight >= g_stAvgWtQueue.m_i16LstAvg + MAX_DEVIATION_FOR_BATCH_CHANGE) 
....................     { 
....................         g_stAvgWtQueue.m_i8Rear = 0; 
....................     } 
....................      
....................     // Check queue length according to auto/fixed calibration mode. 
....................     // If in auto calibration mode then data will be inserted upto user input stored avg queue length. 
....................     if(HMI_REJECTION_AUTO_CALIB_MODE == g_fRejectionMode) 
....................     { 
....................         if (g_stAvgWtQueue.m_i8Rear >= g_stAvgWtQueue.m_i8Length) 
....................         { 
....................             g_stAvgWtQueue.m_i8Rear      = 0; 
....................             // Update state Queue Full 
....................             g_stAvgWtQueue.m_i8QueueFull = 1; 
....................         } 
....................     } 
....................     // Otherwise in fixed calibration mode data will be inserted upto queue's original length. 
....................     else 
....................     { 
....................         if (g_stAvgWtQueue.m_i8Rear >= SIZE_AVG_WT_ARR) 
....................         { 
....................             g_stAvgWtQueue.m_i8Rear      = 0; 
....................             // Update state Queue Full 
....................             g_stAvgWtQueue.m_i8QueueFull = 1; 
....................         } 
....................     } 
....................      
....................     // Insert into Queue 
....................     g_stAvgWtQueue.m_i16Arr[g_stAvgWtQueue.m_i8Rear] = i16LastWeight; 
....................      
....................     // Get the Max entry in queue 
....................     if (1 == g_stAvgWtQueue.m_i8QueueFull) 
....................     { 
....................         if(HMI_REJECTION_AUTO_CALIB_MODE == g_fRejectionMode) 
....................         {     
....................             // Set maximum counted data for average calculation. 
....................             i8MaxEntry = g_stAvgWtQueue.m_i8Length; 
....................              
....................             // Reset queue full flag. 
....................             g_stAvgWtQueue.m_i8QueueFull = 0; 
....................         } 
....................         else 
....................         { 
....................             // Set maximum counted data for average calculation. 
....................             i8MaxEntry = SIZE_AVG_WT_ARR; 
....................              
....................             // Reset queue full flag. 
....................             g_stAvgWtQueue.m_i8QueueFull = 0; 
....................         } 
....................     } 
....................     else 
....................     { 
....................         i8MaxEntry = g_stAvgWtQueue.m_i8Rear + 1; 
....................     } 
....................      
....................     // Get the summation of queue values    
....................     for (i8LoopCount = 0; i8LoopCount < i8MaxEntry; i8LoopCount++) 
....................     { 
....................         i32Sum += g_stAvgWtQueue.m_i16Arr[i8LoopCount]; 
....................     } 
....................      
....................     g_stAvgWtQueue.m_i16CurAvg = (int16)(i32Sum / (int32)i8MaxEntry); 
....................      
....................     // Store the current average in last average of all CBBs. 
....................     g_stAvgWtQueue.m_i16LstAvg = g_stAvgWtQueue.m_i16CurAvg; 
.................... } 
....................  
.................... void IBCSendProdModeAvgData() 
.................... { 
....................     ST_IBC_DATA_NODE stIBCDataNode; 
....................     int8 i8LoopCount = 0; 
....................      
....................  
....................     // Prepare IBC Data Node 
....................     g_unIBCProdModeAvg.m_stAvgData.m_i16Padding  = 0; 
....................     g_unIBCProdModeAvg.m_stAvgData.m_i16CurAvg   = g_stAvgWtQueue.m_i16CurAvg; 
....................      
....................     // Stuff IBC Command 
....................     stIBCDataNode.g_ui8ArrIBCData[0] = IBC_CMD_PROD_AVG_WT_DATA; 
....................     for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         stIBCDataNode.g_ui8ArrIBCData[i8LoopCount] = g_unIBCProdModeAvg.m_ui8Arr[i8LoopCount - 1]; 
....................     } 
....................      
....................     // Send to IBC Insert 
....................     //InsertSendQueue(&stIBCDataNode); 
....................     InsertIBCMsgQueue(&g_stIBCSendQueue, &stIBCDataNode); 
.................... } 
.................... #endif	/* VM_AVERAGE_WEIGHT_CALCULATION_H */ 
....................  
....................  
....................  
....................  
.................... // State 1: Home State 
.................... unsigned int8 StateFunc_SM0_State1(int8 i8StateMachine, int8 i8State) 
.................... { 
....................     // First set the DOs 
....................     StateFunc_GenericState(i8StateMachine, i8State); 
*
02348:  CALL   21E6
....................  
....................     // Step 1: Start Reading the ADC Data for Weighing 
....................     ResetADCDataQ(COLLECT_DYNAMIC_TARE_DATA); 
0234C:  MOVLW  03
0234E:  MOVLB  A
02350:  MOVWF  xBF
02352:  MOVLB  0
02354:  CALL   06A4
....................  
....................     // Step 2: Start ADC Scanning 
....................     g_ui8ADCScanningStatus = ADC_SCAN_ON; 
02358:  MOVLW  01
0235A:  MOVLB  4
0235C:  MOVWF  x43
....................      
....................     // Reset Weighing Calculation Status 
....................     g_fWtCalculationState = FLAG_WT_CALCULATION_NOT_DONE; 
0235E:  MOVLB  3
02360:  CLRF   x99
....................  
....................     return 0; 
02362:  MOVLW  00
02364:  MOVWF  01
02366:  MOVLB  0
02368:  RETURN 0
.................... } 
....................  
.................... // State 2: Box Touches Box Entry Sensor 
.................... unsigned int8 StateFunc_SM0_State2(int8 i8StateMachine, int8 i8State) 
.................... { 
....................     // First set the DOs 
....................     StateFunc_GenericState(i8StateMachine, i8State); 
0236A:  CALL   21E6
....................      
....................     // Step 1: Stop Tare Data Collection 
....................     g_ui8ADCScanningStatus = ADC_SCAN_OFF; 
0236E:  MOVLB  4
02370:  CLRF   x43
....................      
....................     // Step 2: Stop Intermediate Data Sending 
....................     g_fIntermediateDataSend = IBC_INTERMEDIATE_DATA_SEND_OFF; // Dose not matter but Still for safety ... 
02372:  MOVLB  3
02374:  CLRF   x9F
....................      
....................     // Step 3: Stop Main Split Average Calculations and IBC Intermediate Data Sending 
....................     //         and Start fresh Calculations from Start for Final Tare Values 
....................     // Reset Flags 
....................     g_ui8ADCMeanCalState  = ADC_MEAN_CALCULATION_START; 
02376:  MOVLB  4
02378:  CLRF   x36
....................     g_ui8ADCMeanDataState = ADC_MEAN_DATA_FINAL_TARE; 
0237A:  MOVLW  22
0237C:  MOVLB  3
0237E:  MOVWF  x98
....................  
....................     return 0; 
02380:  MOVLW  00
02382:  MOVWF  01
02384:  MOVLB  0
02386:  RETURN 0
.................... } 
....................  
.................... // State 3: Box Touches the Stopper Sensor 
.................... unsigned int8 StateFunc_SM0_State3(int8 i8StateMachine, int8 i8State) 
.................... { 
....................     // Moves up the Stopper 
....................  
....................     // First set the DOs 
....................     StateFunc_GenericState(i8StateMachine, i8State); 
02388:  CALL   21E6
....................      
....................     return 0; 
0238C:  MOVLW  00
0238E:  MOVWF  01
02390:  RETURN 0
.................... } 
....................  
.................... // State 4: Box Completely Entered into the weighing Conveyor 
.................... unsigned int8 StateFunc_SM0_State4(int8 i8StateMachine, int8 i8State) 
.................... { 
....................     // First set the DOs 
....................     StateFunc_GenericState(i8StateMachine, i8State); 
02392:  CALL   21E6
....................      
....................     // Step 1: Start Reading the ADC Data for Weighing 
....................     ResetADCDataQ(COLLECT_WEIGHING_DATA); 
02396:  MOVLW  04
02398:  MOVLB  A
0239A:  MOVWF  xBF
0239C:  MOVLB  0
0239E:  CALL   06A4
....................      
....................     // Step 2: Start ADC Scanning 
....................     g_ui8ADCScanningStatus = ADC_SCAN_ON; 
023A2:  MOVLW  01
023A4:  MOVLB  4
023A6:  MOVWF  x43
....................     return 0; 
023A8:  MOVLW  00
023AA:  MOVWF  01
023AC:  MOVLB  0
023AE:  RETURN 0
.................... } 
....................  
.................... // State 5: Small Box Exits from Stopper Sensor		 
.................... unsigned int8 StateFunc_SM0_State5(int8 i8StateMachine, int8 i8State) 
.................... { 
....................     // First set the DOs 
....................     StateFunc_GenericState(i8StateMachine, i8State); 
023B0:  CALL   21E6
....................      
....................     return 0; 
023B4:  MOVLW  00
023B6:  MOVWF  01
023B8:  RETURN 0
.................... } 
....................  
.................... // State 6 and State 7:  Small or Big Box Touches The Exit Sensor 
.................... unsigned int8 StateFunc_SM0_State6_7(int8 i8StateMachine, int8 i8State) 
.................... { 
....................     // First set the DOs 
....................     StateFunc_GenericState(i8StateMachine, i8State); 
023BA:  CALL   21E6
....................      
....................     // Raise a flag to get a delay between box left the exit sensor and achieving home state. 
....................     g_unDIState.m_stAllDIBits.m_ui1GDICn03 = BOX_LEFT_DELAY_START; 
023BE:  BCF    1A.2
....................      
....................     if (FLAG_WT_CALCULATION_DONE == g_fWtCalculationState) 
023C0:  MOVLB  3
023C2:  DECFSZ x99,W
023C4:  GOTO   23D0
....................     { 
....................         return 0; 
023C8:  MOVLW  00
023CA:  MOVWF  01
023CC:  GOTO   23FE
....................     } 
....................     // Step 1: Stop Weighing Data Collection 
....................     g_ui8ADCScanningStatus = ADC_SCAN_OFF; 
023D0:  MOVLB  4
023D2:  CLRF   x43
....................      
....................     if (IBC_RESET_CALIB_ON == g_fResetCalibStatus) 
023D4:  MOVLB  3
023D6:  DECFSZ xAC,W
023D8:  GOTO   23EA
....................     { 
....................         g_ui8ADCMeanCalState  = ADC_MEAN_CALCULATION_START; 
023DC:  MOVLB  4
023DE:  CLRF   x36
....................         g_ui8ADCMeanDataState = ADC_MEAN_DATA_CALIB_WEIGHT; 
023E0:  MOVLW  23
023E2:  MOVLB  3
023E4:  MOVWF  x98
....................     } 
023E6:  GOTO   23FA
....................  
....................     else 
....................     { 
....................         // Step 1: Increment Box Count 
....................        g_ui16CurrentBoxCount++; 
023EA:  INCF   x9A,F
023EC:  BTFSC  FD8.2
023EE:  INCF   x9B,F
....................         
....................         // Step 2: Get Weighing Data 
....................         g_ui8ADCMeanCalState  = ADC_MEAN_CALCULATION_START; 
023F0:  MOVLB  4
023F2:  CLRF   x36
....................         g_ui8ADCMeanDataState = ADC_MEAN_DATA_FINAL_WEIGHT; 
023F4:  MOVLW  21
023F6:  MOVLB  3
023F8:  MOVWF  x98
....................     } 
....................      
....................     return 0; 
023FA:  MOVLW  00
023FC:  MOVWF  01
023FE:  MOVLB  0
02400:  RETURN 0
.................... } 
....................  
....................  
.................... // State 8: Small Box Touches Exit Sensor 
.................... unsigned int8 StateFunc_SM0_State8(int8 i8StateMachine, int8 i8State) 
.................... { 
....................     // First set the DOs 
....................     StateFunc_GenericState(i8StateMachine, i8State); 
02402:  CALL   21E6
....................      
....................  
....................      
....................     return 0; 
02406:  MOVLW  00
02408:  MOVWF  01
0240A:  RETURN 0
.................... } 
....................  
.................... ////// State 8: Box Left Exit Sensor(HOME) 
.................... ////unsigned int8 StateFunc_SM0_State8(int8 i8StateMachine, int8 i8State) 
.................... ////{ 
.................... ////    // First set the DOs 
.................... ////    StateFunc_GenericState(i8StateMachine, i8State); 
.................... ////     
.................... ////    return 0; 
.................... ////} 
....................  
.................... // Define State Lookup Table 
.................... void Initialize_StateMachine_0() 
.................... { 
....................     // Initialize State DI Filter 
....................     g_stArrStateMachines[STATE_MACHINE_0].m_ui32StateDIFilter      = STATE_SM0_HWDI_FILTER; 
*
00832:  MOVLW  D0
00834:  MOVLB  1
00836:  MOVWF  x65
00838:  CLRF   x64
0083A:  CLRF   x63
0083C:  MOVLW  10
0083E:  MOVWF  x62
....................     g_stArrStateMachines[STATE_MACHINE_0].m_ui16StateDOFilter      = STATE_SM0_HWDO_FILTER; 
00840:  MOVLW  80
00842:  MOVWF  x67
00844:  CLRF   x66
....................     g_stArrStateMachines[STATE_MACHINE_0].m_uiStateCounterFilter   = 0x0000; 
00846:  CLRF   x69
00848:  CLRF   x68
....................     g_stArrStateMachines[STATE_MACHINE_0].m_ui32LastDIState        = STATE_SM0_HWDI_01; 
0084A:  MOVLW  D0
0084C:  MOVLB  2
0084E:  MOVWF  x21
00850:  CLRF   x20
00852:  CLRF   x1F
00854:  MOVLW  10
00856:  MOVWF  x1E
....................     g_stArrStateMachines[STATE_MACHINE_0].m_ui16LastDOState        = STATE_SM0_HWDO_01; 
00858:  MOVLW  80
0085A:  MOVWF  x23
0085C:  CLRF   x22
....................     g_stArrStateMachines[STATE_MACHINE_0].m_i8PrevState            = STATE_01; 
0085E:  MOVLW  01
00860:  MOVWF  x28
....................     //g_stArrStateMachines[STATE_MACHINE_0].m_fContinue = STATE_CONTINUE_OFF; 
....................      
....................     // Initialize Expected Next State for all States 
....................     // We are leaving first state index for No State 
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[0].m_ui32DIState     = 0x0; 
00862:  MOVLB  1
00864:  CLRF   xA9
00866:  CLRF   xA8
00868:  CLRF   xA7
0086A:  CLRF   xA6
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[0].m_ui16DOState     = 0x0;     
0086C:  CLRF   xAB
0086E:  CLRF   xAA
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[0].pFunStateFunction = StateFunc_GenericState;//(STATE_MACHINE_0, STATE_NOTHING); 
00870:  MOVWF  FEA
00872:  MOVLW  B0
00874:  MOVWF  FE9
00876:  MOVLW  21
00878:  MOVWF  03
0087A:  MOVLW  E6
0087C:  MOVFF  03,01
00880:  CLRF   02
00882:  CLRF   03
00884:  MOVWF  FEF
00886:  MOVFF  01,FEC
0088A:  MOVFF  02,FEC
0088E:  MOVFF  03,FEC
....................  
....................     // SM0: State 01: SM0: Home State, Expected no CBBs are in Weighing Conveyor 
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_01].m_ui32DIState = STATE_SM0_HWDI_01; 
00892:  MOVLW  D0
00894:  MOVWF  xB5
00896:  CLRF   xB4
00898:  CLRF   xB3
0089A:  MOVLW  10
0089C:  MOVWF  xB2
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_01].m_ui16DOState = STATE_SM0_HWDO_01; 
0089E:  MOVLW  80
008A0:  MOVWF  xB7
008A2:  CLRF   xB6
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_01].m_i8ArrExpNextState[0] = STATE_02; 
008A4:  MOVLW  02
008A6:  MOVWF  xB8
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_01].m_i8ArrExpNextState[1] = STATE_NOTHING; 
008A8:  CLRF   xB9
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_01].m_i8ArrExpNextState[2] = STATE_NOTHING; 
008AA:  CLRF   xBA
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_01].m_i8ArrExpNextState[3] = STATE_NOTHING; 
008AC:  CLRF   xBB
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_01].pFunStateFunction = StateFunc_SM0_State1;//(STATE_MACHINE_0, STATE_01); 
008AE:  MOVLW  01
008B0:  MOVWF  FEA
008B2:  MOVLW  BC
008B4:  MOVWF  FE9
008B6:  MOVLW  23
008B8:  MOVWF  03
008BA:  MOVLW  48
008BC:  MOVFF  03,01
008C0:  CLRF   02
008C2:  CLRF   03
008C4:  MOVWF  FEF
008C6:  MOVFF  01,FEC
008CA:  MOVFF  02,FEC
008CE:  MOVFF  03,FEC
....................  
....................     // SM0: State 02: Box Touches Box Entry Sensor 
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_02].m_ui32DIState = STATE_SM0_HWDI_02; 
008D2:  MOVLW  50
008D4:  MOVWF  xC1
008D6:  CLRF   xC0
008D8:  CLRF   xBF
008DA:  MOVLW  10
008DC:  MOVWF  xBE
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_02].m_ui16DOState = STATE_SM0_HWDO_02; 
008DE:  MOVLW  80
008E0:  MOVWF  xC3
008E2:  CLRF   xC2
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[0] = STATE_03; 
008E4:  MOVLW  03
008E6:  MOVWF  xC4
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[1] = STATE_NOTHING; 
008E8:  CLRF   xC5
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[2] = STATE_NOTHING; 
008EA:  CLRF   xC6
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[3] = STATE_NOTHING; 
008EC:  CLRF   xC7
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_02].pFunStateFunction = StateFunc_SM0_State2;//(STATE_MACHINE_0, STATE_02); 
008EE:  MOVLW  01
008F0:  MOVWF  FEA
008F2:  MOVLW  C8
008F4:  MOVWF  FE9
008F6:  MOVLW  23
008F8:  MOVWF  03
008FA:  MOVLW  6A
008FC:  MOVFF  03,01
00900:  CLRF   02
00902:  CLRF   03
00904:  MOVWF  FEF
00906:  MOVFF  01,FEC
0090A:  MOVFF  02,FEC
0090E:  MOVFF  03,FEC
....................      
....................     // SM0: State 03: Box Touches Box Stopper Sensor 
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_03].m_ui32DIState = STATE_SM0_HWDI_03; 
00912:  MOVLW  10
00914:  MOVWF  xCD
00916:  CLRF   xCC
00918:  CLRF   xCB
0091A:  MOVWF  xCA
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_03].m_ui16DOState = STATE_SM0_HWDO_03; 
0091C:  CLRF   xCF
0091E:  CLRF   xCE
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_03].m_i8ArrExpNextState[0] = STATE_04; 
00920:  MOVLW  04
00922:  MOVWF  xD0
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_03].m_i8ArrExpNextState[1] = STATE_NOTHING; 
00924:  CLRF   xD1
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_03].m_i8ArrExpNextState[2] = STATE_NOTHING; 
00926:  CLRF   xD2
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_03].m_i8ArrExpNextState[3] = STATE_NOTHING; 
00928:  CLRF   xD3
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_03].pFunStateFunction = StateFunc_SM0_State3;//(STATE_MACHINE_0, STATE_02); 
0092A:  MOVLW  01
0092C:  MOVWF  FEA
0092E:  MOVLW  D4
00930:  MOVWF  FE9
00932:  MOVLW  23
00934:  MOVWF  03
00936:  MOVLW  88
00938:  MOVFF  03,01
0093C:  CLRF   02
0093E:  CLRF   03
00940:  MOVWF  FEF
00942:  MOVFF  01,FEC
00946:  MOVFF  02,FEC
0094A:  MOVFF  03,FEC
....................      
....................     // SM0: State 04: Box Completely Entered into Weighing Conveyor 
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_04].m_ui32DIState = STATE_SM0_HWDI_04; 
0094E:  MOVLW  90
00950:  MOVWF  xD9
00952:  CLRF   xD8
00954:  CLRF   xD7
00956:  MOVLW  10
00958:  MOVWF  xD6
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_04].m_ui16DOState = STATE_SM0_HWDO_04; 
0095A:  CLRF   xDB
0095C:  CLRF   xDA
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_04].m_i8ArrExpNextState[0] = STATE_05; 
0095E:  MOVLW  05
00960:  MOVWF  xDC
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_04].m_i8ArrExpNextState[1] = STATE_06; 
00962:  MOVLW  06
00964:  MOVWF  xDD
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_04].m_i8ArrExpNextState[2] = STATE_NOTHING; 
00966:  CLRF   xDE
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_04].m_i8ArrExpNextState[3] = STATE_NOTHING; 
00968:  CLRF   xDF
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_04].pFunStateFunction = StateFunc_SM0_State4;//(STATE_MACHINE_0, STATE_02); 
0096A:  MOVLW  01
0096C:  MOVWF  FEA
0096E:  MOVLW  E0
00970:  MOVWF  FE9
00972:  MOVLW  23
00974:  MOVWF  03
00976:  MOVLW  92
00978:  MOVFF  03,01
0097C:  CLRF   02
0097E:  CLRF   03
00980:  MOVWF  FEF
00982:  MOVFF  01,FEC
00986:  MOVFF  02,FEC
0098A:  MOVFF  03,FEC
....................   
....................     // SM0: State 05: Small Box Exits from Stopper Sensor 
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_05].m_ui32DIState = STATE_SM0_HWDI_05; 
0098E:  MOVLW  D0
00990:  MOVWF  xE5
00992:  CLRF   xE4
00994:  CLRF   xE3
00996:  MOVLW  10
00998:  MOVWF  xE2
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_05].m_ui16DOState = STATE_SM0_HWDO_05; 
0099A:  CLRF   xE7
0099C:  CLRF   xE6
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_05].m_i8ArrExpNextState[0] = STATE_07; 
0099E:  MOVLW  07
009A0:  MOVWF  xE8
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_05].m_i8ArrExpNextState[1] = STATE_NOTHING; 
009A2:  CLRF   xE9
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_05].m_i8ArrExpNextState[2] = STATE_NOTHING; 
009A4:  CLRF   xEA
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_05].m_i8ArrExpNextState[3] = STATE_NOTHING; 
009A6:  CLRF   xEB
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_05].pFunStateFunction = StateFunc_SM0_State5;//(STATE_MACHINE_0, STATE_02); 
009A8:  MOVLW  01
009AA:  MOVWF  FEA
009AC:  MOVLW  EC
009AE:  MOVWF  FE9
009B0:  MOVLW  23
009B2:  MOVWF  03
009B4:  MOVLW  B0
009B6:  MOVFF  03,01
009BA:  CLRF   02
009BC:  CLRF   03
009BE:  MOVWF  FEF
009C0:  MOVFF  01,FEC
009C4:  MOVFF  02,FEC
009C8:  MOVFF  03,FEC
....................   
....................     // SM0: State 06: Big Box Touches Exit Sensor 
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_06].m_ui32DIState = STATE_SM0_HWDI_06; 
009CC:  MOVLW  80
009CE:  MOVWF  xF1
009D0:  CLRF   xF0
009D2:  CLRF   xEF
009D4:  MOVLW  10
009D6:  MOVWF  xEE
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_06].m_ui16DOState = STATE_SM0_HWDO_06; 
009D8:  CLRF   xF3
009DA:  CLRF   xF2
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_06].m_i8ArrExpNextState[0] = STATE_08; 
009DC:  MOVLW  08
009DE:  MOVWF  xF4
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_06].m_i8ArrExpNextState[1] = STATE_NOTHING; 
009E0:  CLRF   xF5
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_06].m_i8ArrExpNextState[2] = STATE_NOTHING; 
009E2:  CLRF   xF6
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_06].m_i8ArrExpNextState[3] = STATE_NOTHING; 
009E4:  CLRF   xF7
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_06].pFunStateFunction = StateFunc_SM0_State6_7;//(STATE_MACHINE_0, STATE_02); 
009E6:  MOVLW  01
009E8:  MOVWF  FEA
009EA:  MOVLW  F8
009EC:  MOVWF  FE9
009EE:  MOVLW  23
009F0:  MOVWF  03
009F2:  MOVLW  BA
009F4:  MOVFF  03,01
009F8:  CLRF   02
009FA:  CLRF   03
009FC:  MOVWF  FEF
009FE:  MOVFF  01,FEC
00A02:  MOVFF  02,FEC
00A06:  MOVFF  03,FEC
....................   
....................     // SM0: State 07: Small Box Touches Exit Sensor  
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_07].m_ui32DIState = STATE_SM0_HWDI_07; 
00A0A:  MOVLW  C0
00A0C:  MOVWF  xFD
00A0E:  CLRF   xFC
00A10:  CLRF   xFB
00A12:  MOVLW  10
00A14:  MOVWF  xFA
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_07].m_ui16DOState = STATE_SM0_HWDO_07; 
00A16:  CLRF   xFF
00A18:  CLRF   xFE
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_07].m_i8ArrExpNextState[0] = STATE_08; 
00A1A:  MOVLW  08
00A1C:  MOVLB  2
00A1E:  MOVWF  x00
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_07].m_i8ArrExpNextState[1] = STATE_NOTHING; 
00A20:  CLRF   x01
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_07].m_i8ArrExpNextState[2] = STATE_NOTHING; 
00A22:  CLRF   x02
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_07].m_i8ArrExpNextState[3] = STATE_NOTHING; 
00A24:  CLRF   x03
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_07].pFunStateFunction = StateFunc_SM0_State6_7;//(STATE_MACHINE_0, STATE_02); 
00A26:  MOVLW  02
00A28:  MOVWF  FEA
00A2A:  MOVLW  04
00A2C:  MOVWF  FE9
00A2E:  MOVLW  23
00A30:  MOVWF  03
00A32:  MOVLW  BA
00A34:  MOVFF  03,01
00A38:  CLRF   02
00A3A:  CLRF   03
00A3C:  MOVWF  FEF
00A3E:  MOVFF  01,FEC
00A42:  MOVFF  02,FEC
00A46:  MOVFF  03,FEC
....................      
....................     // SM0: State 08: Box Left Exit Sensor  
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_08].m_ui32DIState = STATE_SM0_HWDI_08; 
00A4A:  MOVLW  D0
00A4C:  MOVWF  x09
00A4E:  CLRF   x08
00A50:  CLRF   x07
00A52:  MOVLW  10
00A54:  MOVWF  x06
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_08].m_ui16DOState = STATE_SM0_HWDO_08; 
00A56:  CLRF   x0B
00A58:  CLRF   x0A
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_08].m_i8ArrExpNextState[0] = STATE_01; 
00A5A:  MOVLW  01
00A5C:  MOVWF  x0C
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_08].m_i8ArrExpNextState[1] = STATE_NOTHING; 
00A5E:  CLRF   x0D
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_08].m_i8ArrExpNextState[2] = STATE_NOTHING; 
00A60:  CLRF   x0E
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_08].m_i8ArrExpNextState[3] = STATE_NOTHING; 
00A62:  CLRF   x0F
....................     g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_08].pFunStateFunction = StateFunc_SM0_State8;//(STATE_MACHINE_0, STATE_02); 
00A64:  MOVLW  02
00A66:  MOVWF  FEA
00A68:  MOVLW  10
00A6A:  MOVWF  FE9
00A6C:  MOVLW  24
00A6E:  MOVWF  03
00A70:  MOVLW  02
00A72:  MOVFF  03,01
00A76:  CLRF   02
00A78:  CLRF   03
00A7A:  MOVWF  FEF
00A7C:  MOVFF  01,FEC
00A80:  MOVFF  02,FEC
00A84:  MOVFF  03,FEC
00A88:  MOVLB  0
00A8A:  GOTO   0C08 (RETURN)
....................  
.................... //    // SM0: State 09: Box Left Exit Sensor with Delay time  
.................... //    g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_09].m_ui32DIState = STATE_SM0_HWDI_09; 
.................... //    g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_09].m_ui16DOState = STATE_SM0_HWDO_09; 
.................... //    g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_09].m_i8ArrExpNextState[0] = STATE_01; 
.................... //    g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_09].m_i8ArrExpNextState[1] = STATE_NOTHING; 
.................... //    g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_09].m_i8ArrExpNextState[2] = STATE_NOTHING; 
.................... //    g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_09].m_i8ArrExpNextState[3] = STATE_NOTHING; 
.................... //    g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_09].pFunStateFunction = StateFunc_SM0_State8; 
.................... //     
.................... //    // SM0: State 10: Box Left Exit Sensor(HOME) 
.................... //    g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_10].m_ui32DIState = STATE_SM0_HWDI_08; 
.................... //    g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_10].m_ui16DOState = STATE_SM0_HWDO_08; 
.................... //    g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_10].m_i8ArrExpNextState[0] = STATE_01; 
.................... //    g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_10].m_i8ArrExpNextState[1] = STATE_NOTHING; 
.................... //    g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_10].m_i8ArrExpNextState[2] = STATE_NOTHING; 
.................... //    g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_10].m_i8ArrExpNextState[3] = STATE_NOTHING; 
.................... //    g_stArrStateMachines[STATE_MACHINE_0].m_stArrStateLookupTable[STATE_10].pFunStateFunction = StateFunc_SM0_State8; 
.................... }     
....................  
.................... #endif /* _VM_STATE_MACHINE_0_H_ */ 
....................  
.................... #include "vmStateMachine_1.h" 
....................  
.................... #ifndef _VM_STATE_MACHINE_1_H_ 
.................... #define _VM_STATE_MACHINE_1_H_ 
....................  
.................... /*************************** Inclusion files **********************************/ 
.................... #include "vmSystemConfig.h" 
....................  
.................... #ifndef _VI_SYSTEM_CONFIG_H_ 
.................... #define _VI_SYSTEM_CONFIG_H_ 
....................  
.................... //****************** Inclusion Files *************************** 
.................... #include "18F46K80.h" 
.................... #include "vmPINConfig.h" 
....................  
.................... //****************** Component Configuration ******************** 
....................  
.................... //optimization level. 
.................... #pragma opt 8 
....................   
.................... //********* CPU Settings ******************************************* 
....................  
.................... #pragma device HIGH_INTS=TRUE 
.................... #pragma fuses NOPLLEN,ECH,WDT1024,NOPROTECT,NOBROWNOUT,NOFCMEN,NOIESO,NOPUT /* WDT1024 => 1024 * 4 ms = 4096 mS Watchdog Timer */ /* For Field Mode */ 
....................  
.................... #pragma use delay(clock=20000000,restart_wdt) 
....................  
....................  
.................... //******** Serial Interface ************ 
.................... //#pragma use rs232(stream=RS485, xmit=PIN_RS485_XMIT, rcv=PIN_RS485_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
.................... #pragma use rs232(stream=ARD_RS232, xmit=PIN_LAN_COMM_XMIT, rcv=PIN_LAN_COMM_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
....................  
.................... //#define unsigned int8 BYTE 
.................... #ifndef M0_ADC_MODULE 
.................... #define M0_ADC_MODULE 1 
.................... #endif 
....................  
.................... #endif /* _VI_SYSTEM_CONFIG_H_ */ 
....................  
.................... #include "vmStateMachineForIMW_M0.h" 
.................... #ifndef _VM_STATE_MACHINE_FOR_IMW_M0_H_ 
.................... #define _VM_STATE_MACHINE_FOR_IMW_M0_H_ 
....................  
.................... #include "vmSystemConfig.h" 
.................... #include "vmStateMachine.h" 
....................  
.................... #define STPR_1_EMPTY_ON              0 
.................... #define STPR_1_EMPTY_OFF             1 
.................... #define STPR_0_SET_TRANSFERED_ON     0 
.................... #define STPR_0_SET_TRANSFERED_OFF    1 
.................... #define STPR_1_SET_TRANSFERED_ON     0 
.................... #define STPR_1_SET_TRANSFERED_OFF    1 
.................... #define STPR_1_CAN_SET_COUNT_DONE    0 
.................... #define STPR_1_CAN_SET_COUNT_NOT_DONE 1 
.................... #define PUSHER_EMPTY_ON              0 
.................... #define PUSHER_EMPTY_OFF             1 
.................... #define PUSHER_0_TIME_OUT_ON         0 
.................... #define PUSHER_0_TIME_OUT_OFF        1 
.................... #define PUSHER_0_ALL_DONE            0 
.................... #define PUSHER_0_ALL_NOT_DONE        1 
.................... #define PUSHER_1_TIME_OUT_ON         0 
.................... #define PUSHER_1_TIME_OUT_OFF        1 
.................... #define PUSHER_1_ALL_DONE            0 
.................... #define PUSHER_1_ALL_NOT_DONE        1 
.................... #define STACKER_READY_ON             0 
.................... #define STACKER_READY_OFF            1 
.................... #define PUSHER_0_FIRST_PUSH_ON       0 
.................... #define PUSHER_0_FIRST_PUSH_OFF      1 
.................... #define PUSHER_1_FIRST_PUSH_ON       0 
.................... #define PUSHER_1_FIRST_PUSH_OFF      1 
....................  
....................  
.................... #define SPCL_FLAG_SM_1_START_TRANSFER_OFF 0 
.................... #define SPCL_FLAG_SM_1_START_TRANSFER_ON  1 
....................  
....................  
.................... #define NO_OF_ACTIVE_MACHINE        2 
....................  
.................... #define INITAIL_DI_STATE_ON_PWR_ON   0xFFFF3F5F 
.................... #define INITAIL_DO_STATE_ON_PWR_ON   0x3FFF 
.................... #define SAFE_MODE_DO_STATE           0x3FFF 
.................... #define PRE_PRODUCTION_DO_STATE      0xBFFF 
....................  
.................... //////////////////// State Machine 0 DI DO States Start //////////////////////// 
.................... #define 	STATE_SM0_HWDI_FILTER	0xD0000010 
.................... #define 	STATE_SM0_HWDI_01	0xD0000010 
.................... #define 	STATE_SM0_HWDI_02	0x50000010 
.................... #define 	STATE_SM0_HWDI_03	0x10000010 
.................... #define 	STATE_SM0_HWDI_04	0x90000010 
.................... #define 	STATE_SM0_HWDI_05	0xD0000010 
.................... #define 	STATE_SM0_HWDI_06	0x80000010 
.................... #define 	STATE_SM0_HWDI_07	0xC0000010 
.................... #define 	STATE_SM0_HWDI_08	0xD0000010 
.................... #define 	STATE_SM0_HWDI_09	0xD0000000 
.................... #define 	STATE_SM0_HWDI_10	0xD0000010 
....................  
.................... #define 	STATE_SM0_HWDO_FILTER	0x8000 
.................... #define 	STATE_SM0_HWDO_01	0x8000 
.................... #define 	STATE_SM0_HWDO_02	0x8000 
.................... #define 	STATE_SM0_HWDO_03	0x0000 
.................... #define 	STATE_SM0_HWDO_04	0x0000 
.................... #define 	STATE_SM0_HWDO_05	0x0000 
.................... #define 	STATE_SM0_HWDO_06	0x0000 
.................... #define 	STATE_SM0_HWDO_07	0x0000 
.................... #define 	STATE_SM0_HWDO_08	0x0000 
.................... #define 	STATE_SM0_HWDO_09	0x0000 
.................... #define 	STATE_SM0_HWDO_10	0x8000 
....................  
....................  
.................... //////////////////// State Machine 0 DI DO States End ////////////////////////// 
....................  
.................... //////////////////// State Machine 1 DI DO States Start //////////////////////// 
.................... #define 	STATE_SM1_HWDI_FILTER	0x08001800 
.................... #define 	STATE_SM1_HWDI_01	0x08000800 
.................... #define 	STATE_SM1_HWDI_02	0x00000800 
.................... #define 	STATE_SM1_HWDI_03	0x00001800 
.................... #define 	STATE_SM1_HWDI_04	0x08000000 
....................  
.................... #define 	STATE_SM1_HWDO_FILTER	0x4000 
.................... #define 	STATE_SM1_HWDO_01	0x4000 
.................... #define 	STATE_SM1_HWDO_02	0x0000 
.................... #define 	STATE_SM1_HWDO_03	0x4000 
.................... #define 	STATE_SM1_HWDO_04	0x4000 
....................  
.................... //#define 	STATE_SM1_HWDI_FILTER	0x0C001800 
.................... //#define 	STATE_SM1_HWDI_01	0x0C000800 
.................... //#define 	STATE_SM1_HWDI_02	0x08000800 
.................... //#define 	STATE_SM1_HWDI_03	0x04000800 
.................... //#define 	STATE_SM1_HWDI_04	0x04001800 
.................... //#define 	STATE_SM1_HWDI_05	0x00000800 
.................... //#define 	STATE_SM1_HWDI_06	0x0C000000 
.................... // 
.................... //#define 	STATE_SM1_HWDO_FILTER	0x4000 
.................... //#define 	STATE_SM1_HWDO_01	0x4000 
.................... //#define 	STATE_SM1_HWDO_02	0x4000 
.................... //#define 	STATE_SM1_HWDO_03	0x0000 
.................... //#define 	STATE_SM1_HWDO_04	0x4000 
.................... //#define 	STATE_SM1_HWDO_05	0x4000 
.................... //#define 	STATE_SM1_HWDO_06	0x4000 
.................... //////////////////// State Machine 1 DI DO States End ////////////////////////// 
....................  
.................... ST_STATE_MACHINE g_stArrStateMachines[NO_OF_ACTIVE_MACHINE]; 
....................  
.................... unsigned int8 g_fStateMac1StartCanTransfer = SPCL_FLAG_SM_1_START_TRANSFER_ON; 
....................  
....................  
....................  
.................... //void InitializeStateMachines() 
.................... //{ 
....................     //g_unDIState.m_ui32AllDIs = 0xFFFFFFFF; 
....................     //g_unDOState.m_ui16AllDOs = 0xFFFF; 
.................... //} 
.................... /* 
.................... // 01 : Home State 
.................... unsigned int8 StateFunc_GenericState(int8 i8StateMachine, int8 i8State) 
.................... { 
....................     // Take action 
....................     // Main intention is to not change values of other DO fields, except the fields under the state DO Filter 
....................     // Also only the changes will added to the original ALL DOs  
....................     unsigned int16 ui16Temp0 = 0; 
....................     unsigned int16 ui16Temp1 = 0; 
....................     //g_unAllDOs.m_ui16AllDOs = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState; 
....................      
....................     // Hold the Current DO Values to temp 
....................     ui16Temp0 = g_unDOState.m_ui16AllDOs; 
....................  
....................     // Bitwise AND with the State DO Filter with the Value to change 
....................     ui16Temp1 = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState & 
....................                 g_stArrStateMachines[i8StateMachine].m_ui16StateDOFilter; 
....................      
....................     // Finally Bitwise OR operation between original value to the temp 
....................     g_unDOState.m_ui16AllDOs = ui16Temp0 | ui16Temp1; 
....................  
....................     return 0; 
.................... }  
.................... */ 
.................... unsigned int8 StateFunc_GenericState_(int8 i8StateMachine, int8 i8State) 
.................... { 
....................  
....................         unsigned int16 ui8DO       = g_unDOState.m_ui16AllDOs; 
....................         unsigned int16 ui8Filter   = g_stArrStateMachines[i8StateMachine].m_ui16StateDOFilter; 
....................         unsigned int16 ui8Value    = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState; 
....................         unsigned int16 ui8BitValue = 0; 
....................          
....................         for(int i = 0; i < 16; i++) 
....................         { 
....................             if(1 == ((ui8Filter >> i)&0x0001)) 
....................             { 
....................                 ui8BitValue = ((ui8Value >> i)&0x0001); 
....................                 ui8DO = (ui8DO & (~(1 << i))) | (ui8BitValue << i); 
....................             } 
....................         } 
....................  
....................     g_unDOState.m_ui16AllDOs = ui8DO; 
....................     return 0; 
.................... }  
....................  
.................... unsigned int8 StateFunc_GenericState(int8 i8StateMachine, int8 i8State) 
.................... { 
....................     UN_ALL_DOS unFilter; 
....................     UN_ALL_DOS unValue; 
....................      
....................     unFilter.m_ui16AllDOs = g_stArrStateMachines[i8StateMachine].m_ui16StateDOFilter; 
....................     unValue.m_ui16AllDOs  = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState; 
....................      
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn00) g_unDOState.m_stAllDOBits.m_ui1HWDOCn00 = unValue.m_stAllDOBits.m_ui1HWDOCn00; 
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn01) g_unDOState.m_stAllDOBits.m_ui1HWDOCn01 = unValue.m_stAllDOBits.m_ui1HWDOCn01; 
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn02) g_unDOState.m_stAllDOBits.m_ui1HWDOCn02 = unValue.m_stAllDOBits.m_ui1HWDOCn02; 
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn03) g_unDOState.m_stAllDOBits.m_ui1HWDOCn03 = unValue.m_stAllDOBits.m_ui1HWDOCn03; 
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn04) g_unDOState.m_stAllDOBits.m_ui1HWDOCn04 = unValue.m_stAllDOBits.m_ui1HWDOCn04; 
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn05) g_unDOState.m_stAllDOBits.m_ui1HWDOCn05 = unValue.m_stAllDOBits.m_ui1HWDOCn05; 
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn06) g_unDOState.m_stAllDOBits.m_ui1HWDOCn06 = unValue.m_stAllDOBits.m_ui1HWDOCn06; 
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn07) g_unDOState.m_stAllDOBits.m_ui1HWDOCn07 = unValue.m_stAllDOBits.m_ui1HWDOCn07; 
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn00) g_unDOState.m_stAllDOBits.m_ui1SRDOCn00 = unValue.m_stAllDOBits.m_ui1SRDOCn00; 
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn01) g_unDOState.m_stAllDOBits.m_ui1SRDOCn01 = unValue.m_stAllDOBits.m_ui1SRDOCn01; 
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn02) g_unDOState.m_stAllDOBits.m_ui1SRDOCn02 = unValue.m_stAllDOBits.m_ui1SRDOCn02; 
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn03) g_unDOState.m_stAllDOBits.m_ui1SRDOCn03 = unValue.m_stAllDOBits.m_ui1SRDOCn03; 
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn04) g_unDOState.m_stAllDOBits.m_ui1SRDOCn04 = unValue.m_stAllDOBits.m_ui1SRDOCn04; 
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn05) g_unDOState.m_stAllDOBits.m_ui1SRDOCn05 = unValue.m_stAllDOBits.m_ui1SRDOCn05; 
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn06) g_unDOState.m_stAllDOBits.m_ui1SRDOCn06 = unValue.m_stAllDOBits.m_ui1SRDOCn06; 
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn07) g_unDOState.m_stAllDOBits.m_ui1SRDOCn07 = unValue.m_stAllDOBits.m_ui1SRDOCn07; 
....................      
.................... }     
....................  
....................          
....................  
....................          
.................... // 02: Start to Pick 
.................... unsigned int8 StateFunc_State02() 
.................... { 
....................     // We got message from outer board that Stacker Ready and Hopper Ready 
....................     // Now PD will start moving downword 
....................     //g_unAllDOs.m_bArr[2] = 1; 
....................     //g_unAllDOs.m_bArr[3] = 0; 
....................     // Expected Next State Declaration 
....................     g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[0] = STATE_03; 
....................     g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[1] = STATE_03; 
....................     g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[2] = STATE_03; 
....................     g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[3] = STATE_03; 
....................     return 0; 
.................... } 
....................  
....................  
.................... void InitExpNextStateDefault() 
.................... { 
....................     int8 i8StMcCount = 0; 
....................     int8 i8StCount   = 0; 
....................     int8 i8ExpNxtCount = 0; 
....................     for (i8StMcCount = 0; i8StMcCount < NO_OF_ACTIVE_MACHINE; i8StMcCount++) 
....................     { 
....................         // For all Active Look up tables 
....................         for (i8StCount = 0; i8StCount < MAX_NUMBER_OF_STATE; i8StCount++) 
....................         { 
....................             for (i8ExpNxtCount = 0; i8ExpNxtCount < MAX_NO_OF_EXP_NXT_STATES; i8ExpNxtCount++) 
....................             { 
....................                 g_stArrStateMachines[i8StMcCount].m_stArrStateLookupTable[i8StCount].m_i8ArrExpNextState[i8ExpNxtCount] = STATE_NOTHING; 
....................             } 
....................         } 
....................     } 
.................... } 
....................  
.................... void PostProductionSafeMode() 
.................... { 
....................     g_unDOState.m_ui16AllDOs = 0xFFFF; 
....................      
....................     // 1. Stopper 0 is in Push State 
....................     // 2. Can Stopper 1 is in Push state 
....................     // 3. Pusher 0, Pusher 1 and Can Guide all is in drag state 
....................     g_unDOState.m_ui16AllDOs = SAFE_MODE_DO_STATE; 
....................     ExecuteALLDOs(); 
.................... } 
....................  
.................... void PowerOnDOStateInit() 
.................... { 
....................     g_unDOState.m_ui16AllDOs = 0xFFFF; 
....................      
....................     // 1. Stopper 0 is in drag State 
....................     // 2. Can Stopper 1 is in Push state 
....................     // 3. Pusher 0, Pusher 1 and Can Guide all is in drag state 
....................     g_unDOState.m_ui16AllDOs = INITAIL_DO_STATE_ON_PWR_ON; 
....................     ExecuteALLDOs(); 
.................... } 
....................  
.................... #endif /* _VI_STATE_MACHINE_FOR_CP_H_ */ 
....................  
....................  
.................... //#include "vmSystemConfig.h" 
.................... ////#include "vmStateMachine.h" 
.................... // 
.................... //#define STPR_1_EMPTY_ON              0 
.................... //#define STPR_1_EMPTY_OFF             1 
.................... //#define STPR_0_SET_TRANSFERED_ON     0 
.................... //#define STPR_0_SET_TRANSFERED_OFF    1 
.................... //#define STPR_1_SET_TRANSFERED_ON     0 
.................... //#define STPR_1_SET_TRANSFERED_OFF    1 
.................... //#define STPR_1_CAN_SET_COUNT_DONE    0 
.................... //#define STPR_1_CAN_SET_COUNT_NOT_DONE 1 
.................... //#define PUSHER_EMPTY_ON              0 
.................... //#define PUSHER_EMPTY_OFF             1 
.................... //#define PUSHER_0_TIME_OUT_ON         0 
.................... //#define PUSHER_0_TIME_OUT_OFF        1 
.................... //#define PUSHER_0_ALL_DONE            0 
.................... //#define PUSHER_0_ALL_NOT_DONE        1 
.................... //#define PUSHER_1_TIME_OUT_ON         0 
.................... //#define PUSHER_1_TIME_OUT_OFF        1 
.................... //#define PUSHER_1_ALL_DONE            0 
.................... //#define PUSHER_1_ALL_NOT_DONE        1 
.................... //#define STACKER_READY_ON             0 
.................... //#define STACKER_READY_OFF            1 
.................... //#define PUSHER_0_FIRST_PUSH_ON       0 
.................... //#define PUSHER_0_FIRST_PUSH_OFF      1 
.................... //#define PUSHER_1_FIRST_PUSH_ON       0 
.................... //#define PUSHER_1_FIRST_PUSH_OFF      1 
.................... // 
.................... // 
.................... //#define SPCL_FLAG_SM_1_START_TRANSFER_OFF 0 
.................... //#define SPCL_FLAG_SM_1_START_TRANSFER_ON  1 
.................... // 
.................... // 
.................... //#define NO_OF_ACTIVE_MACHINE        5 
.................... // 
.................... //#define INITAIL_DI_STATE_ON_PWR_ON   0xFFFF3F5F 
.................... //#define INITAIL_DO_STATE_ON_PWR_ON   0x3FFF 
.................... //#define SAFE_MODE_DO_STATE           0x3FFF 
.................... //#define PRE_PRODUCTION_DO_STATE      0xBFFF 
.................... // 
.................... //ST_STATE_MACHINE g_stArrStateMachines[NO_OF_ACTIVE_MACHINE]; 
.................... // 
.................... //unsigned int8 g_fStateMac1StartCanTransfer = SPCL_FLAG_SM_1_START_TRANSFER_ON; 
.................... // 
.................... // 
.................... // 
.................... ////void InitializeStateMachines() 
.................... ////{ 
.................... //    //g_unDIState.m_ui32AllDIs = 0xFFFFFFFF; 
.................... //    //g_unDOState.m_ui16AllDOs = 0xFFFF; 
.................... ////} 
.................... ///* 
.................... //// 01 : Home State 
.................... //unsigned int8 StateFunc_GenericState(int8 i8StateMachine, int8 i8State) 
.................... //{ 
.................... //    // Take action 
.................... //    // Main intention is to not change values of other DO fields, except the fields under the state DO Filter 
.................... //    // Also only the changes will added to the original ALL DOs  
.................... //    unsigned int16 ui16Temp0 = 0; 
.................... //    unsigned int16 ui16Temp1 = 0; 
.................... //    //g_unAllDOs.m_ui16AllDOs = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState; 
.................... //     
.................... //    // Hold the Current DO Values to temp 
.................... //    ui16Temp0 = g_unDOState.m_ui16AllDOs; 
.................... // 
.................... //    // Bitwise AND with the State DO Filter with the Value to change 
.................... //    ui16Temp1 = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState & 
.................... //                g_stArrStateMachines[i8StateMachine].m_ui16StateDOFilter; 
.................... //     
.................... //    // Finally Bitwise OR operation between original value to the temp 
.................... //    g_unDOState.m_ui16AllDOs = ui16Temp0 | ui16Temp1; 
.................... // 
.................... //    return 0; 
.................... //}  
.................... //*/ 
.................... //unsigned int8 StateFunc_GenericState_(int8 i8StateMachine, int8 i8State) 
.................... //{ 
.................... // 
.................... ////        unsigned int16 ui8DO       = g_unDOState.m_ui16AllDOs; 
.................... ////        unsigned int16 ui8Filter   = g_stArrStateMachines[i8StateMachine].m_ui16StateDOFilter; 
.................... ////        unsigned int16 ui8Value    = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState; 
.................... ////        unsigned int16 ui8BitValue = 0; 
.................... ////         
.................... ////        for(int i = 0; i < 16; i++) 
.................... ////        { 
.................... ////            if(1 == ((ui8Filter >> i)&0x0001)) 
.................... ////            { 
.................... ////                ui8BitValue = ((ui8Value >> i)&0x0001); 
.................... ////                ui8DO = (ui8DO & (~(1 << i))) | (ui8BitValue << i); 
.................... ////            } 
.................... ////        } 
.................... //// 
.................... ////    g_unDOState.m_ui16AllDOs = ui8DO; 
.................... ////    return 0; 
.................... //}  
.................... // 
.................... //unsigned int8 StateFunc_GenericState(int8 i8StateMachine, int8 i8State) 
.................... //{ 
.................... ////    UN_ALL_DOS unFilter; 
.................... ////    UN_ALL_DOS unValue; 
.................... ////     
.................... ////    unFilter.m_ui16AllDOs = g_stArrStateMachines[i8StateMachine].m_ui16StateDOFilter; 
.................... ////    unValue.m_ui16AllDOs  = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState; 
.................... ////     
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn00) g_unDOState.m_stAllDOBits.m_ui1HWDOCn00 = unValue.m_stAllDOBits.m_ui1HWDOCn00; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn01) g_unDOState.m_stAllDOBits.m_ui1HWDOCn01 = unValue.m_stAllDOBits.m_ui1HWDOCn01; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn02) g_unDOState.m_stAllDOBits.m_ui1HWDOCn02 = unValue.m_stAllDOBits.m_ui1HWDOCn02; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn03) g_unDOState.m_stAllDOBits.m_ui1HWDOCn03 = unValue.m_stAllDOBits.m_ui1HWDOCn03; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn04) g_unDOState.m_stAllDOBits.m_ui1HWDOCn04 = unValue.m_stAllDOBits.m_ui1HWDOCn04; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn05) g_unDOState.m_stAllDOBits.m_ui1HWDOCn05 = unValue.m_stAllDOBits.m_ui1HWDOCn05; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn06) g_unDOState.m_stAllDOBits.m_ui1HWDOCn06 = unValue.m_stAllDOBits.m_ui1HWDOCn06; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn07) g_unDOState.m_stAllDOBits.m_ui1HWDOCn07 = unValue.m_stAllDOBits.m_ui1HWDOCn07; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn00) g_unDOState.m_stAllDOBits.m_ui1SRDOCn00 = unValue.m_stAllDOBits.m_ui1SRDOCn00; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn01) g_unDOState.m_stAllDOBits.m_ui1SRDOCn01 = unValue.m_stAllDOBits.m_ui1SRDOCn01; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn02) g_unDOState.m_stAllDOBits.m_ui1SRDOCn02 = unValue.m_stAllDOBits.m_ui1SRDOCn02; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn03) g_unDOState.m_stAllDOBits.m_ui1SRDOCn03 = unValue.m_stAllDOBits.m_ui1SRDOCn03; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn04) g_unDOState.m_stAllDOBits.m_ui1SRDOCn04 = unValue.m_stAllDOBits.m_ui1SRDOCn04; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn05) g_unDOState.m_stAllDOBits.m_ui1SRDOCn05 = unValue.m_stAllDOBits.m_ui1SRDOCn05; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn06) g_unDOState.m_stAllDOBits.m_ui1SRDOCn06 = unValue.m_stAllDOBits.m_ui1SRDOCn06; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn07) g_unDOState.m_stAllDOBits.m_ui1SRDOCn07 = unValue.m_stAllDOBits.m_ui1SRDOCn07; 
.................... ////     
.................... //}     
.................... // 
.................... //         
.................... // 
.................... //         
.................... //// 02: Start to Pick 
.................... //unsigned int8 StateFunc_State02() 
.................... //{ 
.................... //    // We got message from outer board that Stacker Ready and Hopper Ready 
.................... //    // Now PD will start moving downword 
.................... //    //g_unAllDOs.m_bArr[2] = 1; 
.................... //    //g_unAllDOs.m_bArr[3] = 0; 
.................... //    // Expected Next State Declaration 
.................... //    g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[0] = STATE_03; 
.................... //    g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[1] = STATE_03; 
.................... //    g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[2] = STATE_03; 
.................... //    g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[3] = STATE_03; 
.................... //    return 0; 
.................... //} 
.................... // 
.................... // 
.................... //void InitExpNextStateDefault() 
.................... //{ 
.................... //    int8 i8StMcCount = 0; 
.................... //    int8 i8StCount   = 0; 
.................... //    int8 i8ExpNxtCount = 0; 
.................... //    for (i8StMcCount = 0; i8StMcCount < NO_OF_ACTIVE_MACHINE; i8StMcCount++) 
.................... //    { 
.................... //        // For all Active Look up tables 
.................... //        for (i8StCount = 0; i8StCount < MAX_NUMBER_OF_STATE; i8StCount++) 
.................... //        { 
.................... //            for (i8ExpNxtCount = 0; i8ExpNxtCount < MAX_NO_OF_EXP_NXT_STATES; i8ExpNxtCount++) 
.................... //            { 
.................... //                g_stArrStateMachines[i8StMcCount].m_stArrStateLookupTable[i8StCount].m_i8ArrExpNextState[i8ExpNxtCount] = STATE_NOTHING; 
.................... //            } 
.................... //        } 
.................... //    } 
.................... //} 
.................... // 
.................... //void PostProductionSafeMode() 
.................... //{ 
.................... //    //g_unDOState.m_ui16AllDOs = 0xFFFF; 
.................... //     
.................... //    // 1. Stopper 0 is in Push State 
.................... //    // 2. Can Stopper 1 is in Push state 
.................... //    // 3. Pusher 0, Pusher 1 and Can Guide all is in drag state 
.................... //    //g_unDOState.m_ui16AllDOs = SAFE_MODE_DO_STATE; 
.................... //    //ExecuteALLDOs(); 
.................... //} 
.................... // 
.................... //void PowerOnDOStateInit() 
.................... //{ 
.................... //   // g_unDOState.m_ui16AllDOs = 0xFFFF; 
.................... //     
.................... //    // 1. Stopper 0 is in drag State 
.................... //    // 2. Can Stopper 1 is in Push state 
.................... //    // 3. Pusher 0, Pusher 1 and Can Guide all is in drag state 
.................... //   // g_unDOState.m_ui16AllDOs = INITAIL_DO_STATE_ON_PWR_ON; 
.................... //    //ExecuteALLDOs(); 
.................... //} 
.................... // 
.................... //#endif /* _VM_STATE_MACHINE_FOR_IMW_M0_H_ */ 
....................  
....................  
....................  
.................... // State 1: Home State 
.................... unsigned int8 StateFunc_SM1_State1(int8 i8StateMachine, int8 i8State) 
.................... { 
....................     // First set the DOs 
....................     StateFunc_GenericState(i8StateMachine, i8State); 
*
0240C:  CALL   21E6
....................      
....................     return 0; 
02410:  MOVLW  00
02412:  MOVWF  01
02414:  RETURN 0
.................... } 
....................  
.................... // State 2: Rejected Box Touches Reject Sensor	 
.................... unsigned int8 StateFunc_SM1_State2(int8 i8StateMachine, int8 i8State) 
.................... { 
....................     // Start Pusher Delay 
....................     g_fPusherDelayStatus = PUSHER_DELAY_START_ON; 
02416:  MOVLB  7
02418:  CLRF   x81
....................      
....................     if (SYS_MODE_CALIB == g_ui8SystemMode) 
0241A:  MOVLB  3
0241C:  MOVF   x9E,W
0241E:  SUBLW  02
02420:  BTFSS  FD8.2
02422:  GOTO   242E
....................     { 
....................         // We do not want Reject Station at the time of calibration 
....................         return 0; 
02426:  MOVLW  00
02428:  MOVWF  01
0242A:  GOTO   243A
....................     } 
....................     // First set the DOs 
....................     StateFunc_GenericState(i8StateMachine, i8State); 
0242E:  MOVLB  0
02430:  CALL   21E6
....................      
....................  
....................      
....................     return 0; 
02434:  MOVLW  00
02436:  MOVWF  01
02438:  MOVLB  3
0243A:  MOVLB  0
0243C:  RETURN 0
.................... } 
....................  
.................... // State 3: Accepted Box Touches Reject Sensor 
.................... unsigned int8 StateFunc_SM1_State3(int8 i8StateMachine, int8 i8State) 
.................... { 
....................     // Change Box Rejection Status 
....................     g_unDIState.m_stAllDIBits.m_ui1GDICn01 = BOX_REJECTED; 
0243E:  BCF    1A.4
....................      
....................     if (SYS_MODE_CALIB == g_ui8SystemMode) 
02440:  MOVLB  3
02442:  MOVF   x9E,W
02444:  SUBLW  02
02446:  BTFSS  FD8.2
02448:  GOTO   2454
....................     { 
....................         // We do not want Reject Station at the time of calibration 
....................         return 0; 
0244C:  MOVLW  00
0244E:  MOVWF  01
02450:  GOTO   2460
....................     } 
....................  
....................     // First set the DOs 
....................     StateFunc_GenericState(i8StateMachine, i8State); 
02454:  MOVLB  0
02456:  CALL   21E6
....................      
....................     return 0; 
0245A:  MOVLW  00
0245C:  MOVWF  01
0245E:  MOVLB  3
02460:  MOVLB  0
02462:  RETURN 0
.................... } 
....................  
.................... // State 4: Reject Pusher Delay Over 
.................... unsigned int8 StateFunc_SM1_State4(int8 i8StateMachine, int8 i8State) 
.................... { 
....................     // First set the DOs 
....................     StateFunc_GenericState(i8StateMachine, i8State); 
02464:  CALL   21E6
....................      
....................     // Change Box Rejection Status 
....................     g_unDIState.m_stAllDIBits.m_ui1GDICn01 = BOX_REJECTED; 
02468:  BCF    1A.4
....................      
....................     // Reset Pusher Delay 
....................     g_unDIState.m_stAllDIBits.m_ui1GDICn02 = 1; 
0246A:  BSF    1A.3
....................      
....................     return 0; 
0246C:  MOVLW  00
0246E:  MOVWF  01
02470:  RETURN 0
.................... } 
....................  
....................  
.................... // Define State Lookup Table 
.................... void Initialize_StateMachine_1() 
.................... { 
....................     // Initialize State DI Filter 
....................     g_stArrStateMachines[STATE_MACHINE_1].m_ui32StateDIFilter    = STATE_SM1_HWDI_FILTER; 
*
00A8E:  MOVLW  08
00A90:  MOVLB  2
00A92:  MOVWF  x2D
00A94:  CLRF   x2C
00A96:  MOVLW  18
00A98:  MOVWF  x2B
00A9A:  CLRF   x2A
....................     g_stArrStateMachines[STATE_MACHINE_1].m_ui16StateDOFilter    = STATE_SM1_HWDO_FILTER; 
00A9C:  MOVLW  40
00A9E:  MOVWF  x2F
00AA0:  CLRF   x2E
....................     g_stArrStateMachines[STATE_MACHINE_1].m_uiStateCounterFilter = 0x0000; 
00AA2:  CLRF   x31
00AA4:  CLRF   x30
....................     g_stArrStateMachines[STATE_MACHINE_1].m_ui32LastDIState      = STATE_SM1_HWDI_01; 
00AA6:  MOVLW  08
00AA8:  MOVWF  xE9
00AAA:  CLRF   xE8
00AAC:  MOVWF  xE7
00AAE:  CLRF   xE6
....................     g_stArrStateMachines[STATE_MACHINE_1].m_ui16LastDOState      = STATE_SM1_HWDO_01; 
00AB0:  MOVLW  40
00AB2:  MOVWF  xEB
00AB4:  CLRF   xEA
....................     g_stArrStateMachines[STATE_MACHINE_1].m_i8PrevState          = STATE_01; 
00AB6:  MOVLW  01
00AB8:  MOVWF  xF0
....................     g_stArrStateMachines[STATE_MACHINE_1].m_fContinue            = STATE_CONTINUE_OFF; 
00ABA:  CLRF   xF1
....................      
....................     // We are leaving first state index for No State 
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[0].m_ui32DIState     = 0x0; 
00ABC:  CLRF   x71
00ABE:  CLRF   x70
00AC0:  CLRF   x6F
00AC2:  CLRF   x6E
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[0].m_ui16DOState     = 0x0;  
00AC4:  CLRF   x73
00AC6:  CLRF   x72
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[0].pFunStateFunction = StateFunc_GenericState; 
00AC8:  MOVLW  02
00ACA:  MOVWF  FEA
00ACC:  MOVLW  78
00ACE:  MOVWF  FE9
00AD0:  MOVLW  21
00AD2:  MOVWF  03
00AD4:  MOVLW  E6
00AD6:  MOVFF  03,01
00ADA:  CLRF   02
00ADC:  CLRF   03
00ADE:  MOVWF  FEF
00AE0:  MOVFF  01,FEC
00AE4:  MOVFF  02,FEC
00AE8:  MOVFF  03,FEC
....................  
....................     // SM1: State 01: Home State 
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_01].m_ui32DIState = STATE_SM1_HWDI_01; 
00AEC:  MOVLW  08
00AEE:  MOVWF  x7D
00AF0:  CLRF   x7C
00AF2:  MOVWF  x7B
00AF4:  CLRF   x7A
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_01].m_ui16DOState = STATE_SM1_HWDO_01; 
00AF6:  MOVLW  40
00AF8:  MOVWF  x7F
00AFA:  CLRF   x7E
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_01].m_i8ArrExpNextState[0] = STATE_02; 
00AFC:  MOVLW  02
00AFE:  MOVWF  x80
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_01].m_i8ArrExpNextState[1] = STATE_03; 
00B00:  MOVLW  03
00B02:  MOVWF  x81
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_01].m_i8ArrExpNextState[2] = STATE_NOTHING; 
00B04:  CLRF   x82
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_01].m_i8ArrExpNextState[3] = STATE_NOTHING; 
00B06:  CLRF   x83
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_01].pFunStateFunction = StateFunc_SM1_State1; 
00B08:  MOVLW  02
00B0A:  MOVWF  FEA
00B0C:  MOVLW  84
00B0E:  MOVWF  FE9
00B10:  MOVLW  24
00B12:  MOVWF  03
00B14:  MOVLW  0C
00B16:  MOVFF  03,01
00B1A:  CLRF   02
00B1C:  CLRF   03
00B1E:  MOVWF  FEF
00B20:  MOVFF  01,FEC
00B24:  MOVFF  02,FEC
00B28:  MOVFF  03,FEC
....................  
....................  
....................     // SM1: State 02: Rejected Box Touches Reject Sensor 
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_02].m_ui32DIState = STATE_SM1_HWDI_02; 
00B2C:  CLRF   x89
00B2E:  CLRF   x88
00B30:  MOVLW  08
00B32:  MOVWF  x87
00B34:  CLRF   x86
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_02].m_ui16DOState = STATE_SM1_HWDO_02; 
00B36:  CLRF   x8B
00B38:  CLRF   x8A
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[0] = STATE_04; 
00B3A:  MOVLW  04
00B3C:  MOVWF  x8C
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[1] = STATE_NOTHING; 
00B3E:  CLRF   x8D
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[2] = STATE_NOTHING; 
00B40:  CLRF   x8E
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[3] = STATE_NOTHING; 
00B42:  CLRF   x8F
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_02].pFunStateFunction = StateFunc_SM1_State2; 
00B44:  MOVLW  02
00B46:  MOVWF  FEA
00B48:  MOVLW  90
00B4A:  MOVWF  FE9
00B4C:  MOVLW  24
00B4E:  MOVWF  03
00B50:  MOVLW  16
00B52:  MOVFF  03,01
00B56:  CLRF   02
00B58:  CLRF   03
00B5A:  MOVWF  FEF
00B5C:  MOVFF  01,FEC
00B60:  MOVFF  02,FEC
00B64:  MOVFF  03,FEC
....................      
....................      
....................     // SM1: State 03: Accepted Box Touches Reject Sensor 
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_03].m_ui32DIState = STATE_SM1_HWDI_03; 
00B68:  CLRF   x95
00B6A:  CLRF   x94
00B6C:  MOVLW  18
00B6E:  MOVWF  x93
00B70:  CLRF   x92
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_03].m_ui16DOState = STATE_SM1_HWDO_03; 
00B72:  MOVLW  40
00B74:  MOVWF  x97
00B76:  CLRF   x96
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_03].m_i8ArrExpNextState[0] = STATE_01; 
00B78:  MOVLW  01
00B7A:  MOVWF  x98
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_03].m_i8ArrExpNextState[1] = STATE_NOTHING; 
00B7C:  CLRF   x99
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_03].m_i8ArrExpNextState[2] = STATE_NOTHING; 
00B7E:  CLRF   x9A
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_03].m_i8ArrExpNextState[3] = STATE_NOTHING; 
00B80:  CLRF   x9B
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_03].pFunStateFunction = StateFunc_SM1_State3; 
00B82:  MOVLW  02
00B84:  MOVWF  FEA
00B86:  MOVLW  9C
00B88:  MOVWF  FE9
00B8A:  MOVLW  24
00B8C:  MOVWF  03
00B8E:  MOVLW  3E
00B90:  MOVFF  03,01
00B94:  CLRF   02
00B96:  CLRF   03
00B98:  MOVWF  FEF
00B9A:  MOVFF  01,FEC
00B9E:  MOVFF  02,FEC
00BA2:  MOVFF  03,FEC
....................  
....................  
....................     // SM1: State 04: Reject Pusher Delay Over 
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_04].m_ui32DIState = STATE_SM1_HWDI_04; 
00BA6:  MOVLW  08
00BA8:  MOVWF  xA1
00BAA:  CLRF   xA0
00BAC:  CLRF   x9F
00BAE:  CLRF   x9E
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_04].m_ui16DOState = STATE_SM1_HWDO_04; 
00BB0:  MOVLW  40
00BB2:  MOVWF  xA3
00BB4:  CLRF   xA2
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_04].m_i8ArrExpNextState[0] = STATE_01; 
00BB6:  MOVLW  01
00BB8:  MOVWF  xA4
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_04].m_i8ArrExpNextState[1] = STATE_NOTHING; 
00BBA:  CLRF   xA5
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_04].m_i8ArrExpNextState[2] = STATE_NOTHING; 
00BBC:  CLRF   xA6
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_04].m_i8ArrExpNextState[3] = STATE_NOTHING; 
00BBE:  CLRF   xA7
....................     g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_04].pFunStateFunction = StateFunc_SM1_State4; 
00BC0:  MOVLW  02
00BC2:  MOVWF  FEA
00BC4:  MOVLW  A8
00BC6:  MOVWF  FE9
00BC8:  MOVLW  24
00BCA:  MOVWF  03
00BCC:  MOVLW  64
00BCE:  MOVFF  03,01
00BD2:  CLRF   02
00BD4:  CLRF   03
00BD6:  MOVWF  FEF
00BD8:  MOVFF  01,FEC
00BDC:  MOVFF  02,FEC
00BE0:  MOVFF  03,FEC
00BE4:  MOVLB  0
00BE6:  GOTO   0C0C (RETURN)
....................      
.................... //+++++++++++++++++++++++++++++++++++++++++++++++++ 
....................  
.................... } 
....................  
....................  
.................... #endif /* _VM_STATE_MACHINE_1_H_ */ 
....................  
.................... //#ifndef _VM_STATE_MACHINE_1_H_ 
.................... //#define _VM_STATE_MACHINE_1_H_ 
.................... // 
.................... ///*************************** Inclusion files **********************************/ 
.................... //#include "vmSystemConfig.h" 
.................... //#include "vmStateMachineForIMW_M0.h" 
.................... // 
.................... // 
.................... //// State 1: Home State 
.................... //unsigned int8 StateFunc_SM1_State1(int8 i8StateMachine, int8 i8State) 
.................... //{ 
.................... //    // First set the DOs 
.................... //    StateFunc_GenericState(i8StateMachine, i8State); 
.................... //     
.................... //    return 0; 
.................... //} 
.................... // 
.................... //// State 2: Box Touches Reject Sensor		 
.................... //unsigned int8 StateFunc_SM1_State2(int8 i8StateMachine, int8 i8State) 
.................... //{ 
.................... //    // First set the DOs 
.................... //    StateFunc_GenericState(i8StateMachine, i8State); 
.................... //     
.................... //    return 0; 
.................... //} 
.................... // 
.................... //// State 3: Box Touches Reject Sensor But Reject Station Busy 
.................... //unsigned int8 StateFunc_SM1_State3(int8 i8StateMachine, int8 i8State) 
.................... //{ 
.................... //    if (IBC_RESET_CALIB_ON == g_fResetCalibStatus) 
.................... //    { 
.................... //        // We do not want Reject Station at the time of calibration 
.................... //        return 0; 
.................... //    } 
.................... //    // First set the DOs 
.................... //    StateFunc_GenericState(i8StateMachine, i8State); 
.................... //     
.................... //    // Start Pusher Delay 
.................... //    g_fPusherDelayStatus = PUSHER_DELAY_START_ON; 
.................... // 
.................... //    return 0; 
.................... //} 
.................... // 
.................... //// State 4: Reject Pusher Delay Over 
.................... //unsigned int8 StateFunc_SM1_State4(int8 i8StateMachine, int8 i8State) 
.................... //{ 
.................... //    if (IBC_RESET_CALIB_ON == g_fResetCalibStatus) 
.................... //    { 
.................... //        // We do not want Reject Station at the time of calibration 
.................... //        return 0; 
.................... //    } 
.................... //    // First set the DOs 
.................... //    StateFunc_GenericState(i8StateMachine, i8State); 
.................... //     
.................... //    // Change Box Rejection Status 
.................... //    g_unDIState.m_stAllDIBits.m_ui1GDICn01 = BOX_REJECTED; 
.................... //     
.................... //    return 0; 
.................... //} 
.................... // 
.................... //// State 5: Reject Pusher Delay Over 
.................... //unsigned int8 StateFunc_SM1_State5(int8 i8StateMachine, int8 i8State) 
.................... //{ 
.................... //    // First set the DOs 
.................... //    StateFunc_GenericState(i8StateMachine, i8State); 
.................... //     
.................... //    // Change Box Rejection Status 
.................... //    g_unDIState.m_stAllDIBits.m_ui1GDICn01 = BOX_REJECTED; 
.................... //     
.................... //    return 0; 
.................... //} 
.................... // 
.................... //// State 6: Reject Pusher Delay Over 
.................... //unsigned int8 StateFunc_SM1_State6(int8 i8StateMachine, int8 i8State) 
.................... //{ 
.................... //    // First set the DOs 
.................... //    StateFunc_GenericState(i8StateMachine, i8State); 
.................... //     
.................... //    // Change Box Rejection Status 
.................... //    g_unDIState.m_stAllDIBits.m_ui1GDICn02 = 1; 
.................... //     
.................... //    return 0; 
.................... //} 
.................... // 
.................... //// Define State Lookup Table 
.................... //void Initialize_StateMachine_1() 
.................... //{ 
.................... //    // Initialize State DI Filter 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_ui32StateDIFilter    = STATE_SM1_HWDI_FILTER; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_ui16StateDOFilter    = STATE_SM1_HWDO_FILTER; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_uiStateCounterFilter = 0x0000; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_ui32LastDIState      = STATE_SM1_HWDI_01; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_ui16LastDOState      = STATE_SM1_HWDO_01; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_i8PrevState          = STATE_01; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_fContinue            = STATE_CONTINUE_OFF; 
.................... //     
.................... //    // We are leaving first state index for No State 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[0].m_ui32DIState     = 0x0; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[0].m_ui16DOState     = 0x0;  
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[0].pFunStateFunction = StateFunc_GenericState; 
.................... // 
.................... //    // SM1: State 01: Home State 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_01].m_ui32DIState = STATE_SM1_HWDI_01; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_01].m_ui16DOState = STATE_SM1_HWDO_01; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_01].m_i8ArrExpNextState[0] = STATE_02; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_01].m_i8ArrExpNextState[1] = STATE_03; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_01].m_i8ArrExpNextState[2] = STATE_04; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_01].m_i8ArrExpNextState[3] = STATE_NOTHING; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_01].pFunStateFunction = StateFunc_SM1_State1; 
.................... // 
.................... // 
.................... //    // SM1: State 02: Box Touches Reject Sensor		 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_02].m_ui32DIState = STATE_SM1_HWDI_02; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_02].m_ui16DOState = STATE_SM1_HWDO_02; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[0] = STATE_05; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[1] = STATE_01; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[2] = STATE_NOTHING; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[3] = STATE_NOTHING; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_02].pFunStateFunction = StateFunc_SM1_State2; 
.................... //     
.................... //     
.................... //    // SM1: State 03: SM1: Box Touches Reject Sensor But Reject Station Busy 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_03].m_ui32DIState = STATE_SM1_HWDI_03; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_03].m_ui16DOState = STATE_SM1_HWDO_03; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_03].m_i8ArrExpNextState[0] = STATE_06; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_03].m_i8ArrExpNextState[1] = STATE_NOTHING; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_03].m_i8ArrExpNextState[2] = STATE_NOTHING; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_03].m_i8ArrExpNextState[3] = STATE_NOTHING; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_03].pFunStateFunction = StateFunc_SM1_State3; 
.................... // 
.................... // 
.................... //    // SM1: State 04: SM1: Reject Pusher Delay Over 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_04].m_ui32DIState = STATE_SM1_HWDI_04; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_04].m_ui16DOState = STATE_SM1_HWDO_04; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_04].m_i8ArrExpNextState[0] = STATE_01; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_04].m_i8ArrExpNextState[1] = STATE_NOTHING; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_04].m_i8ArrExpNextState[2] = STATE_NOTHING; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_04].m_i8ArrExpNextState[3] = STATE_NOTHING; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_04].pFunStateFunction = StateFunc_SM1_State4; 
.................... //     
.................... //    // SM1: State 04: SM1: Reject Pusher Delay Over 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_05].m_ui32DIState = STATE_SM1_HWDI_05; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_05].m_ui16DOState = STATE_SM1_HWDO_05; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_05].m_i8ArrExpNextState[0] = STATE_01; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_05].m_i8ArrExpNextState[1] = STATE_02; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_05].m_i8ArrExpNextState[2] = STATE_NOTHING; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_05].m_i8ArrExpNextState[3] = STATE_NOTHING; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_05].pFunStateFunction = StateFunc_SM1_State5; 
.................... //     
.................... //    // SM1: State 04: SM1: Reject Pusher Delay Over 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_06].m_ui32DIState = STATE_SM1_HWDI_06; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_06].m_ui16DOState = STATE_SM1_HWDO_06; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_06].m_i8ArrExpNextState[0] = STATE_01; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_06].m_i8ArrExpNextState[1] = STATE_02; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_06].m_i8ArrExpNextState[2] = STATE_NOTHING; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_06].m_i8ArrExpNextState[3] = STATE_NOTHING; 
.................... //    g_stArrStateMachines[STATE_MACHINE_1].m_stArrStateLookupTable[STATE_06].pFunStateFunction = StateFunc_SM1_State6; 
.................... //     
.................... ////+++++++++++++++++++++++++++++++++++++++++++++++++ 
.................... // 
.................... //} 
.................... // 
.................... // 
.................... //#endif /* _VM_STATE_MACHINE_1_H_ */ 
....................  
.................... #include "vmIBCProcessM0.h" 
.................... /*  
....................  * File:   vmIBCProcessM0.h 
....................  * Author: Amit 
....................  * 
....................  * Created on December 9, 2018, 6:17 PM 
....................  */ 
....................  
.................... #ifndef VM_IBC_PROCESS_M0_H 
.................... #define	VM_IBC_PROCESS_M0_H 
....................  
.................... #include "../Common/vmIBCConfig.h" 
.................... #ifndef _VI_IBC_CONFIG_H_ 
.................... #define _VI_IBC_CONFIG_H_ 
....................  
.................... #include "vmSystemConfig.h" 
.................... #include "vmCRCConfig.h" 
.................... #include "vmDigitalIOConfig.h" 
.................... //#include "ctype.h" 
.................... #include "vmPINConfig.h" 
.................... #include "vmIBCGlobal.h" 
....................  
.................... #define IBC_MSG_BYTE_COUNT                       5 
.................... #define IBC_DATA_BITS_LENGTH                     10 
.................... #define IBC_DATA_BYTES_LENGTH                    10 
.................... #define IBC_BOARD_ID                             1 
....................  
.................... #define IBC_BAUD_RATE_9600                       20 
.................... #define IBC_BAUD_RATE_19200                      21 
....................  
.................... #define T1_DIV_PRESCALE                          T1_DIV_BY_8 
.................... #define T3_DIV_PRESCALE                          T3_DIV_BY_8 
....................  
.................... #define IBC_TX_1_BT_LOAD_VALUE_9600              (0xFFFF - 0x0041 + 1) 
.................... #define IBC_TX_1_BT_LOAD_VALUE_19200             (0xFFFF - 0x0021 + 1) 
....................  
.................... #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL_9600       (0xFFFF - 0x0062 + 1) // For 9600 
.................... #define IBC_RX_BIT_TIME_T1LOAD_VAL_9600           (0xFFFF - 0x0041 + 1) // For 9600 
....................  
.................... #ifdef M1_COMM_MODULE 
....................     #define IBC_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)  // 78us Instead of 104us we load 91.2 for per bit time. 
.................... #else 
....................     #define IBC_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)//   IBC_RX_BIT_TIME_T1LOAD_VAL_9600  // 104 us 
.................... #endif 
.................... //#define IBC_RX_1_BT_CUSTOMISED_VAL_9600           (0xFFFF - 0x0031 + 1)  // Instead of 104us we load 78 us for per bit time. 
.................... #define IBC_RX_BIT_TIME_1_2_T1LOAD_VAL_9600       (0xFFFF - 0x004E + 1) 
.................... #define IBC_RX_BIT_TIME_1_3_T1LOAD_VAL_9600       (0xFFFF - 0x0051 + 1) 
.................... #define IBC_RX_BIT_TIME_1_4_T1LOAD_VAL_9600       (0xFFFF - 0x005B + 1) 
....................  
....................  
.................... #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL_19200     (0xFFFF - 0x0031 + 1) // For 19200 
.................... #define IBC_RX_BIT_TIME_T1LOAD_VAL_19200         (0xFFFF - 0x0041 + 1) // For 19200 
....................  
.................... #define SIZE_IBC_SEND_BYTE_SEGMENT                15  //1+3+8+3, 1 Start Bit, 3 Sequence Bits, 8 bits of Data and 3 Stop Bits; Total 15bits in one segment/ custised byte 
....................  
.................... #define IBC_TIMER_0_CRITICAL_ON                   0 
.................... #define IBC_TIMER_0_CRITICAL_OFF                  1 
....................  
.................... //***************************************************************************** 
.................... // Below -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
.................... typedef struct _ST_INT_BOARD_ALL_BITS 
.................... { 
....................     unsigned int8 m_ui1IBCRcvbit_0: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_1: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_2: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_3: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_4: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_5: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_6: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_7: 1; 
.................... } ST_INT_BOARD_ALL_BITS; 
....................  
.................... //typedef union _UN_INT_BOARD_BYTE_TYPE 
.................... //{ 
.................... //    unsigned int8          m_ui8Byte; 
.................... //    ST_INT_BOARD_ALL_BITS  m_stByte; 
.................... //    char				   m_chData;	 
.................... //} UN_INT_BOARD_BYTE_TYPE; 
....................  
.................... typedef struct _ST_INT_BOARD_DATA 
.................... { 
....................     char 			m_boardData[IBC_DATA_BITS_LENGTH]; 
....................     unsigned int8  	m_boardID; 
.................... } ST_INT_BOARD_DATA; 
....................  
....................  
.................... //***************************************************************************** 
.................... // Above -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Interboard Communication  RX #  From M1_COMM ********************** 
.................... //***************************************************************************** 
....................  
.................... // Below -> Multiple Baud Rate Settings. 
....................  
.................... #ifdef IBC_BOUD_RATE_1000 
....................     #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL   (0xFFFF - 0x0EA6 + 1) 
....................     #define IBC_RX_BIT_TIME_T1LOAD_VAL       (0xFFFF - 0x09C4 + 1) 
.................... #endif 
....................  
.................... #ifdef IBC_BOUD_RATE_9600 
....................     #define IBC_RX_TIME_DELAY_1_5_BIT           156  
....................     #define IBC_RX_TIME_DELAY_1_BIT             104 
....................     #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL   (0xFFFF - 0x0062 + 1) 
....................     #define IBC_RX_BIT_TIME_T1LOAD_VAL       (0xFFFF - 0x0041 + 1) 
.................... #endif 
....................  
.................... #ifdef IBC_BOUD_RATE_19200 
....................     #define IBC_RX_TIME_DELAY_1_5_VAL           78  
....................     #define IBC_RX_TIME_DELAY_1_VAL             52 
....................     #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL   (0xFFFF - 0x0031 + 1) 
....................     #define IBC_RX_BIT_TIME_T1LOAD_VAL       (0xFFFF - 0x0021 + 1) 
.................... #endif 
....................  
.................... // Above -> Multiple Baud Rate Settings. 
....................  
.................... // Initialize IBC Data Set, Should be called from main()) 
.................... //void InitIBCDataSet() 
.................... //{ 
.................... //    g_unTempRxData1.m_uiByte = 0; 
.................... //} 
....................  
.................... typedef struct _ST_IBC_RCV_BYTE_NODE 
.................... { 
....................  
....................     unsigned int8 m_ui8SeqBit0 :1; 
....................     unsigned int8 m_ui8SeqBit1 :1; 
....................     unsigned int8 m_ui8SeqBit2 :1; 
....................     unsigned int8 m_ui8Padding :5; 
....................      
....................     unsigned int8 m_ui8DataBit0 :1; 
....................     unsigned int8 m_ui8DataBit1 :1; 
....................     unsigned int8 m_ui8DataBit2 :1; 
....................     unsigned int8 m_ui8DataBit3 :1; 
....................     unsigned int8 m_ui8DataBit4 :1; 
....................     unsigned int8 m_ui8DataBit5 :1; 
....................     unsigned int8 m_ui8DataBit6 :1; 
....................     unsigned int8 m_ui8DataBit7 :1; 
.................... } ST_IBC_RCV_BYTE_NODE; 
....................  
.................... typedef union _UN_IBC_RCV_BYTE_NODE 
.................... { 
....................     ST_IBC_RCV_BYTE_NODE m_stIBCNode; 
....................     unsigned int8        m_ui8Arr[2]; 
.................... } UN_IBC_RCV_BYTE_NODE; 
....................  
....................  
....................  
.................... typedef struct _ST_IBC_DATA_NODE 
.................... { 
....................     unsigned int8 g_ui8ArrIBCData[IBC_MSG_BYTE_COUNT]; 
.................... } ST_IBC_DATA_NODE; 
....................  
.................... #define SIZE_IBC_DATA_SEND_QUEUE 15 
....................  
.................... //typedef struct _ST_IBC_DATA_SEND_QUEUE 
.................... //{ 
.................... //    ST_IBC_DATA_NODE m_stArrIBCDataNode[SIZE_IBC_DATA_SEND_QUEUE]; 
.................... //    int8             m_i8Front; 
.................... //    int8             m_i8Rear; 
.................... //} ST_IBC_DATA_SEND_QUEUE; 
....................  
.................... typedef struct _ST_IBC_MSG_QUEUE 
.................... { 
....................     ST_IBC_DATA_NODE m_stArrIBCDataNode[SIZE_IBC_DATA_SEND_QUEUE]; 
....................     int8             m_i8Front; 
....................     int8             m_i8Rear; 
.................... } ST_IBC_MSG_QUEUE; 
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... //UN_INT_BOARD_BYTE_TYPE    g_unIBCRcvData; 
.................... unsigned int8             g_ui8IBCRcvBitCount = 0; 
.................... unsigned int8             g_ui8IBCTxBitCount  = 0; 
....................  
.................... // TESTING 
.................... unsigned int8             g_ui8IBCDataToSend = 0xA5; 
.................... unsigned int8             g_fIBCCommStatus   = 0; 
....................  
.................... ST_IBC_DATA_NODE          g_stIBCRcvData; 
.................... ST_IBC_DATA_NODE          g_stIBCSendData; 
.................... unsigned int8             g_ui8ArrSendSingleMSG[IBC_MSG_BYTE_COUNT*(SIZE_IBC_SEND_BYTE_SEGMENT)] = {0}; // 
.................... unsigned int8             g_fIBCDataReceived = 0; 
....................  
.................... //ST_IBC_DATA_SEND_QUEUE    g_stIBCDataSendQueue; 
.................... unsigned int8             g_fIBCSendBusy = 0; 
.................... UN_IBC_RCV_BYTE_NODE      g_unIBCRcvByteNode; 
....................  
.................... ST_IBC_MSG_QUEUE          g_stIBCSendQueue; 
.................... ST_IBC_MSG_QUEUE          g_stIBCRcvQueue; 
....................  
.................... unsigned int8             g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... ////////// 
.................... //////////void InitializeDataSendQueue() 
.................... //////////{ 
.................... //////////    int iLoopCount1 = 0; 
.................... //////////    int iLoopCount2 = 0; 
.................... //////////    g_stIBCDataSendQueue.m_i8Front = g_stIBCDataSendQueue.m_i8Rear = -1; 
.................... //////////     
.................... //////////    for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBC_DATA_SEND_QUEUE; iLoopCount1++) 
.................... //////////    { 
.................... //////////        for (iLoopCount2 = 0; iLoopCount2 < IBC_MSG_BYTE_COUNT; iLoopCount2++) 
.................... //////////        { 
.................... //////////           g_stIBCDataSendQueue.m_stArrIBCDataNode[iLoopCount1].g_ui8ArrIBCData[iLoopCount2] = 0; 
.................... //////////        } 
.................... //////////    } 
.................... //////////} 
.................... ////////// 
.................... //////////void CopySendData(int8 i8Location, ST_IBC_DATA_NODE* pstIBCData) 
.................... //////////{ 
.................... //////////    int8 i8LoopCount = 0; 
.................... //////////     
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        g_stIBCDataSendQueue.m_stArrIBCDataNode[i8Location].g_ui8ArrIBCData[i8LoopCount] = pstIBCData->g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////    } 
.................... //////////} 
.................... ////////// 
.................... //////////void CopyFromSendQueue(int8 i8Location, ST_IBC_DATA_NODE** ppstIBCData) 
.................... //////////{ 
.................... //////////    int8 i8LoopCount = 0; 
.................... //////////     
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        *ppstIBCData->g_ui8ArrIBCData[i8LoopCount] = g_stIBCDataSendQueue.m_stArrIBCDataNode[i8Location].g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////    } 
.................... //////////} 
.................... /* Function to create Circular queue */ 
.................... //////////void InsertSendQueue(ST_IBC_DATA_NODE* pstIBCData)  
.................... //////////{ 
.................... //////////    if (!pstIBCData) 
.................... //////////    { 
.................... //////////        return; 
.................... //////////    } 
.................... //////////     
.................... //////////    if ((g_stIBCDataSendQueue.m_i8Front == 0 && g_stIBCDataSendQueue.m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1) ||  
.................... //////////            (g_stIBCDataSendQueue.m_i8Front == g_stIBCDataSendQueue.m_i8Rear + 1))  
.................... //////////    {  
.................... //////////        //printf("\nQueue is Full");  
.................... //////////        return;  
.................... //////////    } 
.................... //////////   
.................... //////////    else if (g_stIBCDataSendQueue.m_i8Front == -1) /* Insert First Element */ 
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Front = g_stIBCDataSendQueue.m_i8Rear = 0; 
.................... //////////         
.................... //////////        // Insert Data 
.................... //////////        //arr[g_stIBCDataSendQueue.m_i8Rear] = value; 
.................... //////////        CopySendData(g_stIBCDataSendQueue.m_i8Rear, pstIBCData); 
.................... //////////    }  
.................... //////////   
.................... //////////    else if (g_stIBCDataSendQueue.m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1 && g_stIBCDataSendQueue.m_i8Front != 0)  
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Rear = 0;  
.................... //////////        CopySendData(g_stIBCDataSendQueue.m_i8Rear, pstIBCData);  
.................... //////////    }  
.................... //////////   
.................... //////////    else 
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Rear++;  
.................... //////////        CopySendData(g_stIBCDataSendQueue.m_i8Rear, pstIBCData); 
.................... //////////    }  
.................... //////////}  
....................  
.................... //////////void DeleteQueue(ST_IBC_DATA_NODE* pstIBCData)  
.................... //////////{  
.................... //////////    int8 i8LoopCount = 0; 
.................... ////////// 
.................... //////////    if (g_stIBCDataSendQueue.m_i8Front == -1) 
.................... //////////    {  
.................... //////////        //printf("\nQueue is Empty");  
.................... //////////        return;  
.................... //////////    }  
.................... //////////   
.................... //////////    //int data = arr[g_stIBCDataSendQueue.m_i8Front]; 
.................... //////////    //CopyFromSendQueue(g_stIBCDataSendQueue.m_i8Front, &pstIBCData); 
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        pstIBCData->g_ui8ArrIBCData[i8LoopCount] = g_stIBCDataSendQueue.m_stArrIBCDataNode[g_stIBCDataSendQueue.m_i8Front].g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////    } 
.................... //////////     
.................... //////////    //arr[g_stIBCDataSendQueue.m_i8Front] = -1;  
.................... //////////    if (g_stIBCDataSendQueue.m_i8Front == g_stIBCDataSendQueue.m_i8Rear)  
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Front = -1;  
.................... //////////        g_stIBCDataSendQueue.m_i8Rear = -1;  
.................... //////////    }  
.................... //////////    else if (g_stIBCDataSendQueue.m_i8Front == SIZE_IBC_DATA_SEND_QUEUE-1)  
.................... //////////        g_stIBCDataSendQueue.m_i8Front = 0;  
.................... //////////    else 
.................... //////////        g_stIBCDataSendQueue.m_i8Front++;  
.................... //////////   
.................... //////////    return; 
.................... //////////}  
.................... ////////// 
.................... //////////int8 IsMSGAvailableInIBCSendQueue() 
.................... //////////{ 
.................... //////////    if (g_stIBCDataSendQueue.m_i8Front == -1) 
.................... //////////    { 
.................... //////////        return 0; 
.................... //////////    } 
.................... //////////     
.................... //////////    return 1; 
.................... //////////} 
.................... ////////// 
.................... //////////void SendIBCMSG() 
.................... //////////{ 
.................... //////////    int8          i8LoopCount    = 0; 
.................... //////////    unsigned int8 ui8Sequence    = 0; 
.................... //////////    unsigned int8 ui8TempData    = 0; 
.................... //////////     
.................... //////////    // Initialize the Send Array 
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount] = 0; 
.................... //////////    } 
.................... ////////// 
.................... //////////    // Get Node from Queue 
.................... //////////    DeleteQueue(&g_stIBCSendData); 
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        // Step 1: First Stuff 1 Start Bit 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 0] = 0;   // Start Bit Always 0 
.................... //////////         
.................... //////////        // Step 2: Now Stuff 3 bit Message Byte Sequence Number 
.................... //////////         
.................... //////////        // Stuff the 1st Sequence Bit 
.................... //////////        ui8Sequence = i8LoopCount; 
.................... //////////        ui8Sequence = ui8Sequence << 7; 
.................... //////////        ui8Sequence = ui8Sequence >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 1] = ui8Sequence; 
.................... //////////         
.................... //////////        // Stuff the 2nd Sequence Bit  
.................... //////////        ui8Sequence = i8LoopCount; 
.................... //////////        ui8Sequence = ui8Sequence << 6; 
.................... //////////        ui8Sequence = ui8Sequence >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 2] = ui8Sequence; 
.................... //////////         
.................... //////////        // Stuff the 3rd Bit 
.................... //////////        ui8Sequence = i8LoopCount; 
.................... //////////        ui8Sequence = ui8Sequence << 5; 
.................... //////////        ui8Sequence = ui8Sequence >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 3] = ui8Sequence; 
.................... //////////         
.................... //////////        // Step 3: Now Stuff 8 bit Data 
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 7; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 4] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 6; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 5] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 5; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 6] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 4; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 7] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 3; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 8] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 2; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 9] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 1; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 10] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 11] = ui8TempData; 
.................... //////////         
.................... //////////        // Step 4: Stuff three Stop Bits 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 12] = 1;  // Stop bit is 1 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 13] = 1; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 14] = 1; 
.................... //////////    } 
.................... //////////     
.................... //////////    // So message stuffing is done now start the send timer 
.................... //////////    // Initialize send counter. 
.................... //////////    g_ui8IBCTxBitCount = 0; 
.................... //////////     
.................... //////////    // TESTING Start 
.................... ////////////    g_ui8ArrSendSingleMSG[0] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[1] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[2] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[3] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[4] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[5] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[6] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[7] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[8] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[9] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[10] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[11] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[12] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[13] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[14] = 1;     
.................... //////////    // TESTING End 
.................... //////////     
.................... //////////    // Start Timer3 that handle bit by bit sending. 
.................... //////////    // Set Timer3 as per Bit Time Value. 
.................... //////////    setup_timer_3(T3_INTERNAL | T3_DIV_PRESCALE); 
.................... //////////    set_timer3(IBC_TX_1_BT_LOAD_VALUE_9600); 
.................... //////////     
.................... //////////    clear_interrupt(INT_TIMER3); 
.................... //////////    enable_interrupts(INT_TIMER3); 
.................... //////////} 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving START /////////////// 
....................  
.................... void InitializeDataQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue) 
.................... { 
....................     int iLoopCount1 = 0; 
....................     int iLoopCount2 = 0; 
....................     pstIBCMSGQueue->m_i8Front = pstIBCMSGQueue->m_i8Rear = -1; 
....................      
....................     for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBC_DATA_SEND_QUEUE; iLoopCount1++) 
....................     { 
....................         for (iLoopCount2 = 0; iLoopCount2 < IBC_MSG_BYTE_COUNT; iLoopCount2++) 
....................         { 
....................            pstIBCMSGQueue->m_stArrIBCDataNode[iLoopCount1].g_ui8ArrIBCData[iLoopCount2] = 0; 
....................         } 
....................     } 
.................... } 
....................  
.................... void CopyIBCMsg(ST_IBC_DATA_NODE* pstIBCSource, ST_IBC_DATA_NODE* pstIBCDDest) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................      
....................     for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         pstIBCDDest->g_ui8ArrIBCData[i8LoopCount] = pstIBCSource->g_ui8ArrIBCData[i8LoopCount]; 
....................     } 
.................... } 
....................  
.................... /* Function to create Circular queue */ 
.................... void InsertIBCMsgQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue, ST_IBC_DATA_NODE* pstIBCData)  
.................... { 
....................     if (!pstIBCData) 
....................     { 
....................         return; 
....................     } 
....................      
....................     if ((pstIBCMSGQueue->m_i8Front == 0 && pstIBCMSGQueue->m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1) ||  
....................             (pstIBCMSGQueue->m_i8Rear == (pstIBCMSGQueue->m_i8Front-1)%(SIZE_IBC_DATA_SEND_QUEUE-1)))  
....................     {  
....................         //printf("\nQueue is Full");  
....................         return; 
....................     } 
....................    
....................     else if (pstIBCMSGQueue->m_i8Front == -1) /* Insert First Element */ 
....................     {  
....................         pstIBCMSGQueue->m_i8Front = pstIBCMSGQueue->m_i8Rear = 0; 
....................          
....................         // Insert Data 
....................         //arr[g_stIBCDataSendQueue.m_i8Rear] = value; 
....................         CopyIBCMsg(pstIBCData, &(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else if (pstIBCMSGQueue->m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1 && pstIBCMSGQueue->m_i8Front != 0)  
....................     {  
....................         pstIBCMSGQueue->m_i8Rear = 0;  
....................         CopyIBCMsg(pstIBCData, &(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else 
....................     {  
....................         pstIBCMSGQueue->m_i8Rear++;  
....................         CopyIBCMsg(pstIBCData, &(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Rear])); 
....................     }  
.................... }  
....................  
.................... void DeleteIBCMsgQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue, ST_IBC_DATA_NODE* pstIBCData)  
.................... { 
....................     if (pstIBCMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBCMsg(&(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Front]), pstIBCData); 
....................  
....................     if (pstIBCMSGQueue->m_i8Front == pstIBCMSGQueue->m_i8Rear)  
....................     {  
....................         pstIBCMSGQueue->m_i8Front = -1;  
....................         pstIBCMSGQueue->m_i8Rear = -1;  
....................     }  
....................     else if (pstIBCMSGQueue->m_i8Front == SIZE_IBC_DATA_SEND_QUEUE-1)  
....................         pstIBCMSGQueue->m_i8Front = 0;  
....................     else 
....................         pstIBCMSGQueue->m_i8Front++;  
....................    
....................     return; 
.................... } 
....................  
....................  
.................... int8 IsMSGInIBCQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue) 
.................... { 
....................     if (pstIBCMSGQueue->m_i8Front == -1) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................     return 1; 
.................... } 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving END ///////////////// 
.................... void SendIBCMSGFromQ() 
.................... { 
....................     int8          i8LoopCount    = 0; 
....................     unsigned int8 ui8Sequence    = 0; 
....................     unsigned int8 ui8TempData    = 0; 
....................  
....................     // Initialize the Send Array 
....................     for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount] = 0; 
....................     } 
....................  
....................     // Get Node from Queue 
....................     DeleteIBCMsgQueue(&g_stIBCSendQueue, &g_stIBCSendData); 
....................     for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         // Step 1: First Stuff 1 Start Bit 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 0] = 0;   // Start Bit Always 0 
....................          
....................         // Step 2: Now Stuff 3 bit Message Byte Sequence Number 
....................          
....................         // Stuff the 1st Sequence Bit 
....................         ui8Sequence = i8LoopCount; 
....................         ui8Sequence = ui8Sequence << 7; 
....................         ui8Sequence = ui8Sequence >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 1] = ui8Sequence; 
....................          
....................         // Stuff the 2nd Sequence Bit  
....................         ui8Sequence = i8LoopCount; 
....................         ui8Sequence = ui8Sequence << 6; 
....................         ui8Sequence = ui8Sequence >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 2] = ui8Sequence; 
....................          
....................         // Stuff the 3rd Bit 
....................         ui8Sequence = i8LoopCount; 
....................         ui8Sequence = ui8Sequence << 5; 
....................         ui8Sequence = ui8Sequence >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 3] = ui8Sequence; 
....................          
....................         // Step 3: Now Stuff 8 bit Data 
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 7; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 4] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 6; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 5] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 5; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 6] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 4; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 7] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 3; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 8] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 2; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 9] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 1; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 10] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 11] = ui8TempData; 
....................          
....................         // Step 4: Stuff three Stop Bits 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 12] = 1;  // Stop bit is 1 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 13] = 1; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 14] = 1; 
....................          
.................... ////////        // TESTING Start 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 0] = 0;   
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 1] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 2] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 3] = 1;  
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 4] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 5] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 6] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 7] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 8] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 9] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 10] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 11] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 12] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 13] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 14] = 1; 
.................... ////////        // TESTING End 
....................     } 
....................      
....................      
.................... ////    // TESTING Start 
.................... ////    g_ui8ArrSendSingleMSG[0] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[1] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[2] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[3] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[4] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[5] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[6] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[7] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[8] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[9] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[10] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[11] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[12] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[13] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[14] = 1;     
.................... ////    // TESTING End 
....................          
....................     // So message stuffing is done now start the send timer 
....................     // Initialize send counter. 
....................     g_ui8IBCTxBitCount = 0; 
....................      
....................     // Hold the IBC Send Lock 
....................     g_fIBCSendLockStatus = IBC_SEND_LOCK; 
....................     // Start Timer3 that handle bit by bit sending. 
....................     // Set Timer3 as per Bit Time Value. 
....................     setup_timer_3(T3_INTERNAL | T3_DIV_PRESCALE); 
....................     set_timer3(IBC_TX_1_BT_LOAD_VALUE_9600); 
....................      
....................     // Before Sending Data in IBC Run Timer0 in Time Critical. This we are doing 
....................     // just because we have seen the IBC Send Receive is affecting while Timer 0 
....................     // is executing, hence the IBC data send receive is not sampled at proper time 
....................     g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_ON; 
....................      
....................     clear_interrupt(INT_TIMER3); 
....................     enable_interrupts(INT_TIMER3); 
.................... } 
....................  
.................... void IBCProcessRcvMsg() 
.................... { 
....................     // I 
.................... } 
....................  
.................... #INT_TIMER3    // Used for IBC Send 
.................... void IBC_Tx_ISR(void) 
.................... { 
....................     // Send IBC bits 
....................     output_bit(PIN_IBC_XMIT, g_ui8ArrSendSingleMSG[g_ui8IBCTxBitCount++]); 
....................     // Reset Timer3 at 1Bit Time value. 
....................     set_timer3(IBC_TX_1_BT_LOAD_VALUE_9600); 
....................     clear_interrupt( INT_TIMER3 ); 
....................  
....................     // Check if IBC Sending completed 
....................     if ((IBC_MSG_BYTE_COUNT*SIZE_IBC_SEND_BYTE_SEGMENT) == g_ui8IBCTxBitCount) 
....................     { 
....................         // First release Timer0 Critical run lock 
....................         g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
....................          
....................         // Release Send Busy status 
....................         g_fIBCSendBusy     = 0; 
....................          
....................         // Send Stop bit forever 
....................         output_bit(PIN_IBC_XMIT, 1); 
....................  
....................         // Reset Tx counter 
....................         g_ui8IBCTxBitCount = 0; 
....................         // Reset IBC Send checking status flag. 
....................         //g_fIBCCommStatus = 0; 
....................         // Disable Timer 
....................         setup_timer_3 (T3_DISABLED); 
....................         disable_interrupts(INT_TIMER3); 
....................         // Clear Timer1 interrupt 
....................         clear_interrupt(INT_TIMER3); 
....................          
....................         // Release IBC Send Lock 
....................         g_fIBCSendLockStatus = IBC_SEND_UNLOCK; 
....................     } 
....................      
....................     // TESTING 
....................     //output_toggle(PIN_IN_EXT_DI_00); 
....................   
.................... } 
....................  
....................  
....................  
.................... /* 
....................     Timer1 is used to handle IBC Received bytes. 
....................  and Timer3 is used to handle IBC sent bytes. 
....................  */ 
.................... #ifdef M1_COMM_MODULE 
.................... #INT_EXT1  
.................... #else 
.................... #INT_EXT3 
.................... #endif 
.................... void IBC_Rx_ISR(void) 
.................... { 
....................    
....................     // Initialize Rx Bit Counter. 
....................    	g_ui8IBCRcvBitCount = 0; 
....................     g_unIBCRcvByteNode.m_ui8Arr[0] = 0; 
....................     g_unIBCRcvByteNode.m_ui8Arr[1] = 0; 
....................    	 
....................     // Setup Timer1 at 1.5 Bit Time.                   // Here we are using DIV_BY_8. 
....................     setup_timer_1( T1_INTERNAL | T1_DIV_PRESCALE ); // CPU Ext Clock is 20MHz, 20/4 => 5MHz is Peripheral Clock 
....................                                                 // => T1_DIV_BY_2 => 5/2 = 2.5MHz => (1/2.5)us = 0.4us 
....................                                                 // To Get 1Ms quanta = (1000us/0.4) = 2500 => 0x09C4 
....................                                                 // So, The timer will start counting from (0xFFFF - 0x09C4 + 1) 
....................                                                 // To Get 1.5Ms quanta = (1500us/0.4) = 3750 => 0x0EA6 
....................                                                 // So, The timer will start counting from (0xFFFF - 0x0EA6 + 1)  
....................      
.................... #ifdef M1_COMM_MODULE 
....................     set_timer1( IBC_RX_BIT_TIME_1_4_T1LOAD_VAL_9600);  
.................... #else 
....................     set_timer1( IBC_RX_BIT_TIME_1_5_T1LOAD_VAL_9600); 
.................... #endif 
....................      
....................     // Before Sending Data in IBC Run Timer0 in Time Critical. This we are doing 
....................     // just because we have seen the IBC Send Receive is affecting while Timer 0 
....................     // is executing, hence the IBC data send receive is not sampled at proper time 
....................     g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_ON; 
....................      
....................     clear_interrupt( INT_TIMER1 ); 
....................     enable_interrupts( INT_TIMER1 ); 
....................      
....................     // Clear and Disable External Interrupt 1  
.................... #ifdef M1_COMM_MODULE 
....................     clear_interrupt(INT_EXT1); 
....................     disable_interrupts(INT_EXT1);  
.................... #else 
....................     clear_interrupt(INT_EXT3); 
....................     disable_interrupts(INT_EXT3); 
.................... #endif 
....................      
....................     // TESTING Start 
.................... #ifdef M1_COMM_MODULE 
....................     //output_high(PIN_IN_EXT_DI_00); 
.................... #endif 
....................     // TESTING End 
.................... } 
....................  
.................... // TESTING Start 
.................... int8 g_i8RcvByteCount = 0; 
.................... // TESTING End 
....................  
.................... #INT_TIMER1           // This is for Receive                 
.................... void IBC_Rx_Sampling_ISR(void) 
.................... {  
.................... ////////    // TESTING Start 
.................... ////////#ifdef M1_COMM_MODULE 
.................... ////////    //output_toggle(PIN_IN_EXT_DI_00); 
.................... ////////#else 
.................... ////////    output_toggle(PIN_A5); 
.................... ////////#endif 
.................... ////////    // TESTING End 
....................      
....................     // Increment Rx Bit Counter for each received bit. 
....................    	g_ui8IBCRcvBitCount++; 
.................... 	 
....................     // Check Rx Bit Counter and read Bits 
....................     switch(g_ui8IBCRcvBitCount) 
....................     { 
....................         case 1: // Sequence Bit 0  
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8SeqBit0 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 2: // Sequence Bit 1 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8SeqBit1 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 3: // Sequence Bit 2 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8SeqBit2 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 4: // Data Bit Bit 0 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit0 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 5: // Bit 4 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit1 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 6: // Bit 5 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit2 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 7: // Bit 6 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit3 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 8: // Bit 7 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit4 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................          	set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................          	clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................              
....................              
....................         case 9: // Bit 8 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit5 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_1_BT_CUSTOMISED_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 10: // Bit 9 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit6 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_1_BT_CUSTOMISED_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 11: // Bit 10 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit7 = input(PIN_IBC_RCV); 
....................              
....................             // We have received all data so now we can release Timer0 Critical Run 
....................             g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
....................              
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_1_BT_CUSTOMISED_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................              
....................         case 12: // STOP Bit 
....................             // Check if the Stop Bit is High. 
....................             if(1 == input(PIN_IBC_RCV)) // Stop bit detected 
....................             { 
....................                 // Byte received successfully 
....................                 // Save received byte to the Message Array 1 
....................                 //g_arruiIBCRxMsg1[g_uiIBCRxByteCount1 - 1] = g_unTempRxData1.m_uiByte; 
....................             } 
....................             else 
....................             {  
....................                 // Handle error. 
....................                 // Framing error. 
....................                 // Set Flag tracking Framing Error. 
....................                 //g_uiIBCRxFramingErr1 = 1; 
....................                 //g_uiIBCSTXReceived1  = 0; 
....................             } 
....................             // Disable Timer1. 
....................             setup_timer_1 (T1_DISABLED); 
....................             disable_interrupts(INT_TIMER1);  
....................             // Clear Timer1 interrupt. 
....................             clear_interrupt(INT_TIMER1);  
....................   
....................              
....................             g_i8RcvByteCount++; 
....................             if (5 == g_i8RcvByteCount) 
....................             { 
....................                 g_i8RcvByteCount = 0; 
....................             } 
....................             // Now check the Byte Sequence 
....................             g_stIBCRcvData.g_ui8ArrIBCData[g_unIBCRcvByteNode.m_ui8Arr[0]] = g_unIBCRcvByteNode.m_ui8Arr[1]; 
....................              
....................             if ((IBC_MSG_BYTE_COUNT - 1) == g_unIBCRcvByteNode.m_ui8Arr[0]) 
....................             { 
....................                 // The complete 5 byte data has been received 
....................                 // Now we can process the data 
....................                 g_fIBCDataReceived = 1; 
....................                  
....................                 // Insert Message into IBC Receive Queue 
.................... ////////                InsertIBCMsgQueue(&g_stIBCRcvQueue, &g_stIBCRcvData);   
....................             } 
....................             // Reset Rx Bit Counter. 
....................             g_ui8IBCRcvBitCount = 0; 
....................              
....................             // Enable External Interrupt to detect next byte. 
.................... #ifdef M1_COMM_MODULE 
....................             ext_int_edge(1, H_TO_L);  
....................             clear_interrupt(INT_EXT1); 
....................             enable_interrupts(INT_EXT1); 
.................... #else 
....................             ext_int_edge(3, H_TO_L);  
....................             clear_interrupt(INT_EXT3); 
....................             enable_interrupts(INT_EXT3); 
.................... #endif 
....................             break; 
....................  
....................         default: 
....................             // Framing error. 
....................             // Set Flag tracking Framing Error. 
....................             //g_uiIBCRxFramingErr1 = 1; 
....................              
....................             // First release Timer0 Critical run lock 
....................             g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
....................              
....................             // Disable Timer1. 
....................             setup_timer_1 (T1_DISABLED); 
....................             disable_interrupts(INT_TIMER1);  
....................             // Clear Timer1 interrupt. 
....................             clear_interrupt(INT_TIMER1);  
....................              
....................             // Reset Rx Bit Counter 1. 
....................             g_ui8IBCRcvBitCount = 0; 
....................              
....................             // Enable External Interrupt 0 to detect next start bit. 
....................             ext_int_edge(1, H_TO_L);  
....................             clear_interrupt(INT_EXT1); 
....................             enable_interrupts(INT_EXT1); 
....................             break; 
....................     } 
....................      
.................... } 
....................  
....................  
....................  
.................... #endif /* _VI_IBC_CONFIG_H_ */ 
....................  
.................... #include "vmM0ADCModuleCommon.h" 
.................... /*  
....................  * File:   vmM0ADCModuleCommon.h 
....................  * Author: OEM 
....................  * 
....................  * Created on December 13, 2018, 4:59 PM 
....................  */ 
....................  
.................... #ifndef VM_M0_ADC_MODULE_COMMON_H 
.................... #define	VM_M0_ADC_MODULE_COMMON_H 
....................  
.................... #define BOX_ACCEPTED               1 
.................... #define BOX_REJECTED               0 
.................... //#define BOX_REJECTED_UNDR_WT       0 
.................... //#define BOX_REJECTED_OVR_WT        2 
....................  
.................... #define SYS_MODE_NOTHING   0 
.................... #define SYS_MODE_HOME      1 
.................... #define SYS_MODE_CALIB     2 
.................... #define SYS_MODE_PRE_PROD  3 
.................... #define SYS_MODE_PROD      4 
.................... #define SYS_MODE_POST_PROD 5 
....................  
.................... #define IBC_INTERMEDIATE_DATA_SEND_ON  1 
.................... #define IBC_INTERMEDIATE_DATA_SEND_OFF 0 
....................  
.................... #define ADC_MEAN_DATA_INTERMEDIATE_WEIGHT   31 
.................... #define ADC_MEAN_DATA_INTERMEDIATE_TARE     32 
.................... #define ADC_MEAN_DATA_FINAL_WEIGHT          33 
.................... #define ADC_MEAN_DATA_FINAL_TARE            34 
.................... #define ADC_MEAN_DATA_CALIB_WEIGHT          35 
.................... #define ADC_MEAN_DATA_NOTHING               36 
....................  
.................... unsigned int8 g_ui8ADCMeanDataState = ADC_MEAN_DATA_NOTHING; 
....................  
.................... #define FLAG_WT_CALCULATION_DONE     1 
.................... #define FLAG_WT_CALCULATION_NOT_DONE 0 
....................  
.................... unsigned int8 g_fWtCalculationState = FLAG_WT_CALCULATION_NOT_DONE; 
....................  
.................... #define IBC_RESET_CALIB_OFF    0 
.................... #define IBC_RESET_CALIB_ON     1 
....................  
.................... #define HMI_REJECTION_AUTO_CALIB_MODE   0 
.................... #define HMI_REJECTION_FIXED_CALIB_MODE  1 
....................  
....................  
.................... unsigned int16 g_ui16CurrentBoxCount   = 0;     // Total Box Passed Sofar 
.................... unsigned int16 g_ui16RejectionStatus   = BOX_REJECTED; 
.................... unsigned int8  g_ui8SystemMode         = SYS_MODE_NOTHING; 
.................... unsigned int8  g_fIntermediateDataSend = IBC_INTERMEDIATE_DATA_SEND_OFF; 
.................... unsigned int16 g_ui16DynamicTareValue   = 0; 
.................... unsigned int32 g_ui32DynamicTareADCValue   = 0; 
....................  
.................... unsigned int16 g_ui16PrevDynamicTareValue = 0; 
.................... int32          g_i32StaticTareValue    = 0;  // TODO Should keep in EEPROM 
.................... unsigned int8  g_fResetCalibStatus     = IBC_RESET_CALIB_OFF; 
.................... int16          g_i16CalibResetValue     = 0; 
.................... int16          g_i16CalibResetSumValue  = 0; 
.................... int32          g_i32ADCSumValue         = 0; 
.................... int32          g_i32ADCAvgValue         = 0; 
.................... unsigned int16 g_ui16ADCCalibValueEEPROM = 0; 
.................... unsigned int16 g_ui16CalibPointEEPROM    = 0; 
.................... int16          g_i16CalibResetPrevValue = 0; 
.................... int16          g_i16DynamicErrValue     = 0; 
.................... int16          g_i16CurBoxWeight        = 0; 
.................... int8           g_fRejectionMode         = HMI_REJECTION_FIXED_CALIB_MODE; 
....................  
.................... typedef struct _ST_CUR_BATCH_INFO 
.................... { 
....................     int16 m_i16AvgWeight; 
....................     int16 m_i16PositiveTol; 
....................     int16 m_i16NegativeTol; 
.................... } ST_CUR_BATCH_INFO; 
....................  
.................... ST_CUR_BATCH_INFO g_stCurBatchInfo; 
....................  
.................... #endif	/* VM_M0_ADC_MODULE_COMMON_H */ 
....................  
....................  
.................... #include "vmAverageWeightCalculation.h" 
.................... /*  
....................  * File:   vmAverageWeightCalculation.h 
....................  * Author: OEM 
....................  * 
....................  * Created on December 20, 2018, 11:50 AM 
....................  */ 
....................  
.................... #ifndef VM_AVERAGE_WEIGHT_CALCULATION_H 
.................... #define	VM_AVERAGE_WEIGHT_CALCULATION_H 
....................  
.................... #define SIZE_AVG_WT_ARR                 50 
.................... #define MAX_DEVIATIION_FROM_AVG_WT      1000  // We are considering +- 1000gm weight deviation 
.................... #define MAX_DEVIATION_FOR_BATCH_CHANGE  850   // If Current weight 850gm deviated from last average weight then we consider batch must be changed. 
....................                                               // In that case we reset the queue. 
....................  
.................... typedef struct _ST_AVG_WT_QUEUE 
.................... { 
....................     int16 m_i16Arr[SIZE_AVG_WT_ARR]; 
....................     int8  m_i8Rear; 
....................     int8  m_i8Length; 
....................     int8  m_i8QueueFull; 
....................     int16 m_i16CurAvg; 
....................     int16 m_i16LstAvg; 
.................... } ST_AVG_WT_QUEUE; 
....................  
.................... ST_AVG_WT_QUEUE g_stAvgWtQueue; 
....................  
.................... void InitializeAvgWtQueue() 
.................... { 
....................     unsigned int8 ui8LoopCount = 0; 
....................     g_stAvgWtQueue.m_i8Rear     = -1; 
....................     g_stAvgWtQueue.m_i8Length   = SIZE_AVG_WT_ARR; 
....................     g_stAvgWtQueue.m_i16CurAvg  = 0; 
....................     g_stAvgWtQueue.m_i8QueueFull = 0; 
....................      
....................     // Initialize array member. 
....................     for(ui8LoopCount = 0; ui8LoopCount < SIZE_AVG_WT_ARR; ui8LoopCount++) 
....................     { 
....................         g_stAvgWtQueue.m_i16Arr[ui8LoopCount] = 0; 
....................     } 
.................... } 
....................  
.................... void ResetAvgWtQueue(int8 i8Length) 
.................... { 
....................     if (i8Length <= SIZE_AVG_WT_ARR) 
....................     { 
....................         g_stAvgWtQueue.m_i8Length = i8Length; 
....................     } 
....................     else 
....................     { 
....................         g_stAvgWtQueue.m_i8Length = SIZE_AVG_WT_ARR; 
....................     } 
.................... } 
....................  
.................... void InsertAvgWtQueue(int16 i16LastWeight) 
.................... { 
....................     int8  i8LoopCount = 0; 
....................     int8  i8MaxEntry  = 0; 
....................     int32 i32Sum      = 0; 
....................      
....................     // Check the weight deviation from Selected SKU Average Weight 
....................     if (i16LastWeight > (g_stCurBatchInfo.m_i16AvgWeight + MAX_DEVIATIION_FROM_AVG_WT) || 
....................         i16LastWeight < (g_stCurBatchInfo.m_i16AvgWeight - MAX_DEVIATIION_FROM_AVG_WT)) 
....................     { 
....................         // The weight is out of range, we are not inserting this weight into Average weight queue  
....................         return; 
....................     } 
....................      
....................     // Increment Rear 
....................     g_stAvgWtQueue.m_i8Rear++; 
....................      
....................     // Check if the current weight is a new batch weight. 
....................     if(i16LastWeight >= g_stAvgWtQueue.m_i16LstAvg + MAX_DEVIATION_FOR_BATCH_CHANGE) 
....................     { 
....................         g_stAvgWtQueue.m_i8Rear = 0; 
....................     } 
....................      
....................     // Check queue length according to auto/fixed calibration mode. 
....................     // If in auto calibration mode then data will be inserted upto user input stored avg queue length. 
....................     if(HMI_REJECTION_AUTO_CALIB_MODE == g_fRejectionMode) 
....................     { 
....................         if (g_stAvgWtQueue.m_i8Rear >= g_stAvgWtQueue.m_i8Length) 
....................         { 
....................             g_stAvgWtQueue.m_i8Rear      = 0; 
....................             // Update state Queue Full 
....................             g_stAvgWtQueue.m_i8QueueFull = 1; 
....................         } 
....................     } 
....................     // Otherwise in fixed calibration mode data will be inserted upto queue's original length. 
....................     else 
....................     { 
....................         if (g_stAvgWtQueue.m_i8Rear >= SIZE_AVG_WT_ARR) 
....................         { 
....................             g_stAvgWtQueue.m_i8Rear      = 0; 
....................             // Update state Queue Full 
....................             g_stAvgWtQueue.m_i8QueueFull = 1; 
....................         } 
....................     } 
....................      
....................     // Insert into Queue 
....................     g_stAvgWtQueue.m_i16Arr[g_stAvgWtQueue.m_i8Rear] = i16LastWeight; 
....................      
....................     // Get the Max entry in queue 
....................     if (1 == g_stAvgWtQueue.m_i8QueueFull) 
....................     { 
....................         if(HMI_REJECTION_AUTO_CALIB_MODE == g_fRejectionMode) 
....................         {     
....................             // Set maximum counted data for average calculation. 
....................             i8MaxEntry = g_stAvgWtQueue.m_i8Length; 
....................              
....................             // Reset queue full flag. 
....................             g_stAvgWtQueue.m_i8QueueFull = 0; 
....................         } 
....................         else 
....................         { 
....................             // Set maximum counted data for average calculation. 
....................             i8MaxEntry = SIZE_AVG_WT_ARR; 
....................              
....................             // Reset queue full flag. 
....................             g_stAvgWtQueue.m_i8QueueFull = 0; 
....................         } 
....................     } 
....................     else 
....................     { 
....................         i8MaxEntry = g_stAvgWtQueue.m_i8Rear + 1; 
....................     } 
....................      
....................     // Get the summation of queue values    
....................     for (i8LoopCount = 0; i8LoopCount < i8MaxEntry; i8LoopCount++) 
....................     { 
....................         i32Sum += g_stAvgWtQueue.m_i16Arr[i8LoopCount]; 
....................     } 
....................      
....................     g_stAvgWtQueue.m_i16CurAvg = (int16)(i32Sum / (int32)i8MaxEntry); 
....................      
....................     // Store the current average in last average of all CBBs. 
....................     g_stAvgWtQueue.m_i16LstAvg = g_stAvgWtQueue.m_i16CurAvg; 
.................... } 
....................  
.................... void IBCSendProdModeAvgData() 
.................... { 
....................     ST_IBC_DATA_NODE stIBCDataNode; 
....................     int8 i8LoopCount = 0; 
....................      
....................  
....................     // Prepare IBC Data Node 
....................     g_unIBCProdModeAvg.m_stAvgData.m_i16Padding  = 0; 
....................     g_unIBCProdModeAvg.m_stAvgData.m_i16CurAvg   = g_stAvgWtQueue.m_i16CurAvg; 
....................      
....................     // Stuff IBC Command 
....................     stIBCDataNode.g_ui8ArrIBCData[0] = IBC_CMD_PROD_AVG_WT_DATA; 
....................     for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         stIBCDataNode.g_ui8ArrIBCData[i8LoopCount] = g_unIBCProdModeAvg.m_ui8Arr[i8LoopCount - 1]; 
....................     } 
....................      
....................     // Send to IBC Insert 
....................     //InsertSendQueue(&stIBCDataNode); 
....................     InsertIBCMsgQueue(&g_stIBCSendQueue, &stIBCDataNode); 
.................... } 
.................... #endif	/* VM_AVERAGE_WEIGHT_CALCULATION_H */ 
....................  
....................  
.................... #include "vmEEPROMConfig_Britania.h" 
.................... #ifndef _VM_EEPROM_CONFIG_BRITANIA_H_ 
.................... #define _VM_EEPROM_CONFIG_BRITANIA_H_ 
....................  
.................... #include "vmEEPROMConfig.h" 
.................... #include "vmCalibration.h" 
....................  
.................... //#define EEPROM_ADDRESS_FOR_0_GM       200 
.................... #define EEPROM_ADDRESS_FOR_LCF          100 
.................... //#define CALIB_PONT_DIV_FACTOR         1000 
.................... //#define CALIB_POINT_MULT_FACTOR       4 
....................  
.................... ////void WriteDataToEEPROM(unsigned int16 ui16CalibPointEEPROM, unsigned int16 ui16ADCCalibValueEEPROM) 
.................... ////{ 
.................... ////    unsigned int16 ui16EEPROMStartAddress = 0; 
.................... ////     
.................... ////    // Calculate EEPROM Write Address for each calibration point  
.................... ////    if(!ui16CalibPointEEPROM) 
.................... ////    { 
.................... ////        ui16EEPROMStartAddress = EEPROM_ADDRESS_FOR_0_GM; 
.................... ////    } 
.................... ////    else 
.................... ////    { 
.................... ////        ui16EEPROMStartAddress = EEPROM_ADDRESS_FOR_0_GM + ((ui16CalibPointEEPROM / CALIB_PONT_DIV_FACTOR) * CALIB_POINT_MULT_FACTOR); 
.................... ////    } 
.................... ////     
.................... ////    // Write Calib point to EEPROM 
.................... ////    WriteEEPROMInt16(ui16EEPROMStartAddress, ui16CalibPointEEPROM); 
.................... ////    // Increment address 
.................... ////    ui16EEPROMStartAddress += 2; 
.................... ////    // Write calib value to EEPROM 
.................... ////    WriteEEPROMInt16(ui16EEPROMStartAddress, ui16ADCCalibValueEEPROM); 
.................... ////    
.................... ////} 
....................  
.................... ////void ReadCalibTableFromEEPROM(void) 
.................... ////{ 
.................... ////    unsigned int16 ui16EEPROMStartAddress = 0; 
.................... ////    unsigned int16 ui16EEPROMPoint        = 0; 
.................... ////    unsigned int16 ui16EEPROMValue        = 0; 
.................... ////    unsigned int8 ui8LoopCount = 0; 
.................... ////     
.................... ////    // Write calib value for 0gm predefined 
.................... ////    g_stCalibTable[0].m_i16CalibPoint = 0; 
.................... ////    g_stCalibTable[0].m_ui32CalibValue = 41925; 
.................... ////     
.................... ////    for (ui8LoopCount = 1; ui8LoopCount < SIZE_CALIB_TABLE; ui8LoopCount++) 
.................... ////    { 
.................... ////        // Calculate EEPROM Write Address for each calibration point 
.................... ////        ui16EEPROMStartAddress = EEPROM_ADDRESS_FOR_0_GM + (ui8LoopCount * CALIB_POINT_MULT_FACTOR); 
.................... //// 
.................... ////        // Read calib point from EEPROM  
.................... ////        ui16EEPROMPoint = ReadEEPROMInt16(ui16EEPROMStartAddress); 
.................... ////        // Assign calibration point in calib table 
.................... ////        g_stCalibTable[ui8LoopCount].m_i16CalibPoint = ui16EEPROMPoint; 
.................... ////        // Increment address 
.................... ////        ui16EEPROMStartAddress += 2; 
.................... ////        // Read calib value from EEPROM 
.................... ////        ui16EEPROMValue = ReadEEPROMInt16(ui16EEPROMStartAddress); 
.................... ////        // Assign calib value in calib table 
.................... ////        g_stCalibTable[ui8LoopCount].m_ui32CalibValue = ui16EEPROMValue; 
.................... ////    } 
.................... ////} 
....................  
.................... ////void WriteDynamicErrToEEPROM(int16 i16DynamicErrValue) 
.................... ////{ 
.................... ////    unsigned int16 ui16DynamicErrValue = 0; 
.................... ////     
.................... ////    ui16DynamicErrValue = (unsigned int16)i16DynamicErrValue; 
.................... //// 
.................... ////    //WriteEEPROMInt16(EEPROM_ADRESS_FOR_DYNAMIC_ERR, ui16DynamicErrValue); 
.................... ////     
.................... ////    return; 
.................... ////} 
....................  
.................... void WriteLCFToEEPROM(int16 i16CurrLoadCellFactor) 
.................... { 
....................     unsigned int16 ui16CurrLoadCellFactor = 0; 
....................      
....................     // cast the receive parameter in unsugned. 
....................     ui16CurrLoadCellFactor = (unsigned int16)i16CurrLoadCellFactor; 
....................      
....................     // Store data in EEPROM. 
....................     WriteEEPROMInt16(EEPROM_ADDRESS_FOR_LCF,ui16CurrLoadCellFactor); 
.................... } 
....................  
.................... int16 ReadLCFFromEEPROM(void) 
.................... { 
....................     unsigned int16 ui16RetrieveLCF = 0; 
....................      
....................     // Retrieve stored LCF from EEPROM. 
....................     ui16RetrieveLCF = ReadEEPROMInt16(EEPROM_ADDRESS_FOR_LCF); 
....................      
....................     return((int16)ui16RetrieveLCF); 
.................... } 
....................  
.................... //int16 ReadDynamicERRValueFromEEPROM() 
.................... //{ 
.................... //    int16          i16DynamicErrValue  = 0; 
.................... //    unsigned int16 ui16DynamicERRValue = 0; 
.................... // 
.................... //    ui16DynamicERRValue = ReadEEPROMInt16(EEPROM_ADRESS_FOR_DYNAMIC_ERR); 
.................... //     
.................... ////    if (ui16DynamicERRValue > 0x8000) 
.................... ////    { 
.................... ////        ui16DynamicERRValue = ui16DynamicERRValue << 1; 
.................... ////        ui16DynamicERRValue = ui16DynamicERRValue >> 1; 
.................... ////         
.................... ////        i16DynamicErrValue = (int16)ui16DynamicERRValue; 
.................... ////        i16DynamicErrValue = 0 - i16DynamicErrValue; 
.................... ////    } 
.................... ////    else 
.................... ////    { 
.................... ////        i16DynamicErrValue =  (int16)ui16DynamicERRValue; 
.................... ////    } 
.................... //    i16DynamicErrValue =  (int16)ui16DynamicERRValue; 
.................... //    return i16DynamicErrValue; 
.................... //} 
....................  
.................... //// TESTING 
.................... //void TestEEPROMData(void) 
.................... //{ 
.................... //    unsigned int16 ui16TempCalibPoint = 0; 
.................... //    unsigned int16 ui16TempCalibValue = 41926; 
.................... //    int8           i8LoopCount        = 0; 
.................... //     
.................... //    for (i8LoopCount = 1; i8LoopCount < SIZE_CALIB_TABLE; i8LoopCount++) 
.................... //    { 
.................... //       ui16TempCalibPoint= ui16TempCalibPoint + 1000; 
.................... //       ui16TempCalibValue = ui16TempCalibValue + 1156; 
.................... //       WriteDataToEEPROM(ui16TempCalibPoint, ui16TempCalibValue); 
.................... //    }     
.................... //} 
....................  
.................... //void ResetCalibTable(void) 
.................... //{ 
.................... //    unsigned int8 ui8LoopCount = 0; 
.................... //     
.................... //    for (ui8LoopCount = 0; ui8LoopCount < SIZE_CALIB_TABLE; ui8LoopCount++) 
.................... //    { 
.................... //        g_stCalibTable[ui8LoopCount].m_i16CalibPoint = 0; 
.................... //        g_stCalibTable[ui8LoopCount].m_ui32CalibValue = 0; 
.................... //    } 
.................... //} 
....................  
.................... #endif /* _VM_EEPROM_CONFIG_BRITANIA_H_ */ 
....................  
....................  
.................... //// Get Calib Point Parsing 
.................... //typedef struct _ST_GET_CALIB_POINT 
.................... //{ 
.................... //     
.................... //} ST_GET_CALIB_POINT; 
....................  
.................... // IBC Message Process Proc 
.................... //void ProcessIBCMsg() 
.................... //{ 
.................... //    int8 i8LoopCount = 0; 
.................... // 
.................... //    // There is some valid message in IBC Receive Buffer 
.................... //    // Try to process that message 
.................... //    switch (g_stIBCRcvData.g_ui8ArrIBCData[0]) 
.................... //    { 
.................... //        case IBC_CMD_MODE_HOME: 
.................... //            g_ui8SystemMode = SYS_MODE_HOME; 
.................... //            break; 
.................... //        case IBC_CMD_MODE_CALIB: 
.................... //            g_ui8SystemMode = SYS_MODE_CALIB; 
.................... //            break; 
.................... //        case IBC_CMD_RESET_CALIB_POINT: 
.................... //            // Get the Reset Point Value 
.................... //            // Copy the Message for Parsing 
.................... //            for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //            { 
.................... //                g_unIBCResetCalib.m_ui8Arr[i8LoopCount -1] = g_stIBCRcvData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //            } 
.................... //            g_fResetCalibStatus = IBC_RESET_CALIB_ON; 
.................... //            // Reset Calib Reset Acknowledgment Node 
.................... //            g_unIBCResetCalibAck.m_stIBCResetCalibPoint.m_i16PassCount  = 0; 
.................... //            g_unIBCResetCalibAck.m_stIBCResetCalibPoint.m_i16CalibValue = 0; 
.................... //            break; 
.................... //        case IBC_CMD_RESET_CALIB_POINT_ACK: 
.................... //            for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //            { 
.................... //                g_unIBCAvgNode.m_ui8Arr[i8LoopCount -1] = g_stIBCRcvData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //            } 
.................... //            g_stCurBatchInfo.m_i16AvgWeight = g_unIBCAvgNode.m_stIBCAvgNode.m_i16AvgWt; 
.................... //            break; 
.................... //             
.................... //        case IBC_CMD_MODE_PRE_PROD: 
.................... //            g_ui8SystemMode = SYS_MODE_PRE_PROD; 
.................... //            break; 
.................... //        case IBC_CMD_MODE_PROD: 
.................... //            g_ui8SystemMode = SYS_MODE_PROD; 
.................... //            break; 
.................... //        case IBC_CMD_GET_CALIB_POINT: 
.................... //            break; 
.................... ////        case IBC_CMD_RESET_CALIB_POINT: 
.................... ////            break; 
.................... //        case IBC_CMD_TARE_REQUEST: 
.................... //            break; 
.................... //        case IBC_CMD_PRE_PROD_AVG_WEIGHT: 
.................... //            // Copy the Message for Parsing 
.................... //            for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //            { 
.................... //                g_unIBCAvgNode.m_ui8Arr[i8LoopCount -1] = g_stIBCRcvData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //            } 
.................... //            g_stCurBatchInfo.m_i16AvgWeight = g_unIBCAvgNode.m_stIBCAvgNode.m_i16AvgWt; 
.................... //            break; 
.................... //        case IBC_CMD_PRE_PROD_TOLERANCE: 
.................... //            // Copy the Message for Parsing 
.................... //            for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //            { 
.................... //                g_unIBCTolNode.m_ui8Arr[i8LoopCount - 1] = g_stIBCRcvData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //            } 
.................... //            g_stCurBatchInfo.m_i16PositiveTol = g_unIBCTolNode.m_stIBCTolNode.m_i16PositiveTol; 
.................... //            g_stCurBatchInfo.m_i16NegativeTol = g_unIBCTolNode.m_stIBCTolNode.m_i16NegativeTol; 
.................... //            break; 
.................... //        case IBC_CMD_START_PROD: 
.................... //            break; 
.................... //        default: 
.................... //            break; 
.................... //    } 
.................... //} 
....................  
.................... void ProcessIBCMsg() 
*
01EDE:  MOVLB  A
01EE0:  CLRF   xAB
.................... { 
....................     int8 i8LoopCount = 0; 
....................     ST_IBC_DATA_NODE stIBCRcvNode; 
....................      
....................     // Get Node from IBC Receive Message Queue 
....................     DeleteIBCMsgQueue(&g_stIBCRcvQueue, &stIBCRcvNode); 
01EE2:  MOVLW  01
01EE4:  MOVWF  xB2
01EE6:  MOVLW  02
01EE8:  MOVWF  xB1
01EEA:  MOVLW  0A
01EEC:  MOVWF  xB4
01EEE:  MOVLW  AC
01EF0:  MOVWF  xB3
01EF2:  MOVLB  0
01EF4:  CALL   19D2
....................     // There is some valid message in IBC Receive Buffer 
....................     // Try to process that message 
....................     switch (stIBCRcvNode.g_ui8ArrIBCData[0]) 
01EF8:  MOVLB  A
01EFA:  MOVF   xAC,W
01EFC:  XORLW  64
01EFE:  MOVLB  0
01F00:  BTFSC  FD8.2
01F02:  GOTO   1F6A
01F06:  XORLW  01
01F08:  BTFSC  FD8.2
01F0A:  GOTO   1F74
01F0E:  XORLW  0D
01F10:  BTFSC  FD8.2
01F12:  GOTO   1F7E
01F16:  XORLW  1B
01F18:  BTFSC  FD8.2
01F1A:  GOTO   1FCE
01F1E:  XORLW  18
01F20:  BTFSC  FD8.2
01F22:  GOTO   2030
01F26:  XORLW  1B
01F28:  BTFSC  FD8.2
01F2A:  GOTO   203A
01F2E:  XORLW  16
01F30:  BTFSC  FD8.2
01F32:  GOTO   2044
01F36:  XORLW  0C
01F38:  BTFSC  FD8.2
01F3A:  GOTO   204A
01F3E:  XORLW  06
01F40:  BTFSC  FD8.2
01F42:  GOTO   205C
01F46:  XORLW  01
01F48:  BTFSC  FD8.2
01F4A:  GOTO   20B0
01F4E:  XORLW  1C
01F50:  BTFSC  FD8.2
01F52:  GOTO   210C
01F56:  XORLW  1F
01F58:  BTFSC  FD8.2
01F5A:  GOTO   2112
01F5E:  XORLW  01
01F60:  BTFSC  FD8.2
01F62:  GOTO   211E
01F66:  GOTO   212E
....................     { 
....................         case IBC_CMD_MODE_HOME: 
....................             g_ui8SystemMode = SYS_MODE_HOME; 
01F6A:  MOVLW  01
01F6C:  MOVLB  3
01F6E:  MOVWF  x9E
....................             break; 
01F70:  GOTO   2134
....................         case IBC_CMD_MODE_CALIB: 
....................             g_ui8SystemMode = SYS_MODE_CALIB; 
01F74:  MOVLW  02
01F76:  MOVLB  3
01F78:  MOVWF  x9E
....................             break; 
01F7A:  GOTO   2134
....................         case IBC_CMD_RESET_CALIB_POINT: 
....................             // Get the Reset Point Value 
....................             // Copy the Message for Parsing 
....................             for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
01F7E:  MOVLW  01
01F80:  MOVLB  A
01F82:  MOVWF  xAB
01F84:  MOVF   xAB,W
01F86:  SUBLW  04
01F88:  BTFSS  FD8.0
01F8A:  GOTO   1FC4
....................             { 
....................                 g_unIBCResetCalib.m_ui8Arr[i8LoopCount -1] = stIBCRcvNode.g_ui8ArrIBCData[i8LoopCount]; 
01F8E:  MOVLW  01
01F90:  SUBWF  xAB,W
01F92:  CLRF   03
01F94:  ADDLW  40
01F96:  MOVWF  01
01F98:  MOVLW  00
01F9A:  ADDWFC 03,F
01F9C:  MOVFF  03,AB2
01FA0:  CLRF   03
01FA2:  MOVF   xAB,W
01FA4:  ADDLW  AC
01FA6:  MOVWF  FE9
01FA8:  MOVLW  0A
01FAA:  ADDWFC 03,W
01FAC:  MOVWF  FEA
01FAE:  MOVFF  FEF,AB3
01FB2:  MOVFF  AB2,FEA
01FB6:  MOVFF  01,FE9
01FBA:  MOVFF  AB3,FEF
01FBE:  INCF   xAB,F
01FC0:  GOTO   1F84
....................             } 
....................             g_fResetCalibStatus = IBC_RESET_CALIB_ON; 
01FC4:  MOVLW  01
01FC6:  MOVLB  3
01FC8:  MOVWF  xAC
....................              
....................             break; 
01FCA:  GOTO   2134
.................... //        case IBC_CMD_RESET_CALIB_POINT_ACK: 
.................... //            for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //            { 
.................... //                g_unIBCAvgNode.m_ui8Arr[i8LoopCount -1] = stIBCRcvNode.g_ui8ArrIBCData[i8LoopCount]; 
.................... //            } 
.................... //            g_stCurBatchInfo.m_i16AvgWeight = g_unIBCAvgNode.m_stIBCAvgNode.m_i16AvgWt; 
.................... //            break; 
....................              
....................         case IBC_CMD_SET_LOAD_CELL_FACTOR: 
....................             // Request to update new calibration table. 
....................             //UpdateNewCalibTable(); 
....................             
....................             // Receive current load cell factor. 
....................             for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
01FCE:  MOVLW  01
01FD0:  MOVLB  A
01FD2:  MOVWF  xAB
01FD4:  MOVF   xAB,W
01FD6:  SUBLW  04
01FD8:  BTFSS  FD8.0
01FDA:  GOTO   2014
....................             { 
....................                 g_unIBCCurrLoadCellFactor.m_ui8Arr[i8LoopCount - 1] = stIBCRcvNode.g_ui8ArrIBCData[i8LoopCount]; 
01FDE:  MOVLW  01
01FE0:  SUBWF  xAB,W
01FE2:  CLRF   03
01FE4:  ADDLW  4C
01FE6:  MOVWF  01
01FE8:  MOVLW  00
01FEA:  ADDWFC 03,F
01FEC:  MOVFF  03,AB2
01FF0:  CLRF   03
01FF2:  MOVF   xAB,W
01FF4:  ADDLW  AC
01FF6:  MOVWF  FE9
01FF8:  MOVLW  0A
01FFA:  ADDWFC 03,W
01FFC:  MOVWF  FEA
01FFE:  MOVFF  FEF,AB3
02002:  MOVFF  AB2,FEA
02006:  MOVFF  01,FE9
0200A:  MOVFF  AB3,FEF
0200E:  INCF   xAB,F
02010:  GOTO   1FD4
....................             } 
....................              
....................             //g_stCurBatchInfo.m_i16AvgWeight = g_unIBCAvgNode.m_stIBCAvgNode.m_i16AvgWt; 
....................             // Store current LCF(Load Cell Factor) in RAM. 
....................             g_i16LoadCellFactor = (int16)g_unIBCCurrLoadCellFactor.m_stLoadCellFactor.m_ui16CurrLoadCellFactor; 
02014:  MOVFF  4D,442
02018:  MOVFF  4C,441
....................              
....................             // Store the LCF in EEPROM to retrieve data on system restart. 
....................             WriteLCFToEEPROM(g_i16LoadCellFactor); 
0201C:  MOVFF  442,AB2
02020:  MOVFF  441,AB1
02024:  MOVLB  0
02026:  GOTO   1E50
....................              
....................             break; 
0202A:  MOVLB  3
0202C:  GOTO   2134
....................              
....................         case IBC_CMD_MODE_PRE_PROD: 
....................             g_ui8SystemMode = SYS_MODE_PRE_PROD; 
02030:  MOVLW  03
02032:  MOVLB  3
02034:  MOVWF  x9E
....................             break; 
02036:  GOTO   2134
....................         case IBC_CMD_MODE_PROD: 
....................             g_ui8SystemMode = SYS_MODE_PROD; 
0203A:  MOVLW  04
0203C:  MOVLB  3
0203E:  MOVWF  x9E
....................             break; 
02040:  GOTO   2134
....................         case IBC_CMD_GET_CALIB_POINT: 
....................             break; 
02044:  MOVLB  3
02046:  GOTO   2134
.................... //        case IBC_CMD_RESET_CALIB_POINT: 
.................... //            break; 
....................         case IBC_CMD_TARE_REQUEST: 
....................             ResetCalibTable(g_ui16DynamicTareValue); 
0204A:  MOVFF  3A1,AB2
0204E:  MOVFF  3A0,AB1
02052:  GOTO   1E76
....................             break; 
02056:  MOVLB  3
02058:  GOTO   2134
....................         case IBC_CMD_PRE_PROD_AVG_WEIGHT: 
....................             // Copy the Message for Parsing 
....................             for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
0205C:  MOVLW  01
0205E:  MOVLB  A
02060:  MOVWF  xAB
02062:  MOVF   xAB,W
02064:  SUBLW  04
02066:  BTFSS  FD8.0
02068:  GOTO   20A2
....................             { 
....................                 g_unIBCAvgNode.m_ui8Arr[i8LoopCount -1] = stIBCRcvNode.g_ui8ArrIBCData[i8LoopCount]; 
0206C:  MOVLW  01
0206E:  SUBWF  xAB,W
02070:  CLRF   03
02072:  ADDLW  38
02074:  MOVWF  01
02076:  MOVLW  00
02078:  ADDWFC 03,F
0207A:  MOVFF  03,AB2
0207E:  CLRF   03
02080:  MOVF   xAB,W
02082:  ADDLW  AC
02084:  MOVWF  FE9
02086:  MOVLW  0A
02088:  ADDWFC 03,W
0208A:  MOVWF  FEA
0208C:  MOVFF  FEF,AB3
02090:  MOVFF  AB2,FEA
02094:  MOVFF  01,FE9
02098:  MOVFF  AB3,FEF
0209C:  INCF   xAB,F
0209E:  GOTO   2062
....................             } 
....................             g_stCurBatchInfo.m_i16AvgWeight = g_unIBCAvgNode.m_stIBCAvgNode.m_i16AvgWt; 
020A2:  MOVFF  39,3C5
020A6:  MOVFF  38,3C4
....................             break; 
020AA:  MOVLB  3
020AC:  GOTO   2134
....................         case IBC_CMD_PRE_PROD_TOLERANCE: 
....................             // Copy the Message for Parsing 
....................             for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
020B0:  MOVLW  01
020B2:  MOVLB  A
020B4:  MOVWF  xAB
020B6:  MOVF   xAB,W
020B8:  SUBLW  04
020BA:  BTFSS  FD8.0
020BC:  GOTO   20F6
....................             { 
....................                 g_unIBCTolNode.m_ui8Arr[i8LoopCount - 1] = stIBCRcvNode.g_ui8ArrIBCData[i8LoopCount]; 
020C0:  MOVLW  01
020C2:  SUBWF  xAB,W
020C4:  CLRF   03
020C6:  ADDLW  3C
020C8:  MOVWF  01
020CA:  MOVLW  00
020CC:  ADDWFC 03,F
020CE:  MOVFF  03,AB2
020D2:  CLRF   03
020D4:  MOVF   xAB,W
020D6:  ADDLW  AC
020D8:  MOVWF  FE9
020DA:  MOVLW  0A
020DC:  ADDWFC 03,W
020DE:  MOVWF  FEA
020E0:  MOVFF  FEF,AB3
020E4:  MOVFF  AB2,FEA
020E8:  MOVFF  01,FE9
020EC:  MOVFF  AB3,FEF
020F0:  INCF   xAB,F
020F2:  GOTO   20B6
....................             } 
....................             g_stCurBatchInfo.m_i16PositiveTol = g_unIBCTolNode.m_stIBCTolNode.m_i16PositiveTol; 
020F6:  MOVFF  3D,3C7
020FA:  MOVFF  3C,3C6
....................             g_stCurBatchInfo.m_i16NegativeTol = g_unIBCTolNode.m_stIBCTolNode.m_i16NegativeTol; 
020FE:  MOVFF  3F,3C9
02102:  MOVFF  3E,3C8
....................             break; 
02106:  MOVLB  3
02108:  GOTO   2134
....................         case IBC_CMD_START_PROD: 
....................             break; 
0210C:  MOVLB  3
0210E:  GOTO   2134
....................         case IBC_CMD_MODE_AUTO_CALIB: 
....................             // Copy the Data Length 
....................             g_stAvgWtQueue.m_i8Length = stIBCRcvNode.g_ui8ArrIBCData[1]; 
02112:  MOVFF  AAD,42F
....................             // Change the Rejection Mode to Auto Calib Mode 
....................             g_fRejectionMode = HMI_REJECTION_AUTO_CALIB_MODE; 
02116:  MOVLB  3
02118:  CLRF   xC3
....................             break; 
0211A:  GOTO   2134
....................         case IBC_CMD_MODE_FIXED_CALIB: 
....................             // Mrinmoy - start 
....................             // Copy the Data Length 
....................             g_stAvgWtQueue.m_i8Length = stIBCRcvNode.g_ui8ArrIBCData[1]; 
0211E:  MOVFF  AAD,42F
....................             // Mrinmoy - end 
....................             // Change the Rejection Mode to Fixed Calib Mode 
....................             g_fRejectionMode = HMI_REJECTION_FIXED_CALIB_MODE; 
02122:  MOVLW  01
02124:  MOVLB  3
02126:  MOVWF  xC3
....................             break; 
02128:  GOTO   2134
0212C:  MOVLB  0
....................         default: 
....................             break; 
0212E:  MOVLB  3
02130:  GOTO   2134
....................     } 
02134:  MOVLB  0
02136:  GOTO   2982 (RETURN)
.................... } 
....................  
.................... void UpdateCalibTableToMCU1() 
.................... { 
....................      
.................... } 
.................... #endif	/* VM_IBC_PROCESS_M0_H */ 
....................  
....................  
.................... #include "vmCalibration.h" 
.................... /*  
....................  * File:   vmCalibration.h 
....................  * Author: Amit 
....................  * 
....................  * Created on December 9, 2018, 7:55 PM 
....................  */ 
....................  
.................... #ifndef VM_CALIBRATION_H 
.................... #define	VM_CALIBRATION_H 
....................  
.................... #define SIZE_CALIB_TABLE              11 // Only for the values 0, 1000, 2000, 3000, 4000, 
....................                                             // 5000, 6000, 7000, 8000, 9000 and 10000 
.................... #define EEPROM_START_ADDRESS_CALIB    0 
.................... #define MAX_CALIB_RESET_PASS          3 
....................  
.................... #define 	CALIB_ADC_VAL_0000	43302 
.................... #define 	CALIB_ADC_VAL_1000	44550 
.................... #define 	CALIB_ADC_VAL_2000	45780 
.................... #define 	CALIB_ADC_VAL_3000	47005 
.................... #define 	CALIB_ADC_VAL_4000	48238 
.................... #define 	CALIB_ADC_VAL_5000	49471 
.................... #define 	CALIB_ADC_VAL_6000	50716 
.................... #define 	CALIB_ADC_VAL_7000	51963 
.................... #define 	CALIB_ADC_VAL_8000	53203 
.................... #define 	CALIB_ADC_VAL_9000	54435 
.................... #define 	CALIB_ADC_VAL_10000	55676 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... typedef struct _ST_CALIB_NODE 
.................... { 
....................     int16          m_i16CalibPoint; 
....................     unsigned int32 m_ui32CalibValue; 
.................... } ST_CALIB_NODE; 
....................  
.................... // Node for dynamic error calculations 
.................... typedef struct _ST_DYNAMIC_ERR_NODE 
.................... { 
....................     int16           m_i16WeightPoint; 
....................     unsigned int8   m_ui8ErrValue; 
.................... } ST_DYNAMIC_ERR_NODE; 
....................  
.................... // Parse Union for Calib Point 
.................... typedef union _UN_CALIB_POINT 
.................... { 
....................     unsigned int16 m_un16CalibPoint; 
....................     unsigned int8  m_un8Arr[2]; 
.................... } UN_CALIB_POINT; 
....................  
.................... // Parse Union for Calib Value 
.................... typedef union _UN_CALIB_VALUE 
.................... { 
....................     unsigned int32 m_un32Value; 
....................     unsigned int8  m_un8Arr[4]; 
.................... } UN_CALIB_VALUE; 
....................  
....................  
.................... ST_CALIB_NODE g_stCalibTable[SIZE_CALIB_TABLE]; 
.................... ST_CALIB_NODE g_stTempCalibTable[SIZE_CALIB_TABLE]; 
.................... ST_DYNAMIC_ERR_NODE g_stDynamicErrTable[SIZE_CALIB_TABLE]; 
....................  
.................... // Update Single Calibration Point in EEPROM 
.................... void UpdateCalibPointInRAM(unsigned int16 ui16CalibPoint, unsigned int32 ui32CalibValue) 
.................... { 
....................     // Check if the Calibration Point value is 0 or in Multiple of 1000 or not 
....................     if (!(ui16CalibPoint == 0 || ui16CalibPoint % 1000 == 0)) 
....................     { 
....................         return; 
....................     } 
....................      
....................     // We are only considering 0, or values which are multiple of 1000 
....................     // Now need to check that the value should not be greater than 10000, 
....................     // as we are only considering 10KG of max calibration 
....................     if (ui16CalibPoint > 10000) 
....................     { 
....................         return; 
....................     } 
....................      
....................     // Here we are considering only the following values as calibration point 
....................     // 0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000 and 10000 
....................     // That is only 11 values 
....................     if (!ui16CalibPoint) 
....................     { 
....................         g_stCalibTable[0].m_ui32CalibValue = ui32CalibValue; 
....................     } 
....................     else 
....................     { 
....................         g_stCalibTable[ui16CalibPoint/1000].m_ui32CalibValue = ui32CalibValue; 
....................     } 
.................... } 
....................  
.................... // Update entire table in RAM into EEPROM 
.................... void UpdateCalibTableInEEPROM() 
.................... { 
....................     int iLoopCount = 0; 
....................     unsigned int16 ui16StartAddress = EEPROM_START_ADDRESS_CALIB; 
....................     UN_CALIB_POINT unTempCalibPoint; 
....................     UN_CALIB_VALUE unTempCalibValue; 
....................     unsigned int8  ui8Byte0 = 0; 
....................     unsigned int8  ui8Byte1 = 0; 
....................     unsigned int8  ui8Byte2 = 0; 
....................     unsigned int8  ui8Byte3 = 0; 
....................     unsigned int8  ui8Temp  = 0; 
....................      
....................     for (iLoopCount = 0; iLoopCount < SIZE_CALIB_TABLE; iLoopCount++) 
....................     { 
....................         // Calib Point while in int16 is stored in byte array as  |b1|a1| 
....................         // Calib Value while in int32 is stored in byte array as  |d2|c2|b2|a2| 
....................         // In EEPROM it should be like |a1|b1+c2|a2|b2| 
....................          
....................         // Step 1 : Parse Calib Point and Calib Value 
....................         unTempCalibPoint.m_un16CalibPoint = g_stCalibTable[iLoopCount].m_i16CalibPoint; 
....................         unTempCalibValue.m_un32Value      = g_stCalibTable[iLoopCount].m_ui32CalibValue; 
....................          
....................         // Step2 : Prepare EEPROM Data 0 
....................         ui8Byte0 = unTempCalibPoint.m_un8Arr[0]; 
....................          
....................         ui8Byte1 = unTempCalibPoint.m_un8Arr[1]; 
....................          
....................         // Shift the byte to accommodate high part two bit of value 
....................         ui8Byte1 = ui8Byte1 << 2; 
....................         // Get the High Part 2 bit of of Calib Value 
....................         ui8Temp = unTempCalibValue.m_un8Arr[2]; 
....................         // Make sure that only two bit will present and rest is 0 
....................         ui8Temp = ui8Temp << 6; 
....................         ui8Temp = ui8Temp >> 6; 
....................          
....................         // Now Marge two byte to get the second byte 
....................         ui8Byte1 = ui8Byte1 | ui8Temp; 
....................          
....................         // Step 3: Get the third and 4th Bytes 
....................         ui8Byte2 = unTempCalibValue.m_un8Arr[0]; 
....................         ui8Byte3 = unTempCalibValue.m_un8Arr[1]; 
....................          
....................         // Step 4 : Write to EEPROM 
....................         WriteEEPROMInt8((ui16StartAddress + (4*iLoopCount) + 0), ui8Byte0); 
....................         WriteEEPROMInt8((ui16StartAddress + (4*iLoopCount) + 1), ui8Byte1); 
....................         WriteEEPROMInt8((ui16StartAddress + (4*iLoopCount) + 2), ui8Byte2); 
....................         WriteEEPROMInt8((ui16StartAddress + (4*iLoopCount) + 3), ui8Byte3); 
....................     } 
.................... } 
....................  
.................... // Update entire table in RAM into EEPROM 
.................... void UpdateCalibPointInEEPROM() 
.................... { 
....................      
.................... } 
....................  
.................... void IBCSendCalibTable() 
.................... { 
....................     int8           i8LoopCount1      = 0; 
....................     int8           i8LoopCount2      = 1; 
....................     unsigned int16 ui16StartAddress  = EEPROM_START_ADDRESS_CALIB; 
....................     unsigned int16 ui16EEPROMAddress = EEPROM_START_ADDRESS_CALIB; 
....................     ST_IBC_DATA_NODE stIBCDataNode; 
....................      
....................     for (i8LoopCount1 = 0; i8LoopCount1 < SIZE_CALIB_TABLE; i8LoopCount1++) 
....................     { 
....................         // Step 1: First Stuff the IBC Command in the First Byte 
....................         //stIBCDataNode.g_ui8ArrIBCData[0] = IBC_CMD_SET_CALIB_POINT; 
....................          
....................         // Step 2: Stuff 4 Data Bytes from EEPROM 
....................         for (i8LoopCount2 = 1; i8LoopCount2 < IBC_MSG_BYTE_COUNT; i8LoopCount2++) 
....................         { 
....................             stIBCDataNode.g_ui8ArrIBCData[i8LoopCount2] = 
....................                    ReadEEPROMInt8(ui16StartAddress +  
....................                                  (i8LoopCount1 * (IBC_MSG_BYTE_COUNT - 1)) + 
....................                                  (i8LoopCount2 - 1)); 
....................         } 
....................          
....................         // Step 3: Put it into the IBC Send QUEUE 
....................         //InsertSendQueue(&stIBCDataNode); 
....................         InsertIBCMsgQueue(&g_stIBCSendQueue, &stIBCDataNode); 
....................         //delay_ms(100);  //TODO Just for Testing 
....................     } 
.................... } 
....................  
.................... // Get Calibration Table From EEPROM 
.................... void PrepareCalibTable() 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     unsigned int16 ui16TempCalibPoint = 0; 
....................     unsigned int32 ui32TempCalibValue = 0; 
....................     unsigned int8 ui8Data0 = 0; 
....................     unsigned int8 ui8Data1 = 0; 
....................     unsigned int8 ui8Data2 = 0; 
....................     unsigned int8 ui8Data3 = 0; 
....................     unsigned int8 ui8Temp  = 0; 
....................      
....................     unsigned int16 ui16CalibTableStartAddress = 0;   //TODO Set the Calibration Table Start Address 
....................      
....................     // Read from EEPROM and set Calibration Table 
....................     for (i8LoopCount = 0; i8LoopCount < SIZE_CALIB_TABLE; i8LoopCount++) 
....................     { 
....................         // Get data from EEPROM 
....................         // First 14 bit stores the Calibration Point Second 18 bit stores the Value 
....................         ui8Data0 = ReadEEPROMInt8(ui16CalibTableStartAddress + ((i8LoopCount *4) + 0)); 
....................         ui8Data1 = ReadEEPROMInt8(ui16CalibTableStartAddress + ((i8LoopCount *4) + 1)); 
....................         ui8Data2 = ReadEEPROMInt8(ui16CalibTableStartAddress + ((i8LoopCount *4) + 2)); 
....................         ui8Data3 = ReadEEPROMInt8(ui16CalibTableStartAddress + ((i8LoopCount *4) + 3)); 
....................          
....................         // Set the Calibration Point 
....................         ui16TempCalibPoint = ui8Data1; 
....................         ui16TempCalibPoint = ui16TempCalibPoint >> 2; 
....................         g_stCalibTable[i8LoopCount].m_i16CalibPoint = ui16TempCalibPoint; 
....................         g_stCalibTable[i8LoopCount].m_i16CalibPoint = g_stCalibTable[i8LoopCount].m_i16CalibPoint << 8; 
....................         g_stCalibTable[i8LoopCount].m_i16CalibPoint = g_stCalibTable[i8LoopCount].m_i16CalibPoint | ui8Data0; 
....................          
....................         // Set the Calibration Value 
....................         ui8Temp = ui8Data1; 
....................         ui8Temp = ui8Temp << 6; 
....................         ui8Temp = ui8Temp >> 6; 
....................         g_stCalibTable[i8LoopCount].m_ui32CalibValue = ui8Temp; 
....................         g_stCalibTable[i8LoopCount].m_ui32CalibValue = g_stCalibTable[i8LoopCount].m_ui32CalibValue << 16; 
....................          
....................         ui32TempCalibValue = ui8Data3; 
....................         ui32TempCalibValue = ui32TempCalibValue << 8; 
....................         g_stCalibTable[i8LoopCount].m_ui32CalibValue = g_stCalibTable[i8LoopCount].m_ui32CalibValue | ui32TempCalibValue; 
....................          
....................         ui32TempCalibValue = ui8Data2; 
....................         g_stCalibTable[i8LoopCount].m_ui32CalibValue = g_stCalibTable[i8LoopCount].m_ui32CalibValue | ui32TempCalibValue; 
....................          
....................     } 
.................... } 
....................  
....................  
.................... // TESTING Start 
.................... void PrepareTestCalibTable() 
.................... { 
....................     g_stCalibTable[0].m_i16CalibPoint  = 0; 
....................     g_stCalibTable[0].m_ui32CalibValue = CALIB_ADC_VAL_0000;  //41925 
....................      
....................     g_stCalibTable[1].m_i16CalibPoint  = 1000; 
....................     g_stCalibTable[1].m_ui32CalibValue = CALIB_ADC_VAL_1000;  //43081 
....................      
....................     g_stCalibTable[2].m_i16CalibPoint  = 2000; 
....................     g_stCalibTable[2].m_ui32CalibValue = CALIB_ADC_VAL_2000;  //44233 
....................      
....................     g_stCalibTable[3].m_i16CalibPoint  = 3000; 
....................     g_stCalibTable[3].m_ui32CalibValue = CALIB_ADC_VAL_3000;  //45379 
....................      
....................     g_stCalibTable[4].m_i16CalibPoint  = 4000; 
....................     g_stCalibTable[4].m_ui32CalibValue = CALIB_ADC_VAL_4000;  //46538 
....................      
....................     g_stCalibTable[5].m_i16CalibPoint  = 5000; 
....................     g_stCalibTable[5].m_ui32CalibValue = CALIB_ADC_VAL_5000;  //47686 
....................      
....................     g_stCalibTable[6].m_i16CalibPoint  = 6000; 
....................     g_stCalibTable[6].m_ui32CalibValue = CALIB_ADC_VAL_6000;  //48842 
....................      
....................     g_stCalibTable[7].m_i16CalibPoint  = 7000; 
....................     g_stCalibTable[7].m_ui32CalibValue = CALIB_ADC_VAL_7000;  //49992 
....................      
....................     g_stCalibTable[8].m_i16CalibPoint  = 8000; 
....................     g_stCalibTable[8].m_ui32CalibValue = CALIB_ADC_VAL_8000;  //51151 
....................      
....................     g_stCalibTable[9].m_i16CalibPoint  = 9000; 
....................     g_stCalibTable[9].m_ui32CalibValue = CALIB_ADC_VAL_9000;  //52303 
....................      
....................     g_stCalibTable[10].m_i16CalibPoint  = 10000; 
....................     g_stCalibTable[10].m_ui32CalibValue = CALIB_ADC_VAL_10000; //53456 
.................... } 
....................  
.................... // In RAM Only 
.................... void PrepareTempCalibTable(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................      
....................     // Prepare table 
....................     for (i8LoopCount = 0; i8LoopCount < SIZE_CALIB_TABLE; i8LoopCount++) 
....................     { 
....................         g_stTempCalibTable[i8LoopCount].m_i16CalibPoint = g_stCalibTable[i8LoopCount].m_i16CalibPoint; 
....................         g_stTempCalibTable[i8LoopCount].m_ui32CalibValue = g_stCalibTable[i8LoopCount].m_ui32CalibValue; 
....................     } 
.................... } 
....................  
.................... void ResetCalibTable(int16 i16TareValue) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................      
....................     for (i8LoopCount = 0; i8LoopCount < SIZE_CALIB_TABLE; i8LoopCount++) 
....................     { 
....................         g_stCalibTable[i8LoopCount].m_ui32CalibValue += i16TareValue; 
....................     } 
.................... } 
....................  
.................... void PrepareTestCalibTableX(unsigned int16 ui16X) 
.................... { 
....................     g_stCalibTable[0].m_i16CalibPoint  = 0; 
....................     g_stCalibTable[0].m_ui32CalibValue = 165 + ui16X; 
....................      
....................     g_stCalibTable[1].m_i16CalibPoint  = 1000; 
....................     g_stCalibTable[1].m_ui32CalibValue = 1005 + ui16X; 
....................      
....................     g_stCalibTable[2].m_i16CalibPoint  = 2000; 
....................     g_stCalibTable[2].m_ui32CalibValue = 2005 + ui16X; 
....................      
....................     g_stCalibTable[3].m_i16CalibPoint  = 3000; 
....................     g_stCalibTable[3].m_ui32CalibValue = 3005 + ui16X; 
....................      
....................     g_stCalibTable[4].m_i16CalibPoint  = 4000; 
....................     g_stCalibTable[4].m_ui32CalibValue = 4005 + ui16X; 
....................      
....................     g_stCalibTable[5].m_i16CalibPoint  = 5000; 
....................     g_stCalibTable[5].m_ui32CalibValue = 5005 + ui16X; 
....................      
....................     g_stCalibTable[6].m_i16CalibPoint  = 6000; 
....................     g_stCalibTable[6].m_ui32CalibValue = 6005 + ui16X; 
....................      
....................     g_stCalibTable[7].m_i16CalibPoint  = 7000; 
....................     g_stCalibTable[7].m_ui32CalibValue = 7005 + ui16X; 
....................      
....................     g_stCalibTable[8].m_i16CalibPoint  = 8000; 
....................     g_stCalibTable[8].m_ui32CalibValue = 8005 + ui16X; 
....................      
....................     g_stCalibTable[9].m_i16CalibPoint  = 9000 + ui16X; 
....................     g_stCalibTable[9].m_ui32CalibValue = 9005; 
....................      
....................     g_stCalibTable[10].m_i16CalibPoint  = 10000; 
....................     g_stCalibTable[10].m_ui32CalibValue = 10005 + ui16X; 
.................... } 
.................... // TESTING End 
.................... #endif	/* VM_CALIBRATION_H */ 
....................  
....................  
.................... #include "vmAverageWeightCalculation.h" 
.................... /*  
....................  * File:   vmAverageWeightCalculation.h 
....................  * Author: OEM 
....................  * 
....................  * Created on December 20, 2018, 11:50 AM 
....................  */ 
....................  
.................... #ifndef VM_AVERAGE_WEIGHT_CALCULATION_H 
.................... #define	VM_AVERAGE_WEIGHT_CALCULATION_H 
....................  
.................... #define SIZE_AVG_WT_ARR                 50 
.................... #define MAX_DEVIATIION_FROM_AVG_WT      1000  // We are considering +- 1000gm weight deviation 
.................... #define MAX_DEVIATION_FOR_BATCH_CHANGE  850   // If Current weight 850gm deviated from last average weight then we consider batch must be changed. 
....................                                               // In that case we reset the queue. 
....................  
.................... typedef struct _ST_AVG_WT_QUEUE 
.................... { 
....................     int16 m_i16Arr[SIZE_AVG_WT_ARR]; 
....................     int8  m_i8Rear; 
....................     int8  m_i8Length; 
....................     int8  m_i8QueueFull; 
....................     int16 m_i16CurAvg; 
....................     int16 m_i16LstAvg; 
.................... } ST_AVG_WT_QUEUE; 
....................  
.................... ST_AVG_WT_QUEUE g_stAvgWtQueue; 
....................  
.................... void InitializeAvgWtQueue() 
.................... { 
....................     unsigned int8 ui8LoopCount = 0; 
....................     g_stAvgWtQueue.m_i8Rear     = -1; 
....................     g_stAvgWtQueue.m_i8Length   = SIZE_AVG_WT_ARR; 
....................     g_stAvgWtQueue.m_i16CurAvg  = 0; 
....................     g_stAvgWtQueue.m_i8QueueFull = 0; 
....................      
....................     // Initialize array member. 
....................     for(ui8LoopCount = 0; ui8LoopCount < SIZE_AVG_WT_ARR; ui8LoopCount++) 
....................     { 
....................         g_stAvgWtQueue.m_i16Arr[ui8LoopCount] = 0; 
....................     } 
.................... } 
....................  
.................... void ResetAvgWtQueue(int8 i8Length) 
.................... { 
....................     if (i8Length <= SIZE_AVG_WT_ARR) 
....................     { 
....................         g_stAvgWtQueue.m_i8Length = i8Length; 
....................     } 
....................     else 
....................     { 
....................         g_stAvgWtQueue.m_i8Length = SIZE_AVG_WT_ARR; 
....................     } 
.................... } 
....................  
.................... void InsertAvgWtQueue(int16 i16LastWeight) 
.................... { 
....................     int8  i8LoopCount = 0; 
....................     int8  i8MaxEntry  = 0; 
....................     int32 i32Sum      = 0; 
....................      
....................     // Check the weight deviation from Selected SKU Average Weight 
....................     if (i16LastWeight > (g_stCurBatchInfo.m_i16AvgWeight + MAX_DEVIATIION_FROM_AVG_WT) || 
....................         i16LastWeight < (g_stCurBatchInfo.m_i16AvgWeight - MAX_DEVIATIION_FROM_AVG_WT)) 
....................     { 
....................         // The weight is out of range, we are not inserting this weight into Average weight queue  
....................         return; 
....................     } 
....................      
....................     // Increment Rear 
....................     g_stAvgWtQueue.m_i8Rear++; 
....................      
....................     // Check if the current weight is a new batch weight. 
....................     if(i16LastWeight >= g_stAvgWtQueue.m_i16LstAvg + MAX_DEVIATION_FOR_BATCH_CHANGE) 
....................     { 
....................         g_stAvgWtQueue.m_i8Rear = 0; 
....................     } 
....................      
....................     // Check queue length according to auto/fixed calibration mode. 
....................     // If in auto calibration mode then data will be inserted upto user input stored avg queue length. 
....................     if(HMI_REJECTION_AUTO_CALIB_MODE == g_fRejectionMode) 
....................     { 
....................         if (g_stAvgWtQueue.m_i8Rear >= g_stAvgWtQueue.m_i8Length) 
....................         { 
....................             g_stAvgWtQueue.m_i8Rear      = 0; 
....................             // Update state Queue Full 
....................             g_stAvgWtQueue.m_i8QueueFull = 1; 
....................         } 
....................     } 
....................     // Otherwise in fixed calibration mode data will be inserted upto queue's original length. 
....................     else 
....................     { 
....................         if (g_stAvgWtQueue.m_i8Rear >= SIZE_AVG_WT_ARR) 
....................         { 
....................             g_stAvgWtQueue.m_i8Rear      = 0; 
....................             // Update state Queue Full 
....................             g_stAvgWtQueue.m_i8QueueFull = 1; 
....................         } 
....................     } 
....................      
....................     // Insert into Queue 
....................     g_stAvgWtQueue.m_i16Arr[g_stAvgWtQueue.m_i8Rear] = i16LastWeight; 
....................      
....................     // Get the Max entry in queue 
....................     if (1 == g_stAvgWtQueue.m_i8QueueFull) 
....................     { 
....................         if(HMI_REJECTION_AUTO_CALIB_MODE == g_fRejectionMode) 
....................         {     
....................             // Set maximum counted data for average calculation. 
....................             i8MaxEntry = g_stAvgWtQueue.m_i8Length; 
....................              
....................             // Reset queue full flag. 
....................             g_stAvgWtQueue.m_i8QueueFull = 0; 
....................         } 
....................         else 
....................         { 
....................             // Set maximum counted data for average calculation. 
....................             i8MaxEntry = SIZE_AVG_WT_ARR; 
....................              
....................             // Reset queue full flag. 
....................             g_stAvgWtQueue.m_i8QueueFull = 0; 
....................         } 
....................     } 
....................     else 
....................     { 
....................         i8MaxEntry = g_stAvgWtQueue.m_i8Rear + 1; 
....................     } 
....................      
....................     // Get the summation of queue values    
....................     for (i8LoopCount = 0; i8LoopCount < i8MaxEntry; i8LoopCount++) 
....................     { 
....................         i32Sum += g_stAvgWtQueue.m_i16Arr[i8LoopCount]; 
....................     } 
....................      
....................     g_stAvgWtQueue.m_i16CurAvg = (int16)(i32Sum / (int32)i8MaxEntry); 
....................      
....................     // Store the current average in last average of all CBBs. 
....................     g_stAvgWtQueue.m_i16LstAvg = g_stAvgWtQueue.m_i16CurAvg; 
.................... } 
....................  
.................... void IBCSendProdModeAvgData() 
.................... { 
....................     ST_IBC_DATA_NODE stIBCDataNode; 
....................     int8 i8LoopCount = 0; 
....................      
....................  
....................     // Prepare IBC Data Node 
....................     g_unIBCProdModeAvg.m_stAvgData.m_i16Padding  = 0; 
....................     g_unIBCProdModeAvg.m_stAvgData.m_i16CurAvg   = g_stAvgWtQueue.m_i16CurAvg; 
....................      
....................     // Stuff IBC Command 
....................     stIBCDataNode.g_ui8ArrIBCData[0] = IBC_CMD_PROD_AVG_WT_DATA; 
....................     for (i8LoopCount = 1; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         stIBCDataNode.g_ui8ArrIBCData[i8LoopCount] = g_unIBCProdModeAvg.m_ui8Arr[i8LoopCount - 1]; 
....................     } 
....................      
....................     // Send to IBC Insert 
....................     //InsertSendQueue(&stIBCDataNode); 
....................     InsertIBCMsgQueue(&g_stIBCSendQueue, &stIBCDataNode); 
.................... } 
.................... #endif	/* VM_AVERAGE_WEIGHT_CALCULATION_H */ 
....................  
....................  
.................... #include "vmEEPROMConfig_Britania.h" 
.................... #ifndef _VM_EEPROM_CONFIG_BRITANIA_H_ 
.................... #define _VM_EEPROM_CONFIG_BRITANIA_H_ 
....................  
.................... #include "vmEEPROMConfig.h" 
.................... #include "vmCalibration.h" 
....................  
.................... //#define EEPROM_ADDRESS_FOR_0_GM       200 
.................... #define EEPROM_ADDRESS_FOR_LCF          100 
.................... //#define CALIB_PONT_DIV_FACTOR         1000 
.................... //#define CALIB_POINT_MULT_FACTOR       4 
....................  
.................... ////void WriteDataToEEPROM(unsigned int16 ui16CalibPointEEPROM, unsigned int16 ui16ADCCalibValueEEPROM) 
.................... ////{ 
.................... ////    unsigned int16 ui16EEPROMStartAddress = 0; 
.................... ////     
.................... ////    // Calculate EEPROM Write Address for each calibration point  
.................... ////    if(!ui16CalibPointEEPROM) 
.................... ////    { 
.................... ////        ui16EEPROMStartAddress = EEPROM_ADDRESS_FOR_0_GM; 
.................... ////    } 
.................... ////    else 
.................... ////    { 
.................... ////        ui16EEPROMStartAddress = EEPROM_ADDRESS_FOR_0_GM + ((ui16CalibPointEEPROM / CALIB_PONT_DIV_FACTOR) * CALIB_POINT_MULT_FACTOR); 
.................... ////    } 
.................... ////     
.................... ////    // Write Calib point to EEPROM 
.................... ////    WriteEEPROMInt16(ui16EEPROMStartAddress, ui16CalibPointEEPROM); 
.................... ////    // Increment address 
.................... ////    ui16EEPROMStartAddress += 2; 
.................... ////    // Write calib value to EEPROM 
.................... ////    WriteEEPROMInt16(ui16EEPROMStartAddress, ui16ADCCalibValueEEPROM); 
.................... ////    
.................... ////} 
....................  
.................... ////void ReadCalibTableFromEEPROM(void) 
.................... ////{ 
.................... ////    unsigned int16 ui16EEPROMStartAddress = 0; 
.................... ////    unsigned int16 ui16EEPROMPoint        = 0; 
.................... ////    unsigned int16 ui16EEPROMValue        = 0; 
.................... ////    unsigned int8 ui8LoopCount = 0; 
.................... ////     
.................... ////    // Write calib value for 0gm predefined 
.................... ////    g_stCalibTable[0].m_i16CalibPoint = 0; 
.................... ////    g_stCalibTable[0].m_ui32CalibValue = 41925; 
.................... ////     
.................... ////    for (ui8LoopCount = 1; ui8LoopCount < SIZE_CALIB_TABLE; ui8LoopCount++) 
.................... ////    { 
.................... ////        // Calculate EEPROM Write Address for each calibration point 
.................... ////        ui16EEPROMStartAddress = EEPROM_ADDRESS_FOR_0_GM + (ui8LoopCount * CALIB_POINT_MULT_FACTOR); 
.................... //// 
.................... ////        // Read calib point from EEPROM  
.................... ////        ui16EEPROMPoint = ReadEEPROMInt16(ui16EEPROMStartAddress); 
.................... ////        // Assign calibration point in calib table 
.................... ////        g_stCalibTable[ui8LoopCount].m_i16CalibPoint = ui16EEPROMPoint; 
.................... ////        // Increment address 
.................... ////        ui16EEPROMStartAddress += 2; 
.................... ////        // Read calib value from EEPROM 
.................... ////        ui16EEPROMValue = ReadEEPROMInt16(ui16EEPROMStartAddress); 
.................... ////        // Assign calib value in calib table 
.................... ////        g_stCalibTable[ui8LoopCount].m_ui32CalibValue = ui16EEPROMValue; 
.................... ////    } 
.................... ////} 
....................  
.................... ////void WriteDynamicErrToEEPROM(int16 i16DynamicErrValue) 
.................... ////{ 
.................... ////    unsigned int16 ui16DynamicErrValue = 0; 
.................... ////     
.................... ////    ui16DynamicErrValue = (unsigned int16)i16DynamicErrValue; 
.................... //// 
.................... ////    //WriteEEPROMInt16(EEPROM_ADRESS_FOR_DYNAMIC_ERR, ui16DynamicErrValue); 
.................... ////     
.................... ////    return; 
.................... ////} 
....................  
.................... void WriteLCFToEEPROM(int16 i16CurrLoadCellFactor) 
.................... { 
....................     unsigned int16 ui16CurrLoadCellFactor = 0; 
....................      
....................     // cast the receive parameter in unsugned. 
....................     ui16CurrLoadCellFactor = (unsigned int16)i16CurrLoadCellFactor; 
....................      
....................     // Store data in EEPROM. 
....................     WriteEEPROMInt16(EEPROM_ADDRESS_FOR_LCF,ui16CurrLoadCellFactor); 
.................... } 
....................  
.................... int16 ReadLCFFromEEPROM(void) 
.................... { 
....................     unsigned int16 ui16RetrieveLCF = 0; 
....................      
....................     // Retrieve stored LCF from EEPROM. 
....................     ui16RetrieveLCF = ReadEEPROMInt16(EEPROM_ADDRESS_FOR_LCF); 
....................      
....................     return((int16)ui16RetrieveLCF); 
.................... } 
....................  
.................... //int16 ReadDynamicERRValueFromEEPROM() 
.................... //{ 
.................... //    int16          i16DynamicErrValue  = 0; 
.................... //    unsigned int16 ui16DynamicERRValue = 0; 
.................... // 
.................... //    ui16DynamicERRValue = ReadEEPROMInt16(EEPROM_ADRESS_FOR_DYNAMIC_ERR); 
.................... //     
.................... ////    if (ui16DynamicERRValue > 0x8000) 
.................... ////    { 
.................... ////        ui16DynamicERRValue = ui16DynamicERRValue << 1; 
.................... ////        ui16DynamicERRValue = ui16DynamicERRValue >> 1; 
.................... ////         
.................... ////        i16DynamicErrValue = (int16)ui16DynamicERRValue; 
.................... ////        i16DynamicErrValue = 0 - i16DynamicErrValue; 
.................... ////    } 
.................... ////    else 
.................... ////    { 
.................... ////        i16DynamicErrValue =  (int16)ui16DynamicERRValue; 
.................... ////    } 
.................... //    i16DynamicErrValue =  (int16)ui16DynamicERRValue; 
.................... //    return i16DynamicErrValue; 
.................... //} 
....................  
.................... //// TESTING 
.................... //void TestEEPROMData(void) 
.................... //{ 
.................... //    unsigned int16 ui16TempCalibPoint = 0; 
.................... //    unsigned int16 ui16TempCalibValue = 41926; 
.................... //    int8           i8LoopCount        = 0; 
.................... //     
.................... //    for (i8LoopCount = 1; i8LoopCount < SIZE_CALIB_TABLE; i8LoopCount++) 
.................... //    { 
.................... //       ui16TempCalibPoint= ui16TempCalibPoint + 1000; 
.................... //       ui16TempCalibValue = ui16TempCalibValue + 1156; 
.................... //       WriteDataToEEPROM(ui16TempCalibPoint, ui16TempCalibValue); 
.................... //    }     
.................... //} 
....................  
.................... //void ResetCalibTable(void) 
.................... //{ 
.................... //    unsigned int8 ui8LoopCount = 0; 
.................... //     
.................... //    for (ui8LoopCount = 0; ui8LoopCount < SIZE_CALIB_TABLE; ui8LoopCount++) 
.................... //    { 
.................... //        g_stCalibTable[ui8LoopCount].m_i16CalibPoint = 0; 
.................... //        g_stCalibTable[ui8LoopCount].m_ui32CalibValue = 0; 
.................... //    } 
.................... //} 
....................  
.................... #endif /* _VM_EEPROM_CONFIG_BRITANIA_H_ */ 
....................  
....................  
....................  
.................... void InitGlobalVariables(void) 
.................... { 
....................      
....................     g_manualModeActionOnHw = MANUAL_MODE_ACTION_ON_NOTHING; 
*
0075A:  CLRF   27
....................      
....................     g_ui16DIStatus = 0x1A; 
0075C:  CLRF   29
0075E:  MOVLW  1A
00760:  MOVWF  28
....................     g_ui16DOStatus = 0x1A; 
00762:  CLRF   2B
00764:  MOVWF  2A
....................     g_ui16ErrorStatus = 0x1A; 
00766:  CLRF   2D
00768:  MOVWF  2C
....................     g_ui8IncrementIndex = 0; 
0076A:  CLRF   2E
....................      
....................     // Set all pins digital. 
....................     setup_adc_ports(NO_ANALOGS); 
0076C:  MOVLB  F
0076E:  MOVF   x5C,W
00770:  ANDLW  80
00772:  MOVWF  x5C
00774:  MOVLW  00
00776:  MOVWF  x5D
00778:  BCF    FC1.3
0077A:  BCF    FC1.4
0077C:  BCF    FC1.5
....................      
....................     // Initialize IBC Send Message Queue 
....................     //InitializeDataSendQueue(); 
....................     InitializeDataQueue(&g_stIBCRcvQueue); 
0077E:  MOVLW  01
00780:  MOVLB  A
00782:  MOVWF  xAD
00784:  MOVLW  02
00786:  MOVWF  xAC
00788:  MOVLB  0
0078A:  CALL   05DC
....................     InitializeDataQueue(&g_stIBCSendQueue); 
0078E:  MOVLB  A
00790:  CLRF   xAD
00792:  MOVLW  B5
00794:  MOVWF  xAC
00796:  MOVLB  0
00798:  CALL   05DC
....................     // Initialize Average Weight Queue 
....................     InitializeAvgWtQueue(); 
0079C:  GOTO   0662
....................      
....................     // Wakeup ADS1131 
....................     output_high(PIN_ADC_PDWN); 
007A0:  BCF    F94.2
007A2:  BSF    F8B.2
....................     output_high(PIN_ADC_SCLK); 
007A4:  BCF    F94.3
007A6:  BSF    F8B.3
....................      
....................     int8 i8Count = 0; 
007A8:  MOVLB  A
007AA:  CLRF   xAB
....................     for(i8Count = 0; i8Count < 100; i8Count++) 
007AC:  CLRF   xAB
007AE:  MOVF   xAB,W
007B0:  SUBLW  63
007B2:  BTFSS  FD8.0
007B4:  GOTO   07D2
....................     { 
....................         delay_us(1); 
007B8:  CLRWDT
007BA:  BRA    07BC
007BC:  BRA    07BE
....................         output_high(PIN_ADC_SCLK); 
007BE:  BCF    F94.3
007C0:  BSF    F8B.3
....................         delay_us(1); 
007C2:  CLRWDT
007C4:  BRA    07C6
007C6:  BRA    07C8
....................         output_low(PIN_ADC_SCLK); 
007C8:  BCF    F94.3
007CA:  BCF    F8B.3
007CC:  INCF   xAB,F
007CE:  GOTO   07AE
....................     } 
....................      
....................     // TESTING Start 
....................     g_ui8ADCScanningStatus = ADC_SCAN_ON; 
007D2:  MOVLW  01
007D4:  MOVLB  4
007D6:  MOVWF  x43
....................      
....................     // Reset Data Queue 
....................     ResetADCDataQ(COLLECT_DYNAMIC_TARE_DATA);   // TODO it should be COLLECT_NOTHING for TESTING we are using 
007D8:  MOVLW  03
007DA:  MOVLB  A
007DC:  MOVWF  xBF
007DE:  MOVLB  0
007E0:  CALL   06A4
....................                                       // COLLECT_DYNAMIC_TARE_DATA 
....................     // Initialize Batch Info  
....................     g_stCurBatchInfo.m_i16AvgWeight = 1000; 
007E4:  MOVLW  03
007E6:  MOVLB  3
007E8:  MOVWF  xC5
007EA:  MOVLW  E8
007EC:  MOVWF  xC4
....................     g_stCurBatchInfo.m_i16NegativeTol = 50; 
007EE:  CLRF   xC9
007F0:  MOVLW  32
007F2:  MOVWF  xC8
....................     g_stCurBatchInfo.m_i16PositiveTol = 50; 
007F4:  CLRF   xC7
007F6:  MOVWF  xC6
....................      
....................     // Initialize last average of CBBs in average weight calculations. 
....................     g_stAvgWtQueue.m_i16LstAvg = 0; 
007F8:  MOVLB  4
007FA:  CLRF   x34
007FC:  CLRF   x33
....................  
....................     // Initialize Calib Reset Value 
....................     g_unIBCResetCalibAck.m_stIBCResetCalibPoint.m_i16CalibValue = 0; 
007FE:  CLRF   47
00800:  CLRF   46
....................     g_unIBCResetCalibAck.m_stIBCResetCalibPoint.m_i16PassCount  = 0; 
00802:  CLRF   45
00804:  CLRF   44
....................      
....................     // Get the stored load cell factor from EEPROM. 
....................     g_i16LoadCellFactor = ReadLCFFromEEPROM(); 
00806:  MOVLB  0
00808:  GOTO   0730
0080C:  MOVFF  02,442
00810:  MOVFF  01,441
00814:  GOTO   28AC (RETURN)
.................... } 
....................  
.................... void InitSystemInterrupts(void) 
.................... { 
....................     // Initialize external interrupt for InterBoard Communication. 
....................     ext_int_edge(3, H_TO_L);  
00818:  BCF    FF1.3
....................     clear_interrupt(INT_EXT3); 
0081A:  BCF    FF0.2
....................     enable_interrupts(INT_EXT3); 
0081C:  BSF    FF0.5
....................      
....................      
....................      // Enable 1MS main timer. 
....................     clear_interrupt(INT_TIMER0); 
0081E:  BCF    FF2.2
....................     enable_interrupts(INT_TIMER0); 
00820:  BSF    FF2.5
....................      
....................  
....................     // Enable timer interrupts for InterBoard Communication. 
....................     clear_interrupt(INT_TIMER1); 
00822:  BCF    F9E.0
....................     enable_interrupts(INT_TIMER1); 
00824:  BSF    F9D.0
....................     clear_interrupt(INT_TIMER3); 
00826:  BCF    FA1.1
....................     enable_interrupts(INT_TIMER3); 
00828:  BSF    FA0.1
....................  
....................     // Enable RS232 interrupt. 
....................     clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
0082A:  BSF    F9D.5
....................     clear_interrupt(INT_RDA2); 
.................... 	enable_interrupts(INT_RDA2); 
0082C:  BSF    FA3.5
0082E:  GOTO   28B0 (RETURN)
....................      
....................     // Init Modbus Interrupt 
....................     //InitRS485RxInterrupt(); 
....................  
....................      
.................... } 
....................  
.................... void InitializeStateMachines() 
.................... { 
....................     g_ui8NumberOfActiveMachines = NO_OF_ACTIVE_MACHINE; 
*
00BEA:  MOVLW  02
00BEC:  MOVLB  1
00BEE:  MOVWF  x51
.................... //    g_unHWDIState.m_ui32AllDIs          = INITAIL_DI_STATE_ON_PWR_ON; 
.................... //    g_ui32AllHWDIsPreviousState         = INITAIL_DI_STATE_ON_PWR_ON; 
.................... //    g_ui32AllSWDIsPreviousState         = INITAIL_DI_STATE_ON_PWR_ON; 
.................... //    g_unHWDOState.m_ui16AllDOs          = INITAIL_DO_STATE_ON_PWR_ON; 
....................     g_ui32AllDOsCurrentState            = INITAIL_DO_STATE_ON_PWR_ON; 
00BF0:  MOVLW  3F
00BF2:  MOVWF  x57
00BF4:  SETF   x56
....................     g_ui32AllDOsPreviousState           = INITAIL_DO_STATE_ON_PWR_ON; 
00BF6:  MOVWF  x59
00BF8:  SETF   x58
....................     g_ui32AllCountersCurrentState       = 0; 
00BFA:  CLRF   x5B
00BFC:  CLRF   x5A
....................     g_ui32AllCountersPreviousState      = 0; 
00BFE:  CLRF   x5D
00C00:  CLRF   x5C
....................      
.................... //    g_unHWDIState.m_ui32AllDIs          = INITAIL_DI_STATE_ON_PWR_ON; 
....................     //g_unHWDOState.m_ui16AllDOs        = INITAIL_DO_STATE_ON_PWR_ON; 
....................      
....................     // This is only for TESTING BIG Coils  
....................  //   g_fStateMac1StartCoilTransfer        = SPCL_FLAG_SM_1_START_TRANSFER_OFF; 
....................      
....................     // Initialize Counter 
....................     //g_unAllCounters.m_ui16AllCounters   = 0; 
....................      
....................     Initialize_StateMachine_0(); 
00C02:  MOVLB  0
00C04:  GOTO   0832
....................     Initialize_StateMachine_1(); 
00C08:  GOTO   0A8E
00C0C:  GOTO   28B4 (RETURN)
....................      
....................     // Initialize DI Filter 
.................... //    g_unHWDIStateFilter.m_ui32AllDIs    = 0; // We are initializing with 0 as it is a OR flag 
.................... }     
....................  
....................  
.................... void main() 
*
026D6:  CLRF   FF8
026D8:  BCF    FF1.2
026DA:  BCF    F9F.0
026DC:  BCF    FA2.1
026DE:  BCF    FF1.1
026E0:  BSF    FD0.7
026E2:  BSF    07.7
026E4:  BSF    FA7.3
026E6:  MOVLW  08
026E8:  MOVWF  FAF
026EA:  MOVLW  02
026EC:  MOVWF  F7D
026EE:  MOVLW  A6
026F0:  MOVWF  FAC
026F2:  MOVLW  90
026F4:  MOVWF  FAB
026F6:  CLRF   2F
026F8:  CLRF   58
026FA:  CLRF   59
026FC:  MOVLW  A5
026FE:  MOVWF  5A
02700:  CLRF   5B
02702:  CLRF   xB1
02704:  CLRF   xB2
02706:  MOVLW  01
02708:  MOVLB  1
0270A:  MOVWF  x4F
0270C:  CLRF   x50
0270E:  CLRF   x55
02710:  CLRF   x54
02712:  CLRF   x53
02714:  CLRF   x52
02716:  CLRF   x57
02718:  CLRF   x56
0271A:  CLRF   x59
0271C:  CLRF   x58
0271E:  CLRF   x5B
02720:  CLRF   x5A
02722:  CLRF   x5D
02724:  CLRF   x5C
02726:  CLRF   x5E
02728:  CLRF   x5F
0272A:  CLRF   x61
0272C:  CLRF   x60
0272E:  MOVLB  2
02730:  MOVWF  xF2
02732:  MOVLW  24
02734:  MOVLB  3
02736:  MOVWF  x98
02738:  CLRF   x99
0273A:  CLRF   x9B
0273C:  CLRF   x9A
0273E:  CLRF   x9D
02740:  CLRF   x9C
02742:  CLRF   x9E
02744:  CLRF   x9F
02746:  CLRF   xA1
02748:  CLRF   xA0
0274A:  CLRF   xA5
0274C:  CLRF   xA4
0274E:  CLRF   xA3
02750:  CLRF   xA2
02752:  CLRF   xA7
02754:  CLRF   xA6
02756:  CLRF   xAB
02758:  CLRF   xAA
0275A:  CLRF   xA9
0275C:  CLRF   xA8
0275E:  CLRF   xAC
02760:  CLRF   xAE
02762:  CLRF   xAD
02764:  CLRF   xB0
02766:  CLRF   xAF
02768:  CLRF   xB4
0276A:  CLRF   xB3
0276C:  CLRF   xB2
0276E:  CLRF   xB1
02770:  CLRF   xB8
02772:  CLRF   xB7
02774:  CLRF   xB6
02776:  CLRF   xB5
02778:  CLRF   xBA
0277A:  CLRF   xB9
0277C:  CLRF   xBC
0277E:  CLRF   xBB
02780:  CLRF   xBE
02782:  CLRF   xBD
02784:  CLRF   xC0
02786:  CLRF   xBF
02788:  CLRF   xC2
0278A:  CLRF   xC1
0278C:  MOVLW  01
0278E:  MOVWF  xC3
02790:  MOVLB  4
02792:  CLRF   x35
02794:  MOVWF  x36
02796:  CLRF   x3A
02798:  CLRF   x39
0279A:  CLRF   x38
0279C:  CLRF   x37
0279E:  CLRF   x3E
027A0:  CLRF   x3D
027A2:  CLRF   x3C
027A4:  CLRF   x3B
027A6:  CLRF   x40
027A8:  CLRF   x3F
027AA:  CLRF   x42
027AC:  CLRF   x41
027AE:  CLRF   x43
027B0:  CLRF   x47
027B2:  CLRF   x46
027B4:  CLRF   x45
027B6:  CLRF   x44
027B8:  MOVLW  05
027BA:  MOVWF  x48
027BC:  CLRF   x49
027BE:  CLRF   x4A
027C0:  MOVLB  7
027C2:  CLRF   x74
027C4:  CLRF   x73
027C6:  CLRF   x78
027C8:  CLRF   x77
027CA:  CLRF   x76
027CC:  CLRF   x75
027CE:  CLRF   x7A
027D0:  CLRF   x79
027D2:  MOVLW  01
027D4:  MOVWF  x7B
027D6:  MOVLW  0B
027D8:  MOVWF  x7C
027DA:  CLRF   x7E
027DC:  CLRF   x7D
027DE:  CLRF   x80
027E0:  CLRF   x7F
027E2:  MOVLW  01
027E4:  MOVWF  x81
027E6:  MOVWF  x82
027E8:  CLRF   x84
027EA:  CLRF   x83
027EC:  MOVLB  F
027EE:  MOVF   x5C,W
027F0:  ANDLW  80
027F2:  MOVWF  x5C
027F4:  MOVLW  00
027F6:  MOVWF  x5D
027F8:  BCF    FC1.3
027FA:  BCF    FC1.4
027FC:  BCF    FC1.5
027FE:  MOVLB  1
02800:  CLRF   x88
02802:  MOVLB  F
02804:  CLRF   x5E
02806:  CLRF   x5F
02808:  MOVLB  0
0280A:  CLRF   x66
0280C:  CLRF   x67
0280E:  CLRF   x68
02810:  CLRF   x69
02812:  CLRF   x6A
02814:  CLRF   x6B
02816:  CLRF   x6C
02818:  CLRF   x6D
0281A:  CLRF   x6E
0281C:  CLRF   x6F
0281E:  CLRF   x70
02820:  CLRF   x71
02822:  CLRF   x72
02824:  CLRF   x73
02826:  CLRF   x74
02828:  CLRF   x75
0282A:  CLRF   x76
0282C:  CLRF   x77
0282E:  CLRF   x78
02830:  CLRF   x79
02832:  CLRF   x7A
02834:  CLRF   x7B
02836:  CLRF   x7C
02838:  CLRF   x7D
0283A:  CLRF   x7E
0283C:  CLRF   x7F
0283E:  CLRF   x80
02840:  CLRF   x81
02842:  CLRF   x82
02844:  CLRF   x83
02846:  CLRF   x84
02848:  CLRF   x85
0284A:  CLRF   x86
0284C:  CLRF   x87
0284E:  CLRF   x88
02850:  CLRF   x89
02852:  CLRF   x8A
02854:  CLRF   x8B
02856:  CLRF   x8C
02858:  CLRF   x8D
0285A:  CLRF   x8E
0285C:  CLRF   x8F
0285E:  CLRF   x90
02860:  CLRF   x91
02862:  CLRF   x92
02864:  CLRF   x93
02866:  CLRF   x94
02868:  CLRF   x95
0286A:  CLRF   x96
0286C:  CLRF   x97
0286E:  CLRF   x98
02870:  CLRF   x99
02872:  CLRF   x9A
02874:  CLRF   x9B
02876:  CLRF   x9C
02878:  CLRF   x9D
0287A:  CLRF   x9E
0287C:  CLRF   x9F
0287E:  CLRF   xA0
02880:  CLRF   xA1
02882:  CLRF   xA2
02884:  CLRF   xA3
02886:  CLRF   xA4
02888:  CLRF   xA5
0288A:  CLRF   xA6
0288C:  CLRF   xA7
0288E:  CLRF   xA8
02890:  CLRF   xA9
02892:  CLRF   xAA
02894:  CLRF   xAB
02896:  CLRF   xAC
02898:  CLRF   xAD
0289A:  CLRF   xAE
0289C:  CLRF   xAF
0289E:  CLRF   xB0
.................... { 
....................     // Set Watchdog timer ON 
....................     setup_wdt(WDT_ON); 
028A0:  BSF    FD1.0
....................      
....................     // Initialization Section Start 
....................     int8 i8StateMachineIndex = 0; 
028A2:  MOVLB  7
028A4:  CLRF   x85
....................      
....................     InitGlobalVariables(); 
028A6:  MOVLB  0
028A8:  GOTO   075A
....................     InitSystemInterrupts(); 
028AC:  GOTO   0818
....................     InitializeStateMachines(); //TODO Must go to Pre Production Mode 
028B0:  GOTO   0BEA
....................     InitilizeStates(); 
028B4:  GOTO   0C10
....................     delay_ms(10); 
028B8:  MOVLW  0A
028BA:  MOVLB  A
028BC:  MOVWF  xAB
028BE:  MOVLB  0
028C0:  GOTO   0C20
....................      
....................     // Initialize 1MS main timer i.e.=>TIMER0. 
....................     InitDigitalIOPollingTimer(); 
028C4:  GOTO   0C56
....................     //delay_ms(1000); 
....................      
.................... //////    // TESTING Start. 
.................... //////        // Initialize TIMER1. 
.................... //////        InitTIMER1(); 
.................... //////        delay_ms(1000); 
.................... //////        // Initialize TIMER3. 
.................... //////        InitTIMER3(); 
.................... //////    // TESTING End. 
....................        
....................     // Enable Global Interrupts. 
....................     enable_interrupts(GLOBAL);    
028C8:  MOVLW  C0
028CA:  IORWF  FF2,F
....................      
....................      
....................     // TESTING Start 
....................     ST_IBC_DATA_NODE stIBCData; 
....................     stIBCData.g_ui8ArrIBCData[0] = 32; 
028CC:  MOVLW  20
028CE:  MOVLB  7
028D0:  MOVWF  x86
....................     stIBCData.g_ui8ArrIBCData[1] = 64; 
028D2:  MOVLW  40
028D4:  MOVWF  x87
....................     stIBCData.g_ui8ArrIBCData[2] = 128; 
028D6:  MOVLW  80
028D8:  MOVWF  x88
....................     stIBCData.g_ui8ArrIBCData[3] = 0; 
028DA:  CLRF   x89
....................     stIBCData.g_ui8ArrIBCData[4] = 0; 
028DC:  CLRF   x8A
....................     //InsertSendQueue(&stIBCData); 
....................  
....................     g_ui8SystemMode = SYS_MODE_NOTHING; 
028DE:  MOVLB  3
028E0:  CLRF   x9E
....................    
....................     unsigned int32 arr[200]; 
....................     //unsigned int16 ui16X = 0; 
....................      
....................     // Reset WDT. 
.................... 	restart_wdt(); 
028E2:  CLRWDT
....................  
....................     // Set Rejection State ON 
....................     g_unDIState.m_stAllDIBits.m_ui1GDICn01  = BOX_REJECTED; 
028E4:  BCF    1A.4
....................     g_unDIState.m_stAllDIBits.m_ui1GDICn02  = 1; 
028E6:  BSF    1A.3
....................     g_unDOState.m_stAllDOBits.m_ui1HWDOCn01 = 1; 
028E8:  BSF    1E.6
....................      
....................     for(;;) 
....................     { 
....................         // Check if Mean Calculation is started 
....................         if (ADC_MEAN_CALCULATION_START == g_ui8ADCMeanCalState) 
028EA:  MOVLB  4
028EC:  MOVF   x36,F
028EE:  BTFSS  FD8.2
028F0:  GOTO   28FC
....................         { 
....................             StartADCSplitAvg(); 
028F4:  MOVLB  0
028F6:  GOTO   0C6A
028FA:  MOVLB  4
....................         } 
....................         if (ADC_MEAN_CALCULATION_RUNNING == g_ui8ADCMeanCalState) 
028FC:  MOVF   x36,W
028FE:  SUBLW  02
02900:  BTFSS  FD8.2
02902:  GOTO   290E
....................         { 
....................             GetADCSplitSum(); 
02906:  MOVLB  0
02908:  GOTO   0D6E
0290C:  MOVLB  4
....................         } 
....................         if (ADC_MEAN_CALCULATION_DONE == g_ui8ADCMeanCalState) 
0290E:  MOVF   x36,W
02910:  SUBLW  03
02912:  BTFSS  FD8.2
02914:  GOTO   2920
....................         { 
....................             // Mean Value Calculated 
....................             // Will get mean value at g_ui32ADCCurMeanValue 
....................             AfterADCMeanCalculationDone(); 
02918:  MOVLB  0
0291A:  GOTO   1884
0291E:  MOVLB  4
....................         } 
....................          
....................          
....................          
....................         if (1 == g_fIBCDataReceived) 
02920:  MOVLB  0
02922:  DECFSZ xB1,W
02924:  GOTO   2940
....................         { 
....................             // The complete 5 byte data has been received 
....................             // Now we can process the data 
....................             g_fIBCDataReceived = 0; 
02928:  CLRF   xB1
....................  
....................             // Insert Message into IBC Receive Queue 
....................             InsertIBCMsgQueue(&g_stIBCRcvQueue, &g_stIBCRcvData); 
0292A:  MOVLW  01
0292C:  MOVLB  A
0292E:  MOVWF  xB8
02930:  MOVLW  02
02932:  MOVWF  xB7
02934:  CLRF   xBA
02936:  MOVLW  5C
02938:  MOVWF  xB9
0293A:  MOVLB  0
0293C:  CALL   112E
....................         } 
....................          
....................         // Check if there is any message in IBC Send Queue 
....................         if (IsMSGInIBCQueue(&g_stIBCSendQueue) && (0 == g_fIBCSendBusy)) 
02940:  MOVLB  A
02942:  CLRF   xAC
02944:  MOVLW  B5
02946:  MOVWF  xAB
02948:  MOVLB  0
0294A:  CALL   19AA
0294E:  MOVF   01,F
02950:  BTFSC  FD8.2
02952:  GOTO   2966
02956:  MOVF   xB2,F
02958:  BTFSS  FD8.2
0295A:  GOTO   2966
....................         { 
....................             // Make IBC Send Busy 
....................             g_fIBCSendBusy = 1; 
0295E:  MOVLW  01
02960:  MOVWF  xB2
....................             // Call Send IBC Message 
....................             SendIBCMSGFromQ(); 
02962:  GOTO   1ABC
....................         } 
....................         // Check if there is any message in IBC Receive Queue 
....................         if (IsMSGInIBCQueue(&g_stIBCRcvQueue)) 
02966:  MOVLW  01
02968:  MOVLB  A
0296A:  MOVWF  xAC
0296C:  MOVLW  02
0296E:  MOVWF  xAB
02970:  MOVLB  0
02972:  CALL   19AA
02976:  MOVF   01,F
02978:  BTFSC  FD8.2
0297A:  GOTO   2982
....................         { 
....................             // Process IBC  
....................             ProcessIBCMsg(); 
0297E:  GOTO   1EDE
....................         } 
....................  
....................         // Check if ADC is ready 
....................         if (0 == input(PIN_ADC_DOUT_DRDY) && IBC_SEND_UNLOCK == g_fIBCSendLockStatus) 
02982:  BSF    F94.4
02984:  BTFSC  F82.4
02986:  GOTO   29CE
0298A:  MOVF   2F,F
0298C:  BTFSS  FD8.2
0298E:  GOTO   29CE
....................         { 
....................             g_ui32ADCValue = read_ext_adc(); 
02992:  GOTO   213A
02996:  MOVFF  03,447
0299A:  MOVFF  02,446
0299E:  MOVFF  01,445
029A2:  MOVFF  00,444
....................  
....................             if (g_ui32ADCValue) 
029A6:  MOVLB  4
029A8:  MOVF   x44,F
029AA:  BTFSS  FD8.2
029AC:  GOTO   29C8
029B0:  MOVF   x45,F
029B2:  BTFSS  FD8.2
029B4:  GOTO   29C8
029B8:  MOVF   x46,F
029BA:  BTFSS  FD8.2
029BC:  GOTO   29C8
029C0:  MOVF   x47,F
029C2:  BTFSC  FD8.2
029C4:  GOTO   29CC
....................             { 
....................                 g_fADCDataReadyStatus = ADC_DATA_READY; 
029C8:  MOVLW  01
029CA:  MOVWF  x49
029CC:  MOVLB  0
....................             } 
....................         } 
....................  
....................         // Check If We need to send Intermediate Weighing or Tare Data to HMI 
....................         if (IBC_INTERMEDIATE_DATA_SEND_ON == g_fIntermediateDataSend) 
029CE:  MOVLB  3
029D0:  DECFSZ x9F,W
029D2:  GOTO   2A08
....................         { 
....................             // Reset Flag 
....................             g_fIntermediateDataSend = IBC_INTERMEDIATE_DATA_SEND_OFF; 
029D6:  CLRF   x9F
....................              
....................             // Check Weighing is running or not 
....................             if (COLLECT_WEIGHING_DATA == g_stADCDataQ.m_i8CollectionState) 
029D8:  MOVLB  7
029DA:  MOVF   x72,W
029DC:  SUBLW  04
029DE:  BTFSS  FD8.2
029E0:  GOTO   29F4
....................             { 
....................                 g_ui8ADCMeanCalState  = ADC_MEAN_CALCULATION_START; 
029E4:  MOVLB  4
029E6:  CLRF   x36
....................                 g_ui8ADCMeanDataState = ADC_MEAN_DATA_INTERMEDIATE_WEIGHT; 
029E8:  MOVLW  1F
029EA:  MOVLB  3
029EC:  MOVWF  x98
....................             } 
029EE:  GOTO   2A08
029F2:  MOVLB  7
....................             else if (COLLECT_DYNAMIC_TARE_DATA == g_stADCDataQ.m_i8CollectionState) 
029F4:  MOVF   x72,W
029F6:  SUBLW  03
029F8:  BTFSS  FD8.2
029FA:  GOTO   2A0A
....................             { 
....................                 g_ui8ADCMeanCalState  = ADC_MEAN_CALCULATION_START; 
029FE:  MOVLB  4
02A00:  CLRF   x36
....................                 g_ui8ADCMeanDataState = ADC_MEAN_DATA_INTERMEDIATE_TARE; 
02A02:  MOVLW  20
02A04:  MOVLB  3
02A06:  MOVWF  x98
02A08:  MOVLB  7
....................             } 
....................         } 
....................          
....................                  
....................         // Mode Scanner 
....................         switch(g_ui8SystemMode) //g_ui8AllBoardCurrentMode 
02A0A:  MOVLB  3
02A0C:  MOVF   x9E,W
02A0E:  ADDLW  FA
02A10:  BTFSC  FD8.0
02A12:  GOTO   2AA2
02A16:  ADDLW  06
02A18:  MOVLB  0
02A1A:  GOTO   2AAE
....................         { 
....................             // if it is in Wake up mode 
....................             //case SYS_MODE_WAKE_UP: 
....................             case SYS_MODE_NOTHING: 
....................             { 
....................             } 
....................             break; 
02A1E:  MOVLB  3
02A20:  GOTO   2AA2
....................             case SYS_MODE_HOME: 
....................             { 
....................                  
....................             } 
....................             break; 
02A24:  MOVLB  3
02A26:  GOTO   2AA2
....................             case SYS_MODE_PRE_PROD: 
....................             { 
....................  
....................             } 
....................             break; 
02A2A:  MOVLB  3
02A2C:  GOTO   2AA2
....................             case SYS_MODE_CALIB:  // Intentional Fall through 
....................             case SYS_MODE_PROD: 
....................             { 
....................                 // State Machine Running 
....................                 // Check for any change in All DIs and All DOs 
....................                 if (g_uiStateChange) 
02A30:  MOVLB  1
02A32:  MOVF   x5E,F
02A34:  BTFSC  FD8.2
02A36:  GOTO   2A94
....................                 { 
....................                     g_uiStateChange = FLAG_STATE_NOT_CHANGED; 
02A3A:  CLRF   x5E
....................                     // Check all the active State Machines 
....................                     for (i8StateMachineIndex = 0; i8StateMachineIndex < g_ui8NumberOfActiveMachines; i8StateMachineIndex++) 
02A3C:  MOVLB  7
02A3E:  CLRF   x85
02A40:  MOVLB  1
02A42:  MOVF   x51,W
02A44:  MOVLB  7
02A46:  SUBWF  x85,W
02A48:  BTFSC  FD8.0
02A4A:  GOTO   2A92
....................                     { 
....................                         // Check for State Filter 
....................                         CheckState(&g_stArrStateMachines[i8StateMachineIndex], i8StateMachineIndex); 
02A4E:  MOVLB  A
02A50:  CLRF   xC8
02A52:  MOVFF  785,AC7
02A56:  CLRF   xCA
02A58:  MOVLW  C8
02A5A:  MOVWF  xC9
02A5C:  MOVLB  0
02A5E:  CALL   05BA
02A62:  MOVFF  02,03
02A66:  MOVF   01,W
02A68:  ADDLW  62
02A6A:  MOVWF  01
02A6C:  MOVLW  01
02A6E:  ADDWFC 03,F
02A70:  MOVFF  01,AAB
02A74:  MOVFF  03,AAC
02A78:  MOVFF  03,AAE
02A7C:  MOVFF  01,AAD
02A80:  MOVFF  785,AAF
02A84:  MOVLB  0
02A86:  GOTO   2472
02A8A:  MOVLB  7
02A8C:  INCF   x85,F
02A8E:  GOTO   2A40
02A92:  MOVLB  1
....................                     } 
....................                 } 
....................             } 
....................             break; 
02A94:  MOVLB  3
02A96:  GOTO   2AA2
....................             case SYS_MODE_POST_PROD: 
....................             { 
....................             }     
....................             break; 
02A9A:  MOVLB  3
02A9C:  GOTO   2AA2
02AA0:  MOVLB  3
....................         } 
....................          
....................         // TESTING 
....................         output_toggle(PIN_OUT_DO_02); 
02AA2:  BCF    F96.2
02AA4:  BTG    F8D.2
....................          
....................         // Reset WDT. 
....................         restart_wdt(); 
02AA6:  CLRWDT
02AA8:  GOTO   28EA
....................     } 
.................... } 
....................  
02AAC:  SLEEP 
.................... //void main() 
.................... //{ 
.................... //    // Set Watchdog timer ON 
.................... //    setup_wdt(WDT_ON); 
.................... //     
.................... //    // Initialization Section Start 
.................... //    int8 i8StateMachineIndex = 0; 
.................... //     
.................... //    InitGlobalVariables(); 
.................... //    InitSystemInterrupts(); 
.................... //    InitializeStateMachines(); //TODO Must go to Pre Production Mode 
.................... //    InitilizeStates(); 
.................... //    delay_ms(10); 
.................... //     
.................... //    InitDigitalIOPollingTimer(); 
.................... //     
.................... //    // TESTING Start 
.................... //    ST_IBC_DATA_NODE stIBCData; 
.................... //    stIBCData.g_ui8ArrIBCData[0] = 32; 
.................... //    stIBCData.g_ui8ArrIBCData[1] = 64; 
.................... //    stIBCData.g_ui8ArrIBCData[2] = 128; 
.................... //    stIBCData.g_ui8ArrIBCData[3] = 0; 
.................... //    stIBCData.g_ui8ArrIBCData[4] = 0; 
.................... //    //InsertSendQueue(&stIBCData); 
.................... //     
.................... //     
.................... ////    UN_IBC_NODE unIBCSendTest; 
.................... ////    unIBCSendTest.m_ui8ArrNode[0] = 0xAA; 
.................... ////    unIBCSendTest.m_ui8ArrNode[1] = 0xAA; 
.................... ////    unIBCSendTest.m_ui8ArrNode[2] = 0xAA; 
.................... ////    unIBCSendTest.m_ui8ArrNode[3] = 0xAA; 
.................... ////    unIBCSendTest.m_ui8ArrNode[4] = 0xAA; 
.................... //     
.................... //    //delay_ms(10000);  //TODO Must Take care, used just for Testing 
.................... //    //UpdateCalibTableInEEPROM(); 
.................... //    //PrepareCalibTable(); 
.................... //     
.................... //    // TESTING Start 
.................... //    //ResetCalibTable(); 
.................... //     
.................... //    //TestEEPROMData(); 
.................... //    // TESTING End 
.................... //     
.................... //    // Prepare Calibration table 
.................... //    ReadCalibTableFromEEPROM(); 
.................... //    PrepareTestCalibTable(); 
.................... //    PrepareTempCalibTable(); 
.................... //     
.................... //    //IBCSendCalibTable(); 
.................... //    g_ui8SystemMode = SYS_MODE_PROD; 
.................... //    // TESTING Start 
.................... // 
.................... //    unsigned int32 arr[200]; 
.................... //    unsigned int16 ui16X = 0; 
.................... //     
.................... //    // Reset WDT. 
.................... //	restart_wdt(); 
.................... //    // Set Rejection State ON 
.................... //    g_unDIState.m_stAllDIBits.m_ui1GDICn01  = 0; 
.................... //    g_unDIState.m_stAllDIBits.m_ui1GDICn02  = 1; 
.................... //    g_unDOState.m_stAllDOBits.m_ui1HWDOCn01 = 1; 
.................... //     
.................... //    for(;;) 
.................... //    { 
.................... //        // Check if there is any message in IBC Send Queue 
.................... //        if (IsMSGInIBCQueue(&g_stIBCSendQueue) && (0 == g_fIBCSendBusy)) 
.................... //        { 
.................... //            // Make IBC Send Busy 
.................... //            g_fIBCSendBusy = 1; 
.................... //            // Call Send IBC Message 
.................... //            SendIBCMSGFromQ(); 
.................... //        } 
.................... //        // Check if there is any message in IBC Receive Queue 
.................... //        if (IsMSGInIBCQueue(&g_stIBCRcvQueue)) 
.................... //        { 
.................... //            // Process IBC  
.................... //            ProcessIBCMsg(); 
.................... //        } 
.................... // 
.................... //        // Check if ADC is ready 
.................... //        if (0 == input(PIN_ADC_DOUT_DRDY) && IBC_SEND_UNLOCK == g_fIBCSendLockStatus) 
.................... //        { 
.................... //            g_ui32ADCValue = read_ext_adc(); 
.................... // 
.................... //            if (g_ui32ADCValue) 
.................... //            { 
.................... //                g_fADCDataReadyStatus = ADC_DATA_READY; 
.................... //            } 
.................... //        } 
.................... // 
.................... //        // Check If We need to send Intermediate Weighing or Tare Data to HMI 
.................... //        if (IBC_INTERMEDIATE_DATA_SEND_ON == g_fIntermediateDataSend) 
.................... //        { 
.................... //            // Reset Flag 
.................... //            g_fIntermediateDataSend = IBC_INTERMEDIATE_DATA_SEND_OFF; 
.................... //             
.................... //            // Check Weighing is running or not 
.................... //            if (COLLECT_WEIGHING_DATA == g_stADCDataQ.m_i8CollectionState) 
.................... //            { 
.................... //                // Step 1: Get Mean Value 
.................... //                // Start Flag CALC_MEAN_ON 
.................... //                //g_ui8ADCMeanCalState = ADC_MEAN_CALCULATION_START; 
.................... //                 
.................... //                // Step 1: Get Weighing Data 
.................... //                //g_i16CurBoxWeight = GetWeighingData(); 
.................... //                g_i16CurBoxWeight = g_ui32ADCAvg; 
.................... // 
.................... //                // Step 2: Send Weighing data to IBC 
.................... //                //IBCSendWeighingData(g_i16CurBoxWeight, 0); 
.................... //                IBCSendWtInterMidData(g_i16CurBoxWeight); 
.................... //            } 
.................... //            else if (COLLECT_DYNAMIC_TARE_DATA== g_stADCDataQ.m_i8CollectionState) 
.................... //            { 
.................... //                // Send Dynamic Tare Data to IBC 
.................... //                IBCSendTareData(g_ui32ADCAvg); 
.................... //            } 
.................... //        } 
.................... //         
.................... //        // Mode Scanner 
.................... //        switch(g_ui8SystemMode) //g_ui8AllBoardCurrentMode 
.................... //        { 
.................... //            // if it is in Wake up mode 
.................... //            //case SYS_MODE_WAKE_UP: 
.................... //            case SYS_MODE_NOTHING: 
.................... //            { 
.................... //            } 
.................... //            break; 
.................... //            case SYS_MODE_HOME: 
.................... //            { 
.................... //                 
.................... //            } 
.................... //            break; 
.................... //            case SYS_MODE_PRE_PROD: 
.................... //            { 
.................... // 
.................... //            } 
.................... //            break; 
.................... //            case SYS_MODE_CALIB:  // Intentional Fall through 
.................... //            case SYS_MODE_PROD: 
.................... //            { 
.................... //                // State Machine Running 
.................... //                // Check for any change in All DIs and All DOs 
.................... //                if (g_uiStateChange) 
.................... //                { 
.................... //                    g_uiStateChange = FLAG_STATE_NOT_CHANGED; 
.................... //                    // Check all the active State Machines 
.................... //                    for (i8StateMachineIndex = 0; i8StateMachineIndex < g_ui8NumberOfActiveMachines; i8StateMachineIndex++) 
.................... //                    { 
.................... //                        // Check for State Filter 
.................... //                        CheckState(&g_stArrStateMachines[i8StateMachineIndex], i8StateMachineIndex); 
.................... //                    } 
.................... //                } 
.................... //            } 
.................... //            break; 
.................... //            case SYS_MODE_POST_PROD: 
.................... //            { 
.................... //            }     
.................... //            break; 
.................... //        } 
.................... //         
.................... //        output_toggle(PIN_OUT_DO_02); 
.................... //        // Reset WDT. 
.................... //        restart_wdt(); 
.................... //    } 
.................... //} 

Configuration Fuses:
   Word  1: 0415   VREGSLEEP INTRC_HP SOSC_DIG NOXINST ECH NOPLLEN NOFCMEN NOIESO
   Word  2: 2B79   NOPUT NOBROWNOUT BORV18 ZPBORM WDT WDT1024
   Word  3: 8900   CANB MSSPMSK7 MCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
F00000: 01 02 03 04 
