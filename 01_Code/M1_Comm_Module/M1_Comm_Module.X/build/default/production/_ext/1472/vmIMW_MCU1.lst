CCS PCH C Compiler, Version 5.025, 16586               11-Aug-19 14:41

               Filename:   D:\SVN\Work\Projects\Automation\InMotionWeighing\02_Designs\04_Firmware\IMWM_Cam\01_Code\M1_Comm_Module\M1_Comm_Module.X\build\default\production\_ext\1472\vmIMW_MCU1.lst

               ROM used:   26768 bytes (41%)
                           Largest free fragment is 38764
               RAM used:   2835 (78%) at main() level
                           2922 (80%) worst case
               Stack used: 3 locations (2 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   58A2
*
00008:  NOP   
0000A:  NOP   
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FF2.5
00066:  GOTO   0070
0006A:  BTFSC  FF2.2
0006C:  GOTO   057C
00070:  BTFSS  F9D.0
00072:  GOTO   007C
00076:  BTFSC  F9E.0
00078:  GOTO   039E
0007C:  BTFSS  FA0.1
0007E:  GOTO   0088
00082:  BTFSC  FA1.1
00084:  GOTO   031A
00088:  BTFSS  FF0.3
0008A:  GOTO   0094
0008E:  BTFSC  FF0.0
00090:  GOTO   0376
00094:  BTFSS  F9D.5
00096:  GOTO   00A0
0009A:  BTFSC  F9E.5
0009C:  GOTO   0988
000A0:  BTFSS  FA3.5
000A2:  GOTO   00AC
000A6:  BTFSC  FA4.5
000A8:  GOTO   070E
000AC:  MOVFF  0E,00
000B0:  MOVFF  0F,01
000B4:  MOVFF  10,02
000B8:  MOVFF  11,03
000BC:  MOVFF  0C,FE9
000C0:  MOVFF  07,FEA
000C4:  BSF    07.7
000C6:  MOVFF  08,FE1
000CA:  MOVFF  09,FE2
000CE:  MOVFF  0A,FD9
000D2:  MOVFF  0B,FDA
000D6:  MOVFF  12,FF3
000DA:  MOVFF  13,FF4
000DE:  MOVFF  14,FFA
000E2:  MOVFF  15,FF5
000E6:  MOVFF  16,FF6
000EA:  MOVFF  17,FF7
000EE:  MOVF   04,W
000F0:  MOVFF  06,FE0
000F4:  MOVFF  05,FD8
000F8:  RETFIE 0
.................... #include "vmSystemConfig.h" 
.................... #ifndef _VM_SYSTEM_CONFIG_H_ 
.................... #define _VM_SYSTEM_CONFIG_H_ 
....................  
.................... //****************** Inclusion Files *************************** 
.................... #include "18F46K80.h" 
.................... //////////// Standard Header file for the PIC18F46K80 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F46K80 
000FA:  CLRF   FF7
000FC:  ADDLW  0A
000FE:  MOVWF  FF6
00100:  MOVLW  01
00102:  ADDWFC FF7,F
00104:  TBLRD*+
00106:  MOVF   FF5,W
00108:  RETURN 0
0010A:  DATA 00,C1
0010C:  DATA 81,40
0010E:  DATA 01,C0
00110:  DATA 80,41
00112:  DATA 01,C0
00114:  DATA 80,41
00116:  DATA 00,C1
00118:  DATA 81,40
0011A:  DATA 01,C0
0011C:  DATA 80,41
0011E:  DATA 00,C1
00120:  DATA 81,40
00122:  DATA 00,C1
00124:  DATA 81,40
00126:  DATA 01,C0
00128:  DATA 80,41
0012A:  DATA 01,C0
0012C:  DATA 80,41
0012E:  DATA 00,C1
00130:  DATA 81,40
00132:  DATA 00,C1
00134:  DATA 81,40
00136:  DATA 01,C0
00138:  DATA 80,41
0013A:  DATA 00,C1
0013C:  DATA 81,40
0013E:  DATA 01,C0
00140:  DATA 80,41
00142:  DATA 01,C0
00144:  DATA 80,41
00146:  DATA 00,C1
00148:  DATA 81,40
0014A:  DATA 01,C0
0014C:  DATA 80,41
0014E:  DATA 00,C1
00150:  DATA 81,40
00152:  DATA 00,C1
00154:  DATA 81,40
00156:  DATA 01,C0
00158:  DATA 80,41
0015A:  DATA 00,C1
0015C:  DATA 81,40
0015E:  DATA 01,C0
00160:  DATA 80,41
00162:  DATA 01,C0
00164:  DATA 80,41
00166:  DATA 00,C1
00168:  DATA 81,40
0016A:  DATA 00,C1
0016C:  DATA 81,40
0016E:  DATA 01,C0
00170:  DATA 80,41
00172:  DATA 01,C0
00174:  DATA 80,41
00176:  DATA 00,C1
00178:  DATA 81,40
0017A:  DATA 01,C0
0017C:  DATA 80,41
0017E:  DATA 00,C1
00180:  DATA 81,40
00182:  DATA 00,C1
00184:  DATA 81,40
00186:  DATA 01,C0
00188:  DATA 80,41
0018A:  DATA 01,C0
0018C:  DATA 80,41
0018E:  DATA 00,C1
00190:  DATA 81,40
00192:  DATA 00,C1
00194:  DATA 81,40
00196:  DATA 01,C0
00198:  DATA 80,41
0019A:  DATA 00,C1
0019C:  DATA 81,40
0019E:  DATA 01,C0
001A0:  DATA 80,41
001A2:  DATA 01,C0
001A4:  DATA 80,41
001A6:  DATA 00,C1
001A8:  DATA 81,40
001AA:  DATA 00,C1
001AC:  DATA 81,40
001AE:  DATA 01,C0
001B0:  DATA 80,41
001B2:  DATA 01,C0
001B4:  DATA 80,41
001B6:  DATA 00,C1
001B8:  DATA 81,40
001BA:  DATA 01,C0
001BC:  DATA 80,41
001BE:  DATA 00,C1
001C0:  DATA 81,40
001C2:  DATA 00,C1
001C4:  DATA 81,40
001C6:  DATA 01,C0
001C8:  DATA 80,41
001CA:  DATA 00,C1
001CC:  DATA 81,40
001CE:  DATA 01,C0
001D0:  DATA 80,41
001D2:  DATA 01,C0
001D4:  DATA 80,41
001D6:  DATA 00,C1
001D8:  DATA 81,40
001DA:  DATA 01,C0
001DC:  DATA 80,41
001DE:  DATA 00,C1
001E0:  DATA 81,40
001E2:  DATA 00,C1
001E4:  DATA 81,40
001E6:  DATA 01,C0
001E8:  DATA 80,41
001EA:  DATA 01,C0
001EC:  DATA 80,41
001EE:  DATA 00,C1
001F0:  DATA 81,40
001F2:  DATA 00,C1
001F4:  DATA 81,40
001F6:  DATA 01,C0
001F8:  DATA 80,41
001FA:  DATA 00,C1
001FC:  DATA 81,40
001FE:  DATA 01,C0
00200:  DATA 80,41
00202:  DATA 01,C0
00204:  DATA 80,41
00206:  DATA 00,C1
00208:  DATA 81,40
0020A:  CLRF   FF7
0020C:  ADDLW  1A
0020E:  MOVWF  FF6
00210:  MOVLW  02
00212:  ADDWFC FF7,F
00214:  TBLRD*+
00216:  MOVF   FF5,W
00218:  RETURN 0
0021A:  DATA 00,C0
0021C:  DATA C1,01
0021E:  DATA C3,03
00220:  DATA 02,C2
00222:  DATA C6,06
00224:  DATA 07,C7
00226:  DATA 05,C5
00228:  DATA C4,04
0022A:  DATA CC,0C
0022C:  DATA 0D,CD
0022E:  DATA 0F,CF
00230:  DATA CE,0E
00232:  DATA 0A,CA
00234:  DATA CB,0B
00236:  DATA C9,09
00238:  DATA 08,C8
0023A:  DATA D8,18
0023C:  DATA 19,D9
0023E:  DATA 1B,DB
00240:  DATA DA,1A
00242:  DATA 1E,DE
00244:  DATA DF,1F
00246:  DATA DD,1D
00248:  DATA 1C,DC
0024A:  DATA 14,D4
0024C:  DATA D5,15
0024E:  DATA D7,17
00250:  DATA 16,D6
00252:  DATA D2,12
00254:  DATA 13,D3
00256:  DATA 11,D1
00258:  DATA D0,10
0025A:  DATA F0,30
0025C:  DATA 31,F1
0025E:  DATA 33,F3
00260:  DATA F2,32
00262:  DATA 36,F6
00264:  DATA F7,37
00266:  DATA F5,35
00268:  DATA 34,F4
0026A:  DATA 3C,FC
0026C:  DATA FD,3D
0026E:  DATA FF,3F
00270:  DATA 3E,FE
00272:  DATA FA,3A
00274:  DATA 3B,FB
00276:  DATA 39,F9
00278:  DATA F8,38
0027A:  DATA 28,E8
0027C:  DATA E9,29
0027E:  DATA EB,2B
00280:  DATA 2A,EA
00282:  DATA EE,2E
00284:  DATA 2F,EF
00286:  DATA 2D,ED
00288:  DATA EC,2C
0028A:  DATA E4,24
0028C:  DATA 25,E5
0028E:  DATA 27,E7
00290:  DATA E6,26
00292:  DATA 22,E2
00294:  DATA E3,23
00296:  DATA E1,21
00298:  DATA 20,E0
0029A:  DATA A0,60
0029C:  DATA 61,A1
0029E:  DATA 63,A3
002A0:  DATA A2,62
002A2:  DATA 66,A6
002A4:  DATA A7,67
002A6:  DATA A5,65
002A8:  DATA 64,A4
002AA:  DATA 6C,AC
002AC:  DATA AD,6D
002AE:  DATA AF,6F
002B0:  DATA 6E,AE
002B2:  DATA AA,6A
002B4:  DATA 6B,AB
002B6:  DATA 69,A9
002B8:  DATA A8,68
002BA:  DATA 78,B8
002BC:  DATA B9,79
002BE:  DATA BB,7B
002C0:  DATA 7A,BA
002C2:  DATA BE,7E
002C4:  DATA 7F,BF
002C6:  DATA 7D,BD
002C8:  DATA BC,7C
002CA:  DATA B4,74
002CC:  DATA 75,B5
002CE:  DATA 77,B7
002D0:  DATA B6,76
002D2:  DATA 72,B2
002D4:  DATA B3,73
002D6:  DATA B1,71
002D8:  DATA 70,B0
002DA:  DATA 50,90
002DC:  DATA 91,51
002DE:  DATA 93,53
002E0:  DATA 52,92
002E2:  DATA 96,56
002E4:  DATA 57,97
002E6:  DATA 55,95
002E8:  DATA 94,54
002EA:  DATA 9C,5C
002EC:  DATA 5D,9D
002EE:  DATA 5F,9F
002F0:  DATA 9E,5E
002F2:  DATA 5A,9A
002F4:  DATA 9B,5B
002F6:  DATA 99,59
002F8:  DATA 58,98
002FA:  DATA 88,48
002FC:  DATA 49,89
002FE:  DATA 4B,8B
00300:  DATA 8A,4A
00302:  DATA 4E,8E
00304:  DATA 8F,4F
00306:  DATA 8D,4D
00308:  DATA 4C,8C
0030A:  DATA 44,84
0030C:  DATA 85,45
0030E:  DATA 87,47
00310:  DATA 46,86
00312:  DATA 82,42
00314:  DATA 43,83
00316:  DATA 41,81
00318:  DATA 80,40
*
007C2:  DATA 41,54
007C4:  DATA 2B,43
007C6:  DATA 47,44
007C8:  DATA 43,4F
007CA:  DATA 4E,54
007CC:  DATA 3D,31
007CE:  DATA 2C,22
007D0:  DATA 49,50
007D2:  DATA 22,2C
007D4:  DATA 22,77
007D6:  DATA 77,77
007D8:  DATA 22,0D
007DA:  DATA 00,00
007DC:  DATA 41,54
007DE:  DATA 2B,43
007E0:  DATA 47,41
007E2:  DATA 43,54
007E4:  DATA 3D,31
007E6:  DATA 2C,31
007E8:  DATA 0D,00
007EA:  DATA 41,54
007EC:  DATA 2B,43
007EE:  DATA 47,50
007F0:  DATA 41,44
007F2:  DATA 44,52
007F4:  DATA 3D,31
007F6:  DATA 0D,00
007F8:  DATA 41,54
007FA:  DATA 2B,43
007FC:  DATA 47,41
007FE:  DATA 43,54
00800:  DATA 3F,0D
00802:  DATA 00,00
00804:  DATA 41,54
00806:  DATA 2B,51
00808:  DATA 48,54
0080A:  DATA 54,50
0080C:  DATA 55,52
0080E:  DATA 4C,3D
00810:  DATA 25,75
00812:  DATA 2C,25
00814:  DATA 75,0D
00816:  DATA 00,00
00818:  DATA 68,74
0081A:  DATA 74,70
0081C:  DATA 3A,2F
0081E:  DATA 2F,6D
00820:  DATA 77,6D
00822:  DATA 2E,69
00824:  DATA 74,73
00826:  DATA 69,6E
00828:  DATA 69,6E
0082A:  DATA 64,69
0082C:  DATA 61,2E
0082E:  DATA 63,6F
00830:  DATA 6D,2F
00832:  DATA 61,70
00834:  DATA 69,2F
00836:  DATA 54,65
00838:  DATA 73,74
0083A:  DATA 2F,47
0083C:  DATA 65,74
0083E:  DATA 53,74
00840:  DATA 72,69
00842:  DATA 6E,67
00844:  DATA 47,65
00846:  DATA 74,4D
00848:  DATA 65,74
0084A:  DATA 68,6F
0084C:  DATA 64,3F
0084E:  DATA 61,3D
00850:  DATA 32,26
00852:  DATA 62,3D
00854:  DATA 31,26
00856:  DATA 63,3D
00858:  DATA 35,26
0085A:  DATA 6D,3D
0085C:  DATA 31,30
0085E:  DATA 30,30
00860:  DATA 24,25
00862:  DATA 4C,75
00864:  DATA 24,25
00866:  DATA 4C,75
00868:  DATA 24,31
0086A:  DATA 7C,31
0086C:  DATA 35,30
0086E:  DATA 30,24
00870:  DATA 25,4C
00872:  DATA 75,24
00874:  DATA 25,4C
00876:  DATA 75,24
00878:  DATA 31,00
0087A:  DATA 41,54
0087C:  DATA 2B,51
0087E:  DATA 48,54
00880:  DATA 54,50
00882:  DATA 55,52
00884:  DATA 4C,3D
00886:  DATA 25,75
00888:  DATA 2C,25
0088A:  DATA 75,0D
0088C:  DATA 00,00
0088E:  DATA 68,74
00890:  DATA 74,70
00892:  DATA 3A,2F
00894:  DATA 2F,74
00896:  DATA 72,61
00898:  DATA 63,6B
0089A:  DATA 77,65
0089C:  DATA 69,67
0089E:  DATA 68,65
008A0:  DATA 72,2E
008A2:  DATA 63,6F
008A4:  DATA 6D,2F
008A6:  DATA 61,70
008A8:  DATA 69,2F
008AA:  DATA 54,65
008AC:  DATA 73,74
008AE:  DATA 2F,47
008B0:  DATA 65,74
008B2:  DATA 53,74
008B4:  DATA 72,69
008B6:  DATA 6E,67
008B8:  DATA 47,65
008BA:  DATA 74,4D
008BC:  DATA 65,74
008BE:  DATA 68,6F
008C0:  DATA 64,3F
008C2:  DATA 61,3D
008C4:  DATA 25,75
008C6:  DATA 26,62
008C8:  DATA 3D,25
008CA:  DATA 4C,75
008CC:  DATA 26,63
008CE:  DATA 3D,25
008D0:  DATA 75,26
008D2:  DATA 6D,3D
008D4:  DATA 25,4C
008D6:  DATA 75,24
008D8:  DATA 25,4C
008DA:  DATA 75,24
008DC:  DATA 25,4C
008DE:  DATA 75,24
008E0:  DATA 25,75
008E2:  DATA 7C,25
008E4:  DATA 4C,75
008E6:  DATA 24,25
008E8:  DATA 4C,75
008EA:  DATA 24,25
008EC:  DATA 4C,75
008EE:  DATA 24,25
008F0:  DATA 75,7C
008F2:  DATA 25,4C
008F4:  DATA 75,24
008F6:  DATA 25,4C
008F8:  DATA 75,24
008FA:  DATA 25,4C
008FC:  DATA 75,24
008FE:  DATA 25,75
00900:  DATA 7C,25
00902:  DATA 4C,75
00904:  DATA 24,25
00906:  DATA 4C,75
00908:  DATA 24,25
0090A:  DATA 4C,75
0090C:  DATA 24,25
0090E:  DATA 75,7C
00910:  DATA 25,4C
00912:  DATA 75,24
00914:  DATA 25,4C
00916:  DATA 75,24
00918:  DATA 25,4C
0091A:  DATA 75,24
0091C:  DATA 25,75
0091E:  DATA 00,00
00920:  DATA 68,74
00922:  DATA 74,70
00924:  DATA 3A,2F
00926:  DATA 2F,74
00928:  DATA 72,61
0092A:  DATA 63,6B
0092C:  DATA 77,65
0092E:  DATA 69,67
00930:  DATA 68,65
00932:  DATA 72,2E
00934:  DATA 63,6F
00936:  DATA 6D,2F
00938:  DATA 61,70
0093A:  DATA 69,2F
0093C:  DATA 54,65
0093E:  DATA 73,74
00940:  DATA 2F,47
00942:  DATA 65,74
00944:  DATA 53,74
00946:  DATA 72,69
00948:  DATA 6E,67
0094A:  DATA 47,65
0094C:  DATA 74,4D
0094E:  DATA 65,74
00950:  DATA 68,6F
00952:  DATA 64,3F
00954:  DATA 61,3D
00956:  DATA 25,75
00958:  DATA 26,62
0095A:  DATA 3D,25
0095C:  DATA 4C,75
0095E:  DATA 26,63
00960:  DATA 3D,25
00962:  DATA 75,26
00964:  DATA 6D,3D
00966:  DATA 25,4C
00968:  DATA 75,24
0096A:  DATA 25,4C
0096C:  DATA 75,24
0096E:  DATA 25,4C
00970:  DATA 75,24
00972:  DATA 25,75
00974:  DATA 00,00
00976:  DATA 41,54
00978:  DATA 2B,51
0097A:  DATA 48,54
0097C:  DATA 54,50
0097E:  DATA 47,45
00980:  DATA 54,3D
00982:  DATA 31,32
00984:  DATA 30,0D
00986:  DATA 00,00
*
009C4:  DATA 41,54
009C6:  DATA 45,30
009C8:  DATA 0D,00
009CA:  DATA 41,54
009CC:  DATA 2B,43
009CE:  DATA 53,43
009D0:  DATA 53,3D
009D2:  DATA 22,47
009D4:  DATA 53,4D
009D6:  DATA 22,0D
009D8:  DATA 00,00
009DA:  DATA 41,54
009DC:  DATA 2B,43
009DE:  DATA 50,4D
009E0:  DATA 53,3D
009E2:  DATA 22,53
009E4:  DATA 4D,22
009E6:  DATA 0D,00
009E8:  DATA 41,54
009EA:  DATA 2B,43
009EC:  DATA 4E,4D
009EE:  DATA 49,3D
009F0:  DATA 32,2C
009F2:  DATA 32,2C
009F4:  DATA 30,2C
009F6:  DATA 30,2C
009F8:  DATA 30,0D
009FA:  DATA 00,00
009FC:  DATA 41,54
009FE:  DATA 2B,43
00A00:  DATA 4D,47
00A02:  DATA 46,3D
00A04:  DATA 31,0D
00A06:  DATA 00,00
00A08:  DATA 41,54
00A0A:  DATA 0D,00
00A0C:  DATA 41,54
00A0E:  DATA 2B,43
00A10:  DATA 4D,47
00A12:  DATA 46,3D
00A14:  DATA 31,0D
00A16:  DATA 00,00
00A18:  DATA 41,54
00A1A:  DATA 2B,43
00A1C:  DATA 4D,47
00A1E:  DATA 53,3D
00A20:  DATA 22,25
00A22:  DATA 63,25
00A24:  DATA 63,25
00A26:  DATA 63,25
00A28:  DATA 63,25
00A2A:  DATA 63,25
00A2C:  DATA 63,25
00A2E:  DATA 63,25
00A30:  DATA 63,25
00A32:  DATA 63,25
00A34:  DATA 63,25
00A36:  DATA 63,25
00A38:  DATA 63,25
00A3A:  DATA 63,22
00A3C:  DATA 0D,00
00A3E:  DATA 41,54
00A40:  DATA 2B,43
00A42:  DATA 4D,47
00A44:  DATA 53,3D
00A46:  DATA 22,25
00A48:  DATA 63,25
00A4A:  DATA 63,25
00A4C:  DATA 63,25
00A4E:  DATA 63,25
00A50:  DATA 63,25
00A52:  DATA 63,25
00A54:  DATA 63,25
00A56:  DATA 63,25
00A58:  DATA 63,25
00A5A:  DATA 63,25
00A5C:  DATA 63,25
00A5E:  DATA 63,25
00A60:  DATA 63,22
00A62:  DATA 0D,00
00A64:  DATA 41,54
00A66:  DATA 2B,43
00A68:  DATA 4D,47
00A6A:  DATA 53,3D
00A6C:  DATA 22,25
00A6E:  DATA 63,25
00A70:  DATA 63,25
00A72:  DATA 63,25
00A74:  DATA 63,25
00A76:  DATA 63,25
00A78:  DATA 63,25
00A7A:  DATA 63,25
00A7C:  DATA 63,25
00A7E:  DATA 63,25
00A80:  DATA 63,25
00A82:  DATA 63,25
00A84:  DATA 63,25
00A86:  DATA 63,22
00A88:  DATA 0D,00
00A8A:  DATA 54,48
00A8C:  DATA 49,53
00A8E:  DATA 20,49
00A90:  DATA 53,20
00A92:  DATA 41,20
00A94:  DATA 54,45
00A96:  DATA 53,54
00A98:  DATA 20,4D
00A9A:  DATA 45,53
00A9C:  DATA 53,41
00A9E:  DATA 47,45
00AA0:  DATA 20,46
00AA2:  DATA 52,4F
00AA4:  DATA 4D,20
00AA6:  DATA 51,55
00AA8:  DATA 45,43
00AAA:  DATA 54,45
00AAC:  DATA 4C,00
*
00AC2:  TSTFSZ 01
00AC4:  GOTO   0AD2
00AC8:  TSTFSZ 02
00ACA:  GOTO   0AD4
00ACE:  GOTO   0AE4
00AD2:  INCF   02,F
00AD4:  MOVFF  00,FEE
00AD8:  DECFSZ 01,F
00ADA:  GOTO   0AD4
00ADE:  DECFSZ 02,F
00AE0:  GOTO   0AD4
00AE4:  RETURN 0
*
00B2A:  MOVLB  B
00B2C:  MOVF   x4E,W
00B2E:  MULWF  x50
00B30:  MOVFF  FF3,01
00B34:  MOVFF  FF4,00
00B38:  MULWF  x51
00B3A:  MOVF   FF3,W
00B3C:  ADDWF  00,F
00B3E:  MOVF   x4F,W
00B40:  MULWF  x50
00B42:  MOVF   FF3,W
00B44:  ADDWFC 00,W
00B46:  MOVWF  02
00B48:  MOVLB  0
00B4A:  RETURN 0
*
00DE6:  MOVLB  B
00DE8:  MOVF   x52,W
00DEA:  CLRF   01
00DEC:  SUBWF  x51,W
00DEE:  BTFSC  FD8.0
00DF0:  GOTO   0DFC
00DF4:  MOVFF  B51,00
00DF8:  GOTO   0E16
00DFC:  CLRF   00
00DFE:  MOVLW  08
00E00:  MOVWF  x53
00E02:  RLCF   x51,F
00E04:  RLCF   00,F
00E06:  MOVF   x52,W
00E08:  SUBWF  00,W
00E0A:  BTFSC  FD8.0
00E0C:  MOVWF  00
00E0E:  RLCF   01,F
00E10:  DECFSZ x53,F
00E12:  GOTO   0E02
00E16:  MOVLB  0
00E18:  RETURN 0
*
01A7A:  TBLRD*+
01A7C:  MOVF   FF5,F
01A7E:  BTFSC  FD8.2
01A80:  GOTO   1AA4
01A84:  MOVFF  FF6,B1B
01A88:  MOVFF  FF7,B1C
01A8C:  MOVF   FF5,W
01A8E:  CLRWDT
01A90:  BTFSS  F9E.4
01A92:  GOTO   1A8E
01A96:  MOVWF  FAD
01A98:  MOVFF  B1B,FF6
01A9C:  MOVFF  B1C,FF7
01AA0:  GOTO   1A7A
01AA4:  RETURN 0
*
0462E:  TBLRD*+
04630:  MOVFF  FF6,B50
04634:  MOVFF  FF7,B51
04638:  MOVF   FF5,W
0463A:  CLRWDT
0463C:  BTFSS  F9E.4
0463E:  GOTO   463A
04642:  MOVWF  FAD
04644:  MOVFF  B50,FF6
04648:  MOVFF  B51,FF7
0464C:  MOVLB  B
0464E:  DECFSZ x4F,F
04650:  BRA    4654
04652:  BRA    465A
04654:  MOVLB  0
04656:  GOTO   462E
0465A:  MOVLB  0
0465C:  RETURN 0
0465E:  MOVF   01,W
04660:  MOVFF  B4F,B51
04664:  MOVLW  64
04666:  MOVLB  B
04668:  MOVWF  x52
0466A:  MOVLB  0
0466C:  CALL   0DE6
04670:  MOVFF  00,B4F
04674:  MOVF   01,W
04676:  MOVLW  30
04678:  BTFSS  FD8.2
0467A:  GOTO   4694
0467E:  MOVLB  B
04680:  BTFSS  x50.1
04682:  GOTO   46AA
04686:  BTFSC  x50.3
04688:  GOTO   46AA
0468C:  BTFSC  x50.4
0468E:  MOVLW  20
04690:  GOTO   469C
04694:  MOVLB  B
04696:  BCF    x50.3
04698:  BCF    x50.4
0469A:  BSF    x50.0
0469C:  ADDWF  01,F
0469E:  MOVF   01,W
046A0:  CLRWDT
046A2:  BTFSS  F9E.4
046A4:  GOTO   46A0
046A8:  MOVWF  FAD
046AA:  MOVFF  B4F,B51
046AE:  MOVLW  0A
046B0:  MOVWF  x52
046B2:  MOVLB  0
046B4:  CALL   0DE6
046B8:  MOVFF  00,B4F
046BC:  MOVF   01,W
046BE:  MOVLW  30
046C0:  BTFSS  FD8.2
046C2:  GOTO   46DA
046C6:  MOVLB  B
046C8:  BTFSC  x50.3
046CA:  GOTO   46EA
046CE:  BTFSS  x50.0
046D0:  GOTO   46EA
046D4:  BTFSC  x50.4
046D6:  MOVLW  20
046D8:  MOVLB  0
046DA:  ADDWF  01,F
046DC:  MOVF   01,W
046DE:  CLRWDT
046E0:  BTFSS  F9E.4
046E2:  GOTO   46DE
046E6:  MOVWF  FAD
046E8:  MOVLB  B
046EA:  MOVLW  30
046EC:  ADDWF  x4F,F
046EE:  MOVF   x4F,W
046F0:  CLRWDT
046F2:  BTFSS  F9E.4
046F4:  GOTO   46F0
046F8:  MOVWF  FAD
046FA:  MOVLB  0
046FC:  RETURN 0
*
047CA:  MOVFF  FEA,B57
047CE:  MOVFF  FE9,B56
047D2:  MOVLB  B
047D4:  SWAPF  x50,W
047D6:  IORLW  F0
047D8:  MOVWF  x52
047DA:  ADDWF  x52,F
047DC:  ADDLW  E2
047DE:  MOVWF  x53
047E0:  ADDLW  32
047E2:  MOVWF  x55
047E4:  MOVF   x50,W
047E6:  ANDLW  0F
047E8:  ADDWF  x53,F
047EA:  ADDWF  x53,F
047EC:  ADDWF  x55,F
047EE:  ADDLW  E9
047F0:  MOVWF  x54
047F2:  ADDWF  x54,F
047F4:  ADDWF  x54,F
047F6:  SWAPF  x4F,W
047F8:  ANDLW  0F
047FA:  ADDWF  x54,F
047FC:  ADDWF  x55,F
047FE:  RLCF   x54,F
04800:  RLCF   x55,F
04802:  COMF   x55,F
04804:  RLCF   x55,F
04806:  MOVF   x4F,W
04808:  ANDLW  0F
0480A:  ADDWF  x55,F
0480C:  RLCF   x52,F
0480E:  MOVLW  07
04810:  MOVWF  x51
04812:  MOVLW  0A
04814:  DECF   x54,F
04816:  ADDWF  x55,F
04818:  BTFSS  FD8.0
0481A:  GOTO   4814
0481E:  DECF   x53,F
04820:  ADDWF  x54,F
04822:  BTFSS  FD8.0
04824:  GOTO   481E
04828:  DECF   x52,F
0482A:  ADDWF  x53,F
0482C:  BTFSS  FD8.0
0482E:  GOTO   4828
04832:  DECF   x51,F
04834:  ADDWF  x52,F
04836:  BTFSS  FD8.0
04838:  GOTO   4832
0483C:  MOVLW  0B
0483E:  MOVWF  FEA
04840:  MOVLW  51
04842:  MOVWF  FE9
04844:  MOVLW  07
04846:  ANDWF  x56,W
04848:  BCF    x56.6
0484A:  ADDWF  FE9,F
0484C:  MOVLW  00
0484E:  ADDWFC FEA,F
04850:  MOVF   FE9,W
04852:  SUBLW  55
04854:  BTFSS  FD8.2
04856:  GOTO   4866
0485A:  MOVF   FEA,W
0485C:  SUBLW  0B
0485E:  BTFSS  FD8.2
04860:  GOTO   4866
04864:  BSF    x56.6
04866:  MOVF   FEF,W
04868:  MOVWF  00
0486A:  BTFSS  FD8.2
0486C:  GOTO   4888
04870:  BTFSC  x56.6
04872:  GOTO   4888
04876:  BTFSC  x56.4
04878:  GOTO   489C
0487C:  BTFSC  x56.3
0487E:  GOTO   4888
04882:  MOVLW  20
04884:  GOTO   488E
04888:  BSF    x56.3
0488A:  BCF    x56.4
0488C:  MOVLW  30
0488E:  ADDWF  00,F
04890:  MOVF   00,W
04892:  CLRWDT
04894:  BTFSS  F9E.4
04896:  GOTO   4892
0489A:  MOVWF  FAD
0489C:  MOVF   FEE,W
0489E:  BTFSS  x56.6
048A0:  GOTO   4850
048A4:  MOVLB  0
048A6:  RETURN 0
048A8:  BTFSC  FD8.1
048AA:  GOTO   48B6
048AE:  MOVLW  0B
048B0:  MOVWF  FEA
048B2:  MOVLW  63
048B4:  MOVWF  FE9
048B6:  CLRF   00
048B8:  CLRF   01
048BA:  CLRF   02
048BC:  CLRF   03
048BE:  MOVLB  B
048C0:  CLRF   x63
048C2:  CLRF   x64
048C4:  CLRF   x65
048C6:  CLRF   x66
048C8:  MOVF   x62,W
048CA:  IORWF  x61,W
048CC:  IORWF  x60,W
048CE:  IORWF  x5F,W
048D0:  BTFSC  FD8.2
048D2:  GOTO   4940
048D6:  MOVLW  20
048D8:  MOVWF  x67
048DA:  BCF    FD8.0
048DC:  RLCF   x5B,F
048DE:  RLCF   x5C,F
048E0:  RLCF   x5D,F
048E2:  RLCF   x5E,F
048E4:  RLCF   x63,F
048E6:  RLCF   x64,F
048E8:  RLCF   x65,F
048EA:  RLCF   x66,F
048EC:  MOVF   x62,W
048EE:  SUBWF  x66,W
048F0:  BTFSS  FD8.2
048F2:  GOTO   490E
048F6:  MOVF   x61,W
048F8:  SUBWF  x65,W
048FA:  BTFSS  FD8.2
048FC:  GOTO   490E
04900:  MOVF   x60,W
04902:  SUBWF  x64,W
04904:  BTFSS  FD8.2
04906:  GOTO   490E
0490A:  MOVF   x5F,W
0490C:  SUBWF  x63,W
0490E:  BTFSS  FD8.0
04910:  GOTO   4932
04914:  MOVF   x5F,W
04916:  SUBWF  x63,F
04918:  MOVF   x60,W
0491A:  BTFSS  FD8.0
0491C:  INCFSZ x60,W
0491E:  SUBWF  x64,F
04920:  MOVF   x61,W
04922:  BTFSS  FD8.0
04924:  INCFSZ x61,W
04926:  SUBWF  x65,F
04928:  MOVF   x62,W
0492A:  BTFSS  FD8.0
0492C:  INCFSZ x62,W
0492E:  SUBWF  x66,F
04930:  BSF    FD8.0
04932:  RLCF   00,F
04934:  RLCF   01,F
04936:  RLCF   02,F
04938:  RLCF   03,F
0493A:  DECFSZ x67,F
0493C:  GOTO   48DA
04940:  MOVFF  B63,FEF
04944:  MOVFF  B64,FEC
04948:  MOVFF  B65,FEC
0494C:  MOVFF  B66,FEC
04950:  MOVLB  0
04952:  RETURN 0
04954:  MOVF   FE9,W
04956:  MOVLB  B
04958:  MOVWF  x53
0495A:  MOVLW  3B
0495C:  MOVWF  x5A
0495E:  MOVLW  9A
04960:  MOVWF  x59
04962:  MOVLW  CA
04964:  MOVWF  x58
04966:  CLRF   x57
04968:  MOVLW  0A
0496A:  MOVWF  x55
0496C:  BSF    FD8.1
0496E:  MOVLW  0B
04970:  MOVWF  FEA
04972:  MOVLW  4F
04974:  MOVWF  FE9
04976:  MOVFF  B52,B5E
0497A:  MOVFF  B51,B5D
0497E:  MOVFF  B50,B5C
04982:  MOVFF  B4F,B5B
04986:  MOVFF  B5A,B62
0498A:  MOVFF  B59,B61
0498E:  MOVFF  B58,B60
04992:  MOVFF  B57,B5F
04996:  MOVLB  0
04998:  CALL   48A8
0499C:  MOVF   01,W
0499E:  MOVF   00,F
049A0:  BTFSS  FD8.2
049A2:  GOTO   49E0
049A6:  MOVLB  B
049A8:  MOVF   x55,W
049AA:  XORLW  01
049AC:  BTFSS  FD8.2
049AE:  BRA    49B6
049B0:  MOVLB  0
049B2:  GOTO   49E0
049B6:  MOVF   x53,W
049B8:  BTFSC  FD8.2
049BA:  GOTO   49E4
049BE:  ANDLW  0F
049C0:  SUBWF  x55,W
049C2:  BTFSC  FD8.2
049C4:  GOTO   49CE
049C8:  BTFSC  FD8.0
049CA:  GOTO   49F4
049CE:  BTFSC  x53.7
049D0:  GOTO   49F4
049D4:  BTFSC  x53.6
049D6:  GOTO   49E4
049DA:  MOVLW  20
049DC:  GOTO   49E6
049E0:  MOVLB  B
049E2:  CLRF   x53
049E4:  MOVLW  30
049E6:  ADDWF  00,F
049E8:  MOVF   00,W
049EA:  CLRWDT
049EC:  BTFSS  F9E.4
049EE:  GOTO   49EA
049F2:  MOVWF  FAD
049F4:  BCF    FD8.1
049F6:  MOVFF  B5A,B5E
049FA:  MOVFF  B59,B5D
049FE:  MOVFF  B58,B5C
04A02:  MOVFF  B57,B5B
04A06:  CLRF   x62
04A08:  CLRF   x61
04A0A:  CLRF   x60
04A0C:  MOVLW  0A
04A0E:  MOVWF  x5F
04A10:  MOVLB  0
04A12:  CALL   48A8
04A16:  MOVFF  03,B5A
04A1A:  MOVFF  02,B59
04A1E:  MOVFF  01,B58
04A22:  MOVFF  00,B57
04A26:  MOVLB  B
04A28:  DECFSZ x55,F
04A2A:  GOTO   496C
04A2E:  MOVLB  0
04A30:  RETURN 0
....................  
.................... #list 
....................  
.................... #include "vmPINConfig.h" 
.................... #ifndef _VM_PIN_CONFIG_H_ 
.................... #define _VM_PIN_CONFIG_H_ 
....................  
.................... //#include "18F46K80.h" 
....................  
.................... // RS485 Communication Pin Mapping. 
.................... #define PIN_RS485_XMIT              PIN_D6 
.................... #define PIN_RS485_RCV               PIN_D7 
.................... #define PIN_RS485_RTS               PIN_D4			 
....................  
.................... // GPSR Communication PIN Mapping; SIM900/SIM800/Quectel. 
.................... #define PIN_GPRS_COMM_XMIT          PIN_C6 
.................... #define PIN_GPRS_COMM_RCV           PIN_C7 
....................  
.................... // IBC Communication PIN Mapping. 
.................... #define PIN_IBC_RCV                 PIN_B1 
.................... #define PIN_IBC_XMIT                PIN_D5 
....................  
.................... // UART To UART Communication PIN Mapping. 
.................... #define PIN_SW_UART_COMM_XMIT       PIN_B2 
.................... #define PIN_SW_UART_COMM_RCV        PIN_B3 
....................  
.................... // Software UART PIN Mapping. 
.................... #define PIN_SW_UART_XMIT            PIN_B4 
.................... #define PIN_SW_UART_RCV             PIN_B0 
....................  
.................... // DI PIN Mapping;In 5V 
.................... #define PIN_IN_EXT_DI_00            PIN_C0 
.................... #define PIN_IN_EXT_DI_01            PIN_C1 
.................... #define PIN_IN_EXT_DI_02            PIN_C2 
.................... #define PIN_IN_EXT_DI_03            PIN_C3 
....................  
....................  
.................... #endif /* _VM_PIN_CONFIG_H_ */ 
....................  
....................  
.................... //****************** Component Configuration ******************** 
....................  
.................... //optimization level. 
.................... #pragma opt 8 
....................   
.................... //********* CPU Settings ******************************************* 
....................  
.................... #pragma device HIGH_INTS=TRUE 
.................... #pragma fuses NOPLLEN,ECH,WDT1024,NOPROTECT,NOBROWNOUT,NOFCMEN,NOIESO,NOPUT /* WDT1024 => 1024 * 4 ms = 4096 mS Watchdog Timer */ /* For Field Mode */ 
....................  
.................... #pragma use delay(clock=20000000,restart_wdt) 
*
00DB2:  MOVLW  0B
00DB4:  MOVWF  FEA
00DB6:  MOVLW  34
00DB8:  MOVWF  FE9
00DBA:  MOVF   FEF,W
00DBC:  BTFSC  FD8.2
00DBE:  GOTO   0DE4
00DC2:  MOVLW  06
00DC4:  MOVWF  01
00DC6:  MOVLW  BF
00DC8:  MOVWF  00
00DCA:  CLRWDT
00DCC:  DECFSZ 00,F
00DCE:  BRA    0DCA
00DD0:  DECFSZ 01,F
00DD2:  BRA    0DC6
00DD4:  MOVLW  7A
00DD6:  MOVWF  00
00DD8:  DECFSZ 00,F
00DDA:  BRA    0DD8
00DDC:  BRA    0DDE
00DDE:  CLRWDT
00DE0:  DECFSZ FEF,F
00DE2:  BRA    0DC2
00DE4:  RETURN 0
....................  
....................  
.................... //******** Serial Interface ************ 
.................... #pragma use rs232(stream=GSM_M66, xmit=PIN_GPRS_COMM_XMIT, rcv=PIN_GPRS_COMM_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
.................... #pragma use rs232(stream=RS485, xmit=PIN_RS485_XMIT, rcv=PIN_RS485_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
*
01050:  CLRWDT
01052:  BTFSS  FA4.4
01054:  GOTO   1050
01058:  MOVWF  F79
0105A:  RETURN 0
....................  
.................... //#define unsigned int8 BYTE 
....................  
.................... #ifndef M1_COMM_MODULE 
.................... #define M1_COMM_MODULE  1 
.................... #endif 
....................  
.................... #endif /* _VM_SYSTEM_CONFIG_H_ */ 
....................  
.................... #include "../Common/vmRS485Config.h" 
.................... #ifndef _VI_RS485_CONFIG_H_ 
.................... #define _VI_RS485_CONFIG_H_ 
....................  
.................... #include "vmCRCConfig.h" 
.................... #ifndef _VM_CRC_CONFIG_H_ 
.................... #define _VM_CRC_CONFIG_H_ 
....................  
.................... // Table of CRC values for high–order byte. 
.................... unsigned int8 const auchCRCHi[] =  
.................... { 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40 
.................... } ; 
....................  
.................... // Table of CRC values for low–order byte. 
.................... unsigned int8 const auchCRCLo[] =  
.................... { 
.................... 0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 
.................... 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 
.................... 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 
.................... 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 
.................... 0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7, 
.................... 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 
.................... 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 
.................... 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 
.................... 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 
.................... 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 
.................... 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 
.................... 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5, 
.................... 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91, 
.................... 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 
.................... 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 
.................... 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 
.................... 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // CRC calculation. 
.................... static unsigned int16 ModbusCRC16 (unsigned int8* puiMsg,   // Message to calculate CRC upon. 
....................                                    unsigned short usDataLen) // Quantity of bytes in message. 
*
0319A:  MOVLB  B
0319C:  SETF   x37
0319E:  SETF   x38
.................... { 
....................     unsigned int8 uchCRCHi = 0xFF; // High byte of CRC initialized. 
....................     unsigned int8 uchCRCLo = 0xFF; // Low byte of CRC initialized. 
....................     unsigned int8 uIndex;          // Will index into CRC lookup table. 
....................  
....................     while (usDataLen--) // Loop through message buffer. 
031A0:  MOVF   x36,W
031A2:  DECF   x36,F
031A4:  XORLW  00
031A6:  BTFSC  FD8.2
031A8:  GOTO   31EE
....................     { 
....................         uIndex = uchCRCLo ^ *puiMsg++; // Calculate the CRC. 
031AC:  MOVFF  B35,03
031B0:  MOVF   x34,W
031B2:  INCF   x34,F
031B4:  BTFSC  FD8.2
031B6:  INCF   x35,F
031B8:  MOVWF  FE9
031BA:  MOVFF  03,FEA
031BE:  MOVF   FEF,W
031C0:  XORWF  x38,W
031C2:  MOVWF  x39
....................         uchCRCLo = uchCRCHi ^ auchCRCHi[uIndex]; 
031C4:  CLRF   03
031C6:  MOVF   x39,W
031C8:  MOVLB  0
031CA:  CALL   00FA
031CE:  MOVWF  01
031D0:  MOVLB  B
031D2:  MOVF   x37,W
031D4:  XORWF  01,W
031D6:  MOVWF  x38
....................         uchCRCHi = auchCRCLo[uIndex]; 
031D8:  CLRF   03
031DA:  MOVF   x39,W
031DC:  MOVLB  0
031DE:  CALL   020A
031E2:  MOVWF  01
031E4:  MOVFF  FE8,B37
031E8:  MOVLB  B
031EA:  GOTO   31A0
....................     } 
....................  
....................     return ((((unsigned int16)uchCRCHi) << 8) | uchCRCLo); 
031EE:  MOVFF  B37,B3A
031F2:  CLRF   x3A
031F4:  MOVF   x3A,W
031F6:  IORWF  x38,W
031F8:  MOVFF  B37,03
031FC:  MOVWF  01
031FE:  MOVFF  B37,02
03202:  MOVLB  0
03204:  GOTO   3298 (RETURN)
.................... } 
....................  
.................... unsigned int16 calculateCrc( unsigned int8* pDataBuff, unsigned int8 uiDataLen ) 
*
01CDA:  MOVLB  B
01CDC:  CLRF   x40
01CDE:  CLRF   x3F
01CE0:  SETF   x42
01CE2:  SETF   x41
01CE4:  MOVLW  A0
01CE6:  MOVWF  x44
01CE8:  MOVLW  01
01CEA:  MOVWF  x43
01CEC:  CLRF   x45
01CEE:  CLRF   x46
01CF0:  CLRF   x47
.................... { 
.................... 	unsigned int16 uiCRC        = 0x00; 
.................... 	unsigned int16 shRemainder  = 0xFFFF; 
.................... 	unsigned int16 shGP         = 40961; 
.................... 	unsigned int8  uiByteCount  = 0; 
.................... 	unsigned int8  bShiftCount  = 0; 
.................... 	unsigned int8  bShiftCarry  = 0; 
....................  
.................... 	while (1) 
.................... 	{ 
.................... 		if (uiByteCount == uiDataLen) 
01CF2:  MOVF   x3E,W
01CF4:  SUBWF  x45,W
01CF6:  BTFSS  FD8.2
01CF8:  GOTO   1D00
.................... 		{ 
.................... 			break; 
01CFC:  GOTO   1D82
.................... 		} 
....................  
.................... 		uiByteCount++; 
01D00:  INCF   x45,F
.................... 		bShiftCount = 0; 
01D02:  CLRF   x46
....................  
.................... 		while (1) 
.................... 		{ 
.................... 			if (0 == bShiftCount) 
01D04:  MOVF   x46,F
01D06:  BTFSS  FD8.2
01D08:  GOTO   1D44
.................... 			{ 
.................... 				if (1 == uiByteCount) 
01D0C:  DECFSZ x45,W
01D0E:  GOTO   1D2E
.................... 				{ 
.................... 					uiCRC = (pDataBuff[uiByteCount - 1]) ^ shRemainder; 
01D12:  MOVLW  01
01D14:  SUBWF  x45,W
01D16:  ADDWF  x3C,W
01D18:  MOVWF  FE9
01D1A:  MOVLW  00
01D1C:  ADDWFC x3D,W
01D1E:  MOVWF  FEA
01D20:  MOVF   FEF,W
01D22:  XORWF  x41,W
01D24:  MOVWF  x3F
01D26:  MOVFF  B42,B40
.................... 				} 
01D2A:  GOTO   1D40
.................... 				else 
.................... 				{ 
.................... 					uiCRC = uiCRC ^ (pDataBuff[uiByteCount - 1]); 
01D2E:  MOVLW  01
01D30:  SUBWF  x45,W
01D32:  ADDWF  x3C,W
01D34:  MOVWF  FE9
01D36:  MOVLW  00
01D38:  ADDWFC x3D,W
01D3A:  MOVWF  FEA
01D3C:  MOVF   FEF,W
01D3E:  XORWF  x3F,F
.................... 				} 
.................... 			} 
01D40:  GOTO   1D4C
.................... 			else 
.................... 			{ 
.................... 				uiCRC = uiCRC ^ shGP; 
01D44:  MOVF   x43,W
01D46:  XORWF  x3F,F
01D48:  MOVF   x44,W
01D4A:  XORWF  x40,F
.................... 			} 
....................  
.................... 		    NoBitCarry: 
....................  
.................... 			bShiftCount++; 
01D4C:  INCF   x46,F
....................  
.................... 			if (bShiftCount > 8) 
01D4E:  MOVF   x46,W
01D50:  SUBLW  08
01D52:  BTFSC  FD8.0
01D54:  GOTO   1D5C
.................... 			{ 
.................... 				break; 
01D58:  GOTO   1D7E
.................... 			} 
....................  
.................... 			bShiftCarry = uiCRC & 1; 
01D5C:  MOVF   x3F,W
01D5E:  ANDLW  01
01D60:  MOVWF  x47
....................  
.................... 			uiCRC = uiCRC >> 1; 
01D62:  BCF    FD8.0
01D64:  RRCF   x40,F
01D66:  RRCF   x3F,F
....................  
.................... 			if (1 == bShiftCarry) 
01D68:  DECFSZ x47,W
01D6A:  GOTO   1D76
.................... 			{ 
.................... 				continue; 
01D6E:  GOTO   1D04
.................... 			} 
01D72:  GOTO   1D7A
.................... 			else 
.................... 			{ 
.................... 				goto NoBitCarry; 
01D76:  GOTO   1D4C
.................... 			} 
01D7A:  GOTO   1D04
.................... 		} 
01D7E:  GOTO   1CF2
.................... 	} 
....................  
.................... 	return uiCRC; 
01D82:  MOVFF  B3F,01
01D86:  MOVFF  B40,02
01D8A:  MOVLB  0
01D8C:  RETURN 0
.................... } 
....................  
.................... #endif /* _VM_CRC_CONFIG_H_ */ 
....................  
.................... #include "vmModbusGlobal.h" 
.................... #ifndef _VI_MODBUS_GOBAL_H_ 
.................... #define _VI_MODBUS_GOBAL_H_ 
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE 64   
.................... #define MODBUS_REG_BUFFER_SIZE 10    
....................   
.................... #define MODBUS_REG_OUTPUT_0  	0  
.................... #define MODBUS_REG_OUTPUT_1		1 
.................... #define MODBUS_REG_OUTPUT_2		2 
.................... #define MODBUS_REG_OUTPUT_3		4 
.................... #define MODBUS_REG_OUTPUT_4		8 
.................... #define MODBUS_REG_OUTPUT_5		16 
.................... #define MODBUS_REG_OUTPUT_6		32 
.................... #define MODBUS_REG_OUTPUT_7		64 
.................... #define MODBUS_REG_OUTPUT_8		128 
.................... #define MODBUS_REG_OUTPUT_9		256 
.................... #define MODBUS_REG_OUTPUT_10	512 
.................... #define MODBUS_REG_OUTPUT_11	1024 
.................... #define MODBUS_REG_OUTPUT_12	2048 
.................... #define MODBUS_REG_OUTPUT_13	4096 
.................... #define MODBUS_REG_OUTPUT_14	8192 
.................... #define MODBUS_REG_OUTPUT_15	16384 
.................... #define MODBUS_REG_OUTPUT_16	32768 
....................  
.................... #define MODBUS_AUTO_CALIBRATION  	1  
.................... #define MODBUS_FIXED_CALIBRATION    0 
....................  
.................... enum function { 
.................... 	RS485_FUNCTION_READ_COILS                 = 1, 
.................... 	RS485_FUNCTION_READ_DISCRETE_INPUT        = 2, 
.................... 	RS485_FUNCTION_READ_HOLDING_REGISTERS     = 3, 
.................... 	RS485_FUNCTION_READ_INPUT_REGISTERS       = 4, 
.................... 	RS485_FUNCTION_WRITE_SINGLE_COIL          = 5, 
.................... 	RS485_FUNCTION_WRITE_SINGLE_REGISTER      = 6, 
.................... 	RS485_FUNCTION_READ_MULTIPLE_REGISTERS    = 15, 
.................... 	RS485_FUNCTION_WRITE_MULTIPLE_REGISTERS   = 16		 
.................... }; 
....................  
.................... enum exception { 
.................... 	RS485_ILLEGAL_FUNCTION        = 1,	 
.................... 	RS485_ILLEGAL_DATA_ADDRESS    = 2, 
.................... 	RS485_ILLEGAL_DATA_VALUE      = 3, 
.................... 	RS485_SLAVE_DEVICE_FAILED     = 4, 
.................... 	RS485_ACKNOWLAGE              = 5, 
.................... 	RS485_SLAVE_DEVICE_BUSY       = 6, 
.................... 	RS485_NEG_ACKNOWLAGE          = 7, 
.................... 	RS485_MEMORY_PARITY_ERROR     = 8, 
.................... 	RS485_GETWAY_PATH             = 10, 
.................... 	RS485_GETWAY_DEVICE           = 11	 
.................... }; 
....................  
.................... typedef struct 
.................... {  
....................    unsigned int8    ui8Slaveid;  
....................    unsigned int16   u16Address; 
....................    unsigned int16   u16LenData;                       //number of bytes in the message received  
....................    function         func;                           //the function of the message received  
....................    exception        error;                         //error recieved, if any  
....................    unsigned int16   ui16RegisterData; 
.................... //   unsigned int8    ui8Data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received  
....................    BOOLEAN          bDataProcessed; 
....................    unsigned int8    ui8NoRegDataBytes; 
....................    unsigned int16   ui16RegisterDataArr[MODBUS_REG_BUFFER_SIZE]; 
....................    unsigned int32   u32RegData; 
.................... } Modbus_Rx;  
....................  
.................... Modbus_Rx g_ModbusRx; 
....................  
.................... // use for calibration data 
.................... unsigned int16 g_ui16Register0_1; 
.................... unsigned int16 g_ui16Register0_2; 
.................... unsigned int16 g_ui16Register1000_1; 
.................... unsigned int16 g_ui16Register1000_2; 
.................... unsigned int16 g_ui16Register2000_1; 
.................... unsigned int16 g_ui16Register2000_2; 
.................... unsigned int16 g_ui16Register3000_1; 
.................... unsigned int16 g_ui16Register3000_2; 
.................... unsigned int16 g_ui16Register4000_1; 
.................... unsigned int16 g_ui16Register4000_2; 
.................... unsigned int16 g_ui16Register5000_1; 
.................... unsigned int16 g_ui16Register5000_2; 
.................... unsigned int16 g_ui16Register6000_1; 
.................... unsigned int16 g_ui16Register6000_2; 
.................... unsigned int16 g_ui16Register7000_1; 
.................... unsigned int16 g_ui16Register7000_2; 
.................... unsigned int16 g_ui16Register8000_1; 
.................... unsigned int16 g_ui16Register8000_2; 
.................... unsigned int16 g_ui16Register9000_1; 
.................... unsigned int16 g_ui16Register9000_2; 
.................... unsigned int16 g_ui16Register10000_1; 
.................... unsigned int16 g_ui16Register10000_2; 
....................  
.................... unsigned int16 g_ui16RegisterCurrentCalibrationWeight; 
.................... unsigned int16 g_ui16RegisterCurrentCalibrationPoint; 
.................... unsigned int8  g_fStartCalibration; 
.................... unsigned int32 g_ui32TareADCValueForCalibration; 
.................... unsigned int32 g_ui32gWeightADCValueForCalibration; 
.................... unsigned int16 g_ui16gAvgWtForCalibration; 
....................  
.................... unsigned int16 g_ui16RegisterAvgWeight; 
.................... unsigned int16 g_ui16RegisterTolPv; 
.................... unsigned int16 g_ui16RegisterTolNv; 
.................... unsigned int16 g_ui16RegisterCurrProductIndex; 
....................  
.................... // use for production  
.................... unsigned int16 g_ui16CBBCount; 
.................... unsigned int16 g_ui16CBBCountPrev; 
.................... unsigned int16 g_ui16CurrentWt; 
.................... unsigned int16 g_ui16CurrentPassStatus; 
.................... unsigned int16 g_ui16RunningAvgWt; 
.................... unsigned int16 g_ui16RunningTareValue; 
.................... unsigned int16 g_ui16ServerStatus; 
....................  
.................... unsigned int16 g_ui16FlagForSetTareValue; 
....................  
.................... // use for system date time 
.................... unsigned int16 g_ui16RegisterDateYY; 
.................... unsigned int16 g_ui16RegisterDateMM; 
.................... unsigned int16 g_ui16RegisterDateDD; 
....................  
.................... unsigned int16 g_ui16RegisterTime_HH; 
.................... unsigned int16 g_ui16RegisterTime_mm; 
.................... unsigned int16 g_ui16RegisterTime_ss; 
....................  
.................... unsigned int16 g_ui16RegisterTime_Diff; 
....................  
.................... // use for pre production 
.................... unsigned int16 g_ui16CurrProdIndex; 
.................... unsigned int16 g_ui16CurrProdAvgWt; 
.................... unsigned int16 g_ui16CurrProdPvTol; 
.................... unsigned int16 g_ui16CurrProdNvTol; 
....................  
.................... // Use for Current Mode 
.................... unsigned int16 g_ui16CurrentMode; 
....................  
.................... // use for production type 
.................... unsigned int8  g_fAutoCalibrationMode; 
....................  
.................... // use for sample count for auto calibration 
.................... unsigned int16 g_ui16AutoCalibrationSampleCount; 
....................  
.................... // Use for store load cell factor. 
.................... unsigned int16 g_ui16CurrLoadCellFactor; 
....................  
.................... #endif /* _VI_MODBUS_GOBAL_H_ */ 
....................  
....................  
.................... #include "vmIBCGlobal.h" 
.................... #ifndef _VM_IBC_GOBAL_H_ 
.................... #define _VM_IBC_GOBAL_H_ 
....................  
.................... #define IBC_SEND_LOCK                   1 
.................... #define IBC_SEND_UNLOCK                 0 
....................  
.................... typedef enum _EN_IBC_COMMANDS 
.................... { 
....................     IBC_CMD_MODE_HOME                   = 100, 
....................     // Calibration Mode 
....................     IBC_CMD_MODE_CALIB                  = 101, 
....................     IBC_CMD_GET_CALIB_POINT             = 102, 
....................     IBC_CMD_RESET_CALIB_POINT_TARE      = 103, 
....................     IBC_CMD_RESET_CALIB_POINT           = 104, 
....................     IBC_CMD_RESET_CALIB_POINT_WEIGHT    = 105,  
....................     IBC_CMD_TARE_REQUEST                = 106, 
....................     IBC_CMD_SET_LOAD_CELL_FACTOR        = 115,         
....................  
....................     // Pre-Production Mode 
....................     IBC_CMD_MODE_PRE_PROD               = 107, 
....................     IBC_CMD_PRE_PROD_AVG_WEIGHT         = 108, 
....................     IBC_CMD_PRE_PROD_TOLERANCE          = 109, 
....................     IBC_CMD_MODE_AUTO_CALIB             = 110, 
....................     IBC_CMD_MODE_FIXED_CALIB            = 111, 
....................  
....................  
....................     // Production Mode 
....................     IBC_CMD_MODE_PROD                   = 112, 
....................     IBC_CMD_START_PROD                  = 113, 
....................     IBC_CMD_PROD_WEIGH_DATA             = 114, 
....................  
....................     IBC_CMD_PROD_TARE_DATA              = 118, 
....................     IBC_CMD_PROD_AVG_WT_DATA            = 119, 
....................              
....................     IBC_CMD_PROD_INTMD_DATA             = 122 
....................              
....................              
.................... } EN_IBC_COMMANDS; 
....................  
.................... // Mode type 
.................... enum boardModeType 
.................... { 
....................     BOARD_MODE_TYPE_NOTHING         = 0, 
....................     BOARD_MODE_TYPE_HOME            = 1, 
....................     BOARD_MODE_TYPE_PRE_PRODUCTION  = 2, 
.................... 	BOARD_MODE_TYPE_PRODUCTION      = 3, 
....................     BOARD_MODE_TYPE_CONFIGURATION   = 4, 
....................     BOARD_MODE_TYPE_CALIBRATION     = 5 
.................... }; 
....................  
.................... // Mode action on Hardware 
.................... enum manualModeActionHW { 
....................     MANUAL_MODE_ACTION_ON_NOTHING               = 0, 
....................     MANUAL_MODE_ACTION_ON_COIL_STOPPER_UNIT_1   = 1, 
....................     MANUAL_MODE_ACTION_ON_COIL_STOPPER_UNIT_2   = 2, 
....................     MANUAL_MODE_ACTION_ON_GRIPPER_ARM_1         = 3, 
....................     MANUAL_MODE_ACTION_ON_GRIPPER_ARM_2         = 4, 
....................     MANUAL_MODE_ACTION_ON_ARCH_CHUTE            = 5, 
....................     MANUAL_MODE_ACTION_ON_SERVO                 = 6, 
....................  
.................... 	MANUAL_MODE_ACTION_ON_LA1                   = 7, 
....................     MANUAL_MODE_ACTION_ON_LA2                   = 8, 
....................     MANUAL_MODE_ACTION_ON_VFD                   = 9, 
....................     MANUAL_MODE_ACTION_ON_PNEUMATIC_DRIVE       = 10, 
....................      
....................     MANUAL_MODE_ACTION_ON_COIL_TRANSFER         = 11, 
....................     MANUAL_MODE_ACTION_ON_TUNION                = 12 
....................  
.................... }; 
....................  
.................... //typedef struct _ST_IBC_PROD_M_WEIGHT_DATA 
.................... //{ 
.................... //    int16 m_i16BoxCount; 
.................... //    int16 m_i16BoxWeight; 
.................... //} ST_IBC_PROD_M_WEIGHT_DATA; 
.................... typedef struct _ST_IBC_PROD_M_WEIGHT_DATA 
.................... { 
....................     unsigned int16 m_ui16BoxCount; 
....................     int16 m_i16BoxWeight; 
.................... } ST_IBC_PROD_M_WEIGHT_DATA; 
....................  
....................  
.................... typedef union _UN_IBC_PROD_M_WEIGHT_DATA 
.................... { 
....................     ST_IBC_PROD_M_WEIGHT_DATA m_stWeighingData; 
....................     unsigned int8             m_ui8Arr[4]; 
.................... } UN_IBC_PROD_M_WEIGHT_DATA; 
....................  
.................... typedef struct _ST_IBC_PROD_M_TARE_DATA 
.................... { 
....................     int16 m_i16Padding; 
....................     int16 m_i16TareData; 
.................... } ST_IBC_PROD_M_TARE_DATA; 
....................  
.................... typedef union _UN_IBC_PROD_M_TARE_DATA 
.................... { 
....................     ST_IBC_PROD_M_TARE_DATA m_stTareData; 
....................     unsigned int8           m_ui8Arr[4]; 
.................... } UN_IBC_PROD_M_TARE_DATA; 
....................  
.................... typedef struct _ST_IBC_AVG_WT_NODE 
.................... { 
....................     int16 m_i16AvgWt; 
....................     int16 m_i16Padding; 
.................... } ST_IBC_AVG_WT_NODE; 
....................  
.................... typedef union _UN_IBC_AVG_WT_NODE 
.................... { 
....................     ST_IBC_AVG_WT_NODE m_stIBCAvgNode; 
....................     unsigned int8      m_ui8Arr[4]; 
.................... } UN_IBC_AVG_WT_NODE; 
....................  
.................... typedef struct _ST_IBC_TOL_NODE 
.................... { 
....................     int16 m_i16PositiveTol; 
....................     int16 m_i16NegativeTol; 
.................... } ST_IBC_TOL_NODE; 
....................  
.................... typedef union _UN_IBC_TOLERANCE_NODE 
.................... { 
....................     ST_IBC_TOL_NODE m_stIBCTolNode; 
....................     unsigned int8   m_ui8Arr[4]; 
.................... }UN_IBC_TOLERANCE_NODE; 
....................  
....................  
.................... typedef struct _ST_IBC_RESET_CALIB_POINT 
.................... { 
....................     int16         m_i16CalibPoint; 
....................     int16         m_i16CurrCalibPoint; 
.................... } ST_IBC_RESET_CALIB_POINT; 
....................  
.................... typedef union _UN_IBC_RESET_CALIB_POINT 
.................... { 
....................     ST_IBC_RESET_CALIB_POINT m_stIBCResetCalibPoint; 
....................     unsigned int8            m_ui8Arr[4]; 
.................... } UN_IBC_RESET_CALIB_POINT; 
....................  
....................  
.................... typedef struct _ST_IBC_RESET_CALIB_POINT_ACK 
.................... { 
....................     int16         m_i16PassCount; 
....................     int16         m_i16CalibValue; 
.................... } ST_IBC_RESET_CALIB_POINT_ACK; 
....................  
.................... typedef union _UN_IBC_RESET_CALIB_POINT_ACK 
.................... { 
....................     ST_IBC_RESET_CALIB_POINT_ACK m_stIBCResetCalibPoint; 
....................     unsigned int8                m_ui8Arr[4]; 
.................... } UN_IBC_RESET_CALIB_POINT_ACK; 
....................  
.................... typedef struct _ST_IBC_RESET_CALIB_POINT_TARE 
.................... { 
....................     unsigned int32 m_ui32CalibADCForTare; 
.................... }ST_IBC_RESET_CALIB_POINT_TARE; 
....................  
.................... typedef union _UN_IBC_RESET_CALIB_POINT_TARE 
.................... { 
....................     ST_IBC_RESET_CALIB_POINT_TARE m_stIBCResetCalibTare; 
....................     unsigned int8                 m_ui8Arr[4]; 
.................... }UN_IBC_RESET_CALIB_POINT_TARE; 
....................  
.................... typedef struct _ST_IBC_RESET_CALIB_POINT_WEIGHT 
.................... { 
....................     unsigned int32 m_ui32CalibADCForWeight; 
.................... }ST_IBC_RESET_CALIB_POINT_WEIGHT; 
....................  
.................... typedef union _UN_IBC_RESET_CALIB_POINT_WEIGHT 
.................... { 
....................     ST_IBC_RESET_CALIB_POINT_WEIGHT m_stIBCResetCalibWeight; 
....................     unsigned int8                 m_ui8Arr[4]; 
.................... }UN_IBC_RESET_CALIB_POINT_WEIGHT; 
....................  
.................... // Send Current Average Weight from MCU0 to MCU1, for IBC_CMD_PROD_AVG_WT_DATA 
.................... typedef struct _ST_IBC_PROD_MODE_CUR_AVG 
.................... { 
....................     int16 m_i16CurAvg; 
....................     int16 m_i16Padding; 
.................... } ST_IBC_PROD_MODE_CUR_AVG; 
....................  
.................... typedef union _UN_IBC_PROD_MODE_CUR_AVG 
.................... { 
....................     ST_IBC_PROD_MODE_CUR_AVG m_stAvgData; 
....................     unsigned int8            m_ui8Arr[4]; 
.................... } UN_IBC_PROD_MODE_CUR_AVG; 
....................  
.................... typedef struct _ST_IBC_LOAD_CELL_FACTOR 
.................... { 
....................     unsigned int16 m_ui16CurrLoadCellFactor; 
....................     unsigned int16 m_ui16Padding; 
....................      
.................... }ST_IBC_LOAD_CELL_FACTOR; 
....................  
.................... typedef union _UN_IBC_LOAD_CELL_FACTOR 
.................... { 
....................     ST_IBC_LOAD_CELL_FACTOR     m_stLoadCellFactor; 
....................     unsigned int8               m_ui8Arr[4]; 
.................... }UN_IBC_LOAD_CELL_FACTOR; 
....................  
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //*****************************************************************************  
.................... boardModeType           g_boardModeType; 
.................... boardModeType           g_boardModeTypePre; 
.................... manualModeActionHW      g_manualModeActionOnHw; 
.................... unsigned int16          g_ui16DIStatus; 
.................... unsigned int16          g_ui16DOStatus; 
.................... unsigned int16          g_ui16ErrorStatus; 
.................... unsigned int8           g_ui8IncrementIndex; 
.................... int8                    g_fIBCSendLockStatus = IBC_SEND_UNLOCK; 
....................  
.................... UN_IBC_PROD_M_WEIGHT_DATA    g_unIBCProdModeWtData; 
.................... UN_IBC_PROD_M_TARE_DATA      g_unIBCProdModeTrData; 
.................... UN_IBC_AVG_WT_NODE           g_unIBCAvgNode; 
.................... UN_IBC_TOLERANCE_NODE        g_unIBCTolNode; 
.................... UN_IBC_RESET_CALIB_POINT     g_unIBCResetCalib; 
.................... UN_IBC_RESET_CALIB_POINT_ACK g_unIBCResetCalibAck; 
.................... UN_IBC_PROD_MODE_CUR_AVG     g_unIBCProdModeAvg; 
.................... UN_IBC_LOAD_CELL_FACTOR      g_unIBCCurrLoadCellFactor; 
.................... UN_IBC_RESET_CALIB_POINT_TARE g_unIBCResetCalibTare; 
.................... UN_IBC_RESET_CALIB_POINT_WEIGHT g_unIBCResetCalibWeight; 
....................  
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... // function for set mode as Nothing 
.................... void SetModeNothing(void) 
.................... { 
....................     g_boardModeTypePre  = g_boardModeType; 
*
024D0:  MOVFF  AC,AD
....................     g_boardModeType     = BOARD_MODE_TYPE_NOTHING; 
024D4:  CLRF   xAC
024D6:  GOTO   28B4 (RETURN)
.................... } 
....................  
.................... // function for check mode is Nothing or not 
.................... int8 IsModeNothing(void) 
.................... { 
....................     int8 bRetVal = 0; 
....................      
....................     if(g_boardModeType == BOARD_MODE_TYPE_NOTHING)  
....................     { 
....................         bRetVal = 1; 
....................     } 
....................      
....................     return bRetVal; 
.................... } 
....................  
.................... // function for set mode as WakeUp 
.................... void SetModeHome(void) 
.................... { 
....................     g_boardModeTypePre  = g_boardModeType; 
024DA:  MOVFF  AC,AD
....................     g_boardModeType     = BOARD_MODE_TYPE_HOME; 
024DE:  MOVLW  01
024E0:  MOVWF  xAC
024E2:  GOTO   28BE (RETURN)
.................... } 
....................  
.................... // function for check mode is WakeUp or not 
.................... int8 IsModeHome(void) 
.................... { 
....................     int8 bRetVal = 0; 
....................      
....................     if(g_boardModeType == BOARD_MODE_TYPE_HOME)  
....................     { 
....................         bRetVal = 1; 
....................     } 
....................      
....................     return bRetVal; 
.................... } 
....................  
.................... // function for set mode as manual 
.................... void SetModeCalibration(void) 
.................... { 
....................     g_boardModeTypePre  = g_boardModeType; 
*
0250A:  MOVFF  AC,AD
....................     g_boardModeType     = BOARD_MODE_TYPE_CALIBRATION; 
0250E:  MOVLW  05
02510:  MOVWF  xAC
02512:  GOTO   29AC (RETURN)
.................... } 
....................  
.................... // function for check mode is manual or not 
.................... int8 IsCalibrationMode(void) 
.................... { 
....................     int8 bRetVal = 0; 
....................      
....................     if(g_boardModeType == BOARD_MODE_TYPE_CALIBRATION)  
....................     { 
....................         bRetVal = 1; 
....................     } 
....................      
....................     return bRetVal; 
.................... } 
....................  
.................... // function for set mode as pre production 
.................... void SetModePreProduction() 
.................... { 
....................     g_boardModeTypePre  = g_boardModeType; 
*
024E6:  MOVFF  AC,AD
....................     g_boardModeType     = BOARD_MODE_TYPE_PRE_PRODUCTION; 
024EA:  MOVLW  02
024EC:  MOVWF  xAC
024EE:  GOTO   290A (RETURN)
.................... } 
....................  
.................... // function for check mode is pre production or not 
.................... int8 IsPreProductionMode(void) 
.................... { 
....................     int8 bRetVal = 0; 
....................      
....................     if(g_boardModeType == BOARD_MODE_TYPE_PRE_PRODUCTION)  
....................     { 
....................         bRetVal = 1; 
....................     } 
....................      
....................     return bRetVal; 
.................... } 
....................  
.................... // function for set mode as production 
.................... void SetModeProduction() 
.................... { 
....................     g_boardModeTypePre  = g_boardModeType; 
024F2:  MOVFF  AC,AD
....................     g_boardModeType     = BOARD_MODE_TYPE_PRODUCTION; 
024F6:  MOVLW  03
024F8:  MOVWF  xAC
024FA:  GOTO   2956 (RETURN)
.................... } 
....................  
.................... // function for check mode is production or not 
.................... int8 IsProductionMode(void) 
.................... { 
....................     int8 bRetVal = 0; 
....................      
....................     if(g_boardModeType == BOARD_MODE_TYPE_PRODUCTION)  
....................     { 
....................         bRetVal = 1; 
....................     } 
....................      
....................     return bRetVal; 
.................... } 
....................  
.................... //// function for set mode as post production 
.................... //void SetModePostProduction() 
.................... //{ 
.................... //    g_boardModeTypePre  = g_boardModeType; 
.................... //    g_boardModeType     = BOARD_MODE_TYPE_POST_PRODUCTION; 
.................... //} 
.................... // 
.................... //// function for check mode is post production or not 
.................... //int8 IsPostProductionMode(void) 
.................... //{ 
.................... //    int8 bRetVal = 0; 
.................... //     
.................... //    if(g_boardModeType == BOARD_MODE_TYPE_POST_PRODUCTION)  
.................... //    { 
.................... //        bRetVal = 1; 
.................... //    } 
.................... //     
.................... //    return bRetVal; 
.................... //} 
....................  
.................... // function for set mode as configuration 
.................... void SetModeConfiguration(void) 
.................... { 
....................     g_boardModeTypePre  = g_boardModeType; 
024FE:  MOVFF  AC,AD
....................     g_boardModeType     = BOARD_MODE_TYPE_CONFIGURATION; 
02502:  MOVLW  04
02504:  MOVWF  xAC
02506:  GOTO   29A2 (RETURN)
.................... } 
....................  
.................... // function for check mode is configuration or not 
.................... int8 IsConfigurationMode(void) 
.................... { 
....................     int8 bRetVal = 0; 
....................      
....................     if(g_boardModeType == BOARD_MODE_TYPE_CONFIGURATION)  
....................     { 
....................         bRetVal = 1; 
....................     } 
....................      
....................     return bRetVal; 
.................... } 
....................  
.................... #endif /* _VM_IBC_GOBAL_H_ */ 
....................  
.................... #include "vmTimerConfig.h" 
.................... #ifndef _VM_TIMER_CONFIG_H_ 
.................... #define _VM_TIMER_CONFIG_H_ 
....................  
....................  
.................... //#include "vmCommon.h"   //TESTING 
.................... #include "../Common/viShiftRegister.h" 
.................... #ifndef _VI_SHIFT_REG_H_ 
.................... #define _VI_SHIFT_REG_H_ 
....................  
.................... #include "vmSystemConfig.h" 
.................... #ifndef _VM_SYSTEM_CONFIG_H_ 
.................... #define _VM_SYSTEM_CONFIG_H_ 
....................  
.................... //****************** Inclusion Files *************************** 
.................... #include "18F46K80.h" 
.................... #include "vmPINConfig.h" 
....................  
.................... //****************** Component Configuration ******************** 
....................  
.................... //optimization level. 
.................... #pragma opt 8 
....................   
.................... //********* CPU Settings ******************************************* 
....................  
.................... #pragma device HIGH_INTS=TRUE 
.................... #pragma fuses NOPLLEN,ECH,WDT1024,NOPROTECT,NOBROWNOUT,NOFCMEN,NOIESO,NOPUT /* WDT1024 => 1024 * 4 ms = 4096 mS Watchdog Timer */ /* For Field Mode */ 
....................  
.................... #pragma use delay(clock=20000000,restart_wdt) 
....................  
....................  
.................... //******** Serial Interface ************ 
.................... #pragma use rs232(stream=GSM_M66, xmit=PIN_GPRS_COMM_XMIT, rcv=PIN_GPRS_COMM_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
.................... #pragma use rs232(stream=RS485, xmit=PIN_RS485_XMIT, rcv=PIN_RS485_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
....................  
.................... //#define unsigned int8 BYTE 
....................  
.................... #ifndef M1_COMM_MODULE 
.................... #define M1_COMM_MODULE  1 
.................... #endif 
....................  
.................... #endif /* _VM_SYSTEM_CONFIG_H_ */ 
....................  
....................  
.................... #define LOGICAL_ON  0 
.................... #define LOGICAL_OFF 1 
....................  
.................... #define DO_DBG_SHIFT_REG_CLOCK       PIN_B4 //PIN_B5 
.................... //#define DO_DBG_SHIFT_REG_CLOCK       PIN_D0 
.................... #define DO_DBG_SHIFT_REG_DATA_A      PIN_B5 //PIN_B3 
....................  
.................... typedef struct { 
....................   unsigned int8 bit_0: 1; 
....................   unsigned int8 bit_1: 1; 
....................   unsigned int8 bit_2: 1; 
....................   unsigned int8 bit_3: 1; 
....................   unsigned int8 bit_4: 1; 
....................   unsigned int8 bit_5: 1; 
....................   unsigned int8 bit_6: 1; 
....................   unsigned int8 bit_7: 1; 
.................... } _DbgLedWordType; 
....................  
.................... typedef union { 
....................    unsigned int     gDbgLedWord; 
....................   _DbgLedWordType   DbgLedWord; 
.................... } DbgLedDataType; 
....................  
.................... DbgLedDataType gDbgLedDataWord; 
.................... DbgLedDataType gPreviousDbgLedDataWord; 
....................  
....................  
....................  
....................  
.................... /* Set Reset Debug Shift Register Outputs */ 
.................... static void SetSystemLedState(unsigned int8 ledId, 
....................                              unsigned int8 ledState) 
.................... { 
....................   /* Set LED Data */ 
....................   unsigned int tempWord = 0x01; 
....................      
....................   switch(ledState) 
....................   { 
....................     case 0: /* Reset bit - LED On */ 
....................       tempWord <<= (ledId-1); 
....................       tempWord = ~(tempWord); 
....................       gDbgLedDataWord.gDbgLedWord &= tempWord; 
....................       break; 
....................     case 1: /* Set bit - LED Off */ 
....................       tempWord <<= (ledId-1); 
....................       gDbgLedDataWord.gDbgLedWord |= tempWord; 
....................       break; 
....................     default: /* Nothing to do */ 
....................       break; 
....................   }  
....................  
....................   /* Check for change in Data */ 
....................   if(gDbgLedDataWord.gDbgLedWord != gPreviousDbgLedDataWord.gDbgLedWord) 
....................   { 
....................     /* Send Byte to Shift register 74LS164 */ 
....................     output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
....................  
....................     /* Shift in 1st QH */ 
....................     output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_7); 
....................     output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
....................     //delay_us(10); 
....................     output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
....................     /* Shift in 1st QG */ 
....................     output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_6); 
....................     output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
....................     //delay_us(10); 
....................     output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
....................     /* Shift in 1st QF */ 
....................     output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_5); 
....................     output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
....................    //delay_us(10); 
....................     output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
....................     /* Shift in 1st QE */ 
....................     output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_4); 
....................     output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
....................     //delay_us(10); 
....................     output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
....................     /* Shift in 1st QD */ 
....................     output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_3); 
....................     output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
....................     //delay_us(10); 
....................     output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
....................     /* Shift in 1st QC */ 
....................     output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_2); 
....................     output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
....................     //delay_us(10); 
....................     output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
....................     /* Shift in 1st QB */ 
....................     output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_1); 
....................     output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
....................     //delay_us(10); 
....................     output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
....................     /* Shift in 1st QA */ 
....................     output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_0); 
....................     output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
....................     //delay_us(10); 
....................     output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
....................  
....................     /* Update previous LED data */  
....................     gPreviousDbgLedDataWord.gDbgLedWord = gDbgLedDataWord.gDbgLedWord; 
....................   } 
....................   else 
....................   { 
....................     /* Do nothing */ 
....................   } 
.................... } 
....................  
.................... typedef struct _ST_BYTE_TYPE 
.................... { 
....................     unsigned int8 ui8Bit_00:1; 
....................     unsigned int8 ui8Bit_01:1; 
....................     unsigned int8 ui8Bit_02:1; 
....................     unsigned int8 ui8Bit_03:1; 
....................     unsigned int8 ui8Bit_04:1; 
....................     unsigned int8 ui8Bit_05:1; 
....................     unsigned int8 ui8Bit_06:1; 
....................     unsigned int8 ui8Bit_07:1; 
.................... } ST_BYTE_TYPE; 
....................  
.................... typedef union _UN_BYTE_TYPE 
.................... { 
....................     unsigned int8 m_uiByte; 
....................     ST_BYTE_TYPE  m_stByte; 
.................... } UN_BYTE_TYPE; 
....................  
.................... UN_BYTE_TYPE unByte; 
....................  
....................  
.................... void Reset() 
.................... { 
....................     unsigned int8 ui8LoopCount = 0; 
....................      
....................     gDbgLedDataWord.gDbgLedWord = gPreviousDbgLedDataWord.gDbgLedWord = 0xFF; 
....................      
....................     for(ui8LoopCount=0; ui8LoopCount<8; ui8LoopCount++) 
....................     { 
....................         output_bit(DO_DBG_SHIFT_REG_DATA_A, 1); 
....................         output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
....................         output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
....................     } 
.................... } 
....................  
.................... //###################################### Above Driver ################################################################### 
....................  
.................... //###################################### Below Non Driver ############################################################### 
.................... #define LED_BOX_PASSED               	1 
.................... #define LED_BOX_REJECTED             	2 
.................... #define LED_PC_COMMUNICATION_RX         3 
.................... #define LED_PC_COMMUNICATION_TX         4 
.................... #define LED_LDCD_COMMUNICATION_RX     	5 
.................... #define LED_LDCD_COMMUNICATION_TX     	6 
.................... #define LED_PROD_MODE   				7 
.................... #define LED_CALIB_MODE   				8 
....................  
....................  
....................  
.................... void SetLEDsOnPowerOn() 
.................... { 
....................     SetSystemLedState(LED_PROD_MODE,LOGICAL_OFF); 
....................     SetSystemLedState(LED_CALIB_MODE,LOGICAL_OFF); 
....................     SetSystemLedState(LED_BOX_PASSED,LOGICAL_OFF); 
....................     SetSystemLedState(LED_BOX_REJECTED,LOGICAL_OFF); 
....................     SetSystemLedState(LED_PC_COMMUNICATION_RX,LOGICAL_OFF); 
....................     SetSystemLedState(LED_PC_COMMUNICATION_TX,LOGICAL_OFF); 
....................     SetSystemLedState(LED_LDCD_COMMUNICATION_RX,LOGICAL_OFF); 
....................     SetSystemLedState(LED_LDCD_COMMUNICATION_TX,LOGICAL_OFF); 
....................      
.................... }     
....................  
.................... void SetLEDsOnPowerOff() 
.................... { 
....................     SetSystemLedState(LED_PROD_MODE,LOGICAL_ON); 
....................     SetSystemLedState(LED_CALIB_MODE,LOGICAL_ON); 
....................     SetSystemLedState(LED_BOX_PASSED,LOGICAL_ON); 
....................     SetSystemLedState(LED_BOX_REJECTED,LOGICAL_ON); 
....................     SetSystemLedState(LED_PC_COMMUNICATION_RX,LOGICAL_ON); 
....................     SetSystemLedState(LED_PC_COMMUNICATION_TX,LOGICAL_ON); 
....................     SetSystemLedState(LED_LDCD_COMMUNICATION_RX,LOGICAL_ON); 
....................     SetSystemLedState(LED_LDCD_COMMUNICATION_TX,LOGICAL_ON); 
.................... }   
....................  
.................... void SetLEDsAlter() 
.................... { 
.................... 	SetSystemLedState(LED_PROD_MODE,LOGICAL_ON); 
.................... 	SetSystemLedState(LED_CALIB_MODE,LOGICAL_OFF); 
.................... 	SetSystemLedState(LED_BOX_PASSED,LOGICAL_ON); 
.................... 	SetSystemLedState(LED_BOX_REJECTED,LOGICAL_OFF); 
.................... 	SetSystemLedState(LED_PC_COMMUNICATION_RX,LOGICAL_ON); 
.................... 	SetSystemLedState(LED_PC_COMMUNICATION_TX,LOGICAL_OFF); 
.................... 	SetSystemLedState(LED_LDCD_COMMUNICATION_RX,LOGICAL_ON); 
.................... 	SetSystemLedState(LED_LDCD_COMMUNICATION_TX,LOGICAL_OFF); 
....................  
.................... } 
.................... void SetLEDs1stON() 
.................... { 
.................... 	SetSystemLedState(LED_PROD_MODE,LOGICAL_ON); 
.................... 	SetSystemLedState(LED_CALIB_MODE,LOGICAL_OFF); 
....................     SetSystemLedState(LED_BOX_PASSED,LOGICAL_OFF); 
....................     SetSystemLedState(LED_BOX_REJECTED,LOGICAL_OFF); 
....................     SetSystemLedState(LED_PC_COMMUNICATION_RX,LOGICAL_OFF); 
....................     SetSystemLedState(LED_PC_COMMUNICATION_TX,LOGICAL_OFF); 
....................     SetSystemLedState(LED_LDCD_COMMUNICATION_RX,LOGICAL_OFF); 
....................     SetSystemLedState(LED_LDCD_COMMUNICATION_TX,LOGICAL_OFF); 
.................... 	 
.................... } 
....................  
.................... void SetLEDs2ndON() 
.................... { 
.................... 	SetSystemLedState(LED_PROD_MODE,LOGICAL_OFF); 
.................... 	SetSystemLedState(LED_CALIB_MODE,LOGICAL_ON); 
.................... 	SetSystemLedState(LED_BOX_PASSED,LOGICAL_OFF); 
....................     SetSystemLedState(LED_BOX_REJECTED,LOGICAL_OFF); 
....................     SetSystemLedState(LED_PC_COMMUNICATION_RX,LOGICAL_OFF); 
....................     SetSystemLedState(LED_PC_COMMUNICATION_TX,LOGICAL_OFF); 
....................     SetSystemLedState(LED_LDCD_COMMUNICATION_RX,LOGICAL_OFF); 
....................     SetSystemLedState(LED_LDCD_COMMUNICATION_TX,LOGICAL_OFF); 
....................  
.................... } 
....................  
.................... void SetLEDs3rdON() 
.................... { 
.................... 	SetSystemLedState(LED_PROD_MODE,LOGICAL_OFF); 
.................... 	SetSystemLedState(LED_CALIB_MODE,LOGICAL_OFF); 
.................... 	SetSystemLedState(LED_BOX_PASSED,LOGICAL_ON); 
.................... 	SetSystemLedState(LED_BOX_REJECTED,LOGICAL_OFF); 
....................     SetSystemLedState(LED_PC_COMMUNICATION_RX,LOGICAL_OFF); 
....................     SetSystemLedState(LED_PC_COMMUNICATION_TX,LOGICAL_OFF); 
....................     SetSystemLedState(LED_LDCD_COMMUNICATION_RX,LOGICAL_OFF); 
....................     SetSystemLedState(LED_LDCD_COMMUNICATION_TX,LOGICAL_OFF); 
.................... } 
....................  
.................... void SetLEDs4thON() 
.................... { 
.................... 	SetSystemLedState(LED_PROD_MODE,LOGICAL_OFF); 
.................... 	SetSystemLedState(LED_CALIB_MODE,LOGICAL_OFF); 
.................... 	SetSystemLedState(LED_BOX_PASSED,LOGICAL_OFF); 
.................... 	SetSystemLedState(LED_BOX_REJECTED,LOGICAL_ON); 
....................     SetSystemLedState(LED_PC_COMMUNICATION_RX,LOGICAL_OFF); 
....................     SetSystemLedState(LED_PC_COMMUNICATION_TX,LOGICAL_OFF); 
....................     SetSystemLedState(LED_LDCD_COMMUNICATION_RX,LOGICAL_OFF); 
....................     SetSystemLedState(LED_LDCD_COMMUNICATION_TX,LOGICAL_OFF); 
.................... } 
....................  
.................... void SetLEDs5thON() 
.................... { 
.................... 	SetSystemLedState(LED_PROD_MODE,LOGICAL_OFF); 
.................... 	SetSystemLedState(LED_CALIB_MODE,LOGICAL_OFF); 
.................... 	SetSystemLedState(LED_BOX_PASSED,LOGICAL_OFF); 
.................... 	SetSystemLedState(LED_BOX_REJECTED,LOGICAL_OFF); 
.................... 	SetSystemLedState(LED_PC_COMMUNICATION_RX,LOGICAL_ON); 
....................     SetSystemLedState(LED_PC_COMMUNICATION_TX,LOGICAL_OFF); 
....................     SetSystemLedState(LED_LDCD_COMMUNICATION_RX,LOGICAL_OFF); 
....................     SetSystemLedState(LED_LDCD_COMMUNICATION_TX,LOGICAL_OFF); 
....................  
.................... } 
....................  
.................... void SetLEDs6thON() 
.................... { 
.................... 	SetSystemLedState(LED_PROD_MODE,LOGICAL_OFF); 
.................... 	SetSystemLedState(LED_CALIB_MODE,LOGICAL_OFF); 
.................... 	SetSystemLedState(LED_BOX_PASSED,LOGICAL_OFF); 
.................... 	SetSystemLedState(LED_BOX_REJECTED,LOGICAL_OFF); 
.................... 	SetSystemLedState(LED_PC_COMMUNICATION_RX,LOGICAL_OFF); 
....................     SetSystemLedState(LED_PC_COMMUNICATION_TX,LOGICAL_ON); 
....................     SetSystemLedState(LED_LDCD_COMMUNICATION_RX,LOGICAL_OFF); 
....................     SetSystemLedState(LED_LDCD_COMMUNICATION_TX,LOGICAL_OFF);	 
.................... } 
....................  
.................... void SetLEDs7thON() 
.................... { 
.................... 	SetSystemLedState(LED_PROD_MODE,LOGICAL_OFF); 
.................... 	SetSystemLedState(LED_CALIB_MODE,LOGICAL_OFF); 
.................... 	SetSystemLedState(LED_BOX_PASSED,LOGICAL_OFF); 
.................... 	SetSystemLedState(LED_BOX_REJECTED,LOGICAL_OFF); 
.................... 	SetSystemLedState(LED_PC_COMMUNICATION_RX,LOGICAL_OFF); 
....................     SetSystemLedState(LED_PC_COMMUNICATION_TX,LOGICAL_OFF); 
....................     SetSystemLedState(LED_LDCD_COMMUNICATION_RX,LOGICAL_ON); 
....................     SetSystemLedState(LED_LDCD_COMMUNICATION_TX,LOGICAL_OFF); 
.................... } 
....................  
.................... void SetLEDs8thON() 
.................... { 
.................... 	SetSystemLedState(LED_PROD_MODE,LOGICAL_OFF); 
.................... 	SetSystemLedState(LED_CALIB_MODE,LOGICAL_OFF); 
.................... 	SetSystemLedState(LED_BOX_PASSED,LOGICAL_OFF); 
.................... 	SetSystemLedState(LED_BOX_REJECTED,LOGICAL_OFF); 
.................... 	SetSystemLedState(LED_PC_COMMUNICATION_RX,LOGICAL_OFF); 
....................     SetSystemLedState(LED_PC_COMMUNICATION_TX,LOGICAL_OFF); 
....................     SetSystemLedState(LED_LDCD_COMMUNICATION_RX,LOGICAL_OFF); 
....................     SetSystemLedState(LED_LDCD_COMMUNICATION_TX,LOGICAL_ON); 
.................... } 
....................  
.................... #endif /* _VI_SHIFT_REG_H_ */ 
....................  
.................... //#ifndef _VI_SHIFT_REG_H_ 
.................... //#define _VI_SHIFT_REG_H_ 
.................... // 
.................... //#include "viSystemConfig.h" 
.................... // 
.................... //#define LOGICAL_ON  0 
.................... //#define LOGICAL_OFF 1 
.................... // 
.................... //#define DO_DBG_SHIFT_REG_CLOCK       PIN_B4 
.................... ////#define DO_DBG_SHIFT_REG_CLOCK       PIN_D0 
.................... //#define DO_DBG_SHIFT_REG_DATA_A      PIN_B3 
.................... // 
.................... //typedef struct { 
.................... //  unsigned int8 bit_0: 1; 
.................... //  unsigned int8 bit_1: 1; 
.................... //  unsigned int8 bit_2: 1; 
.................... //  unsigned int8 bit_3: 1; 
.................... //  unsigned int8 bit_4: 1; 
.................... //  unsigned int8 bit_5: 1; 
.................... //  unsigned int8 bit_6: 1; 
.................... //  unsigned int8 bit_7: 1; 
.................... //  unsigned int8 bit_8: 1; 
.................... //  unsigned int8 bit_9: 1; 
.................... //  unsigned int8 bit_10: 1; 
.................... //  unsigned int8 bit_11: 1; 
.................... //  unsigned int8 bit_12: 1; 
.................... //  unsigned int8 bit_13: 1; 
.................... //  unsigned int8 bit_14: 1; 
.................... //  unsigned int8 bit_15: 1; 
.................... //  unsigned int8 bit_16: 1; 
.................... //  unsigned int8 bit_17: 1; 
.................... //  unsigned int8 bit_18: 1; 
.................... //  unsigned int8 bit_19: 1; 
.................... //  unsigned int8 bit_20: 1; 
.................... //  unsigned int8 bit_21: 1; 
.................... //  unsigned int8 bit_22: 1; 
.................... //  unsigned int8 bit_23: 1; 
.................... //  unsigned int8 bit_24: 1; 
.................... //  unsigned int8 bit_25: 1; 
.................... //  unsigned int8 bit_26: 1; 
.................... //  unsigned int8 bit_27: 1; 
.................... //  unsigned int8 bit_28: 1; 
.................... //  unsigned int8 bit_29: 1; 
.................... //  unsigned int8 bit_30: 1; 
.................... //  unsigned int8 bit_31: 1; 
.................... //} _DbgLedWordType; 
.................... // 
.................... //typedef union { 
.................... //  unsigned int32    gDbgLedWord; 
.................... //  _DbgLedWordType   DbgLedWord; 
.................... //} DbgLedDataType; 
.................... // 
.................... //DbgLedDataType gDbgLedDataWord; 
.................... //DbgLedDataType gPreviousDbgLedDataWord; 
.................... // 
.................... // 
.................... // 
.................... // 
.................... ///* Set Reset Debug Shift Register Outputs */ 
.................... //static void SetSystemLedState(unsigned int8 ledId, 
.................... //                             unsigned int8 ledState) 
.................... //{ 
.................... //  /* Set LED Data */ 
.................... //  unsigned int32 tempWord = 0x00000001; 
.................... //     
.................... //  switch(ledState) 
.................... //  { 
.................... //    case 0: /* Reset bit - LED On */ 
.................... //      tempWord <<= (ledId-1); 
.................... //      tempWord = ~(tempWord); 
.................... //      gDbgLedDataWord.gDbgLedWord &= tempWord; 
.................... //      break; 
.................... //    case 1: /* Set bit - LED Off */ 
.................... //      tempWord <<= (ledId-1); 
.................... //      gDbgLedDataWord.gDbgLedWord |= tempWord; 
.................... //      break; 
.................... //    default: /* Nothing to do */ 
.................... //      break; 
.................... //  }  
.................... // 
.................... //  /* Check for change in Data */ 
.................... //  if(gDbgLedDataWord.gDbgLedWord != gPreviousDbgLedDataWord.gDbgLedWord) 
.................... //  { 
.................... //    /* Send Byte to Shift register 74LS164 */ 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
.................... // 
.................... // 
.................... //    /* Shift in 3rd QH */ 
.................... //    output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_23); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
.................... //    /* Shift in 3rd QG */ 
.................... //    output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_22); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
.................... //    /* Shift in 3rd QF */ 
.................... //    output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_21); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
.................... //    /* Shift in 3rd QE */ 
.................... //    output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_20); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
.................... //    /* Shift in 3rd QD */ 
.................... //    output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_19); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
.................... //    /* Shift in 3rd QC */ 
.................... //    output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_18); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
.................... //    /* Shift in 3rd QB */ 
.................... //    output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_17); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
.................... //    /* Shift in 3rd QA */ 
.................... //    output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_16); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
.................... // 
.................... //    /* Shift in 2nd QH */ 
.................... //    output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_15); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
.................... //    /* Shift in 2nd QG */ 
.................... //    output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_14); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
.................... //    /* Shift in 2nd QF */ 
.................... //    output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_13); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
.................... //    /* Shift in 2nd QE */ 
.................... //    output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_12); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
.................... //    /* Shift in 2nd QD */ 
.................... //    output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_11); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
.................... //    /* Shift in 2nd QC */ 
.................... //    output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_10); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
.................... //    /* Shift in 2nd QB */ 
.................... //    output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_9); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
.................... //    /* Shift in 2nd QA */ 
.................... //    output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_8); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
.................... // 
.................... //    /* Shift in 1st QH */ 
.................... //    output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_7); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
.................... //    /* Shift in 1st QG */ 
.................... //    output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_6); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
.................... //    /* Shift in 1st QF */ 
.................... //    output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_5); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
.................... //    /* Shift in 1st QE */ 
.................... //    output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_4); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
.................... //    /* Shift in 1st QD */ 
.................... //    output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_3); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
.................... //    /* Shift in 1st QC */ 
.................... //    output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_2); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
.................... //    /* Shift in 1st QB */ 
.................... //    output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_1); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
.................... //    /* Shift in 1st QA */ 
.................... //    output_bit(DO_DBG_SHIFT_REG_DATA_A, gDbgLedDataWord.DbgLedWord.bit_0); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
.................... //    output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
.................... // 
.................... //    /* Update previous LED data */  
.................... //    gPreviousDbgLedDataWord.gDbgLedWord = gDbgLedDataWord.gDbgLedWord; 
.................... //  } 
.................... //  else 
.................... //  { 
.................... //    /* Do nothing */ 
.................... //  } 
.................... //} 
.................... // 
.................... //typedef struct _ST_BYTE_TYPE 
.................... //{ 
.................... //    unsigned int8 ui8Bit_00:1; 
.................... //    unsigned int8 ui8Bit_01:1; 
.................... //    unsigned int8 ui8Bit_02:1; 
.................... //    unsigned int8 ui8Bit_03:1; 
.................... //    unsigned int8 ui8Bit_04:1; 
.................... //    unsigned int8 ui8Bit_05:1; 
.................... //    unsigned int8 ui8Bit_06:1; 
.................... //    unsigned int8 ui8Bit_07:1; 
.................... //} ST_BYTE_TYPE; 
.................... // 
.................... //typedef union _UN_BYTE_TYPE 
.................... //{ 
.................... //    unsigned int8 m_uiByte; 
.................... //    ST_BYTE_TYPE  m_stByte; 
.................... //} UN_BYTE_TYPE; 
.................... // 
.................... //UN_BYTE_TYPE unByte; 
.................... // 
.................... //void Reset() 
.................... //{ 
.................... //    unsigned int8 ui8LoopCount = 0; 
.................... //     
.................... //    for(ui8LoopCount=0; ui8LoopCount<24; ui8LoopCount++) 
.................... //    { 
.................... //        output_bit(DO_DBG_SHIFT_REG_DATA_A, 1); 
.................... //        output_bit(DO_DBG_SHIFT_REG_CLOCK, 0); 
.................... //        output_bit(DO_DBG_SHIFT_REG_CLOCK, 1); 
.................... //    } 
.................... //} 
.................... // 
.................... ////###################################### Above Driver ################################################################### 
.................... // 
.................... ////###################################### Below Non Driver ############################################################### 
.................... //#define LED_PROD_MODE               24 
.................... //#define LED_CALIB_MODE              25 
.................... //#define LED_BOX_PASSED              26 
.................... //#define LED_BOX_REJECTED            27 
.................... //#define LED_PC_COMMUNICATION_RX     28 
.................... //#define LED_PC_COMMUNICATION_TX     29 
.................... //#define LED_LDCD_COMMUNICATION_RX   30 
.................... //#define LED_LDCD_COMMUNICATION_TX   31 
.................... // 
.................... // 
.................... //#define LED_B2_NON_PROD_MODE   6 
.................... //#define LED_B3_PROD_MODE       7 
.................... //#define LED_B3_NON_PROD_MODE   8 
.................... //#define LED_S0_PROD_MODE       9 
.................... //#define LED_S0_NON_PROD_MODE  10 
.................... //#define LED_S1_PROD_MODE      11 
.................... //#define LED_S1_NON_PROD_MODE  12 
.................... //#define LED_S2_PROD_MODE      13 
.................... //#define LED_S2_NON_PROD_MODE  14 
.................... //#define LED_BIG_CAN_SMALL_LID 15 
.................... //#define LED_BIG_CAN_BIG_LID   16 
.................... //#define LED_SML_CAN_SMALL_LID 17 
.................... ////#define LED_CTRL_ON           18 
.................... //#define LED_E_STOP_ON          21 
.................... // 
.................... //void SetLEDsOnPowerOn() 
.................... //{ 
.................... //    SetSystemLedState(LED_PROD_MODE,LOGICAL_OFF); 
.................... //    SetSystemLedState(LED_CALIB_MODE,LOGICAL_OFF); 
.................... //    SetSystemLedState(LED_BOX_PASSED,LOGICAL_OFF); 
.................... //    SetSystemLedState(LED_BOX_REJECTED,LOGICAL_OFF); 
.................... //    SetSystemLedState(LED_PC_COMMUNICATION_RX,LOGICAL_OFF); 
.................... //    SetSystemLedState(LED_PC_COMMUNICATION_TX,LOGICAL_OFF); 
.................... //    SetSystemLedState(LED_LDCD_COMMUNICATION_RX,LOGICAL_OFF); 
.................... //    SetSystemLedState(LED_LDCD_COMMUNICATION_TX,LOGICAL_OFF); 
.................... //     
.................... ////    SetSystemLedState(LED_PROD_MODE,LOGICAL_ON); 
.................... ////    SetSystemLedState(LED_CALIB_MODE,LOGICAL_ON); 
.................... ////    SetSystemLedState(LED_BOX_PASSED,LOGICAL_ON); 
.................... ////    SetSystemLedState(LED_BOX_REJECTED,LOGICAL_ON); 
.................... ////    SetSystemLedState(LED_PC_COMMUNICATION_RX,LOGICAL_ON); 
.................... ////    SetSystemLedState(LED_PC_COMMUNICATION_TX,LOGICAL_ON); 
.................... ////    SetSystemLedState(LED_LDCD_COMMUNICATION_RX,LOGICAL_ON); 
.................... ////    SetSystemLedState(LED_LDCD_COMMUNICATION_TX,LOGICAL_ON); 
.................... //}     
.................... // 
.................... // 
.................... //#endif /* _VI_SHIFT_REG_H_ */ 
....................  
.................... #include "../Common/vmModbusGlobal.h" 
.................... #ifndef _VI_MODBUS_GOBAL_H_ 
.................... #define _VI_MODBUS_GOBAL_H_ 
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE 64   
.................... #define MODBUS_REG_BUFFER_SIZE 10    
....................   
.................... #define MODBUS_REG_OUTPUT_0  	0  
.................... #define MODBUS_REG_OUTPUT_1		1 
.................... #define MODBUS_REG_OUTPUT_2		2 
.................... #define MODBUS_REG_OUTPUT_3		4 
.................... #define MODBUS_REG_OUTPUT_4		8 
.................... #define MODBUS_REG_OUTPUT_5		16 
.................... #define MODBUS_REG_OUTPUT_6		32 
.................... #define MODBUS_REG_OUTPUT_7		64 
.................... #define MODBUS_REG_OUTPUT_8		128 
.................... #define MODBUS_REG_OUTPUT_9		256 
.................... #define MODBUS_REG_OUTPUT_10	512 
.................... #define MODBUS_REG_OUTPUT_11	1024 
.................... #define MODBUS_REG_OUTPUT_12	2048 
.................... #define MODBUS_REG_OUTPUT_13	4096 
.................... #define MODBUS_REG_OUTPUT_14	8192 
.................... #define MODBUS_REG_OUTPUT_15	16384 
.................... #define MODBUS_REG_OUTPUT_16	32768 
....................  
.................... #define MODBUS_AUTO_CALIBRATION  	1  
.................... #define MODBUS_FIXED_CALIBRATION    0 
....................  
.................... enum function { 
.................... 	RS485_FUNCTION_READ_COILS                 = 1, 
.................... 	RS485_FUNCTION_READ_DISCRETE_INPUT        = 2, 
.................... 	RS485_FUNCTION_READ_HOLDING_REGISTERS     = 3, 
.................... 	RS485_FUNCTION_READ_INPUT_REGISTERS       = 4, 
.................... 	RS485_FUNCTION_WRITE_SINGLE_COIL          = 5, 
.................... 	RS485_FUNCTION_WRITE_SINGLE_REGISTER      = 6, 
.................... 	RS485_FUNCTION_READ_MULTIPLE_REGISTERS    = 15, 
.................... 	RS485_FUNCTION_WRITE_MULTIPLE_REGISTERS   = 16		 
.................... }; 
....................  
.................... enum exception { 
.................... 	RS485_ILLEGAL_FUNCTION        = 1,	 
.................... 	RS485_ILLEGAL_DATA_ADDRESS    = 2, 
.................... 	RS485_ILLEGAL_DATA_VALUE      = 3, 
.................... 	RS485_SLAVE_DEVICE_FAILED     = 4, 
.................... 	RS485_ACKNOWLAGE              = 5, 
.................... 	RS485_SLAVE_DEVICE_BUSY       = 6, 
.................... 	RS485_NEG_ACKNOWLAGE          = 7, 
.................... 	RS485_MEMORY_PARITY_ERROR     = 8, 
.................... 	RS485_GETWAY_PATH             = 10, 
.................... 	RS485_GETWAY_DEVICE           = 11	 
.................... }; 
....................  
.................... typedef struct 
.................... {  
....................    unsigned int8    ui8Slaveid;  
....................    unsigned int16   u16Address; 
....................    unsigned int16   u16LenData;                       //number of bytes in the message received  
....................    function         func;                           //the function of the message received  
....................    exception        error;                         //error recieved, if any  
....................    unsigned int16   ui16RegisterData; 
.................... //   unsigned int8    ui8Data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received  
....................    BOOLEAN          bDataProcessed; 
....................    unsigned int8    ui8NoRegDataBytes; 
....................    unsigned int16   ui16RegisterDataArr[MODBUS_REG_BUFFER_SIZE]; 
....................    unsigned int32   u32RegData; 
.................... } Modbus_Rx;  
....................  
.................... Modbus_Rx g_ModbusRx; 
....................  
.................... // use for calibration data 
.................... unsigned int16 g_ui16Register0_1; 
.................... unsigned int16 g_ui16Register0_2; 
.................... unsigned int16 g_ui16Register1000_1; 
.................... unsigned int16 g_ui16Register1000_2; 
.................... unsigned int16 g_ui16Register2000_1; 
.................... unsigned int16 g_ui16Register2000_2; 
.................... unsigned int16 g_ui16Register3000_1; 
.................... unsigned int16 g_ui16Register3000_2; 
.................... unsigned int16 g_ui16Register4000_1; 
.................... unsigned int16 g_ui16Register4000_2; 
.................... unsigned int16 g_ui16Register5000_1; 
.................... unsigned int16 g_ui16Register5000_2; 
.................... unsigned int16 g_ui16Register6000_1; 
.................... unsigned int16 g_ui16Register6000_2; 
.................... unsigned int16 g_ui16Register7000_1; 
.................... unsigned int16 g_ui16Register7000_2; 
.................... unsigned int16 g_ui16Register8000_1; 
.................... unsigned int16 g_ui16Register8000_2; 
.................... unsigned int16 g_ui16Register9000_1; 
.................... unsigned int16 g_ui16Register9000_2; 
.................... unsigned int16 g_ui16Register10000_1; 
.................... unsigned int16 g_ui16Register10000_2; 
....................  
.................... unsigned int16 g_ui16RegisterCurrentCalibrationWeight; 
.................... unsigned int16 g_ui16RegisterCurrentCalibrationPoint; 
.................... unsigned int8  g_fStartCalibration; 
.................... unsigned int32 g_ui32TareADCValueForCalibration; 
.................... unsigned int32 g_ui32gWeightADCValueForCalibration; 
.................... unsigned int16 g_ui16gAvgWtForCalibration; 
....................  
.................... unsigned int16 g_ui16RegisterAvgWeight; 
.................... unsigned int16 g_ui16RegisterTolPv; 
.................... unsigned int16 g_ui16RegisterTolNv; 
.................... unsigned int16 g_ui16RegisterCurrProductIndex; 
....................  
.................... // use for production  
.................... unsigned int16 g_ui16CBBCount; 
.................... unsigned int16 g_ui16CBBCountPrev; 
.................... unsigned int16 g_ui16CurrentWt; 
.................... unsigned int16 g_ui16CurrentPassStatus; 
.................... unsigned int16 g_ui16RunningAvgWt; 
.................... unsigned int16 g_ui16RunningTareValue; 
.................... unsigned int16 g_ui16ServerStatus; 
....................  
.................... unsigned int16 g_ui16FlagForSetTareValue; 
....................  
.................... // use for system date time 
.................... unsigned int16 g_ui16RegisterDateYY; 
.................... unsigned int16 g_ui16RegisterDateMM; 
.................... unsigned int16 g_ui16RegisterDateDD; 
....................  
.................... unsigned int16 g_ui16RegisterTime_HH; 
.................... unsigned int16 g_ui16RegisterTime_mm; 
.................... unsigned int16 g_ui16RegisterTime_ss; 
....................  
.................... unsigned int16 g_ui16RegisterTime_Diff; 
....................  
.................... // use for pre production 
.................... unsigned int16 g_ui16CurrProdIndex; 
.................... unsigned int16 g_ui16CurrProdAvgWt; 
.................... unsigned int16 g_ui16CurrProdPvTol; 
.................... unsigned int16 g_ui16CurrProdNvTol; 
....................  
.................... // Use for Current Mode 
.................... unsigned int16 g_ui16CurrentMode; 
....................  
.................... // use for production type 
.................... unsigned int8  g_fAutoCalibrationMode; 
....................  
.................... // use for sample count for auto calibration 
.................... unsigned int16 g_ui16AutoCalibrationSampleCount; 
....................  
.................... // Use for store load cell factor. 
.................... unsigned int16 g_ui16CurrLoadCellFactor; 
....................  
.................... #endif /* _VI_MODBUS_GOBAL_H_ */ 
....................  
....................  
.................... //#include "../Common/vmRS485Config.h" 
.................... #include "vmM1Common.h" 
.................... /*  
....................  * File:   vmM1Common.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on July 8, 2019, 3:52 PM 
....................  */ 
....................  
.................... #ifndef VMM1COMMON_H 
.................... #define	VMM1COMMON_H 
....................  
.................... #define RS485_TX_BUFF_SIZE 		20 
.................... #define RS485_RX_BUFF_SIZE 		50 
....................  
.................... #define FLAG_RS485_DATA_READY                   1 
.................... #define FLAG_RS485_DATA_NOT_READY               0 
....................  
.................... #define FLAG_RS485_DATA_SEND_ON                 1 
.................... #define FLAG_RS485_DATA_SEND_DONE               2 
.................... #define FLAG_RS485_DATA_SEND_OFF                3 
....................  
.................... #define DELAY_TIME_RTS_BEFORE                       1 
.................... #define DELAY_TIME_RTS_AFTER                        2 
....................  
....................  
.................... unsigned int8 g_RS485TxBuffer[RS485_TX_BUFF_SIZE] = {0}; 
.................... unsigned int8 g_RS485RxBuffer[RS485_RX_BUFF_SIZE] = {0}; 
....................  
.................... unsigned int8  g_fRS485DataReady                  = FLAG_RS485_DATA_NOT_READY; 
.................... unsigned int8  g_ui8ByteToSend                    = 0; 
.................... unsigned int8  g_ui8fRS485DataSend                = FLAG_RS485_DATA_SEND_OFF; 
....................  
.................... #endif	/* VMM1COMMON_H */ 
....................  
....................  
.................... #include "../Common/vmIBCConfig.h" 
.................... #ifndef _VI_IBC_CONFIG_H_ 
.................... #define _VI_IBC_CONFIG_H_ 
....................  
.................... #include "vmSystemConfig.h" 
.................... #ifndef _VM_SYSTEM_CONFIG_H_ 
.................... #define _VM_SYSTEM_CONFIG_H_ 
....................  
.................... //****************** Inclusion Files *************************** 
.................... #include "18F46K80.h" 
.................... #include "vmPINConfig.h" 
....................  
.................... //****************** Component Configuration ******************** 
....................  
.................... //optimization level. 
.................... #pragma opt 8 
....................   
.................... //********* CPU Settings ******************************************* 
....................  
.................... #pragma device HIGH_INTS=TRUE 
.................... #pragma fuses NOPLLEN,ECH,WDT1024,NOPROTECT,NOBROWNOUT,NOFCMEN,NOIESO,NOPUT /* WDT1024 => 1024 * 4 ms = 4096 mS Watchdog Timer */ /* For Field Mode */ 
....................  
.................... #pragma use delay(clock=20000000,restart_wdt) 
....................  
....................  
.................... //******** Serial Interface ************ 
.................... #pragma use rs232(stream=GSM_M66, xmit=PIN_GPRS_COMM_XMIT, rcv=PIN_GPRS_COMM_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
.................... #pragma use rs232(stream=RS485, xmit=PIN_RS485_XMIT, rcv=PIN_RS485_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
....................  
.................... //#define unsigned int8 BYTE 
....................  
.................... #ifndef M1_COMM_MODULE 
.................... #define M1_COMM_MODULE  1 
.................... #endif 
....................  
.................... #endif /* _VM_SYSTEM_CONFIG_H_ */ 
....................  
.................... #include "vmCRCConfig.h" 
.................... #ifndef _VM_CRC_CONFIG_H_ 
.................... #define _VM_CRC_CONFIG_H_ 
....................  
.................... // Table of CRC values for high–order byte. 
.................... unsigned int8 const auchCRCHi[] =  
.................... { 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40 
.................... } ; 
....................  
.................... // Table of CRC values for low–order byte. 
.................... unsigned int8 const auchCRCLo[] =  
.................... { 
.................... 0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 
.................... 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 
.................... 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 
.................... 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 
.................... 0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7, 
.................... 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 
.................... 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 
.................... 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 
.................... 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 
.................... 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 
.................... 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 
.................... 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5, 
.................... 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91, 
.................... 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 
.................... 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 
.................... 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 
.................... 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // CRC calculation. 
.................... static unsigned int16 ModbusCRC16 (unsigned int8* puiMsg,   // Message to calculate CRC upon. 
....................                                    unsigned short usDataLen) // Quantity of bytes in message. 
.................... { 
....................     unsigned int8 uchCRCHi = 0xFF; // High byte of CRC initialized. 
....................     unsigned int8 uchCRCLo = 0xFF; // Low byte of CRC initialized. 
....................     unsigned int8 uIndex;          // Will index into CRC lookup table. 
....................  
....................     while (usDataLen--) // Loop through message buffer. 
....................     { 
....................         uIndex = uchCRCLo ^ *puiMsg++; // Calculate the CRC. 
....................         uchCRCLo = uchCRCHi ^ auchCRCHi[uIndex]; 
....................         uchCRCHi = auchCRCLo[uIndex]; 
....................     } 
....................  
....................     return ((((unsigned int16)uchCRCHi) << 8) | uchCRCLo); 
.................... } 
....................  
.................... unsigned int16 calculateCrc( unsigned int8* pDataBuff, unsigned int8 uiDataLen ) 
.................... { 
.................... 	unsigned int16 uiCRC        = 0x00; 
.................... 	unsigned int16 shRemainder  = 0xFFFF; 
.................... 	unsigned int16 shGP         = 40961; 
.................... 	unsigned int8  uiByteCount  = 0; 
.................... 	unsigned int8  bShiftCount  = 0; 
.................... 	unsigned int8  bShiftCarry  = 0; 
....................  
.................... 	while (1) 
.................... 	{ 
.................... 		if (uiByteCount == uiDataLen) 
.................... 		{ 
.................... 			break; 
.................... 		} 
....................  
.................... 		uiByteCount++; 
.................... 		bShiftCount = 0; 
....................  
.................... 		while (1) 
.................... 		{ 
.................... 			if (0 == bShiftCount) 
.................... 			{ 
.................... 				if (1 == uiByteCount) 
.................... 				{ 
.................... 					uiCRC = (pDataBuff[uiByteCount - 1]) ^ shRemainder; 
.................... 				} 
.................... 				else 
.................... 				{ 
.................... 					uiCRC = uiCRC ^ (pDataBuff[uiByteCount - 1]); 
.................... 				} 
.................... 			} 
.................... 			else 
.................... 			{ 
.................... 				uiCRC = uiCRC ^ shGP; 
.................... 			} 
....................  
.................... 		    NoBitCarry: 
....................  
.................... 			bShiftCount++; 
....................  
.................... 			if (bShiftCount > 8) 
.................... 			{ 
.................... 				break; 
.................... 			} 
....................  
.................... 			bShiftCarry = uiCRC & 1; 
....................  
.................... 			uiCRC = uiCRC >> 1; 
....................  
.................... 			if (1 == bShiftCarry) 
.................... 			{ 
.................... 				continue; 
.................... 			} 
.................... 			else 
.................... 			{ 
.................... 				goto NoBitCarry; 
.................... 			} 
.................... 		} 
.................... 	} 
....................  
.................... 	return uiCRC; 
.................... } 
....................  
.................... #endif /* _VM_CRC_CONFIG_H_ */ 
....................  
.................... #include "vmDigitalIOConfig.h" 
.................... #ifndef _VM_DIGITAL_IO_CONFIG_H_ 
.................... #define _VM_DIGITAL_IO_CONFIG_H_ 
....................  
....................  
.................... //***************************************************** 
.................... //********* Data Structure For Digital  
....................  
....................  
....................  
....................  
....................  
.................... #endif /* _VM_DIGITAL_IO_CONFIG_H_ */ 
....................  
.................... //#include "ctype.h" 
.................... #include "vmPINConfig.h" 
.................... #ifndef _VM_PIN_CONFIG_H_ 
.................... #define _VM_PIN_CONFIG_H_ 
....................  
.................... //#include "18F46K80.h" 
....................  
.................... // RS485 Communication Pin Mapping. 
.................... #define PIN_RS485_XMIT              PIN_D6 
.................... #define PIN_RS485_RCV               PIN_D7 
.................... #define PIN_RS485_RTS               PIN_D4			 
....................  
.................... // GPSR Communication PIN Mapping; SIM900/SIM800/Quectel. 
.................... #define PIN_GPRS_COMM_XMIT          PIN_C6 
.................... #define PIN_GPRS_COMM_RCV           PIN_C7 
....................  
.................... // IBC Communication PIN Mapping. 
.................... #define PIN_IBC_RCV                 PIN_B1 
.................... #define PIN_IBC_XMIT                PIN_D5 
....................  
.................... // UART To UART Communication PIN Mapping. 
.................... #define PIN_SW_UART_COMM_XMIT       PIN_B2 
.................... #define PIN_SW_UART_COMM_RCV        PIN_B3 
....................  
.................... // Software UART PIN Mapping. 
.................... #define PIN_SW_UART_XMIT            PIN_B4 
.................... #define PIN_SW_UART_RCV             PIN_B0 
....................  
.................... // DI PIN Mapping;In 5V 
.................... #define PIN_IN_EXT_DI_00            PIN_C0 
.................... #define PIN_IN_EXT_DI_01            PIN_C1 
.................... #define PIN_IN_EXT_DI_02            PIN_C2 
.................... #define PIN_IN_EXT_DI_03            PIN_C3 
....................  
....................  
.................... #endif /* _VM_PIN_CONFIG_H_ */ 
....................  
.................... #include "vmIBCGlobal.h" 
.................... #ifndef _VM_IBC_GOBAL_H_ 
.................... #define _VM_IBC_GOBAL_H_ 
....................  
.................... #define IBC_SEND_LOCK                   1 
.................... #define IBC_SEND_UNLOCK                 0 
....................  
.................... typedef enum _EN_IBC_COMMANDS 
.................... { 
....................     IBC_CMD_MODE_HOME                   = 100, 
....................     // Calibration Mode 
....................     IBC_CMD_MODE_CALIB                  = 101, 
....................     IBC_CMD_GET_CALIB_POINT             = 102, 
....................     IBC_CMD_RESET_CALIB_POINT_TARE      = 103, 
....................     IBC_CMD_RESET_CALIB_POINT           = 104, 
....................     IBC_CMD_RESET_CALIB_POINT_WEIGHT    = 105,  
....................     IBC_CMD_TARE_REQUEST                = 106, 
....................     IBC_CMD_SET_LOAD_CELL_FACTOR        = 115,         
....................  
....................     // Pre-Production Mode 
....................     IBC_CMD_MODE_PRE_PROD               = 107, 
....................     IBC_CMD_PRE_PROD_AVG_WEIGHT         = 108, 
....................     IBC_CMD_PRE_PROD_TOLERANCE          = 109, 
....................     IBC_CMD_MODE_AUTO_CALIB             = 110, 
....................     IBC_CMD_MODE_FIXED_CALIB            = 111, 
....................  
....................  
....................     // Production Mode 
....................     IBC_CMD_MODE_PROD                   = 112, 
....................     IBC_CMD_START_PROD                  = 113, 
....................     IBC_CMD_PROD_WEIGH_DATA             = 114, 
....................  
....................     IBC_CMD_PROD_TARE_DATA              = 118, 
....................     IBC_CMD_PROD_AVG_WT_DATA            = 119, 
....................              
....................     IBC_CMD_PROD_INTMD_DATA             = 122 
....................              
....................              
.................... } EN_IBC_COMMANDS; 
....................  
.................... // Mode type 
.................... enum boardModeType 
.................... { 
....................     BOARD_MODE_TYPE_NOTHING         = 0, 
....................     BOARD_MODE_TYPE_HOME            = 1, 
....................     BOARD_MODE_TYPE_PRE_PRODUCTION  = 2, 
.................... 	BOARD_MODE_TYPE_PRODUCTION      = 3, 
....................     BOARD_MODE_TYPE_CONFIGURATION   = 4, 
....................     BOARD_MODE_TYPE_CALIBRATION     = 5 
.................... }; 
....................  
.................... // Mode action on Hardware 
.................... enum manualModeActionHW { 
....................     MANUAL_MODE_ACTION_ON_NOTHING               = 0, 
....................     MANUAL_MODE_ACTION_ON_COIL_STOPPER_UNIT_1   = 1, 
....................     MANUAL_MODE_ACTION_ON_COIL_STOPPER_UNIT_2   = 2, 
....................     MANUAL_MODE_ACTION_ON_GRIPPER_ARM_1         = 3, 
....................     MANUAL_MODE_ACTION_ON_GRIPPER_ARM_2         = 4, 
....................     MANUAL_MODE_ACTION_ON_ARCH_CHUTE            = 5, 
....................     MANUAL_MODE_ACTION_ON_SERVO                 = 6, 
....................  
.................... 	MANUAL_MODE_ACTION_ON_LA1                   = 7, 
....................     MANUAL_MODE_ACTION_ON_LA2                   = 8, 
....................     MANUAL_MODE_ACTION_ON_VFD                   = 9, 
....................     MANUAL_MODE_ACTION_ON_PNEUMATIC_DRIVE       = 10, 
....................      
....................     MANUAL_MODE_ACTION_ON_COIL_TRANSFER         = 11, 
....................     MANUAL_MODE_ACTION_ON_TUNION                = 12 
....................  
.................... }; 
....................  
.................... //typedef struct _ST_IBC_PROD_M_WEIGHT_DATA 
.................... //{ 
.................... //    int16 m_i16BoxCount; 
.................... //    int16 m_i16BoxWeight; 
.................... //} ST_IBC_PROD_M_WEIGHT_DATA; 
.................... typedef struct _ST_IBC_PROD_M_WEIGHT_DATA 
.................... { 
....................     unsigned int16 m_ui16BoxCount; 
....................     int16 m_i16BoxWeight; 
.................... } ST_IBC_PROD_M_WEIGHT_DATA; 
....................  
....................  
.................... typedef union _UN_IBC_PROD_M_WEIGHT_DATA 
.................... { 
....................     ST_IBC_PROD_M_WEIGHT_DATA m_stWeighingData; 
....................     unsigned int8             m_ui8Arr[4]; 
.................... } UN_IBC_PROD_M_WEIGHT_DATA; 
....................  
.................... typedef struct _ST_IBC_PROD_M_TARE_DATA 
.................... { 
....................     int16 m_i16Padding; 
....................     int16 m_i16TareData; 
.................... } ST_IBC_PROD_M_TARE_DATA; 
....................  
.................... typedef union _UN_IBC_PROD_M_TARE_DATA 
.................... { 
....................     ST_IBC_PROD_M_TARE_DATA m_stTareData; 
....................     unsigned int8           m_ui8Arr[4]; 
.................... } UN_IBC_PROD_M_TARE_DATA; 
....................  
.................... typedef struct _ST_IBC_AVG_WT_NODE 
.................... { 
....................     int16 m_i16AvgWt; 
....................     int16 m_i16Padding; 
.................... } ST_IBC_AVG_WT_NODE; 
....................  
.................... typedef union _UN_IBC_AVG_WT_NODE 
.................... { 
....................     ST_IBC_AVG_WT_NODE m_stIBCAvgNode; 
....................     unsigned int8      m_ui8Arr[4]; 
.................... } UN_IBC_AVG_WT_NODE; 
....................  
.................... typedef struct _ST_IBC_TOL_NODE 
.................... { 
....................     int16 m_i16PositiveTol; 
....................     int16 m_i16NegativeTol; 
.................... } ST_IBC_TOL_NODE; 
....................  
.................... typedef union _UN_IBC_TOLERANCE_NODE 
.................... { 
....................     ST_IBC_TOL_NODE m_stIBCTolNode; 
....................     unsigned int8   m_ui8Arr[4]; 
.................... }UN_IBC_TOLERANCE_NODE; 
....................  
....................  
.................... typedef struct _ST_IBC_RESET_CALIB_POINT 
.................... { 
....................     int16         m_i16CalibPoint; 
....................     int16         m_i16CurrCalibPoint; 
.................... } ST_IBC_RESET_CALIB_POINT; 
....................  
.................... typedef union _UN_IBC_RESET_CALIB_POINT 
.................... { 
....................     ST_IBC_RESET_CALIB_POINT m_stIBCResetCalibPoint; 
....................     unsigned int8            m_ui8Arr[4]; 
.................... } UN_IBC_RESET_CALIB_POINT; 
....................  
....................  
.................... typedef struct _ST_IBC_RESET_CALIB_POINT_ACK 
.................... { 
....................     int16         m_i16PassCount; 
....................     int16         m_i16CalibValue; 
.................... } ST_IBC_RESET_CALIB_POINT_ACK; 
....................  
.................... typedef union _UN_IBC_RESET_CALIB_POINT_ACK 
.................... { 
....................     ST_IBC_RESET_CALIB_POINT_ACK m_stIBCResetCalibPoint; 
....................     unsigned int8                m_ui8Arr[4]; 
.................... } UN_IBC_RESET_CALIB_POINT_ACK; 
....................  
.................... typedef struct _ST_IBC_RESET_CALIB_POINT_TARE 
.................... { 
....................     unsigned int32 m_ui32CalibADCForTare; 
.................... }ST_IBC_RESET_CALIB_POINT_TARE; 
....................  
.................... typedef union _UN_IBC_RESET_CALIB_POINT_TARE 
.................... { 
....................     ST_IBC_RESET_CALIB_POINT_TARE m_stIBCResetCalibTare; 
....................     unsigned int8                 m_ui8Arr[4]; 
.................... }UN_IBC_RESET_CALIB_POINT_TARE; 
....................  
.................... typedef struct _ST_IBC_RESET_CALIB_POINT_WEIGHT 
.................... { 
....................     unsigned int32 m_ui32CalibADCForWeight; 
.................... }ST_IBC_RESET_CALIB_POINT_WEIGHT; 
....................  
.................... typedef union _UN_IBC_RESET_CALIB_POINT_WEIGHT 
.................... { 
....................     ST_IBC_RESET_CALIB_POINT_WEIGHT m_stIBCResetCalibWeight; 
....................     unsigned int8                 m_ui8Arr[4]; 
.................... }UN_IBC_RESET_CALIB_POINT_WEIGHT; 
....................  
.................... // Send Current Average Weight from MCU0 to MCU1, for IBC_CMD_PROD_AVG_WT_DATA 
.................... typedef struct _ST_IBC_PROD_MODE_CUR_AVG 
.................... { 
....................     int16 m_i16CurAvg; 
....................     int16 m_i16Padding; 
.................... } ST_IBC_PROD_MODE_CUR_AVG; 
....................  
.................... typedef union _UN_IBC_PROD_MODE_CUR_AVG 
.................... { 
....................     ST_IBC_PROD_MODE_CUR_AVG m_stAvgData; 
....................     unsigned int8            m_ui8Arr[4]; 
.................... } UN_IBC_PROD_MODE_CUR_AVG; 
....................  
.................... typedef struct _ST_IBC_LOAD_CELL_FACTOR 
.................... { 
....................     unsigned int16 m_ui16CurrLoadCellFactor; 
....................     unsigned int16 m_ui16Padding; 
....................      
.................... }ST_IBC_LOAD_CELL_FACTOR; 
....................  
.................... typedef union _UN_IBC_LOAD_CELL_FACTOR 
.................... { 
....................     ST_IBC_LOAD_CELL_FACTOR     m_stLoadCellFactor; 
....................     unsigned int8               m_ui8Arr[4]; 
.................... }UN_IBC_LOAD_CELL_FACTOR; 
....................  
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //*****************************************************************************  
.................... boardModeType           g_boardModeType; 
.................... boardModeType           g_boardModeTypePre; 
.................... manualModeActionHW      g_manualModeActionOnHw; 
.................... unsigned int16          g_ui16DIStatus; 
.................... unsigned int16          g_ui16DOStatus; 
.................... unsigned int16          g_ui16ErrorStatus; 
.................... unsigned int8           g_ui8IncrementIndex; 
.................... int8                    g_fIBCSendLockStatus = IBC_SEND_UNLOCK; 
....................  
.................... UN_IBC_PROD_M_WEIGHT_DATA    g_unIBCProdModeWtData; 
.................... UN_IBC_PROD_M_TARE_DATA      g_unIBCProdModeTrData; 
.................... UN_IBC_AVG_WT_NODE           g_unIBCAvgNode; 
.................... UN_IBC_TOLERANCE_NODE        g_unIBCTolNode; 
.................... UN_IBC_RESET_CALIB_POINT     g_unIBCResetCalib; 
.................... UN_IBC_RESET_CALIB_POINT_ACK g_unIBCResetCalibAck; 
.................... UN_IBC_PROD_MODE_CUR_AVG     g_unIBCProdModeAvg; 
.................... UN_IBC_LOAD_CELL_FACTOR      g_unIBCCurrLoadCellFactor; 
.................... UN_IBC_RESET_CALIB_POINT_TARE g_unIBCResetCalibTare; 
.................... UN_IBC_RESET_CALIB_POINT_WEIGHT g_unIBCResetCalibWeight; 
....................  
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... // function for set mode as Nothing 
.................... void SetModeNothing(void) 
.................... { 
....................     g_boardModeTypePre  = g_boardModeType; 
....................     g_boardModeType     = BOARD_MODE_TYPE_NOTHING; 
.................... } 
....................  
.................... // function for check mode is Nothing or not 
.................... int8 IsModeNothing(void) 
.................... { 
....................     int8 bRetVal = 0; 
....................      
....................     if(g_boardModeType == BOARD_MODE_TYPE_NOTHING)  
....................     { 
....................         bRetVal = 1; 
....................     } 
....................      
....................     return bRetVal; 
.................... } 
....................  
.................... // function for set mode as WakeUp 
.................... void SetModeHome(void) 
.................... { 
....................     g_boardModeTypePre  = g_boardModeType; 
....................     g_boardModeType     = BOARD_MODE_TYPE_HOME; 
.................... } 
....................  
.................... // function for check mode is WakeUp or not 
.................... int8 IsModeHome(void) 
.................... { 
....................     int8 bRetVal = 0; 
....................      
....................     if(g_boardModeType == BOARD_MODE_TYPE_HOME)  
....................     { 
....................         bRetVal = 1; 
....................     } 
....................      
....................     return bRetVal; 
.................... } 
....................  
.................... // function for set mode as manual 
.................... void SetModeCalibration(void) 
.................... { 
....................     g_boardModeTypePre  = g_boardModeType; 
....................     g_boardModeType     = BOARD_MODE_TYPE_CALIBRATION; 
.................... } 
....................  
.................... // function for check mode is manual or not 
.................... int8 IsCalibrationMode(void) 
.................... { 
....................     int8 bRetVal = 0; 
....................      
....................     if(g_boardModeType == BOARD_MODE_TYPE_CALIBRATION)  
....................     { 
....................         bRetVal = 1; 
....................     } 
....................      
....................     return bRetVal; 
.................... } 
....................  
.................... // function for set mode as pre production 
.................... void SetModePreProduction() 
.................... { 
....................     g_boardModeTypePre  = g_boardModeType; 
....................     g_boardModeType     = BOARD_MODE_TYPE_PRE_PRODUCTION; 
.................... } 
....................  
.................... // function for check mode is pre production or not 
.................... int8 IsPreProductionMode(void) 
.................... { 
....................     int8 bRetVal = 0; 
....................      
....................     if(g_boardModeType == BOARD_MODE_TYPE_PRE_PRODUCTION)  
....................     { 
....................         bRetVal = 1; 
....................     } 
....................      
....................     return bRetVal; 
.................... } 
....................  
.................... // function for set mode as production 
.................... void SetModeProduction() 
.................... { 
....................     g_boardModeTypePre  = g_boardModeType; 
....................     g_boardModeType     = BOARD_MODE_TYPE_PRODUCTION; 
.................... } 
....................  
.................... // function for check mode is production or not 
.................... int8 IsProductionMode(void) 
.................... { 
....................     int8 bRetVal = 0; 
....................      
....................     if(g_boardModeType == BOARD_MODE_TYPE_PRODUCTION)  
....................     { 
....................         bRetVal = 1; 
....................     } 
....................      
....................     return bRetVal; 
.................... } 
....................  
.................... //// function for set mode as post production 
.................... //void SetModePostProduction() 
.................... //{ 
.................... //    g_boardModeTypePre  = g_boardModeType; 
.................... //    g_boardModeType     = BOARD_MODE_TYPE_POST_PRODUCTION; 
.................... //} 
.................... // 
.................... //// function for check mode is post production or not 
.................... //int8 IsPostProductionMode(void) 
.................... //{ 
.................... //    int8 bRetVal = 0; 
.................... //     
.................... //    if(g_boardModeType == BOARD_MODE_TYPE_POST_PRODUCTION)  
.................... //    { 
.................... //        bRetVal = 1; 
.................... //    } 
.................... //     
.................... //    return bRetVal; 
.................... //} 
....................  
.................... // function for set mode as configuration 
.................... void SetModeConfiguration(void) 
.................... { 
....................     g_boardModeTypePre  = g_boardModeType; 
....................     g_boardModeType     = BOARD_MODE_TYPE_CONFIGURATION; 
.................... } 
....................  
.................... // function for check mode is configuration or not 
.................... int8 IsConfigurationMode(void) 
.................... { 
....................     int8 bRetVal = 0; 
....................      
....................     if(g_boardModeType == BOARD_MODE_TYPE_CONFIGURATION)  
....................     { 
....................         bRetVal = 1; 
....................     } 
....................      
....................     return bRetVal; 
.................... } 
....................  
.................... #endif /* _VM_IBC_GOBAL_H_ */ 
....................  
....................  
.................... #define IBC_MSG_BYTE_COUNT                       5 
.................... #define IBC_DATA_BITS_LENGTH                     10 
.................... #define IBC_DATA_BYTES_LENGTH                    10 
.................... #define IBC_BOARD_ID                             1 
....................  
.................... #define IBC_BAUD_RATE_9600                       20 
.................... #define IBC_BAUD_RATE_19200                      21 
....................  
.................... #define T1_DIV_PRESCALE                          T1_DIV_BY_8 
.................... #define T3_DIV_PRESCALE                          T3_DIV_BY_8 
....................  
.................... #define IBC_TX_1_BT_LOAD_VALUE_9600              (0xFFFF - 0x0041 + 1) 
.................... #define IBC_TX_1_BT_LOAD_VALUE_19200             (0xFFFF - 0x0021 + 1) 
....................  
.................... #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL_9600       (0xFFFF - 0x0062 + 1) // For 9600 
.................... #define IBC_RX_BIT_TIME_T1LOAD_VAL_9600           (0xFFFF - 0x0041 + 1) // For 9600 
....................  
.................... #ifdef M1_COMM_MODULE 
....................     #define IBC_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)  // 78us Instead of 104us we load 91.2 for per bit time. 
.................... #else 
....................     #define IBC_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)//   IBC_RX_BIT_TIME_T1LOAD_VAL_9600  // 104 us 
.................... #endif 
.................... //#define IBC_RX_1_BT_CUSTOMISED_VAL_9600           (0xFFFF - 0x0031 + 1)  // Instead of 104us we load 78 us for per bit time. 
.................... #define IBC_RX_BIT_TIME_1_2_T1LOAD_VAL_9600       (0xFFFF - 0x004E + 1) 
.................... #define IBC_RX_BIT_TIME_1_3_T1LOAD_VAL_9600       (0xFFFF - 0x0051 + 1) 
.................... #define IBC_RX_BIT_TIME_1_4_T1LOAD_VAL_9600       (0xFFFF - 0x005B + 1) 
....................  
....................  
.................... #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL_19200     (0xFFFF - 0x0031 + 1) // For 19200 
.................... #define IBC_RX_BIT_TIME_T1LOAD_VAL_19200         (0xFFFF - 0x0041 + 1) // For 19200 
....................  
.................... #define SIZE_IBC_SEND_BYTE_SEGMENT                15  //1+3+8+3, 1 Start Bit, 3 Sequence Bits, 8 bits of Data and 3 Stop Bits; Total 15bits in one segment/ custised byte 
....................  
.................... #define IBC_TIMER_0_CRITICAL_ON                   0 
.................... #define IBC_TIMER_0_CRITICAL_OFF                  1 
....................  
.................... //***************************************************************************** 
.................... // Below -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
.................... typedef struct _ST_INT_BOARD_ALL_BITS 
.................... { 
....................     unsigned int8 m_ui1IBCRcvbit_0: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_1: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_2: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_3: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_4: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_5: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_6: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_7: 1; 
.................... } ST_INT_BOARD_ALL_BITS; 
....................  
.................... //typedef union _UN_INT_BOARD_BYTE_TYPE 
.................... //{ 
.................... //    unsigned int8          m_ui8Byte; 
.................... //    ST_INT_BOARD_ALL_BITS  m_stByte; 
.................... //    char				   m_chData;	 
.................... //} UN_INT_BOARD_BYTE_TYPE; 
....................  
.................... typedef struct _ST_INT_BOARD_DATA 
.................... { 
....................     char 			m_boardData[IBC_DATA_BITS_LENGTH]; 
....................     unsigned int8  	m_boardID; 
.................... } ST_INT_BOARD_DATA; 
....................  
....................  
.................... //***************************************************************************** 
.................... // Above -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Interboard Communication  RX #  From M1_COMM ********************** 
.................... //***************************************************************************** 
....................  
.................... // Below -> Multiple Baud Rate Settings. 
....................  
.................... #ifdef IBC_BOUD_RATE_1000 
....................     #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL   (0xFFFF - 0x0EA6 + 1) 
....................     #define IBC_RX_BIT_TIME_T1LOAD_VAL       (0xFFFF - 0x09C4 + 1) 
.................... #endif 
....................  
.................... #ifdef IBC_BOUD_RATE_9600 
....................     #define IBC_RX_TIME_DELAY_1_5_BIT           156  
....................     #define IBC_RX_TIME_DELAY_1_BIT             104 
....................     #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL   (0xFFFF - 0x0062 + 1) 
....................     #define IBC_RX_BIT_TIME_T1LOAD_VAL       (0xFFFF - 0x0041 + 1) 
.................... #endif 
....................  
.................... #ifdef IBC_BOUD_RATE_19200 
....................     #define IBC_RX_TIME_DELAY_1_5_VAL           78  
....................     #define IBC_RX_TIME_DELAY_1_VAL             52 
....................     #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL   (0xFFFF - 0x0031 + 1) 
....................     #define IBC_RX_BIT_TIME_T1LOAD_VAL       (0xFFFF - 0x0021 + 1) 
.................... #endif 
....................  
.................... // Above -> Multiple Baud Rate Settings. 
....................  
.................... // Initialize IBC Data Set, Should be called from main()) 
.................... //void InitIBCDataSet() 
.................... //{ 
.................... //    g_unTempRxData1.m_uiByte = 0; 
.................... //} 
....................  
.................... typedef struct _ST_IBC_RCV_BYTE_NODE 
.................... { 
....................  
....................     unsigned int8 m_ui8SeqBit0 :1; 
....................     unsigned int8 m_ui8SeqBit1 :1; 
....................     unsigned int8 m_ui8SeqBit2 :1; 
....................     unsigned int8 m_ui8Padding :5; 
....................      
....................     unsigned int8 m_ui8DataBit0 :1; 
....................     unsigned int8 m_ui8DataBit1 :1; 
....................     unsigned int8 m_ui8DataBit2 :1; 
....................     unsigned int8 m_ui8DataBit3 :1; 
....................     unsigned int8 m_ui8DataBit4 :1; 
....................     unsigned int8 m_ui8DataBit5 :1; 
....................     unsigned int8 m_ui8DataBit6 :1; 
....................     unsigned int8 m_ui8DataBit7 :1; 
.................... } ST_IBC_RCV_BYTE_NODE; 
....................  
.................... typedef union _UN_IBC_RCV_BYTE_NODE 
.................... { 
....................     ST_IBC_RCV_BYTE_NODE m_stIBCNode; 
....................     unsigned int8        m_ui8Arr[2]; 
.................... } UN_IBC_RCV_BYTE_NODE; 
....................  
....................  
....................  
.................... typedef struct _ST_IBC_DATA_NODE 
.................... { 
....................     unsigned int8 g_ui8ArrIBCData[IBC_MSG_BYTE_COUNT]; 
.................... } ST_IBC_DATA_NODE; 
....................  
.................... #define SIZE_IBC_DATA_SEND_QUEUE 15 
....................  
.................... //typedef struct _ST_IBC_DATA_SEND_QUEUE 
.................... //{ 
.................... //    ST_IBC_DATA_NODE m_stArrIBCDataNode[SIZE_IBC_DATA_SEND_QUEUE]; 
.................... //    int8             m_i8Front; 
.................... //    int8             m_i8Rear; 
.................... //} ST_IBC_DATA_SEND_QUEUE; 
....................  
.................... typedef struct _ST_IBC_MSG_QUEUE 
.................... { 
....................     ST_IBC_DATA_NODE m_stArrIBCDataNode[SIZE_IBC_DATA_SEND_QUEUE]; 
....................     int8             m_i8Front; 
....................     int8             m_i8Rear; 
.................... } ST_IBC_MSG_QUEUE; 
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... //UN_INT_BOARD_BYTE_TYPE    g_unIBCRcvData; 
.................... unsigned int8             g_ui8IBCRcvBitCount = 0; 
.................... unsigned int8             g_ui8IBCTxBitCount  = 0; 
....................  
.................... // TESTING 
.................... unsigned int8             g_ui8IBCDataToSend = 0xA5; 
.................... unsigned int8             g_fIBCCommStatus   = 0; 
....................  
.................... ST_IBC_DATA_NODE          g_stIBCRcvData; 
.................... ST_IBC_DATA_NODE          g_stIBCSendData; 
.................... unsigned int8             g_ui8ArrSendSingleMSG[IBC_MSG_BYTE_COUNT*(SIZE_IBC_SEND_BYTE_SEGMENT)] = {0}; // 
.................... unsigned int8             g_fIBCDataReceived = 0; 
....................  
.................... //ST_IBC_DATA_SEND_QUEUE    g_stIBCDataSendQueue; 
.................... unsigned int8             g_fIBCSendBusy = 0; 
.................... UN_IBC_RCV_BYTE_NODE      g_unIBCRcvByteNode; 
....................  
.................... ST_IBC_MSG_QUEUE          g_stIBCSendQueue; 
.................... ST_IBC_MSG_QUEUE          g_stIBCRcvQueue; 
....................  
.................... unsigned int8             g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... ////////// 
.................... //////////void InitializeDataSendQueue() 
.................... //////////{ 
.................... //////////    int iLoopCount1 = 0; 
.................... //////////    int iLoopCount2 = 0; 
.................... //////////    g_stIBCDataSendQueue.m_i8Front = g_stIBCDataSendQueue.m_i8Rear = -1; 
.................... //////////     
.................... //////////    for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBC_DATA_SEND_QUEUE; iLoopCount1++) 
.................... //////////    { 
.................... //////////        for (iLoopCount2 = 0; iLoopCount2 < IBC_MSG_BYTE_COUNT; iLoopCount2++) 
.................... //////////        { 
.................... //////////           g_stIBCDataSendQueue.m_stArrIBCDataNode[iLoopCount1].g_ui8ArrIBCData[iLoopCount2] = 0; 
.................... //////////        } 
.................... //////////    } 
.................... //////////} 
.................... ////////// 
.................... //////////void CopySendData(int8 i8Location, ST_IBC_DATA_NODE* pstIBCData) 
.................... //////////{ 
.................... //////////    int8 i8LoopCount = 0; 
.................... //////////     
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        g_stIBCDataSendQueue.m_stArrIBCDataNode[i8Location].g_ui8ArrIBCData[i8LoopCount] = pstIBCData->g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////    } 
.................... //////////} 
.................... ////////// 
.................... //////////void CopyFromSendQueue(int8 i8Location, ST_IBC_DATA_NODE** ppstIBCData) 
.................... //////////{ 
.................... //////////    int8 i8LoopCount = 0; 
.................... //////////     
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        *ppstIBCData->g_ui8ArrIBCData[i8LoopCount] = g_stIBCDataSendQueue.m_stArrIBCDataNode[i8Location].g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////    } 
.................... //////////} 
.................... /* Function to create Circular queue */ 
.................... //////////void InsertSendQueue(ST_IBC_DATA_NODE* pstIBCData)  
.................... //////////{ 
.................... //////////    if (!pstIBCData) 
.................... //////////    { 
.................... //////////        return; 
.................... //////////    } 
.................... //////////     
.................... //////////    if ((g_stIBCDataSendQueue.m_i8Front == 0 && g_stIBCDataSendQueue.m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1) ||  
.................... //////////            (g_stIBCDataSendQueue.m_i8Front == g_stIBCDataSendQueue.m_i8Rear + 1))  
.................... //////////    {  
.................... //////////        //printf("\nQueue is Full");  
.................... //////////        return;  
.................... //////////    } 
.................... //////////   
.................... //////////    else if (g_stIBCDataSendQueue.m_i8Front == -1) /* Insert First Element */ 
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Front = g_stIBCDataSendQueue.m_i8Rear = 0; 
.................... //////////         
.................... //////////        // Insert Data 
.................... //////////        //arr[g_stIBCDataSendQueue.m_i8Rear] = value; 
.................... //////////        CopySendData(g_stIBCDataSendQueue.m_i8Rear, pstIBCData); 
.................... //////////    }  
.................... //////////   
.................... //////////    else if (g_stIBCDataSendQueue.m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1 && g_stIBCDataSendQueue.m_i8Front != 0)  
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Rear = 0;  
.................... //////////        CopySendData(g_stIBCDataSendQueue.m_i8Rear, pstIBCData);  
.................... //////////    }  
.................... //////////   
.................... //////////    else 
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Rear++;  
.................... //////////        CopySendData(g_stIBCDataSendQueue.m_i8Rear, pstIBCData); 
.................... //////////    }  
.................... //////////}  
....................  
.................... //////////void DeleteQueue(ST_IBC_DATA_NODE* pstIBCData)  
.................... //////////{  
.................... //////////    int8 i8LoopCount = 0; 
.................... ////////// 
.................... //////////    if (g_stIBCDataSendQueue.m_i8Front == -1) 
.................... //////////    {  
.................... //////////        //printf("\nQueue is Empty");  
.................... //////////        return;  
.................... //////////    }  
.................... //////////   
.................... //////////    //int data = arr[g_stIBCDataSendQueue.m_i8Front]; 
.................... //////////    //CopyFromSendQueue(g_stIBCDataSendQueue.m_i8Front, &pstIBCData); 
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        pstIBCData->g_ui8ArrIBCData[i8LoopCount] = g_stIBCDataSendQueue.m_stArrIBCDataNode[g_stIBCDataSendQueue.m_i8Front].g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////    } 
.................... //////////     
.................... //////////    //arr[g_stIBCDataSendQueue.m_i8Front] = -1;  
.................... //////////    if (g_stIBCDataSendQueue.m_i8Front == g_stIBCDataSendQueue.m_i8Rear)  
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Front = -1;  
.................... //////////        g_stIBCDataSendQueue.m_i8Rear = -1;  
.................... //////////    }  
.................... //////////    else if (g_stIBCDataSendQueue.m_i8Front == SIZE_IBC_DATA_SEND_QUEUE-1)  
.................... //////////        g_stIBCDataSendQueue.m_i8Front = 0;  
.................... //////////    else 
.................... //////////        g_stIBCDataSendQueue.m_i8Front++;  
.................... //////////   
.................... //////////    return; 
.................... //////////}  
.................... ////////// 
.................... //////////int8 IsMSGAvailableInIBCSendQueue() 
.................... //////////{ 
.................... //////////    if (g_stIBCDataSendQueue.m_i8Front == -1) 
.................... //////////    { 
.................... //////////        return 0; 
.................... //////////    } 
.................... //////////     
.................... //////////    return 1; 
.................... //////////} 
.................... ////////// 
.................... //////////void SendIBCMSG() 
.................... //////////{ 
.................... //////////    int8          i8LoopCount    = 0; 
.................... //////////    unsigned int8 ui8Sequence    = 0; 
.................... //////////    unsigned int8 ui8TempData    = 0; 
.................... //////////     
.................... //////////    // Initialize the Send Array 
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount] = 0; 
.................... //////////    } 
.................... ////////// 
.................... //////////    // Get Node from Queue 
.................... //////////    DeleteQueue(&g_stIBCSendData); 
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        // Step 1: First Stuff 1 Start Bit 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 0] = 0;   // Start Bit Always 0 
.................... //////////         
.................... //////////        // Step 2: Now Stuff 3 bit Message Byte Sequence Number 
.................... //////////         
.................... //////////        // Stuff the 1st Sequence Bit 
.................... //////////        ui8Sequence = i8LoopCount; 
.................... //////////        ui8Sequence = ui8Sequence << 7; 
.................... //////////        ui8Sequence = ui8Sequence >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 1] = ui8Sequence; 
.................... //////////         
.................... //////////        // Stuff the 2nd Sequence Bit  
.................... //////////        ui8Sequence = i8LoopCount; 
.................... //////////        ui8Sequence = ui8Sequence << 6; 
.................... //////////        ui8Sequence = ui8Sequence >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 2] = ui8Sequence; 
.................... //////////         
.................... //////////        // Stuff the 3rd Bit 
.................... //////////        ui8Sequence = i8LoopCount; 
.................... //////////        ui8Sequence = ui8Sequence << 5; 
.................... //////////        ui8Sequence = ui8Sequence >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 3] = ui8Sequence; 
.................... //////////         
.................... //////////        // Step 3: Now Stuff 8 bit Data 
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 7; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 4] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 6; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 5] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 5; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 6] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 4; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 7] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 3; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 8] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 2; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 9] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 1; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 10] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 11] = ui8TempData; 
.................... //////////         
.................... //////////        // Step 4: Stuff three Stop Bits 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 12] = 1;  // Stop bit is 1 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 13] = 1; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 14] = 1; 
.................... //////////    } 
.................... //////////     
.................... //////////    // So message stuffing is done now start the send timer 
.................... //////////    // Initialize send counter. 
.................... //////////    g_ui8IBCTxBitCount = 0; 
.................... //////////     
.................... //////////    // TESTING Start 
.................... ////////////    g_ui8ArrSendSingleMSG[0] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[1] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[2] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[3] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[4] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[5] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[6] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[7] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[8] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[9] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[10] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[11] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[12] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[13] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[14] = 1;     
.................... //////////    // TESTING End 
.................... //////////     
.................... //////////    // Start Timer3 that handle bit by bit sending. 
.................... //////////    // Set Timer3 as per Bit Time Value. 
.................... //////////    setup_timer_3(T3_INTERNAL | T3_DIV_PRESCALE); 
.................... //////////    set_timer3(IBC_TX_1_BT_LOAD_VALUE_9600); 
.................... //////////     
.................... //////////    clear_interrupt(INT_TIMER3); 
.................... //////////    enable_interrupts(INT_TIMER3); 
.................... //////////} 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving START /////////////// 
....................  
.................... void InitializeDataQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue) 
*
00CA4:  MOVLB  B
00CA6:  CLRF   x14
00CA8:  CLRF   x15
.................... { 
....................     int iLoopCount1 = 0; 
....................     int iLoopCount2 = 0; 
....................     pstIBCMSGQueue->m_i8Front = pstIBCMSGQueue->m_i8Rear = -1; 
00CAA:  MOVLW  4B
00CAC:  ADDWF  x12,W
00CAE:  MOVWF  01
00CB0:  MOVLW  00
00CB2:  ADDWFC x13,W
00CB4:  MOVWF  03
00CB6:  MOVLW  4C
00CB8:  ADDWF  x12,W
00CBA:  MOVWF  FE9
00CBC:  MOVLW  00
00CBE:  ADDWFC x13,W
00CC0:  MOVWF  FEA
00CC2:  SETF   FEF
00CC4:  MOVLW  FF
00CC6:  MOVFF  03,FEA
00CCA:  MOVFF  01,FE9
00CCE:  MOVWF  FEF
....................      
....................     for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBC_DATA_SEND_QUEUE; iLoopCount1++) 
00CD0:  CLRF   x14
00CD2:  MOVF   x14,W
00CD4:  SUBLW  0E
00CD6:  BTFSS  FD8.0
00CD8:  GOTO   0D26
....................     { 
....................         for (iLoopCount2 = 0; iLoopCount2 < IBC_MSG_BYTE_COUNT; iLoopCount2++) 
00CDC:  CLRF   x15
00CDE:  MOVF   x15,W
00CE0:  SUBLW  04
00CE2:  BTFSS  FD8.0
00CE4:  GOTO   0D20
....................         { 
....................            pstIBCMSGQueue->m_stArrIBCDataNode[iLoopCount1].g_ui8ArrIBCData[iLoopCount2] = 0; 
00CE8:  CLRF   x4F
00CEA:  MOVFF  B14,B4E
00CEE:  CLRF   x51
00CF0:  MOVLW  05
00CF2:  MOVWF  x50
00CF4:  MOVLB  0
00CF6:  CALL   0B2A
00CFA:  MOVFF  01,B16
00CFE:  MOVLB  B
00D00:  MOVF   x15,W
00D02:  ADDWF  01,W
00D04:  MOVWF  01
00D06:  MOVLW  00
00D08:  ADDWFC 02,W
00D0A:  MOVWF  03
00D0C:  MOVF   01,W
00D0E:  ADDWF  x12,W
00D10:  MOVWF  FE9
00D12:  MOVF   x13,W
00D14:  ADDWFC 03,W
00D16:  MOVWF  FEA
00D18:  CLRF   FEF
00D1A:  INCF   x15,F
00D1C:  GOTO   0CDE
....................         } 
00D20:  INCF   x14,F
00D22:  GOTO   0CD2
....................     } 
00D26:  MOVLB  0
00D28:  RETURN 0
.................... } 
....................  
.................... void CopyIBCMsg(ST_IBC_DATA_NODE* pstIBCSource, ST_IBC_DATA_NODE* pstIBCDDest) 
*
00E1A:  MOVLB  B
00E1C:  CLRF   x52
.................... { 
....................     int8 i8LoopCount = 0; 
....................      
....................     for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
00E1E:  CLRF   x52
00E20:  MOVF   x52,W
00E22:  SUBLW  04
00E24:  BTFSS  FD8.0
00E26:  GOTO   0E58
....................     { 
....................         pstIBCDDest->g_ui8ArrIBCData[i8LoopCount] = pstIBCSource->g_ui8ArrIBCData[i8LoopCount]; 
00E2A:  MOVF   x52,W
00E2C:  ADDWF  x50,W
00E2E:  MOVWF  01
00E30:  MOVLW  00
00E32:  ADDWFC x51,W
00E34:  MOVWF  03
00E36:  MOVF   x52,W
00E38:  ADDWF  x4E,W
00E3A:  MOVWF  FE9
00E3C:  MOVLW  00
00E3E:  ADDWFC x4F,W
00E40:  MOVWF  FEA
00E42:  MOVFF  FEF,B55
00E46:  MOVFF  03,FEA
00E4A:  MOVFF  01,FE9
00E4E:  MOVFF  B55,FEF
00E52:  INCF   x52,F
00E54:  GOTO   0E20
....................     } 
00E58:  MOVLB  0
00E5A:  RETURN 0
.................... } 
....................  
.................... /* Function to create Circular queue */ 
.................... void InsertIBCMsgQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue, ST_IBC_DATA_NODE* pstIBCData)  
.................... { 
....................     if (!pstIBCData) 
00E5C:  MOVLB  B
00E5E:  MOVF   x4A,W
00E60:  IORWF  x4B,W
00E62:  BTFSS  FD8.2
00E64:  GOTO   0E6C
....................     { 
....................         return; 
00E68:  GOTO   104C
....................     } 
....................      
....................     if ((pstIBCMSGQueue->m_i8Front == 0 && pstIBCMSGQueue->m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1) ||  
....................             (pstIBCMSGQueue->m_i8Rear == (pstIBCMSGQueue->m_i8Front-1)%(SIZE_IBC_DATA_SEND_QUEUE-1)))  
00E6C:  MOVLW  4B
00E6E:  ADDWF  x48,W
00E70:  MOVWF  FE9
00E72:  MOVLW  00
00E74:  ADDWFC x49,W
00E76:  MOVWF  FEA
00E78:  MOVF   FEF,F
00E7A:  BTFSS  FD8.2
00E7C:  GOTO   0E96
00E80:  MOVLW  4C
00E82:  ADDWF  x48,W
00E84:  MOVWF  FE9
00E86:  MOVLW  00
00E88:  ADDWFC x49,W
00E8A:  MOVWF  FEA
00E8C:  MOVF   FEF,W
00E8E:  SUBLW  0E
00E90:  BTFSC  FD8.2
00E92:  GOTO   0ED0
00E96:  MOVLW  4C
00E98:  ADDWF  x48,W
00E9A:  MOVWF  FE9
00E9C:  MOVLW  00
00E9E:  ADDWFC x49,W
00EA0:  MOVWF  FEA
00EA2:  MOVFF  FEF,B4C
00EA6:  MOVLW  4B
00EA8:  ADDWF  x48,W
00EAA:  MOVWF  FE9
00EAC:  MOVLW  00
00EAE:  ADDWFC x49,W
00EB0:  MOVWF  FEA
00EB2:  MOVLW  01
00EB4:  SUBWF  FEF,W
00EB6:  MOVWF  x4E
00EB8:  MOVWF  x51
00EBA:  MOVLW  0E
00EBC:  MOVWF  x52
00EBE:  MOVLB  0
00EC0:  CALL   0DE6
00EC4:  MOVF   00,W
00EC6:  MOVLB  B
00EC8:  SUBWF  x4C,W
00ECA:  BTFSS  FD8.2
00ECC:  GOTO   0ED8
....................     {  
....................         //printf("\nQueue is Full");  
....................         return; 
00ED0:  GOTO   104C
....................     } 
00ED4:  GOTO   104C
....................    
....................     else if (pstIBCMSGQueue->m_i8Front == -1) /* Insert First Element */ 
00ED8:  MOVLW  4B
00EDA:  ADDWF  x48,W
00EDC:  MOVWF  FE9
00EDE:  MOVLW  00
00EE0:  ADDWFC x49,W
00EE2:  MOVWF  FEA
00EE4:  MOVF   FEF,W
00EE6:  SUBLW  FF
00EE8:  BTFSS  FD8.2
00EEA:  GOTO   0F66
....................     {  
....................         pstIBCMSGQueue->m_i8Front = pstIBCMSGQueue->m_i8Rear = 0; 
00EEE:  MOVLW  4B
00EF0:  ADDWF  x48,W
00EF2:  MOVWF  01
00EF4:  MOVLW  00
00EF6:  ADDWFC x49,W
00EF8:  MOVWF  03
00EFA:  MOVLW  4C
00EFC:  ADDWF  x48,W
00EFE:  MOVWF  FE9
00F00:  MOVLW  00
00F02:  ADDWFC x49,W
00F04:  MOVWF  FEA
00F06:  CLRF   FEF
00F08:  MOVLW  00
00F0A:  MOVFF  03,FEA
00F0E:  MOVFF  01,FE9
00F12:  MOVWF  FEF
....................          
....................         // Insert Data 
....................         //arr[g_stIBCDataSendQueue.m_i8Rear] = value; 
....................         CopyIBCMsg(pstIBCData, &(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Rear])); 
00F14:  MOVLW  4C
00F16:  ADDWF  x48,W
00F18:  MOVWF  FE9
00F1A:  MOVLW  00
00F1C:  ADDWFC x49,W
00F1E:  MOVWF  FEA
00F20:  CLRF   x4F
00F22:  MOVFF  FEF,B4E
00F26:  CLRF   x51
00F28:  MOVLW  05
00F2A:  MOVWF  x50
00F2C:  MOVLB  0
00F2E:  CALL   0B2A
00F32:  MOVFF  02,03
00F36:  MOVF   01,W
00F38:  MOVLB  B
00F3A:  ADDWF  x48,W
00F3C:  MOVWF  01
00F3E:  MOVF   x49,W
00F40:  ADDWFC 03,F
00F42:  MOVFF  01,B4C
00F46:  MOVFF  03,B4D
00F4A:  MOVFF  B4B,B4F
00F4E:  MOVFF  B4A,B4E
00F52:  MOVFF  03,B51
00F56:  MOVFF  01,B50
00F5A:  MOVLB  0
00F5C:  CALL   0E1A
....................     }  
00F60:  GOTO   104A
00F64:  MOVLB  B
....................    
....................     else if (pstIBCMSGQueue->m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1 && pstIBCMSGQueue->m_i8Front != 0)  
00F66:  MOVLW  4C
00F68:  ADDWF  x48,W
00F6A:  MOVWF  FE9
00F6C:  MOVLW  00
00F6E:  ADDWFC x49,W
00F70:  MOVWF  FEA
00F72:  MOVF   FEF,W
00F74:  SUBLW  0E
00F76:  BTFSS  FD8.2
00F78:  GOTO   0FF0
00F7C:  MOVLW  4B
00F7E:  ADDWF  x48,W
00F80:  MOVWF  FE9
00F82:  MOVLW  00
00F84:  ADDWFC x49,W
00F86:  MOVWF  FEA
00F88:  MOVF   FEF,F
00F8A:  BTFSC  FD8.2
00F8C:  GOTO   0FF0
....................     {  
....................         pstIBCMSGQueue->m_i8Rear = 0;  
00F90:  MOVLW  4C
00F92:  ADDWF  x48,W
00F94:  MOVWF  FE9
00F96:  MOVLW  00
00F98:  ADDWFC x49,W
00F9A:  MOVWF  FEA
00F9C:  CLRF   FEF
....................         CopyIBCMsg(pstIBCData, &(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Rear])); 
00F9E:  MOVLW  4C
00FA0:  ADDWF  x48,W
00FA2:  MOVWF  FE9
00FA4:  MOVLW  00
00FA6:  ADDWFC x49,W
00FA8:  MOVWF  FEA
00FAA:  CLRF   x4F
00FAC:  MOVFF  FEF,B4E
00FB0:  CLRF   x51
00FB2:  MOVLW  05
00FB4:  MOVWF  x50
00FB6:  MOVLB  0
00FB8:  CALL   0B2A
00FBC:  MOVFF  02,03
00FC0:  MOVF   01,W
00FC2:  MOVLB  B
00FC4:  ADDWF  x48,W
00FC6:  MOVWF  01
00FC8:  MOVF   x49,W
00FCA:  ADDWFC 03,F
00FCC:  MOVFF  01,B4C
00FD0:  MOVFF  03,B4D
00FD4:  MOVFF  B4B,B4F
00FD8:  MOVFF  B4A,B4E
00FDC:  MOVFF  03,B51
00FE0:  MOVFF  01,B50
00FE4:  MOVLB  0
00FE6:  CALL   0E1A
....................     }  
00FEA:  GOTO   104A
00FEE:  MOVLB  B
....................    
....................     else 
....................     {  
....................         pstIBCMSGQueue->m_i8Rear++;  
00FF0:  MOVLW  4C
00FF2:  ADDWF  x48,W
00FF4:  MOVWF  FE9
00FF6:  MOVLW  00
00FF8:  ADDWFC x49,W
00FFA:  MOVWF  FEA
00FFC:  INCF   FEF,F
....................         CopyIBCMsg(pstIBCData, &(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Rear])); 
00FFE:  MOVLW  4C
01000:  ADDWF  x48,W
01002:  MOVWF  FE9
01004:  MOVLW  00
01006:  ADDWFC x49,W
01008:  MOVWF  FEA
0100A:  CLRF   x4F
0100C:  MOVFF  FEF,B4E
01010:  CLRF   x51
01012:  MOVLW  05
01014:  MOVWF  x50
01016:  MOVLB  0
01018:  CALL   0B2A
0101C:  MOVFF  02,03
01020:  MOVF   01,W
01022:  MOVLB  B
01024:  ADDWF  x48,W
01026:  MOVWF  01
01028:  MOVF   x49,W
0102A:  ADDWFC 03,F
0102C:  MOVFF  01,B4C
01030:  MOVFF  03,B4D
01034:  MOVFF  B4B,B4F
01038:  MOVFF  B4A,B4E
0103C:  MOVFF  03,B51
01040:  MOVFF  01,B50
01044:  MOVLB  0
01046:  CALL   0E1A
0104A:  MOVLB  B
....................     }  
0104C:  MOVLB  0
0104E:  RETURN 0
.................... }  
....................  
.................... void DeleteIBCMsgQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue, ST_IBC_DATA_NODE* pstIBCData)  
.................... { 
....................     if (pstIBCMSGQueue->m_i8Front == -1) 
*
01084:  MOVLW  4B
01086:  MOVLB  B
01088:  ADDWF  x1D,W
0108A:  MOVWF  FE9
0108C:  MOVLW  00
0108E:  ADDWFC x1E,W
01090:  MOVWF  FEA
01092:  MOVF   FEF,W
01094:  SUBLW  FF
01096:  BTFSS  FD8.2
01098:  GOTO   10A0
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
0109C:  GOTO   116A
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBCMsg(&(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Front]), pstIBCData); 
010A0:  MOVLW  4B
010A2:  ADDWF  x1D,W
010A4:  MOVWF  FE9
010A6:  MOVLW  00
010A8:  ADDWFC x1E,W
010AA:  MOVWF  FEA
010AC:  CLRF   x4F
010AE:  MOVFF  FEF,B4E
010B2:  CLRF   x51
010B4:  MOVLW  05
010B6:  MOVWF  x50
010B8:  MOVLB  0
010BA:  CALL   0B2A
010BE:  MOVFF  02,03
010C2:  MOVF   01,W
010C4:  MOVLB  B
010C6:  ADDWF  x1D,W
010C8:  MOVWF  01
010CA:  MOVF   x1E,W
010CC:  ADDWFC 03,F
010CE:  MOVFF  01,B21
010D2:  MOVFF  03,B22
010D6:  MOVFF  03,B4F
010DA:  MOVFF  01,B4E
010DE:  MOVFF  B20,B51
010E2:  MOVFF  B1F,B50
010E6:  MOVLB  0
010E8:  CALL   0E1A
....................  
....................     if (pstIBCMSGQueue->m_i8Front == pstIBCMSGQueue->m_i8Rear)  
010EC:  MOVLW  4B
010EE:  MOVLB  B
010F0:  ADDWF  x1D,W
010F2:  MOVWF  FE9
010F4:  MOVLW  00
010F6:  ADDWFC x1E,W
010F8:  MOVWF  FEA
010FA:  MOVFF  FEF,B21
010FE:  MOVLW  4C
01100:  ADDWF  x1D,W
01102:  MOVWF  FE9
01104:  MOVLW  00
01106:  ADDWFC x1E,W
01108:  MOVWF  FEA
0110A:  MOVF   FEF,W
0110C:  SUBWF  x21,W
0110E:  BTFSS  FD8.2
01110:  GOTO   1134
....................     {  
....................         pstIBCMSGQueue->m_i8Front = -1;  
01114:  MOVLW  4B
01116:  ADDWF  x1D,W
01118:  MOVWF  FE9
0111A:  MOVLW  00
0111C:  ADDWFC x1E,W
0111E:  MOVWF  FEA
01120:  SETF   FEF
....................         pstIBCMSGQueue->m_i8Rear = -1;  
01122:  MOVLW  4C
01124:  ADDWF  x1D,W
01126:  MOVWF  FE9
01128:  MOVLW  00
0112A:  ADDWFC x1E,W
0112C:  MOVWF  FEA
0112E:  SETF   FEF
....................     }  
01130:  GOTO   116A
....................     else if (pstIBCMSGQueue->m_i8Front == SIZE_IBC_DATA_SEND_QUEUE-1)  
01134:  MOVLW  4B
01136:  ADDWF  x1D,W
01138:  MOVWF  FE9
0113A:  MOVLW  00
0113C:  ADDWFC x1E,W
0113E:  MOVWF  FEA
01140:  MOVF   FEF,W
01142:  SUBLW  0E
01144:  BTFSS  FD8.2
01146:  GOTO   115C
....................         pstIBCMSGQueue->m_i8Front = 0;  
0114A:  MOVLW  4B
0114C:  ADDWF  x1D,W
0114E:  MOVWF  FE9
01150:  MOVLW  00
01152:  ADDWFC x1E,W
01154:  MOVWF  FEA
01156:  CLRF   FEF
01158:  GOTO   116A
....................     else 
....................         pstIBCMSGQueue->m_i8Front++;  
0115C:  MOVLW  4B
0115E:  ADDWF  x1D,W
01160:  MOVWF  FE9
01162:  MOVLW  00
01164:  ADDWFC x1E,W
01166:  MOVWF  FEA
01168:  INCF   FEF,F
....................    
....................     return; 
0116A:  MOVLB  0
0116C:  RETURN 0
.................... } 
....................  
....................  
.................... int8 IsMSGInIBCQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue) 
.................... { 
....................     if (pstIBCMSGQueue->m_i8Front == -1) 
*
0105C:  MOVLW  4B
0105E:  MOVLB  B
01060:  ADDWF  x12,W
01062:  MOVWF  FE9
01064:  MOVLW  00
01066:  ADDWFC x13,W
01068:  MOVWF  FEA
0106A:  MOVF   FEF,W
0106C:  SUBLW  FF
0106E:  BTFSS  FD8.2
01070:  GOTO   107C
....................     { 
....................         return 0; 
01074:  MOVLW  00
01076:  MOVWF  01
01078:  GOTO   1080
....................     } 
....................      
....................     return 1; 
0107C:  MOVLW  01
0107E:  MOVWF  01
01080:  MOVLB  0
01082:  RETURN 0
.................... } 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving END ///////////////// 
.................... void SendIBCMSGFromQ() 
*
0116E:  MOVLB  B
01170:  CLRF   x12
01172:  CLRF   x13
01174:  CLRF   x14
.................... { 
....................     int8          i8LoopCount    = 0; 
....................     unsigned int8 ui8Sequence    = 0; 
....................     unsigned int8 ui8TempData    = 0; 
....................  
....................     // Initialize the Send Array 
....................     for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
01176:  CLRF   x12
01178:  MOVF   x12,W
0117A:  SUBLW  04
0117C:  BTFSS  FD8.0
0117E:  GOTO   1198
....................     { 
....................         g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount] = 0; 
01182:  CLRF   03
01184:  MOVF   x12,W
01186:  ADDLW  34
01188:  MOVWF  FE9
0118A:  MOVLW  01
0118C:  ADDWFC 03,W
0118E:  MOVWF  FEA
01190:  CLRF   FEF
01192:  INCF   x12,F
01194:  GOTO   1178
....................     } 
....................  
....................     // Get Node from Queue 
....................     DeleteIBCMsgQueue(&g_stIBCSendQueue, &g_stIBCSendData); 
01198:  MOVLW  01
0119A:  MOVWF  x1E
0119C:  MOVLW  88
0119E:  MOVWF  x1D
011A0:  MOVLW  01
011A2:  MOVWF  x20
011A4:  MOVLW  34
011A6:  MOVWF  x1F
011A8:  MOVLB  0
011AA:  CALL   1084
....................     for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
011AE:  MOVLB  B
011B0:  CLRF   x12
011B2:  MOVF   x12,W
011B4:  SUBLW  04
011B6:  BTFSS  FD8.0
011B8:  GOTO   146A
....................     { 
....................         // Step 1: First Stuff 1 Start Bit 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 0] = 0;   // Start Bit Always 0 
011BC:  MOVF   x12,W
011BE:  MULLW  0F
011C0:  MOVF   FF3,W
011C2:  CLRF   03
011C4:  ADDLW  39
011C6:  MOVWF  FE9
011C8:  MOVLW  01
011CA:  ADDWFC 03,W
011CC:  MOVWF  FEA
011CE:  CLRF   FEF
....................          
....................         // Step 2: Now Stuff 3 bit Message Byte Sequence Number 
....................          
....................         // Stuff the 1st Sequence Bit 
....................         ui8Sequence = i8LoopCount; 
011D0:  MOVFF  B12,B13
....................         ui8Sequence = ui8Sequence << 7; 
011D4:  RRCF   x13,W
011D6:  CLRF   x13
011D8:  BTFSC  FD8.0
011DA:  BSF    x13.7
....................         ui8Sequence = ui8Sequence >> 7; 
011DC:  RLCF   x13,W
011DE:  CLRF   x13
011E0:  BTFSC  FD8.0
011E2:  BSF    x13.0
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 1] = ui8Sequence; 
011E4:  MOVF   x12,W
011E6:  MULLW  0F
011E8:  MOVF   FF3,W
011EA:  ADDLW  01
011EC:  CLRF   03
011EE:  ADDLW  39
011F0:  MOVWF  FE9
011F2:  MOVLW  01
011F4:  ADDWFC 03,W
011F6:  MOVWF  FEA
011F8:  MOVFF  B13,FEF
....................          
....................         // Stuff the 2nd Sequence Bit  
....................         ui8Sequence = i8LoopCount; 
011FC:  MOVFF  B12,B13
....................         ui8Sequence = ui8Sequence << 6; 
01200:  SWAPF  x13,F
01202:  RLCF   x13,F
01204:  RLCF   x13,F
01206:  MOVLW  C0
01208:  ANDWF  x13,F
....................         ui8Sequence = ui8Sequence >> 7; 
0120A:  RLCF   x13,W
0120C:  CLRF   x13
0120E:  BTFSC  FD8.0
01210:  BSF    x13.0
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 2] = ui8Sequence; 
01212:  MOVF   x12,W
01214:  MULLW  0F
01216:  MOVF   FF3,W
01218:  ADDLW  02
0121A:  CLRF   03
0121C:  ADDLW  39
0121E:  MOVWF  FE9
01220:  MOVLW  01
01222:  ADDWFC 03,W
01224:  MOVWF  FEA
01226:  MOVFF  B13,FEF
....................          
....................         // Stuff the 3rd Bit 
....................         ui8Sequence = i8LoopCount; 
0122A:  MOVFF  B12,B13
....................         ui8Sequence = ui8Sequence << 5; 
0122E:  SWAPF  x13,F
01230:  RLCF   x13,F
01232:  MOVLW  E0
01234:  ANDWF  x13,F
....................         ui8Sequence = ui8Sequence >> 7; 
01236:  RLCF   x13,W
01238:  CLRF   x13
0123A:  BTFSC  FD8.0
0123C:  BSF    x13.0
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 3] = ui8Sequence; 
0123E:  MOVF   x12,W
01240:  MULLW  0F
01242:  MOVF   FF3,W
01244:  ADDLW  03
01246:  CLRF   03
01248:  ADDLW  39
0124A:  MOVWF  FE9
0124C:  MOVLW  01
0124E:  ADDWFC 03,W
01250:  MOVWF  FEA
01252:  MOVFF  B13,FEF
....................          
....................         // Step 3: Now Stuff 8 bit Data 
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
01256:  CLRF   03
01258:  MOVF   x12,W
0125A:  ADDLW  34
0125C:  MOVWF  FE9
0125E:  MOVLW  01
01260:  ADDWFC 03,W
01262:  MOVWF  FEA
01264:  MOVFF  FEF,B14
....................         ui8TempData = ui8TempData << 7; 
01268:  RRCF   x14,W
0126A:  CLRF   x14
0126C:  BTFSC  FD8.0
0126E:  BSF    x14.7
....................         ui8TempData = ui8TempData >> 7; 
01270:  RLCF   x14,W
01272:  CLRF   x14
01274:  BTFSC  FD8.0
01276:  BSF    x14.0
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 4] = ui8TempData; 
01278:  MOVF   x12,W
0127A:  MULLW  0F
0127C:  MOVF   FF3,W
0127E:  ADDLW  04
01280:  CLRF   03
01282:  ADDLW  39
01284:  MOVWF  FE9
01286:  MOVLW  01
01288:  ADDWFC 03,W
0128A:  MOVWF  FEA
0128C:  MOVFF  B14,FEF
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
01290:  CLRF   03
01292:  MOVF   x12,W
01294:  ADDLW  34
01296:  MOVWF  FE9
01298:  MOVLW  01
0129A:  ADDWFC 03,W
0129C:  MOVWF  FEA
0129E:  MOVFF  FEF,B14
....................         ui8TempData = ui8TempData << 6; 
012A2:  SWAPF  x14,F
012A4:  RLCF   x14,F
012A6:  RLCF   x14,F
012A8:  MOVLW  C0
012AA:  ANDWF  x14,F
....................         ui8TempData = ui8TempData >> 7; 
012AC:  RLCF   x14,W
012AE:  CLRF   x14
012B0:  BTFSC  FD8.0
012B2:  BSF    x14.0
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 5] = ui8TempData; 
012B4:  MOVF   x12,W
012B6:  MULLW  0F
012B8:  MOVF   FF3,W
012BA:  ADDLW  05
012BC:  CLRF   03
012BE:  ADDLW  39
012C0:  MOVWF  FE9
012C2:  MOVLW  01
012C4:  ADDWFC 03,W
012C6:  MOVWF  FEA
012C8:  MOVFF  B14,FEF
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
012CC:  CLRF   03
012CE:  MOVF   x12,W
012D0:  ADDLW  34
012D2:  MOVWF  FE9
012D4:  MOVLW  01
012D6:  ADDWFC 03,W
012D8:  MOVWF  FEA
012DA:  MOVFF  FEF,B14
....................         ui8TempData = ui8TempData << 5; 
012DE:  SWAPF  x14,F
012E0:  RLCF   x14,F
012E2:  MOVLW  E0
012E4:  ANDWF  x14,F
....................         ui8TempData = ui8TempData >> 7; 
012E6:  RLCF   x14,W
012E8:  CLRF   x14
012EA:  BTFSC  FD8.0
012EC:  BSF    x14.0
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 6] = ui8TempData; 
012EE:  MOVF   x12,W
012F0:  MULLW  0F
012F2:  MOVF   FF3,W
012F4:  ADDLW  06
012F6:  CLRF   03
012F8:  ADDLW  39
012FA:  MOVWF  FE9
012FC:  MOVLW  01
012FE:  ADDWFC 03,W
01300:  MOVWF  FEA
01302:  MOVFF  B14,FEF
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
01306:  CLRF   03
01308:  MOVF   x12,W
0130A:  ADDLW  34
0130C:  MOVWF  FE9
0130E:  MOVLW  01
01310:  ADDWFC 03,W
01312:  MOVWF  FEA
01314:  MOVFF  FEF,B14
....................         ui8TempData = ui8TempData << 4; 
01318:  SWAPF  x14,F
0131A:  MOVLW  F0
0131C:  ANDWF  x14,F
....................         ui8TempData = ui8TempData >> 7; 
0131E:  RLCF   x14,W
01320:  CLRF   x14
01322:  BTFSC  FD8.0
01324:  BSF    x14.0
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 7] = ui8TempData; 
01326:  MOVF   x12,W
01328:  MULLW  0F
0132A:  MOVF   FF3,W
0132C:  ADDLW  07
0132E:  CLRF   03
01330:  ADDLW  39
01332:  MOVWF  FE9
01334:  MOVLW  01
01336:  ADDWFC 03,W
01338:  MOVWF  FEA
0133A:  MOVFF  B14,FEF
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
0133E:  CLRF   03
01340:  MOVF   x12,W
01342:  ADDLW  34
01344:  MOVWF  FE9
01346:  MOVLW  01
01348:  ADDWFC 03,W
0134A:  MOVWF  FEA
0134C:  MOVFF  FEF,B14
....................         ui8TempData = ui8TempData << 3; 
01350:  RLCF   x14,F
01352:  RLCF   x14,F
01354:  RLCF   x14,F
01356:  MOVLW  F8
01358:  ANDWF  x14,F
....................         ui8TempData = ui8TempData >> 7; 
0135A:  RLCF   x14,W
0135C:  CLRF   x14
0135E:  BTFSC  FD8.0
01360:  BSF    x14.0
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 8] = ui8TempData; 
01362:  MOVF   x12,W
01364:  MULLW  0F
01366:  MOVF   FF3,W
01368:  ADDLW  08
0136A:  CLRF   03
0136C:  ADDLW  39
0136E:  MOVWF  FE9
01370:  MOVLW  01
01372:  ADDWFC 03,W
01374:  MOVWF  FEA
01376:  MOVFF  B14,FEF
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
0137A:  CLRF   03
0137C:  MOVF   x12,W
0137E:  ADDLW  34
01380:  MOVWF  FE9
01382:  MOVLW  01
01384:  ADDWFC 03,W
01386:  MOVWF  FEA
01388:  MOVFF  FEF,B14
....................         ui8TempData = ui8TempData << 2; 
0138C:  RLCF   x14,F
0138E:  RLCF   x14,F
01390:  MOVLW  FC
01392:  ANDWF  x14,F
....................         ui8TempData = ui8TempData >> 7; 
01394:  RLCF   x14,W
01396:  CLRF   x14
01398:  BTFSC  FD8.0
0139A:  BSF    x14.0
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 9] = ui8TempData; 
0139C:  MOVF   x12,W
0139E:  MULLW  0F
013A0:  MOVF   FF3,W
013A2:  ADDLW  09
013A4:  CLRF   03
013A6:  ADDLW  39
013A8:  MOVWF  FE9
013AA:  MOVLW  01
013AC:  ADDWFC 03,W
013AE:  MOVWF  FEA
013B0:  MOVFF  B14,FEF
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
013B4:  CLRF   03
013B6:  MOVF   x12,W
013B8:  ADDLW  34
013BA:  MOVWF  FE9
013BC:  MOVLW  01
013BE:  ADDWFC 03,W
013C0:  MOVWF  FEA
013C2:  MOVFF  FEF,B14
....................         ui8TempData = ui8TempData << 1; 
013C6:  BCF    FD8.0
013C8:  RLCF   x14,F
....................         ui8TempData = ui8TempData >> 7; 
013CA:  RLCF   x14,W
013CC:  CLRF   x14
013CE:  BTFSC  FD8.0
013D0:  BSF    x14.0
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 10] = ui8TempData; 
013D2:  MOVF   x12,W
013D4:  MULLW  0F
013D6:  MOVF   FF3,W
013D8:  ADDLW  0A
013DA:  CLRF   03
013DC:  ADDLW  39
013DE:  MOVWF  FE9
013E0:  MOVLW  01
013E2:  ADDWFC 03,W
013E4:  MOVWF  FEA
013E6:  MOVFF  B14,FEF
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
013EA:  CLRF   03
013EC:  MOVF   x12,W
013EE:  ADDLW  34
013F0:  MOVWF  FE9
013F2:  MOVLW  01
013F4:  ADDWFC 03,W
013F6:  MOVWF  FEA
013F8:  MOVFF  FEF,B14
....................         ui8TempData = ui8TempData >> 7; 
013FC:  RLCF   x14,W
013FE:  CLRF   x14
01400:  BTFSC  FD8.0
01402:  BSF    x14.0
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 11] = ui8TempData; 
01404:  MOVF   x12,W
01406:  MULLW  0F
01408:  MOVF   FF3,W
0140A:  ADDLW  0B
0140C:  CLRF   03
0140E:  ADDLW  39
01410:  MOVWF  FE9
01412:  MOVLW  01
01414:  ADDWFC 03,W
01416:  MOVWF  FEA
01418:  MOVFF  B14,FEF
....................          
....................         // Step 4: Stuff three Stop Bits 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 12] = 1;  // Stop bit is 1 
0141C:  MOVF   x12,W
0141E:  MULLW  0F
01420:  MOVF   FF3,W
01422:  ADDLW  0C
01424:  CLRF   03
01426:  ADDLW  39
01428:  MOVWF  FE9
0142A:  MOVLW  01
0142C:  ADDWFC 03,W
0142E:  MOVWF  FEA
01430:  MOVLW  01
01432:  MOVWF  FEF
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 13] = 1; 
01434:  MOVF   x12,W
01436:  MULLW  0F
01438:  MOVF   FF3,W
0143A:  ADDLW  0D
0143C:  CLRF   03
0143E:  ADDLW  39
01440:  MOVWF  FE9
01442:  MOVLW  01
01444:  ADDWFC 03,W
01446:  MOVWF  FEA
01448:  MOVLW  01
0144A:  MOVWF  FEF
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 14] = 1; 
0144C:  MOVF   x12,W
0144E:  MULLW  0F
01450:  MOVF   FF3,W
01452:  ADDLW  0E
01454:  CLRF   03
01456:  ADDLW  39
01458:  MOVWF  FE9
0145A:  MOVLW  01
0145C:  ADDWFC 03,W
0145E:  MOVWF  FEA
01460:  MOVLW  01
01462:  MOVWF  FEF
01464:  INCF   x12,F
01466:  GOTO   11B2
....................          
.................... ////////        // TESTING Start 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 0] = 0;   
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 1] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 2] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 3] = 1;  
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 4] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 5] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 6] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 7] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 8] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 9] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 10] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 11] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 12] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 13] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 14] = 1; 
.................... ////////        // TESTING End 
....................     } 
....................      
....................      
.................... ////    // TESTING Start 
.................... ////    g_ui8ArrSendSingleMSG[0] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[1] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[2] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[3] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[4] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[5] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[6] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[7] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[8] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[9] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[10] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[11] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[12] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[13] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[14] = 1;     
.................... ////    // TESTING End 
....................          
....................     // So message stuffing is done now start the send timer 
....................     // Initialize send counter. 
....................     g_ui8IBCTxBitCount = 0; 
0146A:  MOVLB  1
0146C:  CLRF   x2C
....................      
....................     // Hold the IBC Send Lock 
....................     g_fIBCSendLockStatus = IBC_SEND_LOCK; 
0146E:  MOVLW  01
01470:  MOVLB  0
01472:  MOVWF  xB6
....................     // Start Timer3 that handle bit by bit sending. 
....................     // Set Timer3 as per Bit Time Value. 
....................     setup_timer_3(T3_INTERNAL | T3_DIV_PRESCALE); 
01474:  CLRF   FB0
01476:  MOVLW  37
01478:  MOVWF  FB1
....................     set_timer3(IBC_TX_1_BT_LOAD_VALUE_9600); 
0147A:  SETF   FB3
0147C:  MOVLW  BF
0147E:  MOVWF  FB2
....................      
....................     // Before Sending Data in IBC Run Timer0 in Time Critical. This we are doing 
....................     // just because we have seen the IBC Send Receive is affecting while Timer 0 
....................     // is executing, hence the IBC data send receive is not sampled at proper time 
....................     g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_ON; 
01480:  MOVLB  2
01482:  CLRF   x22
....................      
....................     clear_interrupt(INT_TIMER3); 
01484:  BCF    FA1.1
....................     enable_interrupts(INT_TIMER3); 
01486:  BSF    FA0.1
01488:  MOVLB  0
0148A:  GOTO   64EE (RETURN)
.................... } 
....................  
.................... void IBCProcessRcvMsg() 
.................... { 
....................     // I 
.................... } 
....................  
.................... #INT_TIMER3    // Used for IBC Send 
.................... void IBC_Tx_ISR(void) 
.................... { 
....................     // Send IBC bits 
....................     output_bit(PIN_IBC_XMIT, g_ui8ArrSendSingleMSG[g_ui8IBCTxBitCount++]); 
*
0031A:  MOVLB  1
0031C:  MOVF   x2C,W
0031E:  INCF   x2C,F
00320:  CLRF   03
00322:  ADDLW  39
00324:  MOVWF  FE9
00326:  MOVLW  01
00328:  ADDWFC 03,W
0032A:  MOVWF  FEA
0032C:  MOVF   FEF,F
0032E:  BTFSS  FD8.2
00330:  GOTO   033A
00334:  BCF    F8C.5
00336:  GOTO   033C
0033A:  BSF    F8C.5
0033C:  BCF    F95.5
....................     // Reset Timer3 at 1Bit Time value. 
....................     set_timer3(IBC_TX_1_BT_LOAD_VALUE_9600); 
0033E:  SETF   FB3
00340:  MOVLW  BF
00342:  MOVWF  FB2
....................     clear_interrupt( INT_TIMER3 ); 
00344:  BCF    FA1.1
....................  
....................     // Check if IBC Sending completed 
....................     if ((IBC_MSG_BYTE_COUNT*SIZE_IBC_SEND_BYTE_SEGMENT) == g_ui8IBCTxBitCount) 
00346:  MOVF   x2C,W
00348:  SUBLW  4B
0034A:  BTFSS  FD8.2
0034C:  GOTO   036E
....................     { 
....................         // First release Timer0 Critical run lock 
....................         g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
00350:  MOVLW  01
00352:  MOVLB  2
00354:  MOVWF  x22
....................          
....................         // Release Send Busy status 
....................         g_fIBCSendBusy     = 0; 
00356:  MOVLB  1
00358:  CLRF   x85
....................          
....................         // Send Stop bit forever 
....................         output_bit(PIN_IBC_XMIT, 1); 
0035A:  BSF    F8C.5
0035C:  BCF    F95.5
....................  
....................         // Reset Tx counter 
....................         g_ui8IBCTxBitCount = 0; 
0035E:  CLRF   x2C
....................         // Reset IBC Send checking status flag. 
....................         //g_fIBCCommStatus = 0; 
....................         // Disable Timer 
....................         setup_timer_3 (T3_DISABLED); 
00360:  CLRF   FB0
00362:  CLRF   FB1
....................         disable_interrupts(INT_TIMER3); 
00364:  BCF    FA0.1
....................         // Clear Timer1 interrupt 
....................         clear_interrupt(INT_TIMER3); 
00366:  BCF    FA1.1
....................          
....................         // Release IBC Send Lock 
....................         g_fIBCSendLockStatus = IBC_SEND_UNLOCK; 
00368:  MOVLB  0
0036A:  CLRF   xB6
0036C:  MOVLB  1
....................     } 
....................      
....................     // TESTING 
....................     //output_toggle(PIN_IN_EXT_DI_00); 
....................   
.................... } 
....................  
....................  
....................  
.................... /* 
....................     Timer1 is used to handle IBC Received bytes. 
....................  and Timer3 is used to handle IBC sent bytes. 
....................  */ 
.................... #ifdef M1_COMM_MODULE 
0036E:  BCF    FA1.1
00370:  MOVLB  0
00372:  GOTO   00AC
.................... #INT_EXT1  
.................... #else 
.................... #INT_EXT3 
.................... #endif 
.................... void IBC_Rx_ISR(void) 
.................... { 
....................    
....................     // Initialize Rx Bit Counter. 
....................    	g_ui8IBCRcvBitCount = 0; 
00376:  MOVLB  1
00378:  CLRF   x2B
....................     g_unIBCRcvByteNode.m_ui8Arr[0] = 0; 
0037A:  CLRF   x86
....................     g_unIBCRcvByteNode.m_ui8Arr[1] = 0; 
0037C:  CLRF   x87
....................    	 
....................     // Setup Timer1 at 1.5 Bit Time.                   // Here we are using DIV_BY_8. 
....................     setup_timer_1( T1_INTERNAL | T1_DIV_PRESCALE ); // CPU Ext Clock is 20MHz, 20/4 => 5MHz is Peripheral Clock 
0037E:  MOVLW  37
00380:  MOVWF  FCD
00382:  CLRF   FAA
....................                                                 // => T1_DIV_BY_2 => 5/2 = 2.5MHz => (1/2.5)us = 0.4us 
....................                                                 // To Get 1Ms quanta = (1000us/0.4) = 2500 => 0x09C4 
....................                                                 // So, The timer will start counting from (0xFFFF - 0x09C4 + 1) 
....................                                                 // To Get 1.5Ms quanta = (1500us/0.4) = 3750 => 0x0EA6 
....................                                                 // So, The timer will start counting from (0xFFFF - 0x0EA6 + 1)  
....................      
.................... #ifdef M1_COMM_MODULE 
....................     set_timer1( IBC_RX_BIT_TIME_1_4_T1LOAD_VAL_9600);  
00384:  SETF   FCF
00386:  MOVLW  A5
00388:  MOVWF  FCE
.................... #else 
....................     set_timer1( IBC_RX_BIT_TIME_1_5_T1LOAD_VAL_9600); 
.................... #endif 
....................      
....................     // Before Sending Data in IBC Run Timer0 in Time Critical. This we are doing 
....................     // just because we have seen the IBC Send Receive is affecting while Timer 0 
....................     // is executing, hence the IBC data send receive is not sampled at proper time 
....................     g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_ON; 
0038A:  MOVLB  2
0038C:  CLRF   x22
....................      
....................     clear_interrupt( INT_TIMER1 ); 
0038E:  BCF    F9E.0
....................     enable_interrupts( INT_TIMER1 ); 
00390:  BSF    F9D.0
....................      
....................     // Clear and Disable External Interrupt 1  
.................... #ifdef M1_COMM_MODULE 
....................     clear_interrupt(INT_EXT1); 
00392:  BCF    FF0.0
....................     disable_interrupts(INT_EXT1);  
00394:  BCF    FF0.3
.................... #else 
....................     clear_interrupt(INT_EXT3); 
....................     disable_interrupts(INT_EXT3); 
.................... #endif 
....................      
....................     // TESTING Start 
.................... #ifdef M1_COMM_MODULE 
....................     //output_high(PIN_IN_EXT_DI_00); 
.................... #endif 
....................     // TESTING End 
00396:  BCF    FF0.0
00398:  MOVLB  0
0039A:  GOTO   00AC
.................... } 
....................  
.................... // TESTING Start 
.................... int8 g_i8RcvByteCount = 0; 
.................... // TESTING End 
....................  
.................... #INT_TIMER1           // This is for Receive                 
.................... void IBC_Rx_Sampling_ISR(void) 
.................... {  
.................... ////////    // TESTING Start 
.................... ////////#ifdef M1_COMM_MODULE 
.................... ////////    //output_toggle(PIN_IN_EXT_DI_00); 
.................... ////////#else 
.................... ////////    output_toggle(PIN_A5); 
.................... ////////#endif 
.................... ////////    // TESTING End 
....................      
....................     // Increment Rx Bit Counter for each received bit. 
....................    	g_ui8IBCRcvBitCount++; 
0039E:  MOVLB  1
003A0:  INCF   x2B,F
.................... 	 
....................     // Check Rx Bit Counter and read Bits 
....................     switch(g_ui8IBCRcvBitCount) 
003A2:  MOVF   x2B,W
003A4:  XORLW  01
003A6:  MOVLB  0
003A8:  BTFSC  FD8.2
003AA:  GOTO   040A
003AE:  XORLW  03
003B0:  BTFSC  FD8.2
003B2:  GOTO   0420
003B6:  XORLW  01
003B8:  BTFSC  FD8.2
003BA:  GOTO   0436
003BE:  XORLW  07
003C0:  BTFSC  FD8.2
003C2:  GOTO   044C
003C6:  XORLW  01
003C8:  BTFSC  FD8.2
003CA:  GOTO   0462
003CE:  XORLW  03
003D0:  BTFSC  FD8.2
003D2:  GOTO   0478
003D6:  XORLW  01
003D8:  BTFSC  FD8.2
003DA:  GOTO   048E
003DE:  XORLW  0F
003E0:  BTFSC  FD8.2
003E2:  GOTO   04A4
003E6:  XORLW  01
003E8:  BTFSC  FD8.2
003EA:  GOTO   04BA
003EE:  XORLW  03
003F0:  BTFSC  FD8.2
003F2:  GOTO   04D0
003F6:  XORLW  01
003F8:  BTFSC  FD8.2
003FA:  GOTO   04E6
003FE:  XORLW  07
00400:  BTFSC  FD8.2
00402:  GOTO   0504
00406:  GOTO   0558
....................     { 
....................         case 1: // Sequence Bit 0  
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8SeqBit0 = input(PIN_IBC_RCV); 
0040A:  BSF    F93.1
0040C:  MOVLB  1
0040E:  BCF    x86.0
00410:  BTFSC  F81.1
00412:  BSF    x86.0
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
00414:  SETF   FCF
00416:  MOVLW  BF
00418:  MOVWF  FCE
....................             clear_interrupt( INT_TIMER1 ); 
0041A:  BCF    F9E.0
....................             break; 
0041C:  GOTO   0574
....................         case 2: // Sequence Bit 1 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8SeqBit1 = input(PIN_IBC_RCV); 
00420:  BSF    F93.1
00422:  MOVLB  1
00424:  BCF    x86.1
00426:  BTFSC  F81.1
00428:  BSF    x86.1
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
0042A:  SETF   FCF
0042C:  MOVLW  BF
0042E:  MOVWF  FCE
....................             clear_interrupt( INT_TIMER1 ); 
00430:  BCF    F9E.0
....................             break; 
00432:  GOTO   0574
....................         case 3: // Sequence Bit 2 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8SeqBit2 = input(PIN_IBC_RCV); 
00436:  BSF    F93.1
00438:  MOVLB  1
0043A:  BCF    x86.2
0043C:  BTFSC  F81.1
0043E:  BSF    x86.2
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
00440:  SETF   FCF
00442:  MOVLW  BF
00444:  MOVWF  FCE
....................             clear_interrupt( INT_TIMER1 ); 
00446:  BCF    F9E.0
....................             break; 
00448:  GOTO   0574
....................         case 4: // Data Bit Bit 0 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit0 = input(PIN_IBC_RCV); 
0044C:  BSF    F93.1
0044E:  MOVLB  1
00450:  BCF    x87.0
00452:  BTFSC  F81.1
00454:  BSF    x87.0
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
00456:  SETF   FCF
00458:  MOVLW  BF
0045A:  MOVWF  FCE
....................             clear_interrupt( INT_TIMER1 ); 
0045C:  BCF    F9E.0
....................             break; 
0045E:  GOTO   0574
....................         case 5: // Bit 4 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit1 = input(PIN_IBC_RCV); 
00462:  BSF    F93.1
00464:  MOVLB  1
00466:  BCF    x87.1
00468:  BTFSC  F81.1
0046A:  BSF    x87.1
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
0046C:  SETF   FCF
0046E:  MOVLW  BF
00470:  MOVWF  FCE
....................             clear_interrupt( INT_TIMER1 ); 
00472:  BCF    F9E.0
....................             break; 
00474:  GOTO   0574
....................         case 6: // Bit 5 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit2 = input(PIN_IBC_RCV); 
00478:  BSF    F93.1
0047A:  MOVLB  1
0047C:  BCF    x87.2
0047E:  BTFSC  F81.1
00480:  BSF    x87.2
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
00482:  SETF   FCF
00484:  MOVLW  BF
00486:  MOVWF  FCE
....................             clear_interrupt( INT_TIMER1 ); 
00488:  BCF    F9E.0
....................             break; 
0048A:  GOTO   0574
....................         case 7: // Bit 6 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit3 = input(PIN_IBC_RCV); 
0048E:  BSF    F93.1
00490:  MOVLB  1
00492:  BCF    x87.3
00494:  BTFSC  F81.1
00496:  BSF    x87.3
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
00498:  SETF   FCF
0049A:  MOVLW  BF
0049C:  MOVWF  FCE
....................             clear_interrupt( INT_TIMER1 ); 
0049E:  BCF    F9E.0
....................             break; 
004A0:  GOTO   0574
....................         case 8: // Bit 7 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit4 = input(PIN_IBC_RCV); 
004A4:  BSF    F93.1
004A6:  MOVLB  1
004A8:  BCF    x87.4
004AA:  BTFSC  F81.1
004AC:  BSF    x87.4
....................             // Setup Timer1 at 1 Bit Time. 
....................          	set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
004AE:  SETF   FCF
004B0:  MOVLW  BF
004B2:  MOVWF  FCE
....................          	clear_interrupt( INT_TIMER1 ); 
004B4:  BCF    F9E.0
....................             break; 
004B6:  GOTO   0574
....................              
....................              
....................         case 9: // Bit 8 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit5 = input(PIN_IBC_RCV); 
004BA:  BSF    F93.1
004BC:  MOVLB  1
004BE:  BCF    x87.5
004C0:  BTFSC  F81.1
004C2:  BSF    x87.5
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_1_BT_CUSTOMISED_VAL_9600); 
004C4:  SETF   FCF
004C6:  MOVLW  C7
004C8:  MOVWF  FCE
....................             clear_interrupt( INT_TIMER1 ); 
004CA:  BCF    F9E.0
....................             break; 
004CC:  GOTO   0574
....................         case 10: // Bit 9 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit6 = input(PIN_IBC_RCV); 
004D0:  BSF    F93.1
004D2:  MOVLB  1
004D4:  BCF    x87.6
004D6:  BTFSC  F81.1
004D8:  BSF    x87.6
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_1_BT_CUSTOMISED_VAL_9600); 
004DA:  SETF   FCF
004DC:  MOVLW  C7
004DE:  MOVWF  FCE
....................             clear_interrupt( INT_TIMER1 ); 
004E0:  BCF    F9E.0
....................             break; 
004E2:  GOTO   0574
....................         case 11: // Bit 10 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit7 = input(PIN_IBC_RCV); 
004E6:  BSF    F93.1
004E8:  MOVLB  1
004EA:  BCF    x87.7
004EC:  BTFSC  F81.1
004EE:  BSF    x87.7
....................              
....................             // We have received all data so now we can release Timer0 Critical Run 
....................             g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
004F0:  MOVLW  01
004F2:  MOVLB  2
004F4:  MOVWF  x22
....................              
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_1_BT_CUSTOMISED_VAL_9600); 
004F6:  SETF   FCF
004F8:  MOVLW  C7
004FA:  MOVWF  FCE
....................             clear_interrupt( INT_TIMER1 ); 
004FC:  BCF    F9E.0
....................             break; 
004FE:  MOVLB  1
00500:  GOTO   0574
....................              
....................         case 12: // STOP Bit 
....................             // Check if the Stop Bit is High. 
....................             if(1 == input(PIN_IBC_RCV)) // Stop bit detected 
00504:  BSF    F93.1
00506:  BTFSS  F81.1
00508:  GOTO   0510
....................             { 
....................                 // Byte received successfully 
....................                 // Save received byte to the Message Array 1 
....................                 //g_arruiIBCRxMsg1[g_uiIBCRxByteCount1 - 1] = g_unTempRxData1.m_uiByte; 
....................             } 
0050C:  GOTO   0510
....................             else 
....................             {  
....................                 // Handle error. 
....................                 // Framing error. 
....................                 // Set Flag tracking Framing Error. 
....................                 //g_uiIBCRxFramingErr1 = 1; 
....................                 //g_uiIBCSTXReceived1  = 0; 
....................             } 
....................             // Disable Timer1. 
....................             setup_timer_1 (T1_DISABLED); 
00510:  CLRF   FCD
00512:  CLRF   FAA
....................             disable_interrupts(INT_TIMER1);  
00514:  BCF    F9D.0
....................             // Clear Timer1 interrupt. 
....................             clear_interrupt(INT_TIMER1);  
00516:  BCF    F9E.0
....................   
....................              
....................             g_i8RcvByteCount++; 
00518:  MOVLB  2
0051A:  INCF   x23,F
....................             if (5 == g_i8RcvByteCount) 
0051C:  MOVF   x23,W
0051E:  SUBLW  05
00520:  BTFSS  FD8.2
00522:  GOTO   0528
....................             { 
....................                 g_i8RcvByteCount = 0; 
00526:  CLRF   x23
....................             } 
....................             // Now check the Byte Sequence 
....................             g_stIBCRcvData.g_ui8ArrIBCData[g_unIBCRcvByteNode.m_ui8Arr[0]] = g_unIBCRcvByteNode.m_ui8Arr[1]; 
00528:  CLRF   03
0052A:  MOVLB  1
0052C:  MOVF   x86,W
0052E:  ADDLW  2F
00530:  MOVWF  FE9
00532:  MOVLW  01
00534:  ADDWFC 03,W
00536:  MOVWF  FEA
00538:  MOVFF  187,FEF
....................              
....................             if ((IBC_MSG_BYTE_COUNT - 1) == g_unIBCRcvByteNode.m_ui8Arr[0]) 
0053C:  MOVF   x86,W
0053E:  SUBLW  04
00540:  BTFSS  FD8.2
00542:  GOTO   054A
....................             { 
....................                 // The complete 5 byte data has been received 
....................                 // Now we can process the data 
....................                 g_fIBCDataReceived = 1; 
00546:  MOVLW  01
00548:  MOVWF  x84
....................                  
....................                 // Insert Message into IBC Receive Queue 
.................... ////////                InsertIBCMsgQueue(&g_stIBCRcvQueue, &g_stIBCRcvData);   
....................             } 
....................             // Reset Rx Bit Counter. 
....................             g_ui8IBCRcvBitCount = 0; 
0054A:  CLRF   x2B
....................              
....................             // Enable External Interrupt to detect next byte. 
.................... #ifdef M1_COMM_MODULE 
....................             ext_int_edge(1, H_TO_L);  
0054C:  BCF    FF1.5
....................             clear_interrupt(INT_EXT1); 
0054E:  BCF    FF0.0
....................             enable_interrupts(INT_EXT1); 
00550:  BSF    FF0.3
.................... #else 
....................             ext_int_edge(3, H_TO_L);  
....................             clear_interrupt(INT_EXT3); 
....................             enable_interrupts(INT_EXT3); 
.................... #endif 
....................             break; 
00552:  GOTO   0574
00556:  MOVLB  0
....................  
....................         default: 
....................             // Framing error. 
....................             // Set Flag tracking Framing Error. 
....................             //g_uiIBCRxFramingErr1 = 1; 
....................              
....................             // First release Timer0 Critical run lock 
....................             g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
00558:  MOVLW  01
0055A:  MOVLB  2
0055C:  MOVWF  x22
....................              
....................             // Disable Timer1. 
....................             setup_timer_1 (T1_DISABLED); 
0055E:  CLRF   FCD
00560:  CLRF   FAA
....................             disable_interrupts(INT_TIMER1);  
00562:  BCF    F9D.0
....................             // Clear Timer1 interrupt. 
....................             clear_interrupt(INT_TIMER1);  
00564:  BCF    F9E.0
....................              
....................             // Reset Rx Bit Counter 1. 
....................             g_ui8IBCRcvBitCount = 0; 
00566:  MOVLB  1
00568:  CLRF   x2B
....................              
....................             // Enable External Interrupt 0 to detect next start bit. 
....................             ext_int_edge(1, H_TO_L);  
0056A:  BCF    FF1.5
....................             clear_interrupt(INT_EXT1); 
0056C:  BCF    FF0.0
....................             enable_interrupts(INT_EXT1); 
0056E:  BSF    FF0.3
....................             break; 
00570:  GOTO   0574
....................     } 
....................      
.................... } 
....................  
....................  
....................  
.................... #endif /* _VI_IBC_CONFIG_H_ */ 
....................  
....................  
....................  
.................... #define T0_DIV_PRESCALE                     T0_DIV_8  
.................... #define TIMER_0_VALUE_LOAD_FOR_1MS          0xFD8F 
.................... #define ALL_TIMER_TEST_VAL_FOR_100_US       (0xFFFF - 0x003F + 1) 
.................... #define ALL_TIMER_TEST_VAL_FOR_70_US        (0xFFFF - 0x002C + 1) 
....................  
....................  
.................... #define FLAG_DI_STATE_CHANGED               11 
.................... #define FLAG_DI_STATE_NOT_CHANGED           12 
....................  
.................... #define ISR_TOTAL_BYTE_RECEIVE_TIME             9 //5 
.................... #define ISR_RECEIVED_ALL_BYTE                   21 
.................... #define ISR_PROCESSED_ALL_BYTE                  22 
.................... #define ISR_IS_READY                            40 
.................... #define ISR_IS_NOT_READY                        41 
....................  
.................... #define CHECK_FOR_AT_RESPONSE                   15 
.................... #define DO_NOT_CHECK_FOR_AT_RESPONSE            16 
.................... #define AT_RESPONSE_CHECK_INTRVL_TIMEOUT        60 
....................  
.................... #define MILLISECOND_TIMEOUT                     1000 
.................... #define SECOND_TIMEOUT                          60 
....................  
.................... #define SHOULD_SEND_DATA                        25 
.................... #define SHOULD_NOT_SEND_DATA                    26 
.................... #define DATA_SEND_INTERVAL_TIMEOUT              30 
....................  
.................... #define GPRS_CONNECTED                          1 
.................... #define GPRS_NOT_CONNECTED                      0 
....................  
.................... #define  GPRS_QUEUE_EMPTY_TIME_COUNT_START      80 
.................... #define  GPRS_QUEUE_EMPTY_TIME_COUNT_STOP       81 
.................... #define  GPRS_QUEUE_EMPTY_TIMEOUT               15 
....................  
.................... #define  SHOULD_CHECK_GPRS_CONNECTIVITY         55 
.................... #define  SHOULD_NOT_CHECK_GPRS_CONNECTIVITY     56 
....................  
.................... #define  REDAY_TO_RESTART_MCU                   33 
.................... #define  DO_NOT_RESTART_MCU                     34 
.................... #define  RESTART_MCU_INTERVAL_TIME              15  // In Minutes. Two Consecutive MCU restart will takes place at an interval of 15 minutes. 
....................  
.................... #define  GPRS_CONNECTION_QUERY_TIMEOUT          3  // In seconds. 
.................... #define  HTTP_URL_PARAMETER_SET_TIMEOUT         2 
.................... #define  HTTP_GET_SESSION_TIMEOUT               8 
00574:  BCF    F9E.0
00576:  MOVLB  0
00578:  GOTO   00AC
.................... #define  DATA_RESEND_INTRVL_TIMEOUT             10 
....................  
.................... // ***************************************************************************** 
.................... // ***************** Below -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
.................... unsigned int16 g_ui16StackerEmptyDelayCount           = 0; 
.................... unsigned int8  g_fIsReadyToReceiveByte                = ISR_IS_NOT_READY; 
.................... unsigned int8  g_ui8ISRReceiveByteTimeCounter         = 0; 
.................... unsigned int8  g_fISRAllByteReceived                  = ISR_PROCESSED_ALL_BYTE; 
.................... unsigned int8  g_fDIChangeState                       = FLAG_DI_STATE_NOT_CHANGED; 
.................... unsigned int8  g_fShouldCheckForAtResponse            = CHECK_FOR_AT_RESPONSE; 
.................... unsigned int16 g_ui16MillisecondToSecondCounter       = 0; 
.................... unsigned int8  g_ui8SecondToMinuteCounter             = 0; 
.................... unsigned int8  g_ui8ATResponseCheckTimeInterval       = 0; 
.................... unsigned int16 g_ui16TimeOutMilliseconds              = 0; 
.................... unsigned int8  g_fShouldLookForTimeOut                = 0; 
.................... unsigned int16 g_ui16ShouldLookTimerCounter           = 0; 
.................... unsigned int8  g_fIsTimedOut                          = 0; 
.................... unsigned int8  g_fShouldSendData                      = SHOULD_NOT_SEND_DATA; 
.................... unsigned int16 g_ui16DataSendIntervalTime             = 0; 
.................... //unsigned int8  g_fIsGPRSConnected                     = 0; 
.................... unsigned int8  g_ui8GPRSQueueEmptyTimeCounter         = 0; 
.................... unsigned int8  g_fCheckGPRSConnectivity               = SHOULD_NOT_CHECK_GPRS_CONNECTIVITY; 
.................... unsigned int8  g_fGPRSQueueEmptyTimeStatus            = 0; 
.................... unsigned int8  g_fIsReadyToRestartMCU                 = DO_NOT_RESTART_MCU; 
.................... unsigned int8  g_ui8RestartMCUIntrvlTimeCounter       = 0; 
.................... unsigned int8  g_ui8RS485ByteCnt                      = 0; 
.................... unsigned int8  g_ui8RTSOnCountBefore                  = 0; 
.................... unsigned int8  g_ui8RTSOnCountAfter                   = 0; 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ***************** Above -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //**************** Below -> Timer Initialization Function ********************** 
.................... //****************************************************************************** 
....................  
.................... //Initialize 1MS Timer. 
.................... void Init1MSTimer(void) 
.................... { 
.................... 	//setup timer0 for 1MS time. 
.................... 	setup_timer_0( T0_INTERNAL | T0_DIV_PRESCALE ); 
*
00AAE:  MOVLW  82
00AB0:  MOVWF  FD5
.................... 	set_timer0(TIMER_0_VALUE_LOAD_FOR_1MS); 
00AB2:  MOVLW  FD
00AB4:  MOVWF  FD7
00AB6:  MOVLW  8F
00AB8:  MOVWF  FD6
....................  
.................... 	//Enable timer0 
.................... 	clear_interrupt( INT_TIMER0 ); 
00ABA:  BCF    FF2.2
.................... 	enable_interrupts( INT_TIMER0 ); 
00ABC:  BSF    FF2.5
00ABE:  GOTO   6432 (RETURN)
.................... } 
....................  
.................... #INT_TIMER0 
.................... void timer0_isr(void) 
.................... {    
....................      
.................... 	// Increase millisecond counter at each millisecond. 
....................     g_ui16MillisecondToSecondCounter++;  //=========================================  1 
*
0057C:  MOVLB  2
0057E:  INCF   x2B,F
00580:  BTFSC  FD8.2
00582:  INCF   x2C,F
....................      
.................... ////    if (IBC_TIMER_0_CRITICAL_ON == g_ui8fTimer0State) 
.................... ////    { 
.................... ////        // Reset Timer0. 
.................... ////        set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS ); 
.................... ////        clear_interrupt( INT_TIMER0 ); 
.................... ////         
.................... ////        return; 
.................... ////    } 
....................      
....................      // Check if millisecond counter overflows 
....................     if(g_ui16MillisecondToSecondCounter >= MILLISECOND_TIMEOUT)  //==================== 2 
00584:  MOVF   x2C,W
00586:  SUBLW  02
00588:  BTFSC  FD8.0
0058A:  GOTO   05C0
0058E:  XORLW  FF
00590:  BTFSS  FD8.2
00592:  GOTO   05A0
00596:  MOVF   x2B,W
00598:  SUBLW  E7
0059A:  BTFSC  FD8.0
0059C:  GOTO   05C0
....................     { 
....................         // Reset counter. 
....................         g_ui16MillisecondToSecondCounter = 0; 
005A0:  CLRF   x2C
005A2:  CLRF   x2B
....................          
....................         // 1000MS i.e. 1second completed.. put stuff here that repeats after every second. 
....................          
....................         // Increase each second counter 
....................         g_ui8SecondToMinuteCounter++; 
005A4:  INCF   x2D,F
....................          
....................         // If data should not send through GPRS then count data send interval time 
....................         if(SHOULD_NOT_SEND_DATA == g_fShouldSendData) 
005A6:  MOVF   x35,W
005A8:  SUBLW  1A
005AA:  BTFSS  FD8.2
005AC:  GOTO   05B6
....................         { 
....................             // Increase data send interval time. 
....................             g_ui16DataSendIntervalTime++; 
005B0:  INCF   x36,F
005B2:  BTFSC  FD8.2
005B4:  INCF   x37,F
....................         } 
....................          
....................         // Increment counter to Sync with HMI Time to get proper timestamp. 
....................         g_ui16RegisterTime_Diff++; 
005B6:  MOVLB  0
005B8:  INCF   x9B,F
005BA:  BTFSC  FD8.2
005BC:  INCF   x9C,F
005BE:  MOVLB  2
....................     }    
....................      
....................     // Check If There is data ready to send HMI through RS485 
....................     if (FLAG_RS485_DATA_READY == g_fRS485DataReady) // =================================== 4 
005C0:  MOVLB  1
005C2:  DECFSZ x28,W
005C4:  GOTO   05E6
....................     { 
....................         // Raise RTS Pin On to hold the bus 
....................         output_bit(PIN_RS485_RTS, 1); 
005C8:  BSF    F8C.4
005CA:  BCF    F95.4
....................         if (g_ui8RTSOnCountBefore++ >= DELAY_TIME_RTS_BEFORE) 
005CC:  MOVLB  2
005CE:  MOVF   x3E,W
005D0:  INCF   x3E,F
005D2:  SUBLW  00
005D4:  BTFSC  FD8.0
005D6:  GOTO   05E8
....................         { 
....................             g_ui8RTSOnCountBefore = 0; 
005DA:  CLRF   x3E
....................             g_ui8RS485ByteCnt = 0; 
005DC:  CLRF   x3D
....................             g_ui8fRS485DataSend = FLAG_RS485_DATA_SEND_ON; 
005DE:  MOVLW  01
005E0:  MOVLB  1
005E2:  MOVWF  x2A
....................             g_fRS485DataReady = FLAG_RS485_DATA_NOT_READY; 
005E4:  CLRF   x28
005E6:  MOVLB  2
....................              
....................         } 
....................          
....................     } 
....................      
....................     // Check for RTS Flag 
....................     if (FLAG_RS485_DATA_SEND_DONE == g_ui8fRS485DataSend) // ================================ 5 
005E8:  MOVLB  1
005EA:  MOVF   x2A,W
005EC:  SUBLW  02
005EE:  BTFSS  FD8.2
005F0:  GOTO   060E
....................     { 
....................  
....................         if (g_ui8RTSOnCountAfter++ >= DELAY_TIME_RTS_AFTER) 
005F4:  MOVLB  2
005F6:  MOVF   x3F,W
005F8:  INCF   x3F,F
005FA:  SUBLW  01
005FC:  BTFSC  FD8.0
005FE:  GOTO   0610
....................         { 
....................             // Release RTS Pin 
....................             output_bit(PIN_RS485_RTS,0); 
00602:  BCF    F8C.4
00604:  BCF    F95.4
....................             g_ui8RTSOnCountAfter = 0; 
00606:  CLRF   x3F
....................             g_ui8fRS485DataSend = FLAG_RS485_DATA_SEND_OFF; 
00608:  MOVLW  03
0060A:  MOVLB  1
0060C:  MOVWF  x2A
0060E:  MOVLB  2
....................         } 
....................     } 
....................      
....................     // AR start 
....................     // Checking ISR received byte flag. 
....................     if(ISR_IS_READY == g_fIsReadyToReceiveByte) // =========================================== 
00610:  MOVF   x26,W
00612:  SUBLW  28
00614:  BTFSS  FD8.2
00616:  GOTO   061C
....................     { 
....................         // Increase the counter. 
....................         g_ui8ISRReceiveByteTimeCounter++; 
0061A:  INCF   x27,F
....................     } 
....................      
....................     if(ISR_TOTAL_BYTE_RECEIVE_TIME == g_ui8ISRReceiveByteTimeCounter) // ============================ 
0061C:  MOVF   x27,W
0061E:  SUBLW  09
00620:  BTFSS  FD8.2
00622:  GOTO   0630
....................     { 
....................         // Update all received byte flag. 
....................         g_fISRAllByteReceived = ISR_RECEIVED_ALL_BYTE; 
00626:  MOVLW  15
00628:  MOVWF  x28
....................          
....................         // Update Is received byte flag.  
....................         g_fIsReadyToReceiveByte =  ISR_IS_NOT_READY; 
0062A:  MOVLW  29
0062C:  MOVWF  x26
....................          
....................         // Reset Counter 
....................         g_ui8ISRReceiveByteTimeCounter = 0; 
0062E:  CLRF   x27
....................     } 
....................     // AR end 
....................      
....................     if (IBC_TIMER_0_CRITICAL_ON == g_ui8fTimer0State) 
00630:  MOVF   x22,F
00632:  BTFSS  FD8.2
00634:  GOTO   0646
....................     { 
....................         // Reset Timer0. 
....................         set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS ); 
00638:  MOVLW  FD
0063A:  MOVWF  FD7
0063C:  MOVLW  8F
0063E:  MOVWF  FD6
....................         clear_interrupt( INT_TIMER0 ); 
00640:  BCF    FF2.2
....................          
....................         return; 
00642:  GOTO   0706
....................     } 
....................      
....................     // ############################### Non Critical ############################### 
....................  
....................      
....................     // Check if second counter overflows 
....................     if(g_ui8SecondToMinuteCounter >= SECOND_TIMEOUT) 
00646:  MOVF   x2D,W
00648:  SUBLW  3B
0064A:  BTFSC  FD8.0
0064C:  GOTO   067C
....................     { 
....................         // Reset counter 
....................         g_ui8SecondToMinuteCounter = 0; 
00650:  CLRF   x2D
....................          
....................         // 60Seconds i.e. 1 Minute completed.. put stuff here that repeats after every minute. 
....................          
....................         // Increase AT response check time interval counter..allows upto 60 minutes i.e. for 1 hour 
....................         g_ui8ATResponseCheckTimeInterval++; 
00652:  INCF   x2E,F
....................          
....................         // Check GPRS queue empty time status 
....................         if(GPRS_QUEUE_EMPTY_TIME_COUNT_START == g_fGPRSQueueEmptyTimeStatus) 
00654:  MOVF   x3A,W
00656:  SUBLW  50
00658:  BTFSS  FD8.2
0065A:  GOTO   0664
....................         { 
....................             // Increase time count 
....................             g_ui8GPRSQueueEmptyTimeCounter++; 
0065E:  INCF   x38,F
....................         } 
00660:  GOTO   0670
....................         else if(GPRS_QUEUE_EMPTY_TIME_COUNT_STOP == g_fGPRSQueueEmptyTimeStatus) 
00664:  MOVF   x3A,W
00666:  SUBLW  51
00668:  BTFSS  FD8.2
0066A:  GOTO   0670
....................         { 
....................             // when data available..reset time count 
....................             g_ui8GPRSQueueEmptyTimeCounter = 0; 
0066E:  CLRF   x38
....................         } 
....................          
....................         // Check ready to restart MCU flag. 
....................         if(g_fIsReadyToRestartMCU >= DO_NOT_RESTART_MCU) 
00670:  MOVF   x3B,W
00672:  SUBLW  21
00674:  BTFSC  FD8.0
00676:  GOTO   067C
....................         { 
....................             // Increment counter. 
....................             g_ui8RestartMCUIntrvlTimeCounter++; 
0067A:  INCF   x3C,F
....................         } 
....................     } 
....................      
....................     // Check if AT response check interval time overflow. 
....................     if(AT_RESPONSE_CHECK_INTRVL_TIMEOUT == g_ui8ATResponseCheckTimeInterval) 
0067C:  MOVF   x2E,W
0067E:  SUBLW  3C
00680:  BTFSS  FD8.2
00682:  GOTO   068C
....................     { 
....................         // Reset counter 
....................         g_ui8ATResponseCheckTimeInterval = 0; 
00686:  CLRF   x2E
....................          
....................         // Update AT response check flag. 
....................         g_fShouldCheckForAtResponse = CHECK_FOR_AT_RESPONSE; 
00688:  MOVLW  0F
0068A:  MOVWF  x2A
....................     } 
....................      
....................  
....................      
....................     // Check if timer should look for timeout 
....................     if(g_fShouldLookForTimeOut) 
0068C:  MOVF   x31,F
0068E:  BTFSC  FD8.2
00690:  GOTO   06C2
....................     { 
....................         // Increase timer counter 
....................         g_ui16ShouldLookTimerCounter++; 
00694:  INCF   x32,F
00696:  BTFSC  FD8.2
00698:  INCF   x33,F
....................          
....................         // Check if timer counter reached timeout value 
....................         if(g_ui16ShouldLookTimerCounter >= g_ui16TimeOutMilliseconds) 
0069A:  MOVF   x30,W
0069C:  SUBWF  x33,W
0069E:  BTFSS  FD8.0
006A0:  GOTO   06C2
006A4:  BTFSS  FD8.2
006A6:  GOTO   06B4
006AA:  MOVF   x2F,W
006AC:  SUBWF  x32,W
006AE:  BTFSS  FD8.0
006B0:  GOTO   06C2
....................         { 
....................             // Set flag denoting that timer declares set time is timed out 
....................             g_fIsTimedOut = 1; 
006B4:  MOVLW  01
006B6:  MOVWF  x34
....................              
....................             // Reset variables 
....................             g_fShouldLookForTimeOut      = 0; 
006B8:  CLRF   x31
....................             g_ui16ShouldLookTimerCounter = 0; 
006BA:  CLRF   x33
006BC:  CLRF   x32
....................             g_ui16TimeOutMilliseconds    = 0; 
006BE:  CLRF   x30
006C0:  CLRF   x2F
....................         } 
....................     } 
....................      
....................     // Check GPRS queue empty time count 
....................     if(GPRS_QUEUE_EMPTY_TIMEOUT == g_ui8GPRSQueueEmptyTimeCounter) 
006C2:  MOVF   x38,W
006C4:  SUBLW  0F
006C6:  BTFSS  FD8.2
006C8:  GOTO   06D2
....................     { 
....................         // Set flag that data is not available in GPRS queue for 15 minutes..check GPRS connection 
....................         g_fCheckGPRSConnectivity = SHOULD_CHECK_GPRS_CONNECTIVITY; 
006CC:  MOVLW  37
006CE:  MOVWF  x39
....................          
....................         // Reset counter 
....................         g_ui8GPRSQueueEmptyTimeCounter = 0; 
006D0:  CLRF   x38
....................     } 
....................      
....................     // Check if data send interval time reached timeout 
....................     if(DATA_SEND_INTERVAL_TIMEOUT == g_ui16DataSendIntervalTime) 
006D2:  MOVF   x36,W
006D4:  SUBLW  1E
006D6:  BTFSS  FD8.2
006D8:  GOTO   06EC
006DC:  MOVF   x37,F
006DE:  BTFSS  FD8.2
006E0:  GOTO   06EC
....................     { 
....................         // Update should send data flag 
....................         g_fShouldSendData = SHOULD_SEND_DATA; 
006E4:  MOVLW  19
006E6:  MOVWF  x35
....................          
....................         // Reset variable 
....................         g_ui16DataSendIntervalTime = 0; 
006E8:  CLRF   x37
006EA:  CLRF   x36
....................     } 
....................      
....................     // Check restart MCU interval time counter. 
....................     if(g_ui8RestartMCUIntrvlTimeCounter >= RESTART_MCU_INTERVAL_TIME) 
006EC:  MOVF   x3C,W
006EE:  SUBLW  0E
006F0:  BTFSC  FD8.0
006F2:  GOTO   06FC
....................     { 
....................         // Update flag status. 
....................         g_fIsReadyToRestartMCU = REDAY_TO_RESTART_MCU; 
006F6:  MOVLW  21
006F8:  MOVWF  x3B
....................          
....................         // Reset counter. 
....................         g_ui8RestartMCUIntrvlTimeCounter = 0; 
006FA:  CLRF   x3C
....................     } 
....................      
....................     // TESTING 
.................... 	//output_toggle(PIN_IN_EXT_DI_00); 
....................      
.................... 	// Reset Timer0. 
....................     set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS ); 
006FC:  MOVLW  FD
006FE:  MOVWF  FD7
00700:  MOVLW  8F
00702:  MOVWF  FD6
....................     clear_interrupt( INT_TIMER0 );	 
00704:  BCF    FF2.2
00706:  BCF    FF2.2
00708:  MOVLB  0
0070A:  GOTO   00AC
.................... } 
....................  
.................... //////// TESTING Start 
.................... //////void InitTIMER1(void) 
.................... //////{ 
.................... //////     // Setup Timer0 at 1 ms Time. 
.................... //////    setup_timer_1( T1_INTERNAL | T1_DIV_BY_8 ); 
.................... //////    set_timer0( ALL_TIMER_TEST_VAL_FOR_70_US ); 
.................... //////    // Enable Timer0. 
.................... //////    clear_interrupt( INT_TIMER1 ); 
.................... //////    enable_interrupts( INT_TIMER1 ); 
.................... //////} 
.................... ////// 
.................... //////void InitTIMER3(void) 
.................... //////{ 
.................... //////     // Setup Timer0 at 1 ms Time. 
.................... //////    setup_timer_3( T3_INTERNAL | T3_DIV_BY_8 ); 
.................... //////    set_timer0( ALL_TIMER_TEST_VAL_FOR_70_US ); 
.................... //////    // Enable Timer0. 
.................... //////    clear_interrupt( INT_TIMER3 ); 
.................... //////    enable_interrupts( INT_TIMER3 ); 
.................... //////} 
.................... ////// 
.................... //////// TESTING End. 
....................  
.................... //****************************************************************************** 
.................... //**************** Above -> Timer Initialization Function ********************** 
.................... //****************************************************************************** 
....................  
....................  
....................  
....................  
.................... void ExecuteALLDOs(void) 
.................... { 
.................... //    delay_us(10); 
.................... //    output_bit(PIN_OUT_DO_00, g_unDOState.m_stAllDOBits.m_ui1HWDOCn00); // Solenoid opeartion. 
.................... //    //output_bit(PIN_OUT_DO_01, g_unDOState.m_stAllDOBits.m_ui1HWDOCn01); // Shipper rejection RED LED. 
.................... //    //output_bit(PIN_OUT_DO_02, g_unDOState.m_stAllDOBits.m_ui1HWDOCn02); 
.................... //    output_bit(PIN_OUT_DO_03, g_unDOState.m_stAllDOBits.m_ui1HWDOCn03); // Ready To Feed. 
.................... //    //output_bit(PIN_OUT_DO_04, g_unDOState.m_stAllDOBits.m_ui1HWDOCn04); 
.................... //    //output_bit(PIN_OUT_DO_05, g_unDOState.m_stAllDOBits.m_ui1HWDOCn05); 
.................... //    //output_bit(PIN_OUT_DO_06, g_unDOState.m_stAllDOBits.m_ui1HWDOCn06); 
.................... //    //output_bit(PIN_OUT_DO_07, g_unDOState.m_stAllDOBits.m_ui1HWDOCn07);    
.................... } 
....................  
.................... //****************************************************************************** 
.................... //******************* Below -> 1MS Timer Implementation ************************ 
.................... //****************************************************************************** 
....................  
.................... ////////#INT_TIMER0 
.................... ////////void timer0_isr(void) 
.................... ////////{    
.................... ////////     
.................... ////////	// Increase millisecond counter at each millisecond. 
.................... ////////    g_ui16MillisecondToSecondCounter++;  //=========================================  1 
.................... ////////     
.................... ////////    // Check if millisecond counter overflows 
.................... ////////    if(g_ui16MillisecondToSecondCounter >= MILLISECOND_TIMEOUT)  //==================== 2 
.................... ////////    { 
.................... ////////        // Reset counter. 
.................... ////////        g_ui16MillisecondToSecondCounter = 0; 
.................... ////////         
.................... ////////        // 1000MS i.e. 1second completed.. put stuff here that repeats after every second. 
.................... ////////         
.................... ////////        // Increase each second counter 
.................... ////////        g_ui8SecondToMinuteCounter++; 
.................... ////////         
.................... ////////        // If data should not send through GPRS then count data send interval time 
.................... ////////        if(SHOULD_NOT_SEND_DATA == g_fShouldSendData) 
.................... ////////        { 
.................... ////////            // Increase data send interval time. 
.................... ////////            g_ui16DataSendIntervalTime++; 
.................... ////////        } 
.................... ////////         
.................... ////////        // Increment counter to Sync with HMI Time to get proper timestamp. 
.................... ////////        g_ui16RegisterTime_Diff++; 
.................... ////////    } 
.................... ////////     
.................... ////////    // Check if second counter overflows 
.................... ////////    if(SECOND_TIMEOUT == g_ui8SecondToMinuteCounter) // =============================== 3 
.................... ////////    { 
.................... ////////        // Reset counter 
.................... ////////        g_ui8SecondToMinuteCounter = 0; 
.................... ////////         
.................... ////////        // 60Seconds i.e. 1 Minute completed.. put stuff here that repeats after every minute. 
.................... ////////         
.................... ////////        // Increase AT response check time interval counter..allows upto 60 minutes i.e. for 1 hour 
.................... ////////        g_ui8ATResponseCheckTimeInterval++; 
.................... ////////         
.................... ////////        // Check GPRS queue empty time status 
.................... ////////        if(GPRS_QUEUE_EMPTY_TIME_COUNT_START == g_fGPRSQueueEmptyTimeStatus) 
.................... ////////        { 
.................... ////////            // Increase time count 
.................... ////////            g_ui8GPRSQueueEmptyTimeCounter++; 
.................... ////////        } 
.................... ////////        else if(GPRS_QUEUE_EMPTY_TIME_COUNT_STOP == g_fGPRSQueueEmptyTimeStatus) 
.................... ////////        { 
.................... ////////            // when data available..reset time count 
.................... ////////            g_ui8GPRSQueueEmptyTimeCounter = 0; 
.................... ////////        } 
.................... ////////         
.................... ////////        // Check ready to restart MCU flag. 
.................... ////////        if(DO_NOT_RESTART_MCU == g_fIsReadyToRestartMCU) 
.................... ////////        { 
.................... ////////            // Increment counter. 
.................... ////////            g_ui8RestartMCUIntrvlTimeCounter++; 
.................... ////////        } 
.................... ////////    } 
.................... ////////     
.................... ////////    // Check If There is data ready to send HMI through RS485 
.................... ////////    if (FLAG_RS485_DATA_READY == g_fRS485DataReady) // =================================== 4 
.................... ////////    { 
.................... ////////        // Raise RTS Pin On to hold the bus 
.................... ////////        output_bit(PIN_RS485_RTS, 1); 
.................... ////////        if (g_ui8RTSOnCountBefore++ >= DELAY_TIME_RTS_BEFORE) 
.................... ////////        { 
.................... ////////            g_ui8RTSOnCountBefore = 0; 
.................... ////////            g_ui8RS485ByteCnt = 0; 
.................... ////////            g_ui8fRS485DataSend = FLAG_RS485_DATA_SEND_ON; 
.................... ////////            g_fRS485DataReady = FLAG_RS485_DATA_NOT_READY; 
.................... ////////             
.................... ////////        } 
.................... ////////         
.................... ////////    } 
.................... ////////         
.................... //////// 
.................... //////// 
.................... ////////    // Check for RTS Flag 
.................... ////////    if (FLAG_RS485_DATA_SEND_DONE == g_ui8fRS485DataSend) // ================================ 5 
.................... ////////    { 
.................... //////// 
.................... ////////        if (g_ui8RTSOnCountAfter++ >= DELAY_TIME_RTS_AFTER) 
.................... ////////        { 
.................... ////////            // Release RTS Pin 
.................... ////////            output_bit(PIN_RS485_RTS,0); 
.................... ////////            g_ui8RTSOnCountAfter = 0; 
.................... ////////            g_ui8fRS485DataSend = FLAG_RS485_DATA_SEND_OFF; 
.................... ////////        } 
.................... ////////    } 
.................... ////////    // Check if AT response check interval time overflow. 
.................... ////////    if(AT_RESPONSE_CHECK_INTRVL_TIMEOUT == g_ui8ATResponseCheckTimeInterval) 
.................... ////////    { 
.................... ////////        // Reset counter 
.................... ////////        g_ui8ATResponseCheckTimeInterval = 0; 
.................... ////////         
.................... ////////        // Update AT response check flag. 
.................... ////////        g_fShouldCheckForAtResponse = CHECK_FOR_AT_RESPONSE; 
.................... ////////    } 
.................... ////////     
.................... ////////    // AR start 
.................... ////////    // Checking ISR received byte flag. 
.................... ////////    if(ISR_IS_READY == g_fIsReadyToReceiveByte) // =========================================== 
.................... ////////    { 
.................... ////////        // Increase the counter. 
.................... ////////        g_ui8ISRReceiveByteTimeCounter++; 
.................... ////////    } 
.................... ////////     
.................... ////////    if(ISR_TOTAL_BYTE_RECEIVE_TIME == g_ui8ISRReceiveByteTimeCounter) // ============================ 
.................... ////////    { 
.................... ////////        // Update all received byte flag. 
.................... ////////        g_fISRAllByteReceived = ISR_RECEIVED_ALL_BYTE; 
.................... ////////         
.................... ////////        // Update Is received byte flag.  
.................... ////////        g_fIsReadyToReceiveByte =  ISR_IS_NOT_READY; 
.................... ////////         
.................... ////////        // Reset Counter 
.................... ////////        g_ui8ISRReceiveByteTimeCounter = 0; 
.................... ////////    } 
.................... ////////    // AR end 
.................... ////////     
.................... ////////    // Check if timer should look for timeout 
.................... ////////    if(g_fShouldLookForTimeOut) 
.................... ////////    { 
.................... ////////        // Increase timer counter 
.................... ////////        g_ui16ShouldLookTimerCounter++; 
.................... ////////         
.................... ////////        // Check if timer counter reached timeout value 
.................... ////////        if(g_ui16ShouldLookTimerCounter >= g_ui16TimeOutMilliseconds) 
.................... ////////        { 
.................... ////////            // Set flag denoting that timer declares set time is timed out 
.................... ////////            g_fIsTimedOut = 1; 
.................... ////////             
.................... ////////            // Reset variables 
.................... ////////            g_fShouldLookForTimeOut      = 0; 
.................... ////////            g_ui16ShouldLookTimerCounter = 0; 
.................... ////////            g_ui16TimeOutMilliseconds    = 0; 
.................... ////////        } 
.................... ////////    } 
.................... ////////     
.................... ////////    // Check GPRS queue empty time count 
.................... ////////    if(GPRS_QUEUE_EMPTY_TIMEOUT == g_ui8GPRSQueueEmptyTimeCounter) 
.................... ////////    { 
.................... ////////        // Set flag that data is not available in GPRS queue for 15 minutes..check GPRS connection 
.................... ////////        g_fCheckGPRSConnectivity = SHOULD_CHECK_GPRS_CONNECTIVITY; 
.................... ////////         
.................... ////////        // Reset counter 
.................... ////////        g_ui8GPRSQueueEmptyTimeCounter = 0; 
.................... ////////    } 
.................... ////////     
.................... ////////    // Check if data send interval time reached timeout 
.................... ////////    if(DATA_SEND_INTERVAL_TIMEOUT == g_ui16DataSendIntervalTime) 
.................... ////////    { 
.................... ////////        // Update should send data flag 
.................... ////////        g_fShouldSendData = SHOULD_SEND_DATA; 
.................... ////////         
.................... ////////        // Reset variable 
.................... ////////        g_ui16DataSendIntervalTime = 0; 
.................... ////////    } 
.................... ////////     
.................... ////////    // Check restart MCU interval time counter. 
.................... ////////    if(g_ui8RestartMCUIntrvlTimeCounter >= RESTART_MCU_INTERVAL_TIME) 
.................... ////////    { 
.................... ////////        // Update flag status. 
.................... ////////        g_fIsReadyToRestartMCU = REDAY_TO_RESTART_MCU; 
.................... ////////         
.................... ////////        // Reset counter. 
.................... ////////        g_ui8RestartMCUIntrvlTimeCounter = 0; 
.................... ////////    } 
.................... ////////     
.................... ////////    // TESTING 
.................... ////////	//output_toggle(PIN_IN_EXT_DI_00); 
.................... ////////     
.................... ////////	// Reset Timer0. 
.................... ////////    set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS ); 
.................... ////////    clear_interrupt( INT_TIMER0 );	 
.................... ////////} 
....................  
.................... //////// TESTING Start 
.................... //////#INT_TIMER1 
.................... //////void timer_1_isr(void) 
.................... //////{ 
.................... //////    output_toggle(PIN_IN_EXT_DI_01); 
.................... //////     
.................... //////     // Reset Timer1. 
.................... //////    set_timer1( ALL_TIMER_TEST_VAL_FOR_70_US ); 
.................... //////    clear_interrupt( INT_TIMER1 ); 
.................... //////} 
.................... ////// 
.................... ////// 
.................... //////#INT_TIMER3 
.................... //////void timer_3_isr(void) 
.................... //////{ 
.................... //////    output_toggle(PIN_IN_EXT_DI_02); 
.................... //////     
.................... //////     // Reset Timer1. 
.................... //////    set_timer3( ALL_TIMER_TEST_VAL_FOR_70_US ); 
.................... //////    clear_interrupt( INT_TIMER3 ); 
.................... //////} 
.................... //////// TESTING End 
....................  
.................... //****************************************************************************** 
.................... //******************* Above -> 1MS Timer Implementation ************************ 
.................... //****************************************************************************** 
....................  
.................... void SetTimeout(unsigned int8 ui8TimedOutSeconds) 
.................... { 
....................     // Convert timeout seconds into milliseconds 
....................     g_ui16TimeOutMilliseconds = ui8TimedOutSeconds * 1000; 
*
01AA6:  MOVLB  B
01AA8:  CLRF   x4F
01AAA:  MOVFF  B1B,B4E
01AAE:  MOVLW  03
01AB0:  MOVWF  x51
01AB2:  MOVLW  E8
01AB4:  MOVWF  x50
01AB6:  MOVLB  0
01AB8:  CALL   0B2A
01ABC:  MOVFF  02,230
01AC0:  MOVFF  01,22F
....................      
....................     // Set flag denoting now timer should look for timeout value 
....................     g_fShouldLookForTimeOut = 1; 
01AC4:  MOVLW  01
01AC6:  MOVLB  2
01AC8:  MOVWF  x31
01ACA:  MOVLB  0
01ACC:  RETURN 0
.................... } 
....................  
....................  
.................... #endif /* _VM_TIMER_CONFIG_H_ */ 
....................  
.................... #include "vmIBCConfig.h" 
.................... #ifndef _VI_IBC_CONFIG_H_ 
.................... #define _VI_IBC_CONFIG_H_ 
....................  
.................... #include "vmSystemConfig.h" 
.................... #include "vmCRCConfig.h" 
.................... #include "vmDigitalIOConfig.h" 
.................... //#include "ctype.h" 
.................... #include "vmPINConfig.h" 
.................... #include "vmIBCGlobal.h" 
....................  
.................... #define IBC_MSG_BYTE_COUNT                       5 
.................... #define IBC_DATA_BITS_LENGTH                     10 
.................... #define IBC_DATA_BYTES_LENGTH                    10 
.................... #define IBC_BOARD_ID                             1 
....................  
.................... #define IBC_BAUD_RATE_9600                       20 
.................... #define IBC_BAUD_RATE_19200                      21 
....................  
.................... #define T1_DIV_PRESCALE                          T1_DIV_BY_8 
.................... #define T3_DIV_PRESCALE                          T3_DIV_BY_8 
....................  
.................... #define IBC_TX_1_BT_LOAD_VALUE_9600              (0xFFFF - 0x0041 + 1) 
.................... #define IBC_TX_1_BT_LOAD_VALUE_19200             (0xFFFF - 0x0021 + 1) 
....................  
.................... #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL_9600       (0xFFFF - 0x0062 + 1) // For 9600 
.................... #define IBC_RX_BIT_TIME_T1LOAD_VAL_9600           (0xFFFF - 0x0041 + 1) // For 9600 
....................  
.................... #ifdef M1_COMM_MODULE 
....................     #define IBC_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)  // 78us Instead of 104us we load 91.2 for per bit time. 
.................... #else 
....................     #define IBC_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)//   IBC_RX_BIT_TIME_T1LOAD_VAL_9600  // 104 us 
.................... #endif 
.................... //#define IBC_RX_1_BT_CUSTOMISED_VAL_9600           (0xFFFF - 0x0031 + 1)  // Instead of 104us we load 78 us for per bit time. 
.................... #define IBC_RX_BIT_TIME_1_2_T1LOAD_VAL_9600       (0xFFFF - 0x004E + 1) 
.................... #define IBC_RX_BIT_TIME_1_3_T1LOAD_VAL_9600       (0xFFFF - 0x0051 + 1) 
.................... #define IBC_RX_BIT_TIME_1_4_T1LOAD_VAL_9600       (0xFFFF - 0x005B + 1) 
....................  
....................  
.................... #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL_19200     (0xFFFF - 0x0031 + 1) // For 19200 
.................... #define IBC_RX_BIT_TIME_T1LOAD_VAL_19200         (0xFFFF - 0x0041 + 1) // For 19200 
....................  
.................... #define SIZE_IBC_SEND_BYTE_SEGMENT                15  //1+3+8+3, 1 Start Bit, 3 Sequence Bits, 8 bits of Data and 3 Stop Bits; Total 15bits in one segment/ custised byte 
....................  
.................... #define IBC_TIMER_0_CRITICAL_ON                   0 
.................... #define IBC_TIMER_0_CRITICAL_OFF                  1 
....................  
.................... //***************************************************************************** 
.................... // Below -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
.................... typedef struct _ST_INT_BOARD_ALL_BITS 
.................... { 
....................     unsigned int8 m_ui1IBCRcvbit_0: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_1: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_2: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_3: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_4: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_5: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_6: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_7: 1; 
.................... } ST_INT_BOARD_ALL_BITS; 
....................  
.................... //typedef union _UN_INT_BOARD_BYTE_TYPE 
.................... //{ 
.................... //    unsigned int8          m_ui8Byte; 
.................... //    ST_INT_BOARD_ALL_BITS  m_stByte; 
.................... //    char				   m_chData;	 
.................... //} UN_INT_BOARD_BYTE_TYPE; 
....................  
.................... typedef struct _ST_INT_BOARD_DATA 
.................... { 
....................     char 			m_boardData[IBC_DATA_BITS_LENGTH]; 
....................     unsigned int8  	m_boardID; 
.................... } ST_INT_BOARD_DATA; 
....................  
....................  
.................... //***************************************************************************** 
.................... // Above -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Interboard Communication  RX #  From M1_COMM ********************** 
.................... //***************************************************************************** 
....................  
.................... // Below -> Multiple Baud Rate Settings. 
....................  
.................... #ifdef IBC_BOUD_RATE_1000 
....................     #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL   (0xFFFF - 0x0EA6 + 1) 
....................     #define IBC_RX_BIT_TIME_T1LOAD_VAL       (0xFFFF - 0x09C4 + 1) 
.................... #endif 
....................  
.................... #ifdef IBC_BOUD_RATE_9600 
....................     #define IBC_RX_TIME_DELAY_1_5_BIT           156  
....................     #define IBC_RX_TIME_DELAY_1_BIT             104 
....................     #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL   (0xFFFF - 0x0062 + 1) 
....................     #define IBC_RX_BIT_TIME_T1LOAD_VAL       (0xFFFF - 0x0041 + 1) 
.................... #endif 
....................  
.................... #ifdef IBC_BOUD_RATE_19200 
....................     #define IBC_RX_TIME_DELAY_1_5_VAL           78  
....................     #define IBC_RX_TIME_DELAY_1_VAL             52 
....................     #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL   (0xFFFF - 0x0031 + 1) 
....................     #define IBC_RX_BIT_TIME_T1LOAD_VAL       (0xFFFF - 0x0021 + 1) 
.................... #endif 
....................  
.................... // Above -> Multiple Baud Rate Settings. 
....................  
.................... // Initialize IBC Data Set, Should be called from main()) 
.................... //void InitIBCDataSet() 
.................... //{ 
.................... //    g_unTempRxData1.m_uiByte = 0; 
.................... //} 
....................  
.................... typedef struct _ST_IBC_RCV_BYTE_NODE 
.................... { 
....................  
....................     unsigned int8 m_ui8SeqBit0 :1; 
....................     unsigned int8 m_ui8SeqBit1 :1; 
....................     unsigned int8 m_ui8SeqBit2 :1; 
....................     unsigned int8 m_ui8Padding :5; 
....................      
....................     unsigned int8 m_ui8DataBit0 :1; 
....................     unsigned int8 m_ui8DataBit1 :1; 
....................     unsigned int8 m_ui8DataBit2 :1; 
....................     unsigned int8 m_ui8DataBit3 :1; 
....................     unsigned int8 m_ui8DataBit4 :1; 
....................     unsigned int8 m_ui8DataBit5 :1; 
....................     unsigned int8 m_ui8DataBit6 :1; 
....................     unsigned int8 m_ui8DataBit7 :1; 
.................... } ST_IBC_RCV_BYTE_NODE; 
....................  
.................... typedef union _UN_IBC_RCV_BYTE_NODE 
.................... { 
....................     ST_IBC_RCV_BYTE_NODE m_stIBCNode; 
....................     unsigned int8        m_ui8Arr[2]; 
.................... } UN_IBC_RCV_BYTE_NODE; 
....................  
....................  
....................  
.................... typedef struct _ST_IBC_DATA_NODE 
.................... { 
....................     unsigned int8 g_ui8ArrIBCData[IBC_MSG_BYTE_COUNT]; 
.................... } ST_IBC_DATA_NODE; 
....................  
.................... #define SIZE_IBC_DATA_SEND_QUEUE 15 
....................  
.................... //typedef struct _ST_IBC_DATA_SEND_QUEUE 
.................... //{ 
.................... //    ST_IBC_DATA_NODE m_stArrIBCDataNode[SIZE_IBC_DATA_SEND_QUEUE]; 
.................... //    int8             m_i8Front; 
.................... //    int8             m_i8Rear; 
.................... //} ST_IBC_DATA_SEND_QUEUE; 
....................  
.................... typedef struct _ST_IBC_MSG_QUEUE 
.................... { 
....................     ST_IBC_DATA_NODE m_stArrIBCDataNode[SIZE_IBC_DATA_SEND_QUEUE]; 
....................     int8             m_i8Front; 
....................     int8             m_i8Rear; 
.................... } ST_IBC_MSG_QUEUE; 
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... //UN_INT_BOARD_BYTE_TYPE    g_unIBCRcvData; 
.................... unsigned int8             g_ui8IBCRcvBitCount = 0; 
.................... unsigned int8             g_ui8IBCTxBitCount  = 0; 
....................  
.................... // TESTING 
.................... unsigned int8             g_ui8IBCDataToSend = 0xA5; 
.................... unsigned int8             g_fIBCCommStatus   = 0; 
....................  
.................... ST_IBC_DATA_NODE          g_stIBCRcvData; 
.................... ST_IBC_DATA_NODE          g_stIBCSendData; 
.................... unsigned int8             g_ui8ArrSendSingleMSG[IBC_MSG_BYTE_COUNT*(SIZE_IBC_SEND_BYTE_SEGMENT)] = {0}; // 
.................... unsigned int8             g_fIBCDataReceived = 0; 
....................  
.................... //ST_IBC_DATA_SEND_QUEUE    g_stIBCDataSendQueue; 
.................... unsigned int8             g_fIBCSendBusy = 0; 
.................... UN_IBC_RCV_BYTE_NODE      g_unIBCRcvByteNode; 
....................  
.................... ST_IBC_MSG_QUEUE          g_stIBCSendQueue; 
.................... ST_IBC_MSG_QUEUE          g_stIBCRcvQueue; 
....................  
.................... unsigned int8             g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... ////////// 
.................... //////////void InitializeDataSendQueue() 
.................... //////////{ 
.................... //////////    int iLoopCount1 = 0; 
.................... //////////    int iLoopCount2 = 0; 
.................... //////////    g_stIBCDataSendQueue.m_i8Front = g_stIBCDataSendQueue.m_i8Rear = -1; 
.................... //////////     
.................... //////////    for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBC_DATA_SEND_QUEUE; iLoopCount1++) 
.................... //////////    { 
.................... //////////        for (iLoopCount2 = 0; iLoopCount2 < IBC_MSG_BYTE_COUNT; iLoopCount2++) 
.................... //////////        { 
.................... //////////           g_stIBCDataSendQueue.m_stArrIBCDataNode[iLoopCount1].g_ui8ArrIBCData[iLoopCount2] = 0; 
.................... //////////        } 
.................... //////////    } 
.................... //////////} 
.................... ////////// 
.................... //////////void CopySendData(int8 i8Location, ST_IBC_DATA_NODE* pstIBCData) 
.................... //////////{ 
.................... //////////    int8 i8LoopCount = 0; 
.................... //////////     
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        g_stIBCDataSendQueue.m_stArrIBCDataNode[i8Location].g_ui8ArrIBCData[i8LoopCount] = pstIBCData->g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////    } 
.................... //////////} 
.................... ////////// 
.................... //////////void CopyFromSendQueue(int8 i8Location, ST_IBC_DATA_NODE** ppstIBCData) 
.................... //////////{ 
.................... //////////    int8 i8LoopCount = 0; 
.................... //////////     
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        *ppstIBCData->g_ui8ArrIBCData[i8LoopCount] = g_stIBCDataSendQueue.m_stArrIBCDataNode[i8Location].g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////    } 
.................... //////////} 
.................... /* Function to create Circular queue */ 
.................... //////////void InsertSendQueue(ST_IBC_DATA_NODE* pstIBCData)  
.................... //////////{ 
.................... //////////    if (!pstIBCData) 
.................... //////////    { 
.................... //////////        return; 
.................... //////////    } 
.................... //////////     
.................... //////////    if ((g_stIBCDataSendQueue.m_i8Front == 0 && g_stIBCDataSendQueue.m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1) ||  
.................... //////////            (g_stIBCDataSendQueue.m_i8Front == g_stIBCDataSendQueue.m_i8Rear + 1))  
.................... //////////    {  
.................... //////////        //printf("\nQueue is Full");  
.................... //////////        return;  
.................... //////////    } 
.................... //////////   
.................... //////////    else if (g_stIBCDataSendQueue.m_i8Front == -1) /* Insert First Element */ 
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Front = g_stIBCDataSendQueue.m_i8Rear = 0; 
.................... //////////         
.................... //////////        // Insert Data 
.................... //////////        //arr[g_stIBCDataSendQueue.m_i8Rear] = value; 
.................... //////////        CopySendData(g_stIBCDataSendQueue.m_i8Rear, pstIBCData); 
.................... //////////    }  
.................... //////////   
.................... //////////    else if (g_stIBCDataSendQueue.m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1 && g_stIBCDataSendQueue.m_i8Front != 0)  
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Rear = 0;  
.................... //////////        CopySendData(g_stIBCDataSendQueue.m_i8Rear, pstIBCData);  
.................... //////////    }  
.................... //////////   
.................... //////////    else 
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Rear++;  
.................... //////////        CopySendData(g_stIBCDataSendQueue.m_i8Rear, pstIBCData); 
.................... //////////    }  
.................... //////////}  
....................  
.................... //////////void DeleteQueue(ST_IBC_DATA_NODE* pstIBCData)  
.................... //////////{  
.................... //////////    int8 i8LoopCount = 0; 
.................... ////////// 
.................... //////////    if (g_stIBCDataSendQueue.m_i8Front == -1) 
.................... //////////    {  
.................... //////////        //printf("\nQueue is Empty");  
.................... //////////        return;  
.................... //////////    }  
.................... //////////   
.................... //////////    //int data = arr[g_stIBCDataSendQueue.m_i8Front]; 
.................... //////////    //CopyFromSendQueue(g_stIBCDataSendQueue.m_i8Front, &pstIBCData); 
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        pstIBCData->g_ui8ArrIBCData[i8LoopCount] = g_stIBCDataSendQueue.m_stArrIBCDataNode[g_stIBCDataSendQueue.m_i8Front].g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////    } 
.................... //////////     
.................... //////////    //arr[g_stIBCDataSendQueue.m_i8Front] = -1;  
.................... //////////    if (g_stIBCDataSendQueue.m_i8Front == g_stIBCDataSendQueue.m_i8Rear)  
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Front = -1;  
.................... //////////        g_stIBCDataSendQueue.m_i8Rear = -1;  
.................... //////////    }  
.................... //////////    else if (g_stIBCDataSendQueue.m_i8Front == SIZE_IBC_DATA_SEND_QUEUE-1)  
.................... //////////        g_stIBCDataSendQueue.m_i8Front = 0;  
.................... //////////    else 
.................... //////////        g_stIBCDataSendQueue.m_i8Front++;  
.................... //////////   
.................... //////////    return; 
.................... //////////}  
.................... ////////// 
.................... //////////int8 IsMSGAvailableInIBCSendQueue() 
.................... //////////{ 
.................... //////////    if (g_stIBCDataSendQueue.m_i8Front == -1) 
.................... //////////    { 
.................... //////////        return 0; 
.................... //////////    } 
.................... //////////     
.................... //////////    return 1; 
.................... //////////} 
.................... ////////// 
.................... //////////void SendIBCMSG() 
.................... //////////{ 
.................... //////////    int8          i8LoopCount    = 0; 
.................... //////////    unsigned int8 ui8Sequence    = 0; 
.................... //////////    unsigned int8 ui8TempData    = 0; 
.................... //////////     
.................... //////////    // Initialize the Send Array 
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount] = 0; 
.................... //////////    } 
.................... ////////// 
.................... //////////    // Get Node from Queue 
.................... //////////    DeleteQueue(&g_stIBCSendData); 
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        // Step 1: First Stuff 1 Start Bit 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 0] = 0;   // Start Bit Always 0 
.................... //////////         
.................... //////////        // Step 2: Now Stuff 3 bit Message Byte Sequence Number 
.................... //////////         
.................... //////////        // Stuff the 1st Sequence Bit 
.................... //////////        ui8Sequence = i8LoopCount; 
.................... //////////        ui8Sequence = ui8Sequence << 7; 
.................... //////////        ui8Sequence = ui8Sequence >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 1] = ui8Sequence; 
.................... //////////         
.................... //////////        // Stuff the 2nd Sequence Bit  
.................... //////////        ui8Sequence = i8LoopCount; 
.................... //////////        ui8Sequence = ui8Sequence << 6; 
.................... //////////        ui8Sequence = ui8Sequence >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 2] = ui8Sequence; 
.................... //////////         
.................... //////////        // Stuff the 3rd Bit 
.................... //////////        ui8Sequence = i8LoopCount; 
.................... //////////        ui8Sequence = ui8Sequence << 5; 
.................... //////////        ui8Sequence = ui8Sequence >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 3] = ui8Sequence; 
.................... //////////         
.................... //////////        // Step 3: Now Stuff 8 bit Data 
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 7; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 4] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 6; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 5] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 5; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 6] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 4; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 7] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 3; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 8] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 2; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 9] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 1; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 10] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 11] = ui8TempData; 
.................... //////////         
.................... //////////        // Step 4: Stuff three Stop Bits 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 12] = 1;  // Stop bit is 1 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 13] = 1; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 14] = 1; 
.................... //////////    } 
.................... //////////     
.................... //////////    // So message stuffing is done now start the send timer 
.................... //////////    // Initialize send counter. 
.................... //////////    g_ui8IBCTxBitCount = 0; 
.................... //////////     
.................... //////////    // TESTING Start 
.................... ////////////    g_ui8ArrSendSingleMSG[0] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[1] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[2] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[3] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[4] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[5] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[6] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[7] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[8] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[9] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[10] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[11] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[12] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[13] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[14] = 1;     
.................... //////////    // TESTING End 
.................... //////////     
.................... //////////    // Start Timer3 that handle bit by bit sending. 
.................... //////////    // Set Timer3 as per Bit Time Value. 
.................... //////////    setup_timer_3(T3_INTERNAL | T3_DIV_PRESCALE); 
.................... //////////    set_timer3(IBC_TX_1_BT_LOAD_VALUE_9600); 
.................... //////////     
.................... //////////    clear_interrupt(INT_TIMER3); 
.................... //////////    enable_interrupts(INT_TIMER3); 
.................... //////////} 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving START /////////////// 
....................  
.................... void InitializeDataQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue) 
.................... { 
....................     int iLoopCount1 = 0; 
....................     int iLoopCount2 = 0; 
....................     pstIBCMSGQueue->m_i8Front = pstIBCMSGQueue->m_i8Rear = -1; 
....................      
....................     for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBC_DATA_SEND_QUEUE; iLoopCount1++) 
....................     { 
....................         for (iLoopCount2 = 0; iLoopCount2 < IBC_MSG_BYTE_COUNT; iLoopCount2++) 
....................         { 
....................            pstIBCMSGQueue->m_stArrIBCDataNode[iLoopCount1].g_ui8ArrIBCData[iLoopCount2] = 0; 
....................         } 
....................     } 
.................... } 
....................  
.................... void CopyIBCMsg(ST_IBC_DATA_NODE* pstIBCSource, ST_IBC_DATA_NODE* pstIBCDDest) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................      
....................     for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         pstIBCDDest->g_ui8ArrIBCData[i8LoopCount] = pstIBCSource->g_ui8ArrIBCData[i8LoopCount]; 
....................     } 
.................... } 
....................  
.................... /* Function to create Circular queue */ 
.................... void InsertIBCMsgQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue, ST_IBC_DATA_NODE* pstIBCData)  
.................... { 
....................     if (!pstIBCData) 
....................     { 
....................         return; 
....................     } 
....................      
....................     if ((pstIBCMSGQueue->m_i8Front == 0 && pstIBCMSGQueue->m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1) ||  
....................             (pstIBCMSGQueue->m_i8Rear == (pstIBCMSGQueue->m_i8Front-1)%(SIZE_IBC_DATA_SEND_QUEUE-1)))  
....................     {  
....................         //printf("\nQueue is Full");  
....................         return; 
....................     } 
....................    
....................     else if (pstIBCMSGQueue->m_i8Front == -1) /* Insert First Element */ 
....................     {  
....................         pstIBCMSGQueue->m_i8Front = pstIBCMSGQueue->m_i8Rear = 0; 
....................          
....................         // Insert Data 
....................         //arr[g_stIBCDataSendQueue.m_i8Rear] = value; 
....................         CopyIBCMsg(pstIBCData, &(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else if (pstIBCMSGQueue->m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1 && pstIBCMSGQueue->m_i8Front != 0)  
....................     {  
....................         pstIBCMSGQueue->m_i8Rear = 0;  
....................         CopyIBCMsg(pstIBCData, &(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else 
....................     {  
....................         pstIBCMSGQueue->m_i8Rear++;  
....................         CopyIBCMsg(pstIBCData, &(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Rear])); 
....................     }  
.................... }  
....................  
.................... void DeleteIBCMsgQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue, ST_IBC_DATA_NODE* pstIBCData)  
.................... { 
....................     if (pstIBCMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBCMsg(&(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Front]), pstIBCData); 
....................  
....................     if (pstIBCMSGQueue->m_i8Front == pstIBCMSGQueue->m_i8Rear)  
....................     {  
....................         pstIBCMSGQueue->m_i8Front = -1;  
....................         pstIBCMSGQueue->m_i8Rear = -1;  
....................     }  
....................     else if (pstIBCMSGQueue->m_i8Front == SIZE_IBC_DATA_SEND_QUEUE-1)  
....................         pstIBCMSGQueue->m_i8Front = 0;  
....................     else 
....................         pstIBCMSGQueue->m_i8Front++;  
....................    
....................     return; 
.................... } 
....................  
....................  
.................... int8 IsMSGInIBCQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue) 
.................... { 
....................     if (pstIBCMSGQueue->m_i8Front == -1) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................     return 1; 
.................... } 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving END ///////////////// 
.................... void SendIBCMSGFromQ() 
.................... { 
....................     int8          i8LoopCount    = 0; 
....................     unsigned int8 ui8Sequence    = 0; 
....................     unsigned int8 ui8TempData    = 0; 
....................  
....................     // Initialize the Send Array 
....................     for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount] = 0; 
....................     } 
....................  
....................     // Get Node from Queue 
....................     DeleteIBCMsgQueue(&g_stIBCSendQueue, &g_stIBCSendData); 
....................     for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         // Step 1: First Stuff 1 Start Bit 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 0] = 0;   // Start Bit Always 0 
....................          
....................         // Step 2: Now Stuff 3 bit Message Byte Sequence Number 
....................          
....................         // Stuff the 1st Sequence Bit 
....................         ui8Sequence = i8LoopCount; 
....................         ui8Sequence = ui8Sequence << 7; 
....................         ui8Sequence = ui8Sequence >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 1] = ui8Sequence; 
....................          
....................         // Stuff the 2nd Sequence Bit  
....................         ui8Sequence = i8LoopCount; 
....................         ui8Sequence = ui8Sequence << 6; 
....................         ui8Sequence = ui8Sequence >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 2] = ui8Sequence; 
....................          
....................         // Stuff the 3rd Bit 
....................         ui8Sequence = i8LoopCount; 
....................         ui8Sequence = ui8Sequence << 5; 
....................         ui8Sequence = ui8Sequence >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 3] = ui8Sequence; 
....................          
....................         // Step 3: Now Stuff 8 bit Data 
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 7; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 4] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 6; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 5] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 5; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 6] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 4; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 7] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 3; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 8] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 2; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 9] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 1; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 10] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 11] = ui8TempData; 
....................          
....................         // Step 4: Stuff three Stop Bits 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 12] = 1;  // Stop bit is 1 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 13] = 1; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 14] = 1; 
....................          
.................... ////////        // TESTING Start 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 0] = 0;   
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 1] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 2] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 3] = 1;  
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 4] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 5] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 6] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 7] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 8] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 9] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 10] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 11] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 12] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 13] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 14] = 1; 
.................... ////////        // TESTING End 
....................     } 
....................      
....................      
.................... ////    // TESTING Start 
.................... ////    g_ui8ArrSendSingleMSG[0] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[1] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[2] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[3] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[4] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[5] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[6] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[7] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[8] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[9] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[10] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[11] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[12] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[13] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[14] = 1;     
.................... ////    // TESTING End 
....................          
....................     // So message stuffing is done now start the send timer 
....................     // Initialize send counter. 
....................     g_ui8IBCTxBitCount = 0; 
....................      
....................     // Hold the IBC Send Lock 
....................     g_fIBCSendLockStatus = IBC_SEND_LOCK; 
....................     // Start Timer3 that handle bit by bit sending. 
....................     // Set Timer3 as per Bit Time Value. 
....................     setup_timer_3(T3_INTERNAL | T3_DIV_PRESCALE); 
....................     set_timer3(IBC_TX_1_BT_LOAD_VALUE_9600); 
....................      
....................     // Before Sending Data in IBC Run Timer0 in Time Critical. This we are doing 
....................     // just because we have seen the IBC Send Receive is affecting while Timer 0 
....................     // is executing, hence the IBC data send receive is not sampled at proper time 
....................     g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_ON; 
....................      
....................     clear_interrupt(INT_TIMER3); 
....................     enable_interrupts(INT_TIMER3); 
.................... } 
....................  
.................... void IBCProcessRcvMsg() 
.................... { 
....................     // I 
.................... } 
....................  
.................... #INT_TIMER3    // Used for IBC Send 
.................... void IBC_Tx_ISR(void) 
.................... { 
....................     // Send IBC bits 
....................     output_bit(PIN_IBC_XMIT, g_ui8ArrSendSingleMSG[g_ui8IBCTxBitCount++]); 
....................     // Reset Timer3 at 1Bit Time value. 
....................     set_timer3(IBC_TX_1_BT_LOAD_VALUE_9600); 
....................     clear_interrupt( INT_TIMER3 ); 
....................  
....................     // Check if IBC Sending completed 
....................     if ((IBC_MSG_BYTE_COUNT*SIZE_IBC_SEND_BYTE_SEGMENT) == g_ui8IBCTxBitCount) 
....................     { 
....................         // First release Timer0 Critical run lock 
....................         g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
....................          
....................         // Release Send Busy status 
....................         g_fIBCSendBusy     = 0; 
....................          
....................         // Send Stop bit forever 
....................         output_bit(PIN_IBC_XMIT, 1); 
....................  
....................         // Reset Tx counter 
....................         g_ui8IBCTxBitCount = 0; 
....................         // Reset IBC Send checking status flag. 
....................         //g_fIBCCommStatus = 0; 
....................         // Disable Timer 
....................         setup_timer_3 (T3_DISABLED); 
....................         disable_interrupts(INT_TIMER3); 
....................         // Clear Timer1 interrupt 
....................         clear_interrupt(INT_TIMER3); 
....................          
....................         // Release IBC Send Lock 
....................         g_fIBCSendLockStatus = IBC_SEND_UNLOCK; 
....................     } 
....................      
....................     // TESTING 
....................     //output_toggle(PIN_IN_EXT_DI_00); 
....................   
.................... } 
....................  
....................  
....................  
.................... /* 
....................     Timer1 is used to handle IBC Received bytes. 
....................  and Timer3 is used to handle IBC sent bytes. 
....................  */ 
.................... #ifdef M1_COMM_MODULE 
.................... #INT_EXT1  
.................... #else 
.................... #INT_EXT3 
.................... #endif 
.................... void IBC_Rx_ISR(void) 
.................... { 
....................    
....................     // Initialize Rx Bit Counter. 
....................    	g_ui8IBCRcvBitCount = 0; 
....................     g_unIBCRcvByteNode.m_ui8Arr[0] = 0; 
....................     g_unIBCRcvByteNode.m_ui8Arr[1] = 0; 
....................    	 
....................     // Setup Timer1 at 1.5 Bit Time.                   // Here we are using DIV_BY_8. 
....................     setup_timer_1( T1_INTERNAL | T1_DIV_PRESCALE ); // CPU Ext Clock is 20MHz, 20/4 => 5MHz is Peripheral Clock 
....................                                                 // => T1_DIV_BY_2 => 5/2 = 2.5MHz => (1/2.5)us = 0.4us 
....................                                                 // To Get 1Ms quanta = (1000us/0.4) = 2500 => 0x09C4 
....................                                                 // So, The timer will start counting from (0xFFFF - 0x09C4 + 1) 
....................                                                 // To Get 1.5Ms quanta = (1500us/0.4) = 3750 => 0x0EA6 
....................                                                 // So, The timer will start counting from (0xFFFF - 0x0EA6 + 1)  
....................      
.................... #ifdef M1_COMM_MODULE 
....................     set_timer1( IBC_RX_BIT_TIME_1_4_T1LOAD_VAL_9600);  
.................... #else 
....................     set_timer1( IBC_RX_BIT_TIME_1_5_T1LOAD_VAL_9600); 
.................... #endif 
....................      
....................     // Before Sending Data in IBC Run Timer0 in Time Critical. This we are doing 
....................     // just because we have seen the IBC Send Receive is affecting while Timer 0 
....................     // is executing, hence the IBC data send receive is not sampled at proper time 
....................     g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_ON; 
....................      
....................     clear_interrupt( INT_TIMER1 ); 
....................     enable_interrupts( INT_TIMER1 ); 
....................      
....................     // Clear and Disable External Interrupt 1  
.................... #ifdef M1_COMM_MODULE 
....................     clear_interrupt(INT_EXT1); 
....................     disable_interrupts(INT_EXT1);  
.................... #else 
....................     clear_interrupt(INT_EXT3); 
....................     disable_interrupts(INT_EXT3); 
.................... #endif 
....................      
....................     // TESTING Start 
.................... #ifdef M1_COMM_MODULE 
....................     //output_high(PIN_IN_EXT_DI_00); 
.................... #endif 
....................     // TESTING End 
.................... } 
....................  
.................... // TESTING Start 
.................... int8 g_i8RcvByteCount = 0; 
.................... // TESTING End 
....................  
.................... #INT_TIMER1           // This is for Receive                 
.................... void IBC_Rx_Sampling_ISR(void) 
.................... {  
.................... ////////    // TESTING Start 
.................... ////////#ifdef M1_COMM_MODULE 
.................... ////////    //output_toggle(PIN_IN_EXT_DI_00); 
.................... ////////#else 
.................... ////////    output_toggle(PIN_A5); 
.................... ////////#endif 
.................... ////////    // TESTING End 
....................      
....................     // Increment Rx Bit Counter for each received bit. 
....................    	g_ui8IBCRcvBitCount++; 
.................... 	 
....................     // Check Rx Bit Counter and read Bits 
....................     switch(g_ui8IBCRcvBitCount) 
....................     { 
....................         case 1: // Sequence Bit 0  
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8SeqBit0 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 2: // Sequence Bit 1 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8SeqBit1 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 3: // Sequence Bit 2 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8SeqBit2 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 4: // Data Bit Bit 0 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit0 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 5: // Bit 4 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit1 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 6: // Bit 5 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit2 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 7: // Bit 6 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit3 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 8: // Bit 7 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit4 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................          	set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................          	clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................              
....................              
....................         case 9: // Bit 8 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit5 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_1_BT_CUSTOMISED_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 10: // Bit 9 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit6 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_1_BT_CUSTOMISED_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 11: // Bit 10 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit7 = input(PIN_IBC_RCV); 
....................              
....................             // We have received all data so now we can release Timer0 Critical Run 
....................             g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
....................              
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_1_BT_CUSTOMISED_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................              
....................         case 12: // STOP Bit 
....................             // Check if the Stop Bit is High. 
....................             if(1 == input(PIN_IBC_RCV)) // Stop bit detected 
....................             { 
....................                 // Byte received successfully 
....................                 // Save received byte to the Message Array 1 
....................                 //g_arruiIBCRxMsg1[g_uiIBCRxByteCount1 - 1] = g_unTempRxData1.m_uiByte; 
....................             } 
....................             else 
....................             {  
....................                 // Handle error. 
....................                 // Framing error. 
....................                 // Set Flag tracking Framing Error. 
....................                 //g_uiIBCRxFramingErr1 = 1; 
....................                 //g_uiIBCSTXReceived1  = 0; 
....................             } 
....................             // Disable Timer1. 
....................             setup_timer_1 (T1_DISABLED); 
....................             disable_interrupts(INT_TIMER1);  
....................             // Clear Timer1 interrupt. 
....................             clear_interrupt(INT_TIMER1);  
....................   
....................              
....................             g_i8RcvByteCount++; 
....................             if (5 == g_i8RcvByteCount) 
....................             { 
....................                 g_i8RcvByteCount = 0; 
....................             } 
....................             // Now check the Byte Sequence 
....................             g_stIBCRcvData.g_ui8ArrIBCData[g_unIBCRcvByteNode.m_ui8Arr[0]] = g_unIBCRcvByteNode.m_ui8Arr[1]; 
....................              
....................             if ((IBC_MSG_BYTE_COUNT - 1) == g_unIBCRcvByteNode.m_ui8Arr[0]) 
....................             { 
....................                 // The complete 5 byte data has been received 
....................                 // Now we can process the data 
....................                 g_fIBCDataReceived = 1; 
....................                  
....................                 // Insert Message into IBC Receive Queue 
.................... ////////                InsertIBCMsgQueue(&g_stIBCRcvQueue, &g_stIBCRcvData);   
....................             } 
....................             // Reset Rx Bit Counter. 
....................             g_ui8IBCRcvBitCount = 0; 
....................              
....................             // Enable External Interrupt to detect next byte. 
.................... #ifdef M1_COMM_MODULE 
....................             ext_int_edge(1, H_TO_L);  
....................             clear_interrupt(INT_EXT1); 
....................             enable_interrupts(INT_EXT1); 
.................... #else 
....................             ext_int_edge(3, H_TO_L);  
....................             clear_interrupt(INT_EXT3); 
....................             enable_interrupts(INT_EXT3); 
.................... #endif 
....................             break; 
....................  
....................         default: 
....................             // Framing error. 
....................             // Set Flag tracking Framing Error. 
....................             //g_uiIBCRxFramingErr1 = 1; 
....................              
....................             // First release Timer0 Critical run lock 
....................             g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
....................              
....................             // Disable Timer1. 
....................             setup_timer_1 (T1_DISABLED); 
....................             disable_interrupts(INT_TIMER1);  
....................             // Clear Timer1 interrupt. 
....................             clear_interrupt(INT_TIMER1);  
....................              
....................             // Reset Rx Bit Counter 1. 
....................             g_ui8IBCRcvBitCount = 0; 
....................              
....................             // Enable External Interrupt 0 to detect next start bit. 
....................             ext_int_edge(1, H_TO_L);  
....................             clear_interrupt(INT_EXT1); 
....................             enable_interrupts(INT_EXT1); 
....................             break; 
....................     } 
....................      
.................... } 
....................  
....................  
....................  
.................... #endif /* _VI_IBC_CONFIG_H_ */ 
....................  
.................... //#include "../vmCommon.h" 
.................... #include "vmTime.h" // arijita 
.................... #ifndef _VM_TIME_CONFIG_H_ 
.................... #define _VM_TIME_CONFIG_H_ 
....................  
.................... //#include "18F46K80.h" 
.................... #include "vmModbusGlobal.h" 
.................... #ifndef _VI_MODBUS_GOBAL_H_ 
.................... #define _VI_MODBUS_GOBAL_H_ 
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE 64   
.................... #define MODBUS_REG_BUFFER_SIZE 10    
....................   
.................... #define MODBUS_REG_OUTPUT_0  	0  
.................... #define MODBUS_REG_OUTPUT_1		1 
.................... #define MODBUS_REG_OUTPUT_2		2 
.................... #define MODBUS_REG_OUTPUT_3		4 
.................... #define MODBUS_REG_OUTPUT_4		8 
.................... #define MODBUS_REG_OUTPUT_5		16 
.................... #define MODBUS_REG_OUTPUT_6		32 
.................... #define MODBUS_REG_OUTPUT_7		64 
.................... #define MODBUS_REG_OUTPUT_8		128 
.................... #define MODBUS_REG_OUTPUT_9		256 
.................... #define MODBUS_REG_OUTPUT_10	512 
.................... #define MODBUS_REG_OUTPUT_11	1024 
.................... #define MODBUS_REG_OUTPUT_12	2048 
.................... #define MODBUS_REG_OUTPUT_13	4096 
.................... #define MODBUS_REG_OUTPUT_14	8192 
.................... #define MODBUS_REG_OUTPUT_15	16384 
.................... #define MODBUS_REG_OUTPUT_16	32768 
....................  
.................... #define MODBUS_AUTO_CALIBRATION  	1  
.................... #define MODBUS_FIXED_CALIBRATION    0 
....................  
.................... enum function { 
.................... 	RS485_FUNCTION_READ_COILS                 = 1, 
.................... 	RS485_FUNCTION_READ_DISCRETE_INPUT        = 2, 
.................... 	RS485_FUNCTION_READ_HOLDING_REGISTERS     = 3, 
.................... 	RS485_FUNCTION_READ_INPUT_REGISTERS       = 4, 
.................... 	RS485_FUNCTION_WRITE_SINGLE_COIL          = 5, 
.................... 	RS485_FUNCTION_WRITE_SINGLE_REGISTER      = 6, 
.................... 	RS485_FUNCTION_READ_MULTIPLE_REGISTERS    = 15, 
.................... 	RS485_FUNCTION_WRITE_MULTIPLE_REGISTERS   = 16		 
.................... }; 
....................  
.................... enum exception { 
.................... 	RS485_ILLEGAL_FUNCTION        = 1,	 
.................... 	RS485_ILLEGAL_DATA_ADDRESS    = 2, 
.................... 	RS485_ILLEGAL_DATA_VALUE      = 3, 
.................... 	RS485_SLAVE_DEVICE_FAILED     = 4, 
.................... 	RS485_ACKNOWLAGE              = 5, 
.................... 	RS485_SLAVE_DEVICE_BUSY       = 6, 
.................... 	RS485_NEG_ACKNOWLAGE          = 7, 
.................... 	RS485_MEMORY_PARITY_ERROR     = 8, 
.................... 	RS485_GETWAY_PATH             = 10, 
.................... 	RS485_GETWAY_DEVICE           = 11	 
.................... }; 
....................  
.................... typedef struct 
.................... {  
....................    unsigned int8    ui8Slaveid;  
....................    unsigned int16   u16Address; 
....................    unsigned int16   u16LenData;                       //number of bytes in the message received  
....................    function         func;                           //the function of the message received  
....................    exception        error;                         //error recieved, if any  
....................    unsigned int16   ui16RegisterData; 
.................... //   unsigned int8    ui8Data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received  
....................    BOOLEAN          bDataProcessed; 
....................    unsigned int8    ui8NoRegDataBytes; 
....................    unsigned int16   ui16RegisterDataArr[MODBUS_REG_BUFFER_SIZE]; 
....................    unsigned int32   u32RegData; 
.................... } Modbus_Rx;  
....................  
.................... Modbus_Rx g_ModbusRx; 
....................  
.................... // use for calibration data 
.................... unsigned int16 g_ui16Register0_1; 
.................... unsigned int16 g_ui16Register0_2; 
.................... unsigned int16 g_ui16Register1000_1; 
.................... unsigned int16 g_ui16Register1000_2; 
.................... unsigned int16 g_ui16Register2000_1; 
.................... unsigned int16 g_ui16Register2000_2; 
.................... unsigned int16 g_ui16Register3000_1; 
.................... unsigned int16 g_ui16Register3000_2; 
.................... unsigned int16 g_ui16Register4000_1; 
.................... unsigned int16 g_ui16Register4000_2; 
.................... unsigned int16 g_ui16Register5000_1; 
.................... unsigned int16 g_ui16Register5000_2; 
.................... unsigned int16 g_ui16Register6000_1; 
.................... unsigned int16 g_ui16Register6000_2; 
.................... unsigned int16 g_ui16Register7000_1; 
.................... unsigned int16 g_ui16Register7000_2; 
.................... unsigned int16 g_ui16Register8000_1; 
.................... unsigned int16 g_ui16Register8000_2; 
.................... unsigned int16 g_ui16Register9000_1; 
.................... unsigned int16 g_ui16Register9000_2; 
.................... unsigned int16 g_ui16Register10000_1; 
.................... unsigned int16 g_ui16Register10000_2; 
....................  
.................... unsigned int16 g_ui16RegisterCurrentCalibrationWeight; 
.................... unsigned int16 g_ui16RegisterCurrentCalibrationPoint; 
.................... unsigned int8  g_fStartCalibration; 
.................... unsigned int32 g_ui32TareADCValueForCalibration; 
.................... unsigned int32 g_ui32gWeightADCValueForCalibration; 
.................... unsigned int16 g_ui16gAvgWtForCalibration; 
....................  
.................... unsigned int16 g_ui16RegisterAvgWeight; 
.................... unsigned int16 g_ui16RegisterTolPv; 
.................... unsigned int16 g_ui16RegisterTolNv; 
.................... unsigned int16 g_ui16RegisterCurrProductIndex; 
....................  
.................... // use for production  
.................... unsigned int16 g_ui16CBBCount; 
.................... unsigned int16 g_ui16CBBCountPrev; 
.................... unsigned int16 g_ui16CurrentWt; 
.................... unsigned int16 g_ui16CurrentPassStatus; 
.................... unsigned int16 g_ui16RunningAvgWt; 
.................... unsigned int16 g_ui16RunningTareValue; 
.................... unsigned int16 g_ui16ServerStatus; 
....................  
.................... unsigned int16 g_ui16FlagForSetTareValue; 
....................  
.................... // use for system date time 
.................... unsigned int16 g_ui16RegisterDateYY; 
.................... unsigned int16 g_ui16RegisterDateMM; 
.................... unsigned int16 g_ui16RegisterDateDD; 
....................  
.................... unsigned int16 g_ui16RegisterTime_HH; 
.................... unsigned int16 g_ui16RegisterTime_mm; 
.................... unsigned int16 g_ui16RegisterTime_ss; 
....................  
.................... unsigned int16 g_ui16RegisterTime_Diff; 
....................  
.................... // use for pre production 
.................... unsigned int16 g_ui16CurrProdIndex; 
.................... unsigned int16 g_ui16CurrProdAvgWt; 
.................... unsigned int16 g_ui16CurrProdPvTol; 
.................... unsigned int16 g_ui16CurrProdNvTol; 
....................  
.................... // Use for Current Mode 
.................... unsigned int16 g_ui16CurrentMode; 
....................  
.................... // use for production type 
.................... unsigned int8  g_fAutoCalibrationMode; 
....................  
.................... // use for sample count for auto calibration 
.................... unsigned int16 g_ui16AutoCalibrationSampleCount; 
....................  
.................... // Use for store load cell factor. 
.................... unsigned int16 g_ui16CurrLoadCellFactor; 
....................  
.................... #endif /* _VI_MODBUS_GOBAL_H_ */ 
....................  
....................  
.................... #include <time.h> 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                       /// 
.................... ///                               time.h                                  /// 
.................... ///                                                                       /// 
.................... /// Time algorithms.  This follows the standard C API, with the following /// 
.................... /// exceptions:                                                           /// 
.................... ///   * ctime() has another input parameter which is the pointer to where /// 
.................... ///     the input string is.  Normally ctime() and asctime() write the    /// 
.................... ///     output to a globally allocated string and return a pointer to     /// 
.................... ///     this string.  This library doesn't want to make this assumption   /// 
.................... ///     so the library doesn't allocate the space needed for those        /// 
.................... ///     functions.                                                        /// 
.................... ///   * asctime() has nother input parameter which is the pointer to      /// 
.................... ///     where the input string is.  See the above paragraph.              /// 
.................... ///   * strftime() is not supported.                                      /// 
.................... ///   * SetTime() is added that initializes/set the current time.         /// 
.................... ///   * GetTime() is added so you can read directly into a struct_tm,     /// 
.................... ///      instead of having to use localtime(time()) which is usually      /// 
.................... ///       innefecient.                                                    /// 
.................... ///   * TimeInit() added for any real time clock devices that may need    /// 
.................... ///      to be initialized first.                                         /// 
.................... ///   * Not all timebases have a tick system, so it's not recommended     /// 
.................... ///      to use clock().  If you need clock(), look at CCS's              /// 
.................... ///      #use timer() library.                                            /// 
.................... ///                                                                       /// 
.................... /// This file only provides the prototypes and definitions needed to      /// 
.................... /// proved a time alogrithm that follows the C standard library.  You     /// 
.................... /// also need to include/link the actual library that performs the time   /// 
.................... /// base.  As of this writing CCS provides the following compatible       /// 
.................... /// timebase libraries:                                                   /// 
.................... ///      rtcperipheral.c - for PICs with internal real time clock.        /// 
.................... ///      ds1305.c - external DS1305 real time clock.                      /// 
.................... ///      rtcticks.c - Use a PIC's timer with CCS #use timer() library.    /// 
.................... ///                                                                       /// 
.................... /// API:                                                                  /// 
.................... ///                                                                       /// 
.................... /// Variable definitions:                                                 /// 
.................... ///   c - clock timer (clock_t), number of ticks since powerup.  See      /// 
.................... ///       CLOCKS_PER_SECOND to determine clock rate.                      /// 
.................... ///                                                                       /// 
.................... ///   t - second timer (time_t), number of seconds since Jan 1st, 1970.   /// 
.................... ///                                                                       /// 
.................... ///   ts - time struct (struct_tm), a structure that holds time in        /// 
.................... ///        descriptive format (seconds, minutes, hours, day, month, etc). /// 
.................... ///                                                                       /// 
.................... /// CLOCKS_PER_SECOND - This is a constant which needs to be defined that /// 
.................... ///   configures the timebase used by the clock timer and clock().        /// 
.................... ///   If you are not using clock() then you don't need to define this.    /// 
.................... ///   If you are using a method such a PIC's timer for the timebase then  /// 
.................... ///   you will need to set this.                                          /// 
.................... ///                                                                       /// 
.................... /// c = clock() - Return current clock timer.                             /// 
.................... ///                                                                       /// 
.................... /// t = time(*t) - Return current second timer.  Returns twice (as a      /// 
.................... ///         a return, and saves to input pointer).                        /// 
.................... ///                                                                       /// 
.................... /// SetTime(*tm) - Initializes the current time with a struct_tm          /// 
.................... ///                                                                       /// 
.................... /// SetTimeSec(t) - Initializes the current time with a seconds time      /// 
.................... ///                                                                       /// 
.................... /// t = mktime(*tm) - Converts a time struct to a second timer.           /// 
.................... ///                                                                       /// 
.................... /// t = difftime(t,t) - Returns difference between two second timers.     /// 
.................... ///                                                                       /// 
.................... /// *char = ctime(*t, *char) - Converts second timer to a readable string /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *char = asctime(*ts, *char) - Converts time struct to a readable      /// 
.................... ///                            string.                                    /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *ts = localtime(*t) - Converts second timer to a time struct.         /// 
.................... ///                  *ts points to a global time struct and will be       /// 
.................... ///                  corrupted in future calls to localtime().            /// 
.................... ///                                                                       /// 
.................... /// GetTime(*tm) - Returns the current time as a time struct              /// 
.................... ///                                                                       /// 
.................... /// TimeInit() - Initializes the timing device                            /// 
.................... ///                                                                       /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __TIME_H__ 
.................... #define __TIME_H__ 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
.................... #USE DYNAMIC_MEMORY 
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
....................        node->next= NULL; 
....................     else 
....................        node->next=place->next; 
....................     place->next=node; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu\r\n", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................  
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                    
....................  
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
.................... #ENDIF 
....................  
....................  
.................... /* API Types*/ 
.................... typedef signed int32 time_t; 
.................... typedef unsigned int32 clock_t; 
....................  
.................... typedef enum 
.................... { 
....................    SUNDAY = 0, 
....................    MONDAY, 
....................    TUESDAY, 
....................    WEDNESDAY, 
....................    THURSDAY, 
....................    FRIDAY, 
....................    SATURDAY    
.................... }  Weekday; 
....................  
.................... typedef enum 
.................... { 
....................    JANUARY = 0, 
....................    FEBRUARY, 
....................    MARCH, 
....................    APRIL, 
....................    MAY, 
....................    JUNE, 
....................    JULY, 
....................    AUGUST, 
....................    SEPTEMBER, 
....................    OCTOBER, 
....................    NOVEMBER, 
....................    DECEMBER 
.................... }  Month; 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int8 tm_sec;   // seconds after the minute (0-59) 
....................    unsigned int8 tm_min;   // minutes after the hour (0-59) 
....................    unsigned int8 tm_hour;  // hours since midnight (0-23) 
....................    unsigned int8 tm_mday;  // day of the month (0-30) 
....................    Month tm_mon;           // month of the year (0-11) 
....................    unsigned int16 tm_year; // years since 1900 
....................    Weekday tm_wday;        // day of the week (0-6) (Sunday=0) 
....................    unsigned int16 tm_yday; // day of the year (0-365) 
.................... } struct_tm; 
....................  
....................  
.................... /* Functions */ 
.................... clock_t clock(void); 
.................... time_t time(time_t * timer); 
.................... signed int32 difftime(time_t later, time_t earlier); 
.................... time_t mktime(struct_tm * timeT); 
....................  
.................... char * asctime(struct_tm * timeptr, char *szTime); 
.................... char * ctime(time_t * timer, char *szTime); 
.................... struct_tm * localtime ( time_t * timer ); 
.................... void SetTime(struct_tm * nTime); 
.................... void SetTimeSec(time_t sTime); 
.................... void GetTime(struct_tm *pRetTm); 
.................... void TimeInit(void); 
....................  
.................... #endif 
....................  
.................... #include <time.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... ///                              time.c                                 /// 
.................... ///                                                                     /// 
.................... /// Contains common time routines that can be used by several           /// 
.................... /// timebases, and the runtime code needed for time.h.                  /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __TIME_C__ 
.................... #define __TIME_C__ 
....................  
.................... /* Returns the number of days in a given month, leap year dependent 
....................  */ 
.................... unsigned int8 DaysInMonth(unsigned int8 month, int1 IsLeapYear) 
.................... { 
....................    switch(month) 
....................    { 
....................       case JANUARY: 
....................       case MARCH: 
....................       case MAY: 
....................       case JULY: 
....................       case AUGUST: 
....................       case OCTOBER: 
....................       case DECEMBER: 
....................          return 31; 
....................  
....................       case FEBRUARY: 
....................          if(IsLeapYear) 
....................             return 29;             
....................          return 28; 
....................  
....................       case APRIL: 
....................       case JUNE: 
....................       case SEPTEMBER: 
....................       case NOVEMBER: 
....................          return 30; 
....................        
....................       // error 
....................       default: 
....................          return 0; 
....................    } 
.................... }  
....................  
.................... /* Formats a given week day (as an integer) to a string 
....................  */ 
.................... void WeekdayAbbreviations(unsigned int8 day, char* wString) 
.................... { 
....................    switch(day) 
....................    { 
....................       case SUNDAY: 
....................       memcpy(wString,"Sun\0",4); 
....................       break; 
....................        
....................       case MONDAY: 
....................       memcpy(wString,"Mon\0",4); 
....................       break; 
....................        
....................       case TUESDAY: 
....................       memcpy(wString,"Tue\0",4); 
....................       break; 
....................        
....................       case WEDNESDAY: 
....................       memcpy(wString,"Wed\0",4); 
....................       break; 
....................        
....................       case THURSDAY: 
....................       memcpy(wString,"Thu\0",4); 
....................       break; 
....................        
....................       case FRIDAY: 
....................       memcpy(wString,"Fri\0",4); 
....................       break; 
....................        
....................       case SATURDAY: 
....................       memcpy(wString,"Sat\0",4); 
....................       break; 
....................        
....................       default: 
....................       memcpy(wString,"Invalid\0",8); 
....................       break; 
....................    } 
.................... } 
....................  
.................... /* Formats a given month (as an integer) to a string 
....................  */ 
.................... void MonthAbbreviations(unsigned int8 month, char* mString) 
.................... { 
....................    switch(month) 
....................    { 
....................       case JANUARY: 
....................       memcpy(mString,"Jan\0",4); 
....................       break; 
....................        
....................       case FEBRUARY: 
....................       memcpy(mString,"Feb\0",4); 
....................       break; 
....................        
....................       case MARCH: 
....................       memcpy(mString,"Mar\0",4); 
....................       break; 
....................        
....................       case APRIL: 
....................       memcpy(mString,"Apr\0",4); 
....................       break; 
....................        
....................       case MAY: 
....................       memcpy(mString,"May\0",4); 
....................       break; 
....................        
....................       case JUNE: 
....................       memcpy(mString,"Jun\0",4); 
....................       break; 
....................        
....................       case JULY: 
....................       memcpy(mString,"Jul\0",4); 
....................       break; 
....................        
....................       case AUGUST: 
....................       memcpy(mString,"Aug\0",4); 
....................       break; 
....................        
....................       case SEPTEMBER: 
....................       memcpy(mString,"Sep\0",4); 
....................       break; 
....................        
....................       case OCTOBER: 
....................       memcpy(mString,"Oct\0",4); 
....................       break; 
....................        
....................       case NOVEMBER: 
....................       memcpy(mString,"Nov\0",4); 
....................       break; 
....................        
....................       case DECEMBER: 
....................       memcpy(mString,"Dec\0",4); 
....................       break; 
....................        
....................       default: 
....................       memcpy(mString,"Invalid\0",8); 
....................       break; 
....................    } 
.................... } 
.................... /* Determines if a year is a leap year 
....................  * 'year' is the number of years since 1900 
....................  * A year is a leap year if is evenly divisible by 4 while not divisible by 100 
....................  * or if it is evenly divisible by 400. (Ex. 2000 is a leap year, 2100 is not) 
....................  * Returns TRUE if the year is a leap year, FALSE if not 
....................  */ 
.................... int1 LeapYear(unsigned int16 year) 
.................... { 
....................    if( ((year + 1900) % 400 == 0) ||  
....................        (((year + 1900) % 4 == 0) && ((year + 1900) % 100 != 0)) ) 
....................       return TRUE; 
....................       
....................    return FALSE; 
.................... } 
....................  
.................... /* Returns the difference in seconds between two times 
....................  * Times later and earlier are expressed in seconds  
....................  */ 
.................... signed int32 difftime(time_t later, time_t earlier) 
.................... { 
....................    return (later - earlier); 
.................... } 
....................  
.................... /* Calculates the Unix Time from a standard time format 
....................  * Returns the Unix Time (time in seconds since Jan 1, 1970 00:00:00) 
....................  */ 
.................... time_t mktime(struct_tm * timeT) 
.................... { 
....................    time_t unixTime = 0; 
....................    int1 isLeapYear = FALSE; 
....................    unsigned int16 i = 0; 
....................     
....................    if(timeT != NULL) 
....................    { 
....................     
....................       unixTime += timeT->tm_sec; 
....................       unixTime += (unsigned int32)(timeT->tm_min) * 60; 
....................       unixTime += (unsigned int32)(timeT->tm_hour) * 3600; 
....................        
....................       isLeapYear = LeapYear(timeT->tm_year); 
....................        /* Clamp the month to [0,11) */ 
....................       timeT->tm_mon %= 12; 
....................       for(i = 1;i <= timeT->tm_mon;i++) 
....................       { 
....................          unixTime += (DaysInMonth(i - 1,isLeapYear) * 86400); 
....................       } 
....................        
....................       /* Clamp the days in the month */ 
....................       timeT->tm_mday %= DaysInMonth(timeT->tm_mon,isLeapYear); 
....................       unixTime += (timeT->tm_mday) * 86400; 
....................        
....................       if(isLeapYear) 
....................       { 
....................          timeT->tm_yday = (unixTime / 86400) % 366; 
....................       } 
....................       else 
....................       { 
....................          timeT->tm_yday = (unixTime / 86400) % 365; 
....................       } 
....................        
....................       i = 70; 
....................       if(timeT->tm_year - 70 >= 0) 
....................       { 
....................          while(i < (timeT->tm_year)) 
....................          { 
....................             isLeapYear = LeapYear(i); 
....................             if(isLeapYear) 
....................             { 
....................                unixTime += (31622400); // seconds in 366 days 
....................             } 
....................             else 
....................             { 
....................                unixTime += (31536000); // seconds in 365 days 
....................             } 
....................             i++; 
....................          } 
....................       } 
....................        
....................       timeT->tm_wday = ((unixTime / 86400) + 4) % 7; 
....................    } 
....................  
....................    return unixTime; 
.................... } 
....................  
.................... /* Returns the given time as a string of the form:  
....................  *  Day Mon X HH:MM:SS YYYY\0  
....................  */ 
.................... char * asctime ( struct_tm * timeptr, char * szTime) 
.................... { 
....................    char szDay[8]; 
....................    char szMon[8]; 
....................     
....................    WeekdayAbbreviations(timeptr->tm_wday, szDay); 
....................    MonthAbbreviations(timeptr->tm_mon, szMon); 
....................     
....................    sprintf(szTime,"%s %s %d %02d:%02d:%02d %04Lu", 
....................       szDay, 
....................       szMon, 
....................       timeptr->tm_mday + 1, 
....................       timeptr->tm_hour, 
....................       timeptr->tm_min, 
....................       timeptr->tm_sec, 
....................       (timeptr->tm_year + 1900)); 
....................        
....................    return szTime; 
.................... } 
....................  
.................... /* Converts the given calendar time (in seconds) to local time  
....................  * and returns the equivalent string.  
....................  */ 
.................... char * ctime ( time_t * timer, char *szTime ) 
.................... { 
....................    return (asctime(localtime(timer),szTime)); 
.................... } 
....................  
.................... /* Global local time variable */ 
.................... struct_tm g_lTime; 
....................  
.................... /* Converts the given calendar time (in seconds) to local time 
....................  * and sets this time in the global g_lTime 
....................  * Returns a pointer to g_lTime 
....................  */ 
.................... struct_tm * localtime(time_t * timer) 
.................... { 
....................    time_t timeCounter; 
....................    int1 done = FALSE; 
....................    int1 isLeapYear = FALSE;//1970 is not a leap year 
....................  
....................    if(timer != NULL) 
....................    { 
....................       timeCounter = *timer; 
....................       g_lTime.tm_wday = ((timeCounter / 86400) + 4) % 7;//fill in the weekday 
....................       g_lTime.tm_year = 70;//we are starting in 1970 
....................        
....................       while(!done) 
....................       { 
....................          if(timeCounter < (31622400) && isLeapYear) // seconds in 366 days 
....................          { 
....................             g_lTime.tm_yday = (timeCounter / 86400); 
....................             break; 
....................          } 
....................          else if(timeCounter < (31536000)) // seconds in 365 days 
....................          { 
....................             g_lTime.tm_yday = (timeCounter / 86400); 
....................             break; 
....................          } 
....................           
....................          if(isLeapYear) 
....................          { 
....................             timeCounter -= 31622400; // seconds in 366 days 
....................          } 
....................          else 
....................          { 
....................             timeCounter -= 31536000; // seconds in 365 days 
....................          } 
....................           
....................          g_lTime.tm_year++; 
....................          isLeapYear = LeapYear(g_lTime.tm_year); 
....................       } 
....................        
....................       g_lTime.tm_mon = 0; 
....................       while(!done) 
....................       {          
....................          if(timeCounter < DaysInMonth(g_lTime.tm_mon,isLeapYear) * 86400) 
....................          { 
....................             break; 
....................          } 
....................          else if(timeCounter >= DaysInMonth(g_lTime.tm_mon,isLeapYear) * 86400) 
....................          { 
....................             timeCounter -= DaysInMonth(g_lTime.tm_mon,isLeapYear) * 86400; 
....................             g_lTime.tm_mon++; 
....................          } 
....................       }   
....................  
....................       g_lTime.tm_mday = (timeCounter / (86400)); 
....................       timeCounter -= (g_lTime.tm_mday * (86400)); 
....................        
....................       g_lTime.tm_hour = (timeCounter / (3600)); 
....................       timeCounter -= ((unsigned int32)g_lTime.tm_hour) * 3600; 
....................        
....................       g_lTime.tm_min = (timeCounter / 60); 
....................       timeCounter -= (((unsigned int16)g_lTime.tm_min) * 60); 
....................       
....................       g_lTime.tm_sec = timeCounter; 
....................    } 
....................     
....................    return &g_lTime; 
.................... } 
....................  
.................... #endif 
....................  
.................... //#include "vmHMIBoardModbusSetup.h" 
....................  
.................... #define SYSTEM_BASE_DATE 		1900 
.................... #define SYSTEM_HH_TO_SS 		3600 
.................... #define SYSTEM_MM_TO_SS 		60 
....................  
....................  
.................... unsigned int32 GetRTC(void) 
.................... { 
....................     struct_tm lDate;     
....................  
....................     unsigned int16 ui16SSDiff = 0; 
....................     unsigned int16 ui16MMDiff = 0; 
....................     unsigned int16 ui16HHDiff = g_ui16RegisterTime_Diff / SYSTEM_HH_TO_SS; 
....................     ui16SSDiff = g_ui16RegisterTime_Diff % SYSTEM_HH_TO_SS; 
....................     ui16MMDiff = ui16SSDiff / SYSTEM_MM_TO_SS; 
....................     ui16SSDiff = ui16SSDiff % SYSTEM_MM_TO_SS; 
....................      
....................     lDate.tm_sec = (unsigned int8) g_ui16RegisterTime_ss + ui16SSDiff;   
....................     lDate.tm_min = (unsigned int8)g_ui16RegisterTime_mm + ui16MMDiff;   
....................     lDate.tm_hour = (unsigned int8)g_ui16RegisterTime_HH + ui16HHDiff;   
....................     lDate.tm_mday = (unsigned int8) g_ui16RegisterDateDD;   
....................     lDate.tm_mon = (Month) g_ui16RegisterDateMM;   
....................     lDate.tm_year = (unsigned int16) g_ui16RegisterDateYY - SYSTEM_BASE_DATE;   
....................  
....................     time_t lTimeEpoch = mktime(&lDate); 
....................     return lTimeEpoch; 
.................... //lTimeEpoch 
.................... } 
....................  
.................... #endif /* _VM_TIME_CONFIG_H_ */ 
....................  
....................  
.................... #include "../M1_Comm_Module/vmCommon.h" 
.................... #ifndef VM_IMW_COMMON_H 
.................... #define VM_IMW_COMMON_H 
....................  
.................... #define MODE_PRODUCTION                  0  
.................... #define MODE_CALIBRATION                 1 
....................  
.................... #define HIGHEST_16_BIT_UNSIGNED_INTERGER 65535 
....................  
.................... #define FLAG_LDCDISP_DATA_FETCH_ON       1 
.................... #define FLAG_LDCDISP_DATA_FETCH_OFF      0 
....................  
.................... #define SIZE_LDCDISP_VALUE               100 
....................  
.................... #define PIN_HIGH                         0   
.................... #define PIN_LOW                          1  
....................  
.................... #define VARITY_1                         1 
.................... #define VARITY_2                         2 
.................... #define VARITY_3                         3 
.................... #define VARITY_4                         4 
.................... #define VARITY_5                         5 
.................... #define VARITY_6                         6 
....................  
.................... #define READY_TO_FEED_DELAY_ON			 12 
.................... #define READY_TO_FEED_DELAY_OFF			 13 
....................  
.................... #define READY_TO_FEED_DELAY_TIMEOUT      1000 
....................  
.................... #define POSITIVE_ERROR_FACTOR            17 
.................... #define NEGATIVE_ERROR_FACTOR  			 18 
.................... #define NO_ERROR_FACTOR					 19 
....................  
....................  
.................... //**************** For Dynamic Error Calculation ************************ 
.................... 	 
.................... #define DEC_ACTIVE_MODE                  45 
.................... #define DEC_DEACTIVE_MODE                46	 
....................  
.................... #define DEC_LDCD_ARR_SIZE                200 
.................... #define DEC_LDCD_RECEIVED_BYTE_COUNT_GREATER_THAN_100     12 
.................... #define DEC_LDCD_RECEIVED_BYTE_COUNT_LESS_THAN_100        13   
....................  
.................... #define ERROR_FACTOR_FOR_2000GM							  15 
.................... #define ERROR_FACTOR_FOR_5240GM							  19 
.................... #define ERROR_FACTOR_FOR_7340GM							  19 
....................  
.................... //************************** End **************************************** 
....................  
.................... //****************  For Dynamic Speed Calculation *********************** 
....................  
.................... #define DSC_ACTIVE_MODE                  67 
.................... #define DSC_DECATIVE_MODE                68 
.................... #define DSC_CALCULATIVE_MODE             69 
....................  
.................... #define DISTANCE_MEASUREMENT_FOR_DSC     100 
....................  
.................... //*************************** End *************************************** 
....................  
.................... //****************************************************** 
.................... //************* Shift Register Delays ****************** 
.................... //****************************************************** 
....................  
.................... #define REJECTION_SOLENOID_BACK_TIMEOUT  470 
.................... #define PC_COMM_TX_LED_OFF_TIMEOUT       200 
.................... #define PC_COMM_RX_LED_OFF_TIMEOUT		 200 
.................... #define LDCD_TX_LED_OFF_TIMEOUT          200 
.................... #define LDCD_RX_LED_OFF_TIMEOUT          200 
....................  
.................... #define SOLENOID_BACK_START_TIME_COUNT    1 
.................... #define SOLENOID_BACK_STOP_TIME_COUNT     0 
....................  
.................... #define PC_TX_LED_OFF_START_TIME_COUNT       20 
.................... #define PC_TX_LED_OFF_STOP_TIME_COUNT        21 
....................  
.................... #define PC_RX_LED_OFF_START_TIME_COUNT       40 
.................... #define PC_RX_LED_OFF_STOP_TIME_COUNT        41 
....................  
.................... #define LDCD_TX_LED_OFF_START_TIME_COUNT     60 
.................... #define LDCD_TX_LED_OFF_STOP_TIME_COUNT      61 
....................  
.................... #define LDCD_RX_LED_OFF_START_TIME_COUNT     80 
.................... #define LDCD_RX_LED_OFF_STOP_TIME_COUNT      81 
....................  
.................... #define LDCD_TX_LED_ON						 30 
.................... #define LDCD_TX_LED_OFF						 31 
....................  
.................... #define LDCD_RX_LED_ON					     35 
.................... #define LDCD_RX_LED_OFF					     36 
....................  
.................... #define PC_COMM_RX_LED_ON                    45 
.................... #define PC_COMM_RX_LED_OFF					 46 
....................  
.................... #define REJECTION_UNIT_ENGAGE				 75 
.................... #define REJECTION_UNIT_FREE					 76 
....................  
.................... //******************************************************* 
.................... //************** End ************************************ 
.................... //******************************************************* 
....................  
.................... #define LDCD_FILTER_TOLERANCE 5   // 50% Tolerance for Filter Value (Base is 10, Means 10 = 100%) 
.................... #define LDCD_FILTER_MEAN      50  // 80% Max is 100 
....................  
.................... //typedef union _UN_SHIPPER_WEIGHT 
.................... //{ 
.................... //    unsigned int16 m_ui16ShipperWeight; 
.................... //    BYTE           m_bArr[2]; 
.................... //} UN_SHIPPER_WEIGHT; 
.................... // 
.................... // 
.................... ////BYTE g_bCurMode  = MODE_PRODUCTION;  
.................... ////BYTE g_fLdCDispDataFetchState = FLAG_LDCDISP_DATA_FETCH_OFF; 
.................... // 
.................... ////************************************************************************************* 
.................... //// *********************** For Collection Of Running Weight *************************** 
.................... ////************************************************************************************* 
.................... //#define SIZE_RUNNING_WEIGHT_ARRAY                      200 
.................... //typedef struct _ST_RUNNING_WEIGHT_ARRAY 
.................... //{ 
.................... //    int16           m_i16ArrRunningWeight[SIZE_RUNNING_WEIGHT_ARRAY]; 
.................... //    int16           m_i16Rear; 
.................... //    unsigned int8   m_fRunningWeightArrayFull; 
.................... //} ST_RUNNING_WEIGHT_ARRAY; 
.................... // 
.................... //ST_RUNNING_WEIGHT_ARRAY g_stRunningWeightArray; 
.................... // 
.................... //// ****************************** End *************************************************  
.................... //// ************************************************************************************ 
.................... ////************** Shift Register  Global Variables ************************************* 
.................... ////************************************************************************************* 
.................... // 
.................... ////unsigned int16 g_fSolenoidBackTimeCountStart = SOLENOID_BACK_STOP_TIME_COUNT; 
.................... //// 
.................... ////unsigned int8  g_fPCCommTxLEDOffTimeCountStart = PC_TX_LED_OFF_STOP_TIME_COUNT; 
.................... ////unsigned int8  g_fPCCommRxLEDOffTimeCountStart = PC_RX_LED_OFF_STOP_TIME_COUNT; 
.................... ////unsigned int8  g_fLdCDTxLEDOffTimeCountStart   = LDCD_TX_LED_OFF_STOP_TIME_COUNT; 
.................... ////unsigned int8  g_fLdCDRxLEDOffTimeCountStart   = LDCD_RX_LED_OFF_STOP_TIME_COUNT; 
.................... ////unsigned int8  g_fLdCDTxLEDStatus              = LDCD_TX_LED_OFF; 
.................... ////unsigned int8  g_fLdCDRxLEDStatus    		   = LDCD_RX_LED_OFF; 
.................... ////unsigned int8  g_fPCCommRxLEDStatus			   = PC_COMM_RX_LED_OFF; 
.................... // 
.................... ////************************************************************************************* 
.................... ////**************************** End **************************************************** 
.................... ////************************************************************************************* 
.................... // 
.................... ////unsigned int16        g_ui16ArrCurLdCDValue[SIZE_LDCDISP_VALUE];  // Here we are holding the Load Cell Display Value 
.................... ////unsigned int8         g_ui8CountLdCDValue = 0;                    // This variable holds how many entries are 
.................... ////unsigned int8         g_ui8WtLdCDIdx      = 0; 
.................... ////                                                  
.................... ////unsigned int8 g_fDynamicSpeedCalculationStatus      = DSC_DECATIVE_MODE;    
.................... ////unsigned int16 g_ui16DynamicSpeedCalculationCounter = 0;      
.................... ////unsigned int8 g_ui8ConveyorDynamicSpeed             = 0;  
.................... ////BYTE g_fReadyToFeedON                               =  READY_TO_FEED_DELAY_OFF; 
.................... ////BYTE g_fErrorfactorStatus 							=  NO_ERROR_FACTOR; 
.................... ////BYTE g_fCurrRejectionUnitStatus						=  REJECTION_UNIT_FREE; 
.................... // 
.................... ////************************************************************************************* 
.................... //// *********************** For Dynamic Error Calculation ****************************** 
.................... ////************************************************************************************* 
.................... // 
.................... ////unsigned int8 g_fDynamicErrorCalculationStatus = DEC_DEACTIVE_MODE; 
.................... ////  
.................... ////int16 g_i16ArrCurrLdCDValuesDEC[DEC_LDCD_ARR_SIZE] = {0}; 
.................... ////unsigned int8 g_ui8DECLdCDReceivedArrIndex      = 0; 
.................... ////unsigned int8 g_ui8DECLdCDReceivedByteCount     = 0; 
.................... ////BYTE  g_fDECLdCDReceivedByteStatus              = DEC_LDCD_RECEIVED_BYTE_COUNT_LESS_THAN_100; 
.................... // 
.................... //// ****************************** End *************************************************       
.................... //                                                                   
.................... //BYTE g_fProcessModbusData = 0; 
.................... // 
.................... //int16 g_i16LdCDValueMax = 0; 
.................... //int16 g_i16LdCDValueMin = 0; 
.................... // 
.................... //void DELAY(unsigned int16 time) 
.................... //{ 
.................... //	unsigned int16 ui16Counter = 0; 
.................... //	while(ui16Counter < time) 
.................... //	{ 
.................... //		delay_ms(1); 
.................... //		ui16Counter++; 
.................... //	} 
.................... //} 
.................... // 
.................... // 
.................... ////TESTING 
.................... //int16 g_i16Mean = 0; 
.................... // 
.................... //int16 g_i16ErrorFactor = 0; 
.................... // 
.................... //// AK - start 
.................... //// Init running weight array 
.................... //void InitRunningWeightArray(void) 
.................... //{ 
.................... //    g_stRunningWeightArray.m_fRunningWeightArrayFull = 0; 
.................... //    g_stRunningWeightArray.m_i16Rear = -1; 
.................... //} 
.................... // 
.................... //// Is any data in running weight array 
.................... //int8 HasRunningWeightArrayData(void) 
.................... //{ 
.................... //    int8 i8HasData = (g_stRunningWeightArray.m_i16Rear) > 0 ? 1 : 0; 
.................... //    return i8HasData; 
.................... //} 
.................... // 
.................... //// Push Running data in data structure 
.................... //void PushRunningWeightData(int16 i16Data) 
.................... //{ 
.................... //    g_stRunningWeightArray.m_i16Rear++; 
.................... // 
.................... //    if(g_stRunningWeightArray.m_i16Rear >= SIZE_RUNNING_WEIGHT_ARRAY) 
.................... //    { 
.................... //       g_stRunningWeightArray.m_i16Rear = 0;  
.................... //       g_stRunningWeightArray.m_fRunningWeightArrayFull = 1; 
.................... //    } 
.................... // 
.................... //    g_stRunningWeightArray.m_i16ArrRunningWeight[g_stRunningWeightArray.m_i16Rear] = i16Data; 
.................... //} 
.................... // 
.................... //// Make running weight average 
.................... //int16 GetRunningWeightDataAverage() 
.................... //{ 
.................... //    int16 i16DataAvg = 0; 
.................... //    int32 i32DataAvg = 0; 
.................... //    int32 i32DataSum = 0; 
.................... //    int32 i32DataSize = 0; 
.................... //    int32 i32Index    = 0; 
.................... //     
.................... //    if(HasRunningWeightArrayData() <= 0)  
.................... //    { 
.................... //        return i16DataAvg; 
.................... //    } 
.................... //     
.................... //    i32DataSize = g_stRunningWeightArray.m_i16Rear + 1; 
.................... //     
.................... //    if(g_stRunningWeightArray.m_fRunningWeightArrayFull == 1) 
.................... //    { 
.................... //       i32DataSize = SIZE_RUNNING_WEIGHT_ARRAY;  
.................... //    } 
.................... // 
.................... //    for(i32Index = 0; i32Index < i32DataSize; i32Index++) 
.................... //    { 
.................... //        i32DataSum += g_stRunningWeightArray.m_i16ArrRunningWeight[i32Index]; 
.................... //    } 
.................... //     
.................... //    if(i32DataSize > 0) 
.................... //    { 
.................... //        i32DataAvg = (int32)(i32DataSum / i32DataSize); 
.................... //    } 
.................... //    i16DataAvg = (int16)i32DataAvg; 
.................... //     
.................... //    return i16DataAvg; 
.................... //} 
.................... // 
.................... //// Process running weight 
.................... //unsigned int16 ProcessWeightData(unsigned int16 ui16WeightData) 
.................... //{ 
.................... //    unsigned int16 i16RunningAvgWt = 0; 
.................... //    PushRunningWeightData(ui16WeightData); 
.................... //    i16RunningAvgWt = GetRunningWeightDataAverage(); 
.................... //    return i16RunningAvgWt; 
.................... //} 
.................... //// AR - end 
....................  
.................... #endif // VM_IMW_COMMON_H 
....................  
....................  
....................  
....................  
....................  
.................... //#define PIN_HIGH     			0 
.................... //#define PIN_LOW      			1 
.................... //#define MODBUS_ADDRESS_FOR_SET_AVG_CALIBRATION_POINT        0x296 
.................... #define SLAVE_ID                                            0x1 
....................  
.................... #define MODE_ADDRESS                            0x05 
.................... //#define ADDRESS_COUNTER_SEND_DATA               0x04 
....................  
.................... #define ADDRESS_FOR_SET_CALIB_0                 0x272 
.................... #define ADDRESS_FOR_SET_CALIB_1000              0x274 
.................... #define ADDRESS_FOR_SET_CALIB_2000              0x276 
.................... #define ADDRESS_FOR_SET_CALIB_3000              0x278 
.................... #define ADDRESS_FOR_SET_CALIB_4000              0x280 
.................... #define ADDRESS_FOR_SET_CALIB_5000              0x202 
.................... #define ADDRESS_FOR_SET_LOAD_CELL_FACTOR        0x282 
.................... #define ADDRESS_FOR_SET_CALIB_6000              0x284 
.................... #define ADDRESS_FOR_SET_CALIB_7000              0x286 
.................... #define ADDRESS_FOR_SET_CALIB_8000              0x288 
.................... #define ADDRESS_FOR_SET_CALIB_9000              0x290 
.................... #define ADDRESS_FOR_SET_CALIB_10000             0x292 
.................... #define ADDRESS_FOR_SET_CALIB_TARE              0x296  
....................  
.................... #define ADDRESS_FOR_CURRENT_CALIBRATION_WT      0x310 
.................... #define ADDRESS_FOR_CURRENT_CALIBRATION_PT      0x315 
.................... #define ADDRESS_FOR_START_CALIBRATION           0x299 
.................... #define ADDRESS_FOR_SET_CALIB_WEIGHT            0x298  
.................... #define ADDRESS_FOR_UPDATE_CALIB_TABLE          0x592 
....................  
....................  
.................... #define ADDRESS_FOR_SET_CONFIG_AVG_WT           0x250 
.................... #define ADDRESS_FOR_SET_CONFIG_TOL_PV           0x252 
.................... #define ADDRESS_FOR_SET_CONFIG_TOL_NV           0x254 
.................... #define ADDRESS_FOR_SET_CONFIG_INDEX            0x256 
....................  
.................... // use for production 
.................... #define ADDRESS_FOR_CBB_COUNT_IN_PRODUCTION         0x560 
.................... #define ADDRESS_FOR_CURRENT_WT_IN_PRODUCTION        0x562 
.................... #define ADDRESS_FOR_PASS_STATUS_WT_IN_PRODUCTION    0x564 // SET 1 for accept 
.................... #define ADDRESS_FOR_RUNNING_AVG_WT_IN_PRODUCTION    0x566 
.................... #define ADDRESS_FOR_TARE_VALUE_IN_PRODUCTION        0x568 
.................... #define ADDRESS_FOR_WRITE_TARE_VALUE                0x570 
.................... #define ADDRESS_FOR_SERVER_STATUS_WT_IN_PRODUCTION  0x700 
.................... #define ADDRESS_FOR_PREV_CBB_COUNT_IN_PRODUCTION    0x720 
....................  
.................... // use for preproduction 
.................... #define ADDRESS_FOR_PRODUCTION_INDEX_PRE_PRODUCTION  0x500 
.................... #define ADDRESS_FOR_PRODUCTION_AVG_WT_PRE_PRODUCTION 0x550 
.................... #define ADDRESS_FOR_PRODUCTION_PV_TOL_PRE_PRODUCTION 0x552 
.................... #define ADDRESS_FOR_PRODUCTION_NV_TOL_PRE_PRODUCTION 0x554 
....................  
.................... #define ADDRESS_FOR_YEAR                            0x10 
.................... #define ADDRESS_FOR_MONTH                           0x11 
.................... #define ADDRESS_FOR_DATE                            0x12 
.................... #define ADDRESS_FOR_HOUR                            0x14 
.................... #define ADDRESS_FOR_MINUTE                          0x15 
.................... #define ADDRESS_FOR_SECOND                          0x16 
....................  
.................... // use for calibration type set 
.................... #define ADDRESS_FOR_CALIBRATION_TYPE                0x710 
.................... #define ADDRESS_FOR_AUTO_CALIB_SAMPLE_COUNT         0x711 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... #define SIZE_TEMP_ARR_CRC_VALID                        15 
.................... #define MSG_QUEUE_EMPTY                                 0 
.................... #define MSG_QUEUE_NOT_EMPTY                             1 
.................... #define MODBUS_MASTER_QUERY_LENGTH_MIN                  8 
.................... #define MODBUS_MASTER_QUERY_LENGTH_MIX                 12 
.................... #define MODBUS_MASTER_QUERY_READ_REG_LENGTH             8 
.................... #define MODBUS_MASTER_QUERY_SINGLE_WRITE_REG_LENGTH     8 
....................  
.................... #define MODBUS_OFFSET_ONE       1 
.................... #define MODBUS_OFFSET_TWO       2 
.................... #define MODBUS_OFFSET_THREE     3 
.................... #define MODBUS_OFFSET_FOUR      4 
.................... #define MODBUS_OFFSET_FIVE      5 
.................... #define MODBUS_OFFSET_SIX       6 
.................... #define MODBUS_OFFSET_SEVEN     7 
.................... #define MODBUS_OFFSET_8         8 
.................... #define MODBUS_OFFSET_9         9 
.................... #define MODBUS_OFFSET_10        10 
.................... #define MODBUS_OFFSET_11        11 
.................... #define MODBUS_OFFSET_12        12 
.................... #define MODBUS_OFFSET_13        13 
.................... #define MODBUS_OFFSET_14        14 
.................... #define MODBUS_OFFSET_15        15 
.................... #define MODBUS_OFFSET_16        16 
....................  
.................... typedef struct _ST_ISR_QUEUE_MEMBERS 
.................... { 
....................     unsigned int8 m_ui8Arr[RS485_RX_BUFF_SIZE]; 
....................     int8 m_i8Front; 
....................     int8 m_i8Rear; 
....................      
.................... }ST_ISR_QUEUE_MEMBERS; 
....................  
.................... typedef struct _ST_GPRS_MSG_HEADER 
.................... { 
....................     unsigned int8   m_ui8NoOfMessages; 
....................     unsigned int16  m_ui16MachineID; 
....................     unsigned int8   m_ui8Variety; 
.................... } ST_GPRS_MSG_HEADER;  
....................  
.................... ST_ISR_QUEUE_MEMBERS g_stUART2RcvBuffModbus; 
.................... unsigned int8 g_ui8TempByte = 0; 
.................... unsigned int8 g_ui8TempArrForCRCValidation[SIZE_TEMP_ARR_CRC_VALID] = {0}; 
.................... ST_GPRS_MSG_HEADER       g_stGPRSMsgHeader; 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #define REG_DATA_LO_TO_HI                       1 // 1 = lo byte first, 2 = lo byte last 
....................  
....................  
.................... unsigned int8 g_ui8RS485RxByteCount               = 0; 
.................... unsigned int8 g_ui8ReceivedModbusResponse         = 0; 
.................... unsigned int8 g_ui8RS485MaxByteCount              = 8; 
.................... unsigned int8 g_ui8RS485Done              		  = 0; 
.................... unsigned int8 g_uiInputOutputMatch				  = 0; 
....................  
.................... unsigned int8 g_ui8Front                          = 0; 
.................... unsigned int8 g_ui8End                            = 0; 
....................  
....................  
.................... // init interept 
.................... void InitRS485RxInterrupt(void) 
.................... { 
....................     // Enable RS485 interrupt. 
....................     //clear_interrupt(INT_RDA); 
.................... 	//enable_interrupts(INT_RDA); 
....................      
....................     // Initialize Queue 
....................     g_stUART2RcvBuffModbus.m_i8Front = g_stUART2RcvBuffModbus.m_i8Rear = -1; 
*
00AE6:  MOVLB  2
00AE8:  SETF   x81
00AEA:  MOVFF  281,280
....................     memset(g_stUART2RcvBuffModbus.m_ui8Arr, 0, RS485_RX_BUFF_SIZE); 
00AEE:  MOVLW  02
00AF0:  MOVWF  FEA
00AF2:  MOVLW  4E
00AF4:  MOVWF  FE9
00AF6:  CLRF   00
00AF8:  CLRF   02
00AFA:  MOVLW  32
00AFC:  MOVWF  01
00AFE:  MOVLB  0
00B00:  CALL   0AC2
....................  
....................     clear_interrupt(INT_RDA2); 
.................... 	enable_interrupts(INT_RDA2); 
00B04:  BSF    FA3.5
00B06:  GOTO   6436 (RETURN)
.................... } 
....................  
.................... void Delay_milisecond(unsigned int16 ui16DelayTime) 
.................... { 
.................... 	unsigned int16 ui16Counter = 0; 
.................... 	while(ui16Counter < ui16DelayTime) 
.................... 	{ 
.................... 		delay_ms(1); 
.................... 		ui16Counter++; 
.................... 	} 
.................... } 
....................  
.................... // reset buffer 
.................... void ResetRS485RxBuffer(void) 
.................... { 
....................     // Reset Rx Byte count. 
....................   //  g_ui8RS485RxByteCount       = 0; 
....................     // Set 0 to Rx Buffer. 
....................  //   memset(g_RS485RxBuffer, 0, RS485_RX_BUFF_SIZE); 
....................     g_ui8ReceivedModbusResponse--; 
....................     if(g_ui8ReceivedModbusResponse < 0) 
....................     { 
....................         g_ui8ReceivedModbusResponse = 0; 
....................     } 
....................     g_ui8RS485MaxByteCount = 8; 
....................      
....................     if((g_ui8Front == g_ui8End) && (g_ui8Front!=0)) 
....................     { 
....................         g_ui8Front = 0; 
....................         g_ui8End = 0; 
....................         g_ui8RS485RxByteCount = 0; 
....................     } 
....................      
....................     // Check if Rx Byte count is equal to the Rx Buffer capacity. 
....................     if(g_ui8RS485RxByteCount >= RS485_RX_BUFF_SIZE - 15) //g_ui8RS485MaxByteCount) 
....................     { 
....................         // Reset Rx Byte count to prevent buffer overflow. 
....................     //    g_ui8Front = 0; 
....................         g_ui8End = 0; 
....................         g_ui8RS485RxByteCount = g_ui8End;  
....................     } 
....................  
....................     // Reset holding buffer 
....................     g_ui8RS485Done = 0; 
....................    	clear_interrupt(INT_RDA2); 
.................... } 
....................  
.................... void InitRegistryVariables() 
.................... { 
....................     g_ui16Register0_1 = 0; 
....................     g_ui16Register0_2 = 0; 
....................     g_ui16Register1000_1 = 0; 
....................     g_ui16Register1000_2 = 0; 
....................     g_ui16Register2000_1 = 0; 
....................     g_ui16Register2000_2 = 0; 
....................     g_ui16Register3000_1 = 0; 
....................     g_ui16Register3000_2 = 0; 
....................     g_ui16Register4000_1 = 0; 
....................     g_ui16Register4000_2 = 0; 
....................     g_ui16Register5000_1 = 0; 
....................     g_ui16Register5000_2 = 0; 
....................     g_ui16Register6000_1 = 0; 
....................     g_ui16Register6000_2 = 0; 
....................     g_ui16Register7000_1 = 0; 
....................     g_ui16Register7000_2 = 0; 
....................     g_ui16Register8000_1 = 0; 
....................     g_ui16Register8000_2 = 0; 
....................     g_ui16Register9000_1 = 0; 
....................     g_ui16Register9000_2 = 0; 
....................     g_ui16Register10000_1 = 0; 
....................     g_ui16Register10000_2 = 0; 
....................  
....................     g_ui16RegisterCurrentCalibrationWeight = 0; 
....................     g_fStartCalibration = 0; 
....................     //g_ui16CounterForAvgCalibrationWt = 0; 
....................     g_ui16gAvgWtForCalibration = 0; 
....................      
....................     g_ui16RegisterAvgWeight = 0; 
....................     g_ui16RegisterTolPv = 0; 
....................     g_ui16RegisterTolNv = 0; 
....................     g_ui16RegisterCurrProductIndex = 0; 
....................  
....................     g_ui16CBBCount = 0; 
....................     g_ui16CurrentWt = 0; 
....................     g_ui16CurrentPassStatus = 0; 
....................     g_ui16RunningAvgWt = 0; 
....................     g_ui16RunningTareValue = 0; 
....................     g_ui16ServerStatus = 0;   
....................      
....................     g_ui16FlagForSetTareValue = 0; 
....................      
....................     g_ui16CurrProdIndex = 0; 
....................     g_ui16CurrProdAvgWt = 0; 
....................     g_ui16CurrProdPvTol = 0; 
....................     g_ui16CurrProdNvTol = 0; 
....................      
....................     g_ui16RegisterDateYY = 0; 
....................     g_ui16RegisterDateMM = 0; 
....................     g_ui16RegisterDateDD = 0; 
....................  
....................     g_ui16RegisterTime_HH = 0; 
....................     g_ui16RegisterTime_mm = 0; 
....................     g_ui16RegisterTime_ss = 0; 
....................  
....................     g_ui16RegisterTime_Diff = 0; 
....................      
....................     g_ui16CurrentMode = 0; 
....................  
....................     // use for production type 
....................     g_fAutoCalibrationMode = 0; 
....................  
....................     // use for sample count for auto calibration 
....................     g_ui16AutoCalibrationSampleCount = 10; 
....................      
....................     // use for store load cell factor. 
....................     g_ui16CurrLoadCellFactor = 0; 
....................      
.................... } 
....................  
.................... void SetHILowRS485() 
.................... {	 
....................   	//set transmit active. 
.................... 	output_bit(PIN_RS485_RTS,1); 
.................... 	delay_ms(4); 
.................... 	 
.................... 	//set transmit inactive. 
.................... 	output_bit(PIN_RS485_RTS,0); 
.................... 	delay_ms(4); 
.................... } 
....................  
.................... void TestPollRS485( 
....................                    unsigned int8 ui8SlaveID,  
....................                    unsigned int8 ui8FunctionType,  
....................                    unsigned int16 ui16StartAddress, 
....................                    unsigned int16 ui16RegisterData) 
.................... { 
.................... 	// function for send data to server/master 
.................... 	unsigned int16 ui16CRCvalue = 0; 
....................     unsigned int8  ui8SendBytes = 0; 
.................... 	 
.................... 	//value assign in transmit buffer of RS485 
....................   	g_RS485TxBuffer[0]  = ui8SlaveID; 
....................   	g_RS485TxBuffer[1]  = ui8FunctionType; //3;//Function code;read holding register. 3 for read, 6 for write 
....................   	g_RS485TxBuffer[2]  = (unsigned int8)((ui16StartAddress >> 8) & 0xFF); 
....................   	g_RS485TxBuffer[3]  = (unsigned int8)((ui16StartAddress >> 0) & 0xFF); // Address of the register. 
....................  
....................   	g_RS485TxBuffer[4]  = (unsigned int8)((ui16RegisterData >> 8) & 0xFF); 
....................   	g_RS485TxBuffer[5]  = (unsigned int8)((ui16RegisterData >> 0) & 0xFF); 
....................    	g_RS485TxBuffer[6]  = 0; 
....................   	g_RS485TxBuffer[7]  = 0; 
....................   	 
.................... 	//Calculate CRC values using function call.  
....................   	ui16CRCvalue = calculateCrc(g_RS485TxBuffer,6);  
....................   	 
.................... 	//assign CRC values in transmit buffer. 
....................   	g_RS485TxBuffer[6]  = (unsigned int8)((ui16CRCvalue >> 0) & 0xFF); 
....................   	g_RS485TxBuffer[7]  = (unsigned int8)((ui16CRCvalue >> 8) & 0xFF); 
....................   	 
....................     // Send Signal to Timer 
....................     g_ui8ByteToSend = 8; 
....................      
....................     // Raise RS485 Data Send Timer Flag On. So that our 1msTimer will take the 
....................     // Responsibility to send RS485 Data 
....................     g_fRS485DataReady = FLAG_RS485_DATA_READY; 
.................... ////////  	//set transmit active. 
.................... ////////  	//delay_ms(DELAY_TIME_RTS_BEFORE); 
.................... ////////	output_bit(PIN_RS485_RTS,1); 
.................... ////////	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... ////////	//send bytes. 
.................... ////////	for(ui8SendBytes = 0; ui8SendBytes<8; ui8SendBytes++) 
.................... ////////	{ 
.................... ////////		fputc(g_RS485TxBuffer[ui8SendBytes],RS485); 
.................... ////////	} 
.................... ////////	//hold to bytes properly transmit. 
.................... ////////	//delay_ms(DELAY_TIME_RTS_AFTER); 
.................... ////////	//set transmit inactive. 
.................... ////////	output_bit(PIN_RS485_RTS,0); 
.................... //////////	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... } 
....................  
.................... // wirte to register 
.................... void WriteToOneRegRS485( 
....................                         unsigned int8 ui8SlaveID,  
....................                         unsigned int8 ui8FunctionType,  
....................                         unsigned int8 ui8Len, 
....................                         unsigned int16 ui16RegisterData) 
*
01E68:  MOVLB  B
01E6A:  CLRF   x36
01E6C:  CLRF   x35
.................... { 
.................... 	unsigned int16 ui16CRCvalue = 0; 
.................... 	 
.................... 	//value assign in transmit buffer of RS485 
....................   	g_RS485TxBuffer[0]  = ui8SlaveID;  //37; 
01E6E:  MOVFF  B30,E2
....................   	g_RS485TxBuffer[1]  = ui8FunctionType;  //3; 
01E72:  MOVFF  B31,E3
....................   	g_RS485TxBuffer[2]  = ui8Len;  //2; 
01E76:  MOVFF  B32,E4
....................  
....................   	g_RS485TxBuffer[3]  = (unsigned int8)((ui16RegisterData >> 8) & 0xFF); 
01E7A:  MOVFF  B34,E5
01E7E:  MOVLB  0
....................   	g_RS485TxBuffer[4]  = (unsigned int8)((ui16RegisterData >> 0) & 0xFF); 
01E80:  MOVFF  B33,E6
01E84:  MOVLB  0
....................   	g_RS485TxBuffer[5]  = 0; 
01E86:  CLRF   xE7
....................    	g_RS485TxBuffer[6]  = 0; 
01E88:  CLRF   xE8
.................... //  	g_RS485TxBuffer[7]  = 0; 
....................   	 
.................... 	//Calculate CRC values using function call.  
....................   	ui16CRCvalue = calculateCrc(g_RS485TxBuffer,5);  
01E8A:  MOVLB  B
01E8C:  CLRF   x3D
01E8E:  MOVLW  E2
01E90:  MOVWF  x3C
01E92:  MOVLW  05
01E94:  MOVWF  x3E
01E96:  MOVLB  0
01E98:  CALL   1CDA
01E9C:  MOVFF  02,B36
01EA0:  MOVFF  01,B35
....................   	 
.................... 	//assign CRC values in transmit buffer. 
....................   	g_RS485TxBuffer[5]  = (unsigned int8)((ui16CRCvalue >> 0) & 0xFF); 
01EA4:  MOVFF  B35,E7
01EA8:  MOVLB  0
....................   	g_RS485TxBuffer[6]  = (unsigned int8)((ui16CRCvalue >> 8) & 0xFF); 
01EAA:  MOVFF  B36,E8
01EAE:  MOVLB  0
....................   	 
....................     // Send Signal to Timer 
....................     g_ui8ByteToSend = 7; 
01EB0:  MOVLW  07
01EB2:  MOVLB  1
01EB4:  MOVWF  x29
....................      
....................     // Raise RS485 Data Send Timer Flag On. So that our 1msTimer will take the 
....................     // Responsibility to send RS485 Data 
....................     g_fRS485DataReady = FLAG_RS485_DATA_READY; 
01EB6:  MOVLW  01
01EB8:  MOVWF  x28
01EBA:  MOVLB  0
01EBC:  RETURN 0
.................... ////////  	//set transmit active. 
.................... ////////  	delay_ms(DELAY_TIME_RTS_BEFORE); 
.................... ////////	output_bit(PIN_RS485_RTS,1); 
.................... ////////	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... ////////	//send bytes. 
.................... ////////	for(unsigned int8 ui8SendBytes = 0; ui8SendBytes < 7; ui8SendBytes++) 
.................... ////////	{ 
.................... ////////		fputc(g_RS485TxBuffer[ui8SendBytes],RS485); 
.................... ////////	} 
.................... ////////	//hold to bytes properly transmit. 
.................... ////////	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... ////////	//set transmit inactive. 
.................... ////////	output_bit(PIN_RS485_RTS,0); 
.................... //////////	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... } 
....................  
.................... // write to a register 
.................... void WriteToTwoRegRS485( 
....................                         unsigned int8 ui8SlaveID,  
....................                         unsigned int8 ui8FunctionType,  
....................                         unsigned int8 ui8Len, 
....................                         unsigned int16 ui16RegisterData1,  
....................                         unsigned int16 ui16RegisterData2) 
*
0208A:  MOVLB  B
0208C:  CLRF   x36
0208E:  CLRF   x35
.................... { 
.................... 	unsigned int16 ui16CRCvalue = 0; 
.................... 	 
.................... 	//value assign in transmit buffer of RS485 
....................   	g_RS485TxBuffer[0]  = ui8SlaveID; 
02090:  MOVFF  B2E,E2
....................   	g_RS485TxBuffer[1]  = ui8FunctionType; 
02094:  MOVFF  B2F,E3
....................   	g_RS485TxBuffer[2]  = ui8Len; 
02098:  MOVFF  B30,E4
....................  
....................   	g_RS485TxBuffer[3]  = (unsigned int8)((ui16RegisterData1 >> 8) & 0xFF); 
0209C:  MOVFF  B32,E5
020A0:  MOVLB  0
....................   	g_RS485TxBuffer[4]  = (unsigned int8)((ui16RegisterData1 >> 0) & 0xFF); 
020A2:  MOVFF  B31,E6
020A6:  MOVLB  0
....................   	 
....................   	g_RS485TxBuffer[5]  = (unsigned int8)((ui16RegisterData2 >> 8) & 0xFF); 
020A8:  MOVFF  B34,E7
020AC:  MOVLB  0
....................   	g_RS485TxBuffer[6]  = (unsigned int8)((ui16RegisterData2 >> 0) & 0xFF); 
020AE:  MOVFF  B33,E8
020B2:  MOVLB  0
....................  
....................    	g_RS485TxBuffer[7]  = 0; 
020B4:  CLRF   xE9
....................   	g_RS485TxBuffer[8]  = 0; 
020B6:  CLRF   xEA
....................   	 
.................... 	//Calculate CRC values using function call.  
....................   	ui16CRCvalue        = calculateCrc(g_RS485TxBuffer,7);  
020B8:  MOVLB  B
020BA:  CLRF   x3D
020BC:  MOVLW  E2
020BE:  MOVWF  x3C
020C0:  MOVLW  07
020C2:  MOVWF  x3E
020C4:  MOVLB  0
020C6:  CALL   1CDA
020CA:  MOVFF  02,B36
020CE:  MOVFF  01,B35
....................   	 
.................... 	//assign CRC values in transmit buffer. 
....................   	g_RS485TxBuffer[7]  = (unsigned int8)((ui16CRCvalue >> 0) & 0xFF); 
020D2:  MOVFF  B35,E9
020D6:  MOVLB  0
....................   	g_RS485TxBuffer[8]  = (unsigned int8)((ui16CRCvalue >> 8) & 0xFF); 
020D8:  MOVFF  B36,EA
020DC:  MOVLB  0
....................   	 
....................     // Send Signal to Timer 
....................     g_ui8ByteToSend = 9; 
020DE:  MOVLW  09
020E0:  MOVLB  1
020E2:  MOVWF  x29
....................      
....................     // Raise RS485 Data Send Timer Flag On. So that our 1msTimer will take the 
....................     // Responsibility to send RS485 Data 
....................     g_fRS485DataReady = FLAG_RS485_DATA_READY; 
020E4:  MOVLW  01
020E6:  MOVWF  x28
020E8:  MOVLB  0
020EA:  RETURN 0
.................... ////////  	//set transmit active. 
.................... ////////  	delay_ms(DELAY_TIME_RTS_BEFORE); 
.................... ////////	output_bit(PIN_RS485_RTS,1); 
.................... ////////	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... ////////	//send bytes. 
.................... ////////	for(unsigned int8 ui8SendBytes = 0; ui8SendBytes<9; ui8SendBytes++) 
.................... ////////	{ 
.................... ////////		fputc(g_RS485TxBuffer[ui8SendBytes],RS485); 
.................... ////////	} 
.................... ////////	//hold to bytes properly transmit. 
.................... ////////	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... ////////	//set transmit inactive. 
.................... ////////	output_bit(PIN_RS485_RTS,0); 
.................... //////////	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... } 
....................  
.................... // write to a register 
.................... void WriteToThreeRegRS485( 
....................     unsigned int8  ui8SlaveID, 
....................     unsigned int8  ui8FunctionType, 
....................     unsigned int8  ui8Len, 
....................     unsigned int16 ui16RegisterData1, 
....................     unsigned int16 ui16RegisterData2, 
....................     unsigned int16 ui16RegisterData3) 
*
023CE:  MOVLB  B
023D0:  CLRF   x36
023D2:  CLRF   x35
.................... { 
.................... 	unsigned int16 ui16CRCvalue = 0; 
.................... 	 
.................... 	//value assign in transmit buffer of RS485 
....................   	g_RS485TxBuffer[0]  = ui8SlaveID; 
023D4:  MOVFF  B2C,E2
....................   	g_RS485TxBuffer[1]  = ui8FunctionType; 
023D8:  MOVFF  B2D,E3
....................   	g_RS485TxBuffer[2]  = ui8Len; 
023DC:  MOVFF  B2E,E4
....................  
....................   	g_RS485TxBuffer[3]  = (unsigned int8)((ui16RegisterData1 >> 8) & 0x00FF); 
023E0:  MOVFF  B30,E5
023E4:  MOVLB  0
....................   	g_RS485TxBuffer[4]  = (unsigned int8)((ui16RegisterData1 >> 0) & 0x00FF); 
023E6:  MOVFF  B2F,E6
023EA:  MOVLB  0
....................   	 
....................   	g_RS485TxBuffer[5]  = (unsigned int8)((ui16RegisterData2 >> 8) & 0x00FF); 
023EC:  MOVFF  B32,E7
023F0:  MOVLB  0
....................   	g_RS485TxBuffer[6]  = (unsigned int8)((ui16RegisterData2 >> 0) & 0x00FF); 
023F2:  MOVFF  B31,E8
023F6:  MOVLB  0
....................  
....................    	g_RS485TxBuffer[7]  = (unsigned int8)((ui16RegisterData3 >> 8) & 0x00FF); 
023F8:  MOVFF  B34,E9
023FC:  MOVLB  0
....................   	g_RS485TxBuffer[8]  = (unsigned int8)((ui16RegisterData3 >> 0) & 0x00FF); 
023FE:  MOVFF  B33,EA
02402:  MOVLB  0
....................   	 
.................... 	//Calculate CRC values using function call.  
....................   	ui16CRCvalue        = calculateCrc(g_RS485TxBuffer,9);  
02404:  MOVLB  B
02406:  CLRF   x3D
02408:  MOVLW  E2
0240A:  MOVWF  x3C
0240C:  MOVLW  09
0240E:  MOVWF  x3E
02410:  MOVLB  0
02412:  CALL   1CDA
02416:  MOVFF  02,B36
0241A:  MOVFF  01,B35
....................   	 
.................... 	//assign CRC values in transmit buffer. 
....................   	g_RS485TxBuffer[9]   = (unsigned int8)((ui16CRCvalue >> 0) & 0x00FF); 
0241E:  MOVFF  B35,EB
02422:  MOVLB  0
....................   	g_RS485TxBuffer[10]  = (unsigned int8)((ui16CRCvalue >> 8) & 0x00FF); 
02424:  MOVFF  B36,EC
02428:  MOVLB  0
....................   	 
....................     // Send Signal to Timer 
....................     g_ui8ByteToSend = 11; 
0242A:  MOVLW  0B
0242C:  MOVLB  1
0242E:  MOVWF  x29
....................      
....................     // Raise RS485 Data Send Timer Flag On. So that our 1msTimer will take the 
....................     // Responsibility to send RS485 Data 
....................     g_fRS485DataReady = FLAG_RS485_DATA_READY; 
02430:  MOVLW  01
02432:  MOVWF  x28
02434:  MOVLB  0
02436:  GOTO   34F2 (RETURN)
....................      
.................... //////  	//set transmit active. 
.................... //////  	delay_ms(DELAY_TIME_RTS_BEFORE); 
.................... //////	output_bit(PIN_RS485_RTS,1); 
.................... //////	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... //////    delay_ms(3); 
.................... //////	//send bytes. 
.................... //////	for(unsigned int8 ui8SendBytes = 0; ui8SendBytes < 11; ui8SendBytes++) 
.................... //////	{ 
.................... //////		fputc(g_RS485TxBuffer[ui8SendBytes], RS485); 
.................... //////	} 
.................... //////	//hold to bytes properly transmit. 
.................... //////	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... //////	//set transmit inactive. 
.................... //////	output_bit(PIN_RS485_RTS,0); 
.................... ////////	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... } 
.................... ////////// write to a register 
.................... ////////void WriteToThreeRegRS485( 
.................... ////////    unsigned int8  ui8SlaveID, 
.................... ////////    unsigned int8  ui8FunctionType, 
.................... ////////    unsigned int8  ui8Len, 
.................... ////////    unsigned int16 ui16RegisterData1, 
.................... ////////    unsigned int16 ui16RegisterData2, 
.................... ////////    unsigned int16 ui16RegisterData3) 
.................... ////////{ 
.................... ////////	unsigned int16 ui16CRCvalue = 0; 
.................... ////////	 
.................... ////////	//value assign in transmit buffer of RS485 
.................... ////////  	g_RS485TxBuffer[0]  = ui8SlaveID; 
.................... ////////  	g_RS485TxBuffer[1]  = ui8FunctionType; 
.................... ////////  	g_RS485TxBuffer[2]  = ui8Len; 
.................... //////// 
.................... ////////  	g_RS485TxBuffer[3]  = (unsigned int8)((ui16RegisterData1 >> 8) & 0x00FF); 
.................... ////////  	g_RS485TxBuffer[4]  = (unsigned int8)((ui16RegisterData1 >> 0) & 0x00FF); 
.................... ////////  	 
.................... ////////  	g_RS485TxBuffer[5]  = (unsigned int8)((ui16RegisterData2 >> 8) & 0x00FF); 
.................... ////////  	g_RS485TxBuffer[6]  = (unsigned int8)((ui16RegisterData2 >> 0) & 0x00FF); 
.................... //////// 
.................... ////////   	g_RS485TxBuffer[7]  = (unsigned int8)((ui16RegisterData3 >> 8) & 0x00FF); 
.................... ////////  	g_RS485TxBuffer[8]  = (unsigned int8)((ui16RegisterData3 >> 0) & 0x00FF); 
.................... ////////  	 
.................... ////////	//Calculate CRC values using function call.  
.................... ////////  	ui16CRCvalue        = calculateCrc(g_RS485TxBuffer,9);  
.................... ////////  	 
.................... ////////	//assign CRC values in transmit buffer. 
.................... ////////  	g_RS485TxBuffer[9]   = (unsigned int8)((ui16CRCvalue >> 0) & 0x00FF); 
.................... ////////  	g_RS485TxBuffer[10]  = (unsigned int8)((ui16CRCvalue >> 8) & 0x00FF); 
.................... ////////  	 
.................... ////////  	//set transmit active. 
.................... ////////  	delay_ms(DELAY_TIME_RTS_BEFORE); 
.................... ////////	output_bit(PIN_RS485_RTS,1); 
.................... ////////	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... ////////    delay_ms(3); 
.................... ////////	//send bytes. 
.................... ////////	for(unsigned int8 ui8SendBytes = 0; ui8SendBytes < 11; ui8SendBytes++) 
.................... ////////	{ 
.................... ////////		fputc(g_RS485TxBuffer[ui8SendBytes], RS485); 
.................... ////////	} 
.................... ////////	//hold to bytes properly transmit. 
.................... ////////	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... ////////	//set transmit inactive. 
.................... ////////	output_bit(PIN_RS485_RTS,0); 
.................... //////////	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... ////////} 
....................  
.................... // write to a register 
.................... void ReplyForTwoRegister( 
....................                         unsigned int8 ui8SlaveID,  
....................                         unsigned int8 ui8FunctionType,  
....................                         unsigned int8 ui8Len, 
....................                         unsigned int16 ui16RegisterAddress,  
....................                         unsigned int16 ui16RegisterData1,  
....................                         unsigned int16 ui16RegisterData2) 
*
02E00:  MOVLB  B
02E02:  CLRF   x3B
02E04:  CLRF   x3A
.................... { 
.................... 	unsigned int16 ui16CRCvalue = 0; 
.................... 	 
.................... 	//value assign in transmit buffer of RS485 
....................   	g_RS485TxBuffer[0]  = ui8SlaveID; 
02E06:  MOVFF  B31,E2
....................   	g_RS485TxBuffer[1]  = ui8FunctionType; 
02E0A:  MOVFF  B32,E3
....................   	g_RS485TxBuffer[2]  = (unsigned int8)((ui16RegisterAddress >> 8) & 0xFF); 
02E0E:  MOVFF  B35,E4
02E12:  MOVLB  0
....................   	g_RS485TxBuffer[3]  = (unsigned int8)((ui16RegisterAddress >> 0) & 0xFF); 
02E14:  MOVFF  B34,E5
02E18:  MOVLB  0
....................   	g_RS485TxBuffer[4]  = (unsigned int8)((ui8Len >> 8) & 0xFF); 
02E1A:  MOVLW  00
02E1C:  MOVWF  xE6
....................   	g_RS485TxBuffer[5]  = (unsigned int8)((ui8Len >> 0) & 0xFF); 
02E1E:  MOVFF  B33,E7
02E22:  MOVLB  0
....................      
....................   	g_RS485TxBuffer[6]  = 2 * ui8Len; 
02E24:  BCF    FD8.0
02E26:  MOVLB  B
02E28:  RLCF   x33,W
02E2A:  MOVLB  0
02E2C:  MOVWF  xE8
....................  
....................   	g_RS485TxBuffer[7]  = (unsigned int8)((ui16RegisterData1 >> 8) & 0xFF); 
02E2E:  MOVFF  B37,E9
02E32:  MOVLB  0
....................   	g_RS485TxBuffer[8]  = (unsigned int8)((ui16RegisterData1 >> 0) & 0xFF); 
02E34:  MOVFF  B36,EA
02E38:  MOVLB  0
....................   	 
....................   	g_RS485TxBuffer[9]  = (unsigned int8)((ui16RegisterData2 >> 8) & 0xFF); 
02E3A:  MOVFF  B39,EB
02E3E:  MOVLB  0
....................   	g_RS485TxBuffer[10]  = (unsigned int8)((ui16RegisterData2 >> 0) & 0xFF); 
02E40:  MOVFF  B38,EC
02E44:  MOVLB  0
....................  
....................    	g_RS485TxBuffer[11]  = 0; 
02E46:  CLRF   xED
....................   	g_RS485TxBuffer[12]  = 0; 
02E48:  CLRF   xEE
....................   	 
.................... 	//Calculate CRC values using function call.  
....................   	ui16CRCvalue        = calculateCrc(g_RS485TxBuffer,11);  
02E4A:  MOVLB  B
02E4C:  CLRF   x3D
02E4E:  MOVLW  E2
02E50:  MOVWF  x3C
02E52:  MOVLW  0B
02E54:  MOVWF  x3E
02E56:  MOVLB  0
02E58:  CALL   1CDA
02E5C:  MOVFF  02,B3B
02E60:  MOVFF  01,B3A
....................   	 
.................... 	//assign CRC values in transmit buffer. 
....................   	g_RS485TxBuffer[11]  = (unsigned int8)((ui16CRCvalue >> 0) & 0xFF); 
02E64:  MOVFF  B3A,ED
02E68:  MOVLB  0
....................   	g_RS485TxBuffer[12]  = (unsigned int8)((ui16CRCvalue >> 8) & 0xFF); 
02E6A:  MOVFF  B3B,EE
02E6E:  MOVLB  0
....................   	 
....................     // Send Signal to Timer 
....................     g_ui8ByteToSend = 13; 
02E70:  MOVLW  0D
02E72:  MOVLB  1
02E74:  MOVWF  x29
....................      
....................     // Raise RS485 Data Send Timer Flag On. So that our 1msTimer will take the 
....................     // Responsibility to send RS485 Data 
....................     g_fRS485DataReady = FLAG_RS485_DATA_READY; 
02E76:  MOVLW  01
02E78:  MOVWF  x28
02E7A:  MOVLB  0
02E7C:  RETURN 0
.................... ////////  	//set transmit active. 
.................... ////////  	delay_ms(DELAY_TIME_RTS_BEFORE); 
.................... ////////	output_bit(PIN_RS485_RTS,1); 
.................... ////////	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... ////////	//send bytes. 
.................... ////////	for(unsigned int8 ui8SendBytes = 0; ui8SendBytes<13; ui8SendBytes++) 
.................... ////////	{ 
.................... ////////		fputc(g_RS485TxBuffer[ui8SendBytes],RS485); 
.................... ////////	} 
.................... ////////	//hold to bytes properly transmit. 
.................... ////////	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... ////////	//set transmit inactive. 
.................... ////////	output_bit(PIN_RS485_RTS,0); 
.................... //////////	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... } 
....................  
.................... // is bit is on a data 
.................... int8 IsBitOn(int8 uiBitIndex, int16 u16RegData) 
.................... { 
.................... 	int8 uiRetVal   = 1; 
.................... 	int8 uiMaxBits  = 15; 
.................... 	 
.................... 	int16 u16Data   = u16RegData << (uiMaxBits-uiBitIndex); 
.................... 	 
.................... 	u16Data         = u16Data >> uiMaxBits; 
.................... 	 
.................... 	if(u16Data == 1)  
.................... 		uiRetVal = 0; 
.................... 	else  
.................... 		uiRetVal = 1;	 
.................... 	return uiRetVal; 
.................... } 
....................  
.................... // set bit on in a data 
.................... int32 SetBitOn(int8 uiBitIndex, int32 u32RegData) 
.................... { 
.................... 	int32 uiRetVal = u32RegData; 
.................... 	int8 uiMaxBits = 31; 
.................... 	 
.................... 	if(uiBitIndex > uiMaxBits)  
....................     { 
.................... 		return uiRetVal; 
.................... 	} 
.................... 	uiRetVal = uiRetVal | (1 << uiBitIndex); 
.................... 	 
.................... 	return uiRetVal; 
.................... } 
....................  
.................... // dlear a bit from data 
.................... int32 ClearBitOn(int8 uiBitIndex, int32 u32RegData) 
.................... { 
.................... 	int32 uiRetVal = u32RegData; 
.................... 	int8 uiMaxBits = 31; 
.................... 	 
.................... 	if(uiBitIndex > uiMaxBits) { 
.................... 		return uiRetVal; 
.................... 	} 
.................... 	uiRetVal = uiRetVal & ~(1 << uiBitIndex); 
.................... 	 
.................... 	return uiRetVal; 
.................... } 
....................  
.................... // toggle bit on 
.................... int32 ToggleBitOn(int8 uiBitIndex, int32 u32RegData) 
.................... { 
.................... 	int32 uiRetVal = u32RegData; 
.................... 	int8 uiMaxBits = 31; 
.................... 	 
.................... 	if(uiBitIndex > uiMaxBits) { 
.................... 		return uiRetVal; 
.................... 	} 
.................... 	uiRetVal = uiRetVal ^ (1 << uiBitIndex); 
.................... 	 
.................... 	return uiRetVal; 
.................... } 
....................  
.................... void PollRS485( 
....................                 unsigned int8 uiFunctionCode,  
....................                 unsigned int16 ui16StartAddress,  
....................                 unsigned int16 ui16FirstRegisterData,  
....................                 unsigned int16 ui16SecondregisterData) 
.................... { 
.................... 	// function for polling data 
.................... 	unsigned int16 ui16CRCvalue = 0; 
.................... 	 
.................... 	//Reset the receiver buffer. 
.................... 	ResetRS485RxBuffer(); 
.................... 	 
.................... 	g_RS485TxBuffer[0]  = SLAVE_ID; 
.................... 	g_RS485TxBuffer[1]  = uiFunctionCode;// Function code. 
.................... 	g_RS485TxBuffer[2]  = ((ui16StartAddress >> 8)& 0xFF); 
.................... 	g_RS485TxBuffer[3]  = ((ui16StartAddress >> 0)& 0xFF); 
.................... 	g_RS485TxBuffer[4]  = 0x00; 
.................... 	g_RS485TxBuffer[5]  = 0x02;// Number of registers to write. 
.................... 	g_RS485TxBuffer[6]  = 0x04;// Number of bytes to write.  
.................... 	g_RS485TxBuffer[7]  = (unsigned int8)((ui16FirstRegisterData >> 8)& 0xFF); 
.................... 	g_RS485TxBuffer[8]  = (unsigned int8)((ui16FirstRegisterData >> 0)& 0xFF);// Data of the first register. 
.................... 	g_RS485TxBuffer[9]  = (unsigned int8)((ui16SecondregisterData >> 8)& 0xFF); 
.................... 	g_RS485TxBuffer[10] = (unsigned int8)((ui16SecondregisterData >> 0)& 0xFF);// Data of the second register.  
.................... 	g_RS485TxBuffer[11] = 0; 
.................... 	g_RS485TxBuffer[12] = 0; 
.................... 	 
.................... 	//Function call CRC calculation. 
.................... 	ui16CRCvalue = ModbusCRC16(g_RS485TxBuffer,11); 
.................... 	 
.................... 	g_RS485TxBuffer[11] = (unsigned int8)((ui16CRCvalue >> 0)& 0xFF); 
.................... 	g_RS485TxBuffer[12] = (unsigned int8)((ui16CRCvalue >> 8)& 0xFF); 
....................  
.................... 	//set transmit active. 
.................... 	delay_ms(2); 
.................... 	output_bit(PIN_RS485_RTS,1); 
.................... 	delay_ms(3); 
.................... 	//send bytes. 
.................... 	for(unsigned int8 ui8SendBytes = 0; ui8SendBytes<13; ui8SendBytes++) 
.................... 	{ 
.................... 		fputc(g_RS485TxBuffer[ui8SendBytes],RS485); 
.................... 	} 
.................... 	//hold to bytes properly transmit. 
.................... 	delay_ms(3); 
.................... 	//set transmit inactive. 
.................... 	output_bit(PIN_RS485_RTS,0); 
.................... 	delay_ms(3); 
.................... } 
....................  
.................... ////=============================== START NEW CODE ====================================================== 
.................... #INT_RDA2 
.................... void RS485_RxByteReady_ISR2(void) 
.................... { 
....................      
....................     // Checking for Is ISR ready flag. 
....................     if(ISR_IS_NOT_READY == g_fIsReadyToReceiveByte) 
*
0070E:  MOVLB  2
00710:  MOVF   x26,W
00712:  SUBLW  29
00714:  BTFSS  FD8.2
00716:  GOTO   071E
....................     { 
....................         g_fIsReadyToReceiveByte = ISR_IS_READY; 
0071A:  MOVLW  28
0071C:  MOVWF  x26
....................     } 
....................      
....................     g_ui8TempByte = fgetc(RS485); 
0071E:  CLRWDT
00720:  BTFSS  FA4.5
00722:  GOTO   071E
00726:  MOVFF  F7A,282
....................      
....................     // Checking queue boundary conditions. 
....................     if(g_stUART2RcvBuffModbus.m_i8Front == -1 && g_stUART2RcvBuffModbus.m_i8Rear == -1) 
0072A:  MOVF   x80,W
0072C:  SUBLW  FF
0072E:  BTFSS  FD8.2
00730:  GOTO   075A
00734:  MOVF   x81,W
00736:  SUBLW  FF
00738:  BTFSS  FD8.2
0073A:  GOTO   075A
....................     { 
....................         // Initialize queue front and rear. 
....................         g_stUART2RcvBuffModbus.m_i8Front = g_stUART2RcvBuffModbus.m_i8Rear = 0; 
0073E:  CLRF   x81
00740:  MOVFF  281,280
....................          
....................         // Inserting first element. 
....................         g_stUART2RcvBuffModbus.m_ui8Arr[g_stUART2RcvBuffModbus.m_i8Rear] = g_ui8TempByte; 
00744:  CLRF   03
00746:  MOVF   x81,W
00748:  ADDLW  4E
0074A:  MOVWF  FE9
0074C:  MOVLW  02
0074E:  ADDWFC 03,W
00750:  MOVWF  FEA
00752:  MOVFF  282,FEF
....................     }  
00756:  GOTO   07BA
....................     else if((RS485_RX_BUFF_SIZE - 1) == g_stUART2RcvBuffModbus.m_i8Rear && g_stUART2RcvBuffModbus.m_i8Front > 0) 
0075A:  MOVF   x81,W
0075C:  SUBLW  31
0075E:  BTFSS  FD8.2
00760:  GOTO   0784
00764:  MOVF   x80,F
00766:  BTFSC  FD8.2
00768:  GOTO   0784
....................     { 
....................         // Rear reached last position..initialize it. 
....................         g_stUART2RcvBuffModbus.m_i8Rear = 0; 
0076C:  CLRF   x81
....................         // Then insert data. 
....................         g_stUART2RcvBuffModbus.m_ui8Arr[g_stUART2RcvBuffModbus.m_i8Rear] = g_ui8TempByte; 
0076E:  CLRF   03
00770:  MOVF   x81,W
00772:  ADDLW  4E
00774:  MOVWF  FE9
00776:  MOVLW  02
00778:  ADDWFC 03,W
0077A:  MOVWF  FEA
0077C:  MOVFF  282,FEF
....................     } 
00780:  GOTO   07BA
....................     else if(((RS485_RX_BUFF_SIZE - 1) == g_stUART2RcvBuffModbus.m_i8Rear && g_stUART2RcvBuffModbus.m_i8Front == 0) || 
....................             (g_stUART2RcvBuffModbus.m_i8Rear == g_stUART2RcvBuffModbus.m_i8Front - 1)) 
00784:  MOVF   x81,W
00786:  SUBLW  31
00788:  BTFSS  FD8.2
0078A:  GOTO   0796
0078E:  MOVF   x80,F
00790:  BTFSC  FD8.2
00792:  GOTO   07A2
00796:  MOVLW  01
00798:  SUBWF  x80,W
0079A:  SUBWF  x81,W
0079C:  BTFSS  FD8.2
0079E:  GOTO   07A6
....................     { 
....................         // Queue is full 
....................         //TODO Handle This 
....................     } 
007A2:  GOTO   07BA
....................     else  
....................     { 
....................         g_stUART2RcvBuffModbus.m_i8Rear++; 
007A6:  INCF   x81,F
....................         g_stUART2RcvBuffModbus.m_ui8Arr[g_stUART2RcvBuffModbus.m_i8Rear] = g_ui8TempByte; 
007A8:  CLRF   03
007AA:  MOVF   x81,W
007AC:  ADDLW  4E
007AE:  MOVWF  FE9
007B0:  MOVLW  02
007B2:  ADDWFC 03,W
007B4:  MOVWF  FEA
007B6:  MOVFF  282,FEF
....................     } 
....................      
.................... 	// Clear interrupt. 
.................... 	clear_interrupt(INT_RDA2); 
007BA:  BCF    FA4.5
007BC:  MOVLB  0
007BE:  GOTO   00AC
.................... } 
....................  
.................... BYTE GetUART2Queue(BYTE* pbIsQueueEmpty ) 
*
01C0C:  MOVLB  B
01C0E:  CLRF   x2E
.................... { 
....................     BYTE bData = 0; 
....................      
....................     *pbIsQueueEmpty = MSG_QUEUE_NOT_EMPTY; 
01C10:  MOVFF  B2C,FE9
01C14:  MOVFF  B2D,FEA
01C18:  MOVLW  01
01C1A:  MOVWF  FEF
....................  
....................     if (-1 == g_stUART2RcvBuffModbus.m_i8Front) 
01C1C:  MOVLB  2
01C1E:  MOVF   x80,W
01C20:  SUBLW  FF
01C22:  BTFSS  FD8.2
01C24:  GOTO   1C3E
....................     { 
....................         // Queue is empty 
....................         *pbIsQueueEmpty = MSG_QUEUE_EMPTY; 
01C28:  MOVLB  B
01C2A:  MOVFF  B2C,FE9
01C2E:  MOVFF  B2D,FEA
01C32:  CLRF   FEF
....................         return 0; 
01C34:  MOVLW  00
01C36:  MOVWF  01
01C38:  GOTO   1C8C
01C3C:  MOVLB  2
....................     } 
....................      
....................     bData = g_stUART2RcvBuffModbus.m_ui8Arr[g_stUART2RcvBuffModbus.m_i8Front]; 
01C3E:  CLRF   03
01C40:  MOVF   x80,W
01C42:  ADDLW  4E
01C44:  MOVWF  FE9
01C46:  MOVLW  02
01C48:  ADDWFC 03,W
01C4A:  MOVWF  FEA
01C4C:  MOVFF  FEF,B2E
....................     g_stUART2RcvBuffModbus.m_ui8Arr[g_stUART2RcvBuffModbus.m_i8Front] = 0;  // Fill the Queue by 0 
01C50:  CLRF   03
01C52:  MOVF   x80,W
01C54:  ADDLW  4E
01C56:  MOVWF  FE9
01C58:  MOVLW  02
01C5A:  ADDWFC 03,W
01C5C:  MOVWF  FEA
01C5E:  CLRF   FEF
....................      
....................     if (g_stUART2RcvBuffModbus.m_i8Front == g_stUART2RcvBuffModbus.m_i8Rear) 
01C60:  MOVF   x81,W
01C62:  SUBWF  x80,W
01C64:  BTFSS  FD8.2
01C66:  GOTO   1C74
....................     { 
....................         g_stUART2RcvBuffModbus.m_i8Front = g_stUART2RcvBuffModbus.m_i8Rear = -1; 
01C6A:  SETF   x81
01C6C:  MOVFF  281,280
....................     } 
01C70:  GOTO   1C86
....................     else if ((RS485_RX_BUFF_SIZE - 1) == g_stUART2RcvBuffModbus.m_i8Front) 
01C74:  MOVF   x80,W
01C76:  SUBLW  31
01C78:  BTFSS  FD8.2
01C7A:  GOTO   1C84
....................     { 
....................         g_stUART2RcvBuffModbus.m_i8Front = 0; 
01C7E:  CLRF   x80
....................     } 
01C80:  GOTO   1C86
....................     else 
....................     { 
....................         g_stUART2RcvBuffModbus.m_i8Front++; 
01C84:  INCF   x80,F
....................     } 
....................      
....................     // Return Data 
....................     return bData; 
01C86:  MOVLB  B
01C88:  MOVFF  B2E,01
01C8C:  MOVLB  0
01C8E:  GOTO   3328 (RETURN)
.................... } 
....................  
.................... int8 GetQueueLength() 
.................... { 
....................     // Check if Front is less then rear, Normal case 
....................     if (g_stUART2RcvBuffModbus.m_i8Front < g_stUART2RcvBuffModbus.m_i8Rear) 
01C92:  MOVLB  2
01C94:  MOVF   x81,W
01C96:  SUBWF  x80,W
01C98:  BTFSC  FD8.0
01C9A:  GOTO   1CAE
....................     { 
....................         return (g_stUART2RcvBuffModbus.m_i8Rear - g_stUART2RcvBuffModbus.m_i8Front + 1); 
01C9E:  MOVF   x80,W
01CA0:  SUBWF  x81,W
01CA2:  ADDLW  01
01CA4:  MOVWF  01
01CA6:  GOTO   1CCC
....................     } 
01CAA:  GOTO   1CC8
....................     // Else if the Rear precedes front 
....................     else if (g_stUART2RcvBuffModbus.m_i8Front > g_stUART2RcvBuffModbus.m_i8Rear) 
01CAE:  MOVF   x80,W
01CB0:  SUBWF  x81,W
01CB2:  BTFSC  FD8.0
01CB4:  GOTO   1CC8
....................     { 
....................         return ((RS485_RX_BUFF_SIZE - g_stUART2RcvBuffModbus.m_i8Front) + 
....................                 g_stUART2RcvBuffModbus.m_i8Rear + 1); 
01CB8:  MOVLW  32
01CBA:  BSF    FD8.0
01CBC:  SUBFWB x80,W
01CBE:  ADDWF  x81,W
01CC0:  ADDLW  01
01CC2:  MOVWF  01
01CC4:  GOTO   1CCC
....................          
....................     } 
....................     // If the queue is empty 
....................     return 0; 
01CC8:  MOVLW  00
01CCA:  MOVWF  01
01CCC:  MOVLB  0
01CCE:  RETURN 0
.................... } 
....................  
.................... void EmptyQueue() 
.................... { 
....................     g_stUART2RcvBuffModbus.m_i8Front = -1; 
01CD0:  MOVLB  2
01CD2:  SETF   x80
....................     g_stUART2RcvBuffModbus.m_i8Rear = -1; 
01CD4:  SETF   x81
01CD6:  MOVLB  0
01CD8:  RETURN 0
.................... } 
....................  
.................... unsigned int8 CheckValidityForReadReg(void) 
*
01D8E:  MOVLB  B
01D90:  CLRF   x2D
01D92:  CLRF   x2C
01D94:  MOVLW  01
01D96:  MOVWF  x2E
01D98:  CLRF   x2F
01D9A:  CLRF   x30
01D9C:  CLRF   x31
01D9E:  MOVFF  280,B32
.................... { 
....................     unsigned int16 ui16CRCValue       = 0; 
....................     BYTE           bIsQueueEmpty      = MSG_QUEUE_NOT_EMPTY; 
....................     BYTE           bTemp              = 0; 
....................     unsigned int8  ui8IsValidResponse = 0; 
....................     int8           i8LoopCount        = 0; 
....................     int8           i8TempFront        = g_stUART2RcvBuffModbus.m_i8Front; 
....................      
....................     // Step 1: Populate the Message in a temporary array 
....................     g_ui8TempArrForCRCValidation[0] = SLAVE_ID; 
01DA2:  MOVLB  2
01DA4:  MOVWF  x83
....................     for(i8LoopCount = 1; i8LoopCount != MODBUS_MASTER_QUERY_READ_REG_LENGTH - 2; i8LoopCount++) 
01DA6:  MOVLB  B
01DA8:  MOVWF  x31
01DAA:  MOVF   x31,W
01DAC:  SUBLW  06
01DAE:  BTFSC  FD8.2
01DB0:  GOTO   1DEA
....................     { 
....................         g_ui8TempArrForCRCValidation[i8LoopCount] = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront++]; 
01DB4:  CLRF   03
01DB6:  MOVF   x31,W
01DB8:  ADDLW  83
01DBA:  MOVWF  01
01DBC:  MOVLW  02
01DBE:  ADDWFC 03,F
01DC0:  MOVFF  03,B34
01DC4:  MOVF   x32,W
01DC6:  INCF   x32,F
01DC8:  CLRF   03
01DCA:  ADDLW  4E
01DCC:  MOVWF  FE9
01DCE:  MOVLW  02
01DD0:  ADDWFC 03,W
01DD2:  MOVWF  FEA
01DD4:  MOVFF  FEF,B35
01DD8:  MOVFF  B34,FEA
01DDC:  MOVFF  01,FE9
01DE0:  MOVFF  B35,FEF
01DE4:  INCF   x31,F
01DE6:  GOTO   1DAA
....................     } 
....................      
....................     // Calculate CRC value with received bytes for validation. 
....................     ui16CRCValue = calculateCrc(g_ui8TempArrForCRCValidation, MODBUS_MASTER_QUERY_READ_REG_LENGTH - 2); 
01DEA:  MOVLW  02
01DEC:  MOVWF  x3D
01DEE:  MOVLW  83
01DF0:  MOVWF  x3C
01DF2:  MOVLW  06
01DF4:  MOVWF  x3E
01DF6:  MOVLB  0
01DF8:  CALL   1CDA
01DFC:  MOVFF  02,B2D
01E00:  MOVFF  01,B2C
....................      
....................     // Match with received first CRC byte 
....................     bTemp = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront++]; 
01E04:  MOVLB  B
01E06:  MOVF   x32,W
01E08:  INCF   x32,F
01E0A:  CLRF   03
01E0C:  ADDLW  4E
01E0E:  MOVWF  FE9
01E10:  MOVLW  02
01E12:  ADDWFC 03,W
01E14:  MOVWF  FEA
01E16:  MOVFF  FEF,B2F
....................     if(bTemp == (unsigned int8)((ui16CRCValue >> 0) & 0xFF)) 
01E1A:  MOVFF  B2D,B34
01E1E:  MOVFF  B2C,B33
01E22:  MOVFF  B2C,00
01E26:  CLRF   03
01E28:  MOVF   x2C,W
01E2A:  SUBWF  x2F,W
01E2C:  BTFSS  FD8.2
01E2E:  GOTO   1E5E
....................     { 
....................         // Match with received second CRC byte. 
....................         bTemp = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront]; 
01E32:  CLRF   03
01E34:  MOVF   x32,W
01E36:  ADDLW  4E
01E38:  MOVWF  FE9
01E3A:  MOVLW  02
01E3C:  ADDWFC 03,W
01E3E:  MOVWF  FEA
01E40:  MOVFF  FEF,B2F
....................         if(bTemp == (unsigned int8)((ui16CRCValue >> 8) & 0xFF)) 
01E44:  MOVFF  B2D,B33
01E48:  CLRF   x34
01E4A:  MOVFF  B2D,00
01E4E:  CLRF   03
01E50:  MOVF   x2D,W
01E52:  SUBWF  x2F,W
01E54:  BTFSS  FD8.2
01E56:  GOTO   1E5E
....................         { 
....................             // Update flag denote CRC bytes matched..valid response. 
....................             ui8IsValidResponse = 1; 
01E5A:  MOVLW  01
01E5C:  MOVWF  x30
....................         } 
....................     } 
....................      
....................     return ui8IsValidResponse; 
01E5E:  MOVFF  B30,01
01E62:  MOVLB  0
01E64:  GOTO   346A (RETURN)
.................... } 
....................  
.................... // send response 
.................... void SendRS485Response() 
*
0243A:  MOVLB  B
0243C:  CLRF   x2C
0243E:  CLRF   x2D
02440:  CLRF   x2E
02442:  CLRF   x2F
02444:  CLRF   x30
.................... { 
.................... 	// function for sending reply 
.................... 	 
.................... 	//value assign in transmit buffer of RS485 
....................     int8 i8TempFront             = 0; 
....................     BYTE ui8Temp                 = 0; 
....................     int8 i8TempLen               = 0;   
....................     int8 i8IndexTx               = 0; 
....................     int8 i8Index                 = 0; 
....................              
....................     i8TempFront = g_stUART2RcvBuffModbus.m_i8Front;     
02446:  MOVFF  280,B2C
....................     ui8Temp     = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront];  // g_ui8TempArrForCRCValidation 
0244A:  CLRF   03
0244C:  MOVF   x2C,W
0244E:  ADDLW  4E
02450:  MOVWF  FE9
02452:  MOVLW  02
02454:  ADDWFC 03,W
02456:  MOVWF  FEA
02458:  MOVFF  FEF,B2D
....................     i8TempLen   = GetQueueLength() + 1; // +1 is just due to we have deleted First byte from queue 
0245C:  MOVLB  0
0245E:  CALL   1C92
02462:  MOVLW  01
02464:  ADDWF  01,W
02466:  MOVLB  B
02468:  MOVWF  x2E
....................      
....................     g_RS485TxBuffer[i8IndexTx] = SLAVE_ID; 
0246A:  CLRF   03
0246C:  MOVF   x2F,W
0246E:  ADDLW  E2
02470:  MOVWF  FE9
02472:  MOVLW  00
02474:  ADDWFC 03,W
02476:  MOVWF  FEA
02478:  MOVLW  01
0247A:  MOVWF  FEF
....................     i8IndexTx++; 
0247C:  INCF   x2F,F
.................... 	for(i8Index = i8TempFront; i8Index < i8TempLen; i8Index++) 
0247E:  MOVFF  B2C,B30
02482:  MOVF   x2E,W
02484:  SUBWF  x30,W
02486:  BTFSC  FD8.0
02488:  GOTO   24C2
.................... 	{ 
.................... 		g_RS485TxBuffer[i8IndexTx]= g_stUART2RcvBuffModbus.m_ui8Arr[i8Index];  
0248C:  CLRF   03
0248E:  MOVF   x2F,W
02490:  ADDLW  E2
02492:  MOVWF  01
02494:  MOVLW  00
02496:  ADDWFC 03,F
02498:  MOVFF  03,B32
0249C:  CLRF   03
0249E:  MOVF   x30,W
024A0:  ADDLW  4E
024A2:  MOVWF  FE9
024A4:  MOVLW  02
024A6:  ADDWFC 03,W
024A8:  MOVWF  FEA
024AA:  MOVFF  FEF,B33
024AE:  MOVFF  B32,FEA
024B2:  MOVFF  01,FE9
024B6:  MOVFF  B33,FEF
....................         i8IndexTx++; 
024BA:  INCF   x2F,F
024BC:  INCF   x30,F
024BE:  GOTO   2482
.................... 	} 
.................... 	 
....................     // Send Signal to Timer 
....................     g_ui8ByteToSend = i8TempLen; 
024C2:  MOVFF  B2E,129
....................      
....................     // Raise RS485 Data Send Timer Flag On. So that our 1msTimer will take the 
....................     // Responsibility to send RS485 Data 
....................     g_fRS485DataReady = FLAG_RS485_DATA_READY; 
024C6:  MOVLW  01
024C8:  MOVLB  1
024CA:  MOVWF  x28
024CC:  MOVLB  0
024CE:  RETURN 0
.................... ////////  	//set transmit active. 
.................... ////////  	//delay_ms(DELAY_TIME_RTS_BEFORE); 
.................... ////////	output_bit(PIN_RS485_RTS,1); 
.................... ////////	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... ////////	 
.................... ////////	//send bytes. 
.................... ////////	for(unsigned int8 ui8SendBytes = 0; ui8SendBytes <= i8TempLen; ui8SendBytes++) // g_ui8RS485MaxByteCount 
.................... ////////	{ 
.................... ////////		fputc(g_RS485TxBuffer[ui8SendBytes],RS485); 
.................... ////////	} 
.................... ////////	 
.................... ////////	//hold to bytes properly transmit. 
.................... ////////	 
.................... ////////	//set transmit inactive. 
.................... ////////	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... ////////	output_bit(PIN_RS485_RTS,0); 
.................... //////////	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... } 
....................  
.................... // send response 
.................... void SendRS485ResponseForMultipleRegWrite() 
*
03208:  MOVLB  B
0320A:  CLRF   x2C
0320C:  CLRF   x2D
0320E:  CLRF   x2E
03210:  CLRF   x2F
03212:  CLRF   x31
03214:  CLRF   x30
.................... { 
.................... 	// function for sending reply 
.................... 	 
.................... 	//value assign in transmit buffer of RS485 
....................     int8 i8TempFront             = 0; 
....................     BYTE ui8Temp                 = 0; 
....................     int8 i8TempLen               = 0;   
....................     int8 i8IndexTx               = 0;   
....................             	// function for polling data 
.................... 	unsigned int16 ui16CRCvalue = 0; 
....................      
....................     i8TempFront = g_stUART2RcvBuffModbus.m_i8Front;     
03216:  MOVFF  280,B2C
....................     ui8Temp     = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront];  // g_ui8TempArrForCRCValidation 
0321A:  CLRF   03
0321C:  MOVF   x2C,W
0321E:  ADDLW  4E
03220:  MOVWF  FE9
03222:  MOVLW  02
03224:  ADDWFC 03,W
03226:  MOVWF  FEA
03228:  MOVFF  FEF,B2D
....................     i8TempLen   = 6; 
0322C:  MOVLW  06
0322E:  MOVWF  x2E
....................      
....................     g_RS485TxBuffer[i8IndexTx] = SLAVE_ID; 
03230:  CLRF   03
03232:  MOVF   x2F,W
03234:  ADDLW  E2
03236:  MOVWF  FE9
03238:  MOVLW  00
0323A:  ADDWFC 03,W
0323C:  MOVWF  FEA
0323E:  MOVLW  01
03240:  MOVWF  FEF
....................     i8IndexTx++; 
03242:  INCF   x2F,F
.................... 	for(int8 i8Index = i8TempFront; i8IndexTx < i8TempLen; i8Index++) 
03244:  MOVFF  B2C,B32
03248:  MOVF   x2E,W
0324A:  SUBWF  x2F,W
0324C:  BTFSC  FD8.0
0324E:  GOTO   3288
.................... 	{ 
.................... 		g_RS485TxBuffer[i8IndexTx]= g_stUART2RcvBuffModbus.m_ui8Arr[i8Index];  
03252:  CLRF   03
03254:  MOVF   x2F,W
03256:  ADDLW  E2
03258:  MOVWF  01
0325A:  MOVLW  00
0325C:  ADDWFC 03,F
0325E:  MOVFF  03,B35
03262:  CLRF   03
03264:  MOVF   x32,W
03266:  ADDLW  4E
03268:  MOVWF  FE9
0326A:  MOVLW  02
0326C:  ADDWFC 03,W
0326E:  MOVWF  FEA
03270:  MOVFF  FEF,B36
03274:  MOVFF  B35,FEA
03278:  MOVFF  01,FE9
0327C:  MOVFF  B36,FEF
....................         i8IndexTx++; 
03280:  INCF   x2F,F
03282:  INCF   x32,F
03284:  GOTO   3248
.................... 	} 
.................... 	 
....................     	//Function call CRC calculation. 
.................... 	ui16CRCvalue = ModbusCRC16(g_RS485TxBuffer,6); 
03288:  CLRF   x35
0328A:  MOVLW  E2
0328C:  MOVWF  x34
0328E:  MOVLW  06
03290:  MOVWF  x36
03292:  MOVLB  0
03294:  GOTO   319A
03298:  MOVFF  02,B31
0329C:  MOVFF  01,B30
.................... 	 
.................... 	g_RS485TxBuffer[6] = (unsigned int8)((ui16CRCvalue >> 0)& 0xFF); 
032A0:  MOVFF  B30,E8
032A4:  MOVLB  0
.................... 	g_RS485TxBuffer[7] = (unsigned int8)((ui16CRCvalue >> 8)& 0xFF); 
032A6:  MOVFF  B31,E9
032AA:  MOVLB  0
....................  
....................   	//set transmit active. 
....................   	delay_ms(DELAY_TIME_RTS_BEFORE); 
032AC:  MOVLW  01
032AE:  MOVLB  B
032B0:  MOVWF  x34
032B2:  MOVLB  0
032B4:  CALL   0DB2
.................... 	output_bit(PIN_RS485_RTS,1); 
032B8:  BSF    F8C.4
032BA:  BCF    F95.4
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
032BC:  MOVLW  02
032BE:  MOVLB  B
032C0:  MOVWF  x34
032C2:  MOVLB  0
032C4:  CALL   0DB2
.................... 	 
.................... 	//send bytes. 
.................... 	for(unsigned int8 ui8SendBytes = 0; ui8SendBytes <= 7; ui8SendBytes++) // g_ui8RS485MaxByteCount 
032C8:  MOVLB  B
032CA:  CLRF   x33
032CC:  MOVF   x33,W
032CE:  SUBLW  07
032D0:  BTFSS  FD8.0
032D2:  GOTO   32F8
.................... 	{ 
.................... 		fputc(g_RS485TxBuffer[ui8SendBytes],RS485); 
032D6:  CLRF   03
032D8:  MOVF   x33,W
032DA:  ADDLW  E2
032DC:  MOVWF  FE9
032DE:  MOVLW  00
032E0:  ADDWFC 03,W
032E2:  MOVWF  FEA
032E4:  MOVFF  FEF,B34
032E8:  MOVF   x34,W
032EA:  MOVLB  0
032EC:  CALL   1050
032F0:  MOVLB  B
032F2:  INCF   x33,F
032F4:  GOTO   32CC
.................... 	} 
.................... 	 
.................... 	//hold to bytes properly transmit. 
.................... 	 
.................... 	//set transmit inactive. 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
032F8:  MOVLW  02
032FA:  MOVWF  x34
032FC:  MOVLB  0
032FE:  CALL   0DB2
.................... 	output_bit(PIN_RS485_RTS,0); 
03302:  BCF    F8C.4
03304:  BCF    F95.4
03306:  GOTO   357C (RETURN)
.................... //	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... } 
....................  
.................... void MakeData(void) 
.................... { 
.................... 	//value assign in transmit buffer of RS485 
....................     int8 i8TempFront             = 0; 
....................     BYTE ui8Temp                 = 0; 
....................     int8 i8TempLen               = 0;   
....................     unsigned int16 ui16Address    = 0; 
....................     unsigned int16 ui16RegData    = 0; 
....................      
....................     g_ModbusRx.ui8Slaveid = SLAVE_ID; 
....................     g_ModbusRx.func = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_ONE]; 
....................              
....................     i8TempFront = g_stUART2RcvBuffModbus.m_i8Front;     
....................     ui8Temp     = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront];  // g_ui8TempArrForCRCValidation 
....................     i8TempLen   = GetQueueLength(); 
....................      
.................... 	int8 i8AddH = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_TWO]; 
.................... 	int8 i8AddL = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_THREE]; 
.................... 	 
....................     g_ModbusRx.u16Address = i8AddH; 
.................... 	g_ModbusRx.u16Address <<= 8; 
.................... 	g_ModbusRx.u16Address += i8AddL; 
.................... 	 
.................... 	int8 i8DataH = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_FOUR]; 
.................... 	int8 i8DataL = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_FIVE]; 
.................... 	 
.................... 	unsigned int16 ui16WriteAddress = ui16Address + 1; 
.................... 	 
.................... 	g_ModbusRx.u16LenData = i8DataH; 
.................... 	g_ModbusRx.u16LenData <<= 8; 
.................... 	g_ModbusRx.u16LenData += i8DataL; 
....................      
....................      
....................     	// prepare data for multiple register or coils 
.................... 	if((g_ModbusRx.func == RS485_FUNCTION_WRITE_MULTIPLE_REGISTERS) || (g_ModbusRx.func == RS485_FUNCTION_READ_MULTIPLE_REGISTERS))  
.................... 	{ 
.................... 		g_ModbusRx.ui8NoRegDataBytes = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_SIX]; 
.................... 		int8 iStartIndx = i8TempFront+7; 
.................... 		int8 iRegIndx = 0; 
.................... 	 
.................... 		for(int i = 0; i < g_ModbusRx.ui8NoRegDataBytes; )  
.................... 		{ 
.................... 			int8 i8DataH = g_stUART2RcvBuffModbus.m_ui8Arr[iStartIndx]; 
.................... 			int8 i8DataL = g_stUART2RcvBuffModbus.m_ui8Arr[iStartIndx+MODBUS_OFFSET_ONE]; 
.................... 	 
.................... 			unsigned int16 u16LenData = i8DataH; 
.................... 			u16LenData <<= 8; 
.................... 			u16LenData += i8DataL; 
.................... 			 
.................... 			g_ModbusRx.ui16RegisterDataArr[iRegIndx] = u16LenData; 
.................... 			 
.................... 			iStartIndx +=2; 
.................... 			iRegIndx++; 
.................... 			i +=2; 
.................... 		} 
.................... 	 
.................... 		unsigned int32 u32RegData = 0; 
.................... 		 
.................... 		if(REG_DATA_LO_TO_HI == 1)  
.................... 		{ 
.................... 			int8 j = iRegIndx-1; 
.................... 			 
.................... 			for(int8 count = 0; count < iRegIndx; count++)  
.................... 			{ 
.................... 				unsigned int16 u16LenData = g_ModbusRx.ui16RegisterDataArr[j]; 
.................... 					 
.................... 				if(j == (iRegIndx-1))  
.................... 				{ 
.................... 					u32RegData = u16LenData; 
.................... 				} 
.................... 				else  
.................... 				{ 
.................... 					u32RegData <<= 16; 
.................... 					u32RegData += u16LenData; 
.................... 				} 
.................... 				j--; 
.................... 			} 
.................... 		} 
.................... 		else  
.................... 		{ 
.................... 			int8 j = 0; 
.................... 			 
.................... 			for(int8 count = 0; count < iRegIndx; count++)  
.................... 			{ 
.................... 				unsigned int16 u16LenData = g_ModbusRx.ui16RegisterDataArr[j]; 
.................... 					 
.................... 				if(j == 0)  
.................... 				{ 
.................... 					u32RegData = u16LenData; 
.................... 				} 
.................... 				else  
.................... 				{ 
.................... 					u32RegData <<= 16; 
.................... 					u32RegData += u16LenData; 
.................... 				} 
.................... 				j++; 
.................... 			} 
.................... 		} 
.................... 		 
.................... 		g_ModbusRx.u32RegData = u32RegData; 
.................... 	} 
.................... 	else  
.................... 	{ 
.................... 		// prepare data for single register or coil 
.................... 		g_ModbusRx.ui8NoRegDataBytes = 0; 
.................... 		if(g_ModbusRx.func == RS485_FUNCTION_WRITE_SINGLE_REGISTER)  
.................... 		{ 
.................... 			g_ModbusRx.ui16RegisterDataArr[0] = g_ModbusRx.u16LenData; 
.................... 			g_ModbusRx.u32RegData = g_ModbusRx.u16LenData; 
.................... 		} 
.................... 	} 
.................... 		         
.................... } 
.................... void ProcessSingleRegister(void) 
*
02516:  MOVLB  B
02518:  CLRF   x2C
0251A:  CLRF   x2D
0251C:  CLRF   x2E
0251E:  CLRF   x30
02520:  CLRF   x2F
02522:  CLRF   x32
02524:  CLRF   x31
02526:  CLRF   x36
02528:  CLRF   x35
0252A:  CLRF   x34
0252C:  CLRF   x33
.................... { 
.................... 	// function for process single register 
.................... 	 
.................... 	//value assign in transmit buffer of RS485 
....................     int8 i8TempFront              = 0; 
....................     BYTE ui8Temp                  = 0; 
....................     int8 i8TempLen                = 0;   
....................     unsigned int16 ui16Address    = 0; 
....................     unsigned int16 ui16RegData    = 0; 
....................     unsigned int32 ui32RTC        = 0; 
....................              
....................     i8TempFront = g_stUART2RcvBuffModbus.m_i8Front;     
0252E:  MOVFF  280,B2C
....................     ui8Temp     = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront];  // g_ui8TempArrForCRCValidation 
02532:  CLRF   03
02534:  MOVF   x2C,W
02536:  ADDLW  4E
02538:  MOVWF  FE9
0253A:  MOVLW  02
0253C:  ADDWFC 03,W
0253E:  MOVWF  FEA
02540:  MOVFF  FEF,B2D
....................     i8TempLen   = GetQueueLength(); 
02544:  MOVLB  0
02546:  CALL   1C92
0254A:  MOVFF  01,B2E
....................      
.................... 	int8 i8AddH = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_TWO - 1]; 
.................... 	int8 i8AddL = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_THREE - 1]; 
0254E:  MOVLW  02
02550:  MOVLB  B
02552:  ADDWF  x2C,W
02554:  ADDLW  FF
02556:  CLRF   03
02558:  ADDLW  4E
0255A:  MOVWF  FE9
0255C:  MOVLW  02
0255E:  ADDWFC 03,W
02560:  MOVWF  FEA
02562:  MOVFF  FEF,B37
02566:  MOVLW  03
02568:  ADDWF  x2C,W
0256A:  ADDLW  FF
0256C:  CLRF   03
0256E:  ADDLW  4E
02570:  MOVWF  FE9
02572:  MOVLW  02
02574:  ADDWFC 03,W
02576:  MOVWF  FEA
02578:  MOVFF  FEF,B38
.................... 	 
....................     ui16Address = i8AddH; 
0257C:  CLRF   x30
0257E:  MOVFF  B37,B2F
.................... 	ui16Address <<= 8; 
02582:  MOVFF  B2F,B30
02586:  CLRF   x2F
.................... 	ui16Address += i8AddL; 
02588:  MOVF   x38,W
0258A:  ADDWF  x2F,F
0258C:  MOVLW  00
0258E:  ADDWFC x30,F
....................      
.................... 	 
.................... 	int8 i8DataH = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_FOUR -1]; 
.................... 	int8 i8DataL = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_FIVE -1]; 
.................... 	 
.................... 	unsigned int16 ui16WriteAddress = ui16Address + 1; 
02590:  MOVLW  04
02592:  ADDWF  x2C,W
02594:  ADDLW  FF
02596:  CLRF   03
02598:  ADDLW  4E
0259A:  MOVWF  FE9
0259C:  MOVLW  02
0259E:  ADDWFC 03,W
025A0:  MOVWF  FEA
025A2:  MOVFF  FEF,B39
025A6:  MOVLW  05
025A8:  ADDWF  x2C,W
025AA:  ADDLW  FF
025AC:  CLRF   03
025AE:  ADDLW  4E
025B0:  MOVWF  FE9
025B2:  MOVLW  02
025B4:  ADDWFC 03,W
025B6:  MOVWF  FEA
025B8:  MOVFF  FEF,B3A
025BC:  MOVLW  01
025BE:  ADDWF  x2F,W
025C0:  MOVWF  x3B
025C2:  MOVLW  00
025C4:  ADDWFC x30,W
025C6:  MOVWF  x3C
.................... 	 
.................... 	ui16RegData = i8DataH; 
025C8:  CLRF   x32
025CA:  MOVFF  B39,B31
.................... 	ui16RegData <<= 8; 
025CE:  MOVFF  B31,B32
025D2:  CLRF   x31
.................... 	ui16RegData += i8DataL; 
025D4:  MOVF   x3A,W
025D6:  ADDWF  x31,F
025D8:  MOVLW  00
025DA:  ADDWFC x32,F
.................... 		     
....................     // set led on or off depending on received bytes 
.................... //    unsigned int8 ui8RetVal1  = IsBitOn(0,ui16RegData); 
.................... //    unsigned int8 ui8RetVal2  = IsBitOn(1,ui16RegData); 
.................... //    unsigned int8 ui8RetVal3  = IsBitOn(2,ui16RegData); 
.................... //    unsigned int8 ui8RetVal4  = IsBitOn(3,ui16RegData); 
.................... //    unsigned int8 ui8RetVal5  = IsBitOn(4,ui16RegData); 
.................... //    unsigned int8 ui8RetVal6  = IsBitOn(5,ui16RegData); 
.................... //    unsigned int8 ui8RetVal7  = IsBitOn(6,ui16RegData); 
.................... //    unsigned int8 ui8RetVal8  = IsBitOn(7,ui16RegData); 
.................... //    unsigned int8 ui8RetVal9  = IsBitOn(8,ui16RegData); 
.................... //    unsigned int8 ui8RetVal10 = IsBitOn(9,ui16RegData); 
.................... //    unsigned int8 ui8RetVal11 = IsBitOn(10,ui16RegData); 
.................... //    unsigned int8 ui8RetVal12 = IsBitOn(11,ui16RegData); 
.................... //    unsigned int8 ui8RetVal13 = IsBitOn(12,ui16RegData); 
.................... //    unsigned int8 ui8RetVal14 = IsBitOn(13,ui16RegData); 
.................... //    unsigned int8 ui8RetVal15 = IsBitOn(14,ui16RegData); 
.................... //    unsigned int8 ui8RetVal16 = IsBitOn(15,ui16RegData); 
....................      
....................     // Set Mode  
....................     switch(ui16Address) 
025DC:  MOVF   x2F,W
025DE:  MOVWF  00
025E0:  MOVF   x30,W
025E2:  MOVWF  03
025E4:  MOVF   03,W
025E6:  BTFSS  FD8.2
025E8:  GOTO   25FA
025EC:  MOVLW  05
025EE:  SUBWF  00,W
025F0:  MOVLB  0
025F2:  BTFSC  FD8.2
025F4:  GOTO   2818
025F8:  MOVLB  B
025FA:  MOVLW  02
025FC:  SUBWF  03,W
025FE:  BTFSS  FD8.2
02600:  GOTO   2612
02604:  MOVLW  50
02606:  SUBWF  00,W
02608:  MOVLB  0
0260A:  BTFSC  FD8.2
0260C:  GOTO   29F8
02610:  MOVLB  B
02612:  MOVLW  02
02614:  SUBWF  03,W
02616:  BTFSS  FD8.2
02618:  GOTO   262A
0261C:  MOVLW  52
0261E:  SUBWF  00,W
02620:  MOVLB  0
02622:  BTFSC  FD8.2
02624:  GOTO   2A06
02628:  MOVLB  B
0262A:  MOVLW  02
0262C:  SUBWF  03,W
0262E:  BTFSS  FD8.2
02630:  GOTO   2642
02634:  MOVLW  54
02636:  SUBWF  00,W
02638:  MOVLB  0
0263A:  BTFSC  FD8.2
0263C:  GOTO   2A14
02640:  MOVLB  B
02642:  MOVLW  02
02644:  SUBWF  03,W
02646:  BTFSS  FD8.2
02648:  GOTO   265A
0264C:  MOVLW  56
0264E:  SUBWF  00,W
02650:  MOVLB  0
02652:  BTFSC  FD8.2
02654:  GOTO   2A22
02658:  MOVLB  B
0265A:  MOVLW  05
0265C:  SUBWF  03,W
0265E:  BTFSS  FD8.2
02660:  GOTO   2672
02664:  MOVLW  92
02666:  SUBWF  00,W
02668:  MOVLB  0
0266A:  BTFSC  FD8.2
0266C:  GOTO   2A30
02670:  MOVLB  B
02672:  MOVLW  02
02674:  SUBWF  03,W
02676:  BTFSS  FD8.2
02678:  GOTO   268A
0267C:  MOVLW  82
0267E:  SUBWF  00,W
02680:  MOVLB  0
02682:  BTFSC  FD8.2
02684:  GOTO   2A72
02688:  MOVLB  B
0268A:  MOVLW  07
0268C:  SUBWF  03,W
0268E:  BTFSS  FD8.2
02690:  GOTO   26A2
02694:  MOVLW  20
02696:  SUBWF  00,W
02698:  MOVLB  0
0269A:  BTFSC  FD8.2
0269C:  GOTO   2AE6
026A0:  MOVLB  B
026A2:  MOVLW  05
026A4:  SUBWF  03,W
026A6:  BTFSS  FD8.2
026A8:  GOTO   26BA
026AC:  MOVLW  70
026AE:  SUBWF  00,W
026B0:  MOVLB  0
026B2:  BTFSC  FD8.2
026B4:  GOTO   2AF4
026B8:  MOVLB  B
026BA:  MOVLW  05
026BC:  SUBWF  03,W
026BE:  BTFSS  FD8.2
026C0:  GOTO   26D0
026C4:  MOVF   00,F
026C6:  MOVLB  0
026C8:  BTFSC  FD8.2
026CA:  GOTO   2B44
026CE:  MOVLB  B
026D0:  MOVLW  05
026D2:  SUBWF  03,W
026D4:  BTFSS  FD8.2
026D6:  GOTO   26E8
026DA:  MOVLW  50
026DC:  SUBWF  00,W
026DE:  MOVLB  0
026E0:  BTFSC  FD8.2
026E2:  GOTO   2B56
026E6:  MOVLB  B
026E8:  MOVLW  05
026EA:  SUBWF  03,W
026EC:  BTFSS  FD8.2
026EE:  GOTO   2700
026F2:  MOVLW  52
026F4:  SUBWF  00,W
026F6:  MOVLB  0
026F8:  BTFSC  FD8.2
026FA:  GOTO   2BD2
026FE:  MOVLB  B
02700:  MOVLW  05
02702:  SUBWF  03,W
02704:  BTFSS  FD8.2
02706:  GOTO   2718
0270A:  MOVLW  54
0270C:  SUBWF  00,W
0270E:  MOVLB  0
02710:  BTFSC  FD8.2
02712:  GOTO   2BE8
02716:  MOVLB  B
02718:  MOVF   03,W
0271A:  BTFSS  FD8.2
0271C:  GOTO   272E
02720:  MOVLW  10
02722:  SUBWF  00,W
02724:  MOVLB  0
02726:  BTFSC  FD8.2
02728:  GOTO   2C60
0272C:  MOVLB  B
0272E:  MOVF   03,W
02730:  BTFSS  FD8.2
02732:  GOTO   2744
02736:  MOVLW  11
02738:  SUBWF  00,W
0273A:  MOVLB  0
0273C:  BTFSC  FD8.2
0273E:  GOTO   2C6E
02742:  MOVLB  B
02744:  MOVF   03,W
02746:  BTFSS  FD8.2
02748:  GOTO   275A
0274C:  MOVLW  12
0274E:  SUBWF  00,W
02750:  MOVLB  0
02752:  BTFSC  FD8.2
02754:  GOTO   2C7C
02758:  MOVLB  B
0275A:  MOVF   03,W
0275C:  BTFSS  FD8.2
0275E:  GOTO   2770
02762:  MOVLW  14
02764:  SUBWF  00,W
02766:  MOVLB  0
02768:  BTFSC  FD8.2
0276A:  GOTO   2C8A
0276E:  MOVLB  B
02770:  MOVF   03,W
02772:  BTFSS  FD8.2
02774:  GOTO   2786
02778:  MOVLW  15
0277A:  SUBWF  00,W
0277C:  MOVLB  0
0277E:  BTFSC  FD8.2
02780:  GOTO   2C98
02784:  MOVLB  B
02786:  MOVF   03,W
02788:  BTFSS  FD8.2
0278A:  GOTO   279C
0278E:  MOVLW  16
02790:  SUBWF  00,W
02792:  MOVLB  0
02794:  BTFSC  FD8.2
02796:  GOTO   2CA6
0279A:  MOVLB  B
0279C:  MOVLW  03
0279E:  SUBWF  03,W
027A0:  BTFSS  FD8.2
027A2:  GOTO   27B4
027A6:  MOVLW  15
027A8:  SUBWF  00,W
027AA:  MOVLB  0
027AC:  BTFSC  FD8.2
027AE:  GOTO   2CB8
027B2:  MOVLB  B
027B4:  MOVLW  03
027B6:  SUBWF  03,W
027B8:  BTFSS  FD8.2
027BA:  GOTO   27CC
027BE:  MOVLW  10
027C0:  SUBWF  00,W
027C2:  MOVLB  0
027C4:  BTFSC  FD8.2
027C6:  GOTO   2CC6
027CA:  MOVLB  B
027CC:  MOVLW  02
027CE:  SUBWF  03,W
027D0:  BTFSS  FD8.2
027D2:  GOTO   27E4
027D6:  MOVLW  99
027D8:  SUBWF  00,W
027DA:  MOVLB  0
027DC:  BTFSC  FD8.2
027DE:  GOTO   2CE4
027E2:  MOVLB  B
027E4:  MOVLW  07
027E6:  SUBWF  03,W
027E8:  BTFSS  FD8.2
027EA:  GOTO   27FC
027EE:  MOVLW  10
027F0:  SUBWF  00,W
027F2:  MOVLB  0
027F4:  BTFSC  FD8.2
027F6:  GOTO   2D68
027FA:  MOVLB  B
027FC:  MOVLW  07
027FE:  SUBWF  03,W
02800:  BTFSS  FD8.2
02802:  GOTO   2814
02806:  MOVLW  11
02808:  SUBWF  00,W
0280A:  MOVLB  0
0280C:  BTFSC  FD8.2
0280E:  GOTO   2D8A
02812:  MOVLB  B
02814:  GOTO   2DFA
....................     { 
....................         case MODE_ADDRESS: 
....................         { 
....................             g_ui16CurrentMode = ui16RegData;             
02818:  MOVFF  B32,A6
0281C:  MOVFF  B31,A5
....................              
....................             // Insert in IBC data send queue 
....................  //           InitRunningWeightArray(); 
....................              
.................... //            unsigned int16 data = 0; 
.................... //            for(int8 i= 0; i<10; i++) 
.................... //            { 
.................... //                data = 0 + 1000; 
.................... //                g_ui16RunningAvgWt = ProcessWeightData(g_ui16CurrentWt); 
.................... //            } 
....................              
....................             switch(ui16RegData) 
02820:  MOVLB  B
02822:  MOVF   x31,W
02824:  MOVWF  00
02826:  MOVF   x32,W
02828:  MOVWF  03
0282A:  MOVF   03,W
0282C:  BTFSS  FD8.2
0282E:  GOTO   283E
02832:  MOVF   00,F
02834:  MOVLB  0
02836:  BTFSC  FD8.2
02838:  GOTO   28B0
0283C:  MOVLB  B
0283E:  MOVF   03,W
02840:  BTFSS  FD8.2
02842:  GOTO   2854
02846:  MOVLW  01
02848:  SUBWF  00,W
0284A:  MOVLB  0
0284C:  BTFSC  FD8.2
0284E:  GOTO   28BA
02852:  MOVLB  B
02854:  MOVF   03,W
02856:  BTFSS  FD8.2
02858:  GOTO   286A
0285C:  MOVLW  02
0285E:  SUBWF  00,W
02860:  MOVLB  0
02862:  BTFSC  FD8.2
02864:  GOTO   2906
02868:  MOVLB  B
0286A:  MOVF   03,W
0286C:  BTFSS  FD8.2
0286E:  GOTO   2880
02872:  MOVLW  03
02874:  SUBWF  00,W
02876:  MOVLB  0
02878:  BTFSC  FD8.2
0287A:  GOTO   2952
0287E:  MOVLB  B
02880:  MOVF   03,W
02882:  BTFSS  FD8.2
02884:  GOTO   2896
02888:  MOVLW  04
0288A:  SUBWF  00,W
0288C:  MOVLB  0
0288E:  BTFSC  FD8.2
02890:  GOTO   299E
02894:  MOVLB  B
02896:  MOVF   03,W
02898:  BTFSS  FD8.2
0289A:  GOTO   28AC
0289E:  MOVLW  05
028A0:  SUBWF  00,W
028A2:  MOVLB  0
028A4:  BTFSC  FD8.2
028A6:  GOTO   29A8
028AA:  MOVLB  B
028AC:  GOTO   29F4
....................             { 
....................                 case BOARD_MODE_TYPE_NOTHING: 
....................                 { 
....................                     SetModeNothing(); 
028B0:  GOTO   24D0
....................                    // output_bit(PIN_OUT_DO_00,0); 
....................                 } 
....................                 break; 
028B4:  MOVLB  B
028B6:  GOTO   29F4
....................                 case BOARD_MODE_TYPE_HOME: 
....................                 { 
....................                     SetModeHome(); 
028BA:  GOTO   24DA
....................                      
....................                     // Stuff IBC Command 
....................                     g_stIBCSendData.g_ui8ArrIBCData[0] = IBC_CMD_MODE_HOME; 
028BE:  MOVLW  64
028C0:  MOVLB  1
028C2:  MOVWF  x34
....................                     for(unsigned int8 ui8Loopcount = 1; ui8Loopcount < IBC_MSG_BYTE_COUNT; ui8Loopcount++) 
028C4:  MOVLW  01
028C6:  MOVLB  B
028C8:  MOVWF  x3D
028CA:  MOVF   x3D,W
028CC:  SUBLW  04
028CE:  BTFSS  FD8.0
028D0:  GOTO   28EA
....................                     { 
....................                         // Staff padding bytes 
....................                         g_stIBCSendData.g_ui8ArrIBCData[ui8Loopcount] = 0; 
028D4:  CLRF   03
028D6:  MOVF   x3D,W
028D8:  ADDLW  34
028DA:  MOVWF  FE9
028DC:  MOVLW  01
028DE:  ADDWFC 03,W
028E0:  MOVWF  FEA
028E2:  CLRF   FEF
028E4:  INCF   x3D,F
028E6:  GOTO   28CA
....................                     }  
....................                      
....................                     // Insert data in IBC Send queue 
....................                    //InsertSendQueue(&g_stIBCSendData); 
....................                     InsertIBCMsgQueue(&g_stIBCSendQueue, &g_stIBCSendData); 
028EA:  MOVLW  01
028EC:  MOVWF  x49
028EE:  MOVLW  88
028F0:  MOVWF  x48
028F2:  MOVLW  01
028F4:  MOVWF  x4B
028F6:  MOVLW  34
028F8:  MOVWF  x4A
028FA:  MOVLB  0
028FC:  CALL   0E5C
....................                      
....................                 } 
....................                 break; 
02900:  MOVLB  B
02902:  GOTO   29F4
....................                 case BOARD_MODE_TYPE_PRE_PRODUCTION: 
....................                 { 
....................                     SetModePreProduction(); 
02906:  GOTO   24E6
....................                      
....................                     // Stuff IBC Command 
....................                     g_stIBCSendData.g_ui8ArrIBCData[0] = IBC_CMD_MODE_PRE_PROD; 
0290A:  MOVLW  6B
0290C:  MOVLB  1
0290E:  MOVWF  x34
....................                     for(unsigned int8 ui8Loopcount = 1; ui8Loopcount < IBC_MSG_BYTE_COUNT; ui8Loopcount++) 
02910:  MOVLW  01
02912:  MOVLB  B
02914:  MOVWF  x3E
02916:  MOVF   x3E,W
02918:  SUBLW  04
0291A:  BTFSS  FD8.0
0291C:  GOTO   2936
....................                     { 
....................                         // Staff padding bytes 
....................                         g_stIBCSendData.g_ui8ArrIBCData[ui8Loopcount] = 0; 
02920:  CLRF   03
02922:  MOVF   x3E,W
02924:  ADDLW  34
02926:  MOVWF  FE9
02928:  MOVLW  01
0292A:  ADDWFC 03,W
0292C:  MOVWF  FEA
0292E:  CLRF   FEF
02930:  INCF   x3E,F
02932:  GOTO   2916
....................                     }  
....................                      
....................                     // Insert data in IBC Send queue 
....................                     //InsertSendQueue(&g_stIBCSendData); 
....................                     InsertIBCMsgQueue(&g_stIBCSendQueue, &g_stIBCSendData); 
02936:  MOVLW  01
02938:  MOVWF  x49
0293A:  MOVLW  88
0293C:  MOVWF  x48
0293E:  MOVLW  01
02940:  MOVWF  x4B
02942:  MOVLW  34
02944:  MOVWF  x4A
02946:  MOVLB  0
02948:  CALL   0E5C
....................  
....................                 // output_bit(PIN_OUT_DO_02,0); 
....................                 } 
....................                 break; 
0294C:  MOVLB  B
0294E:  GOTO   29F4
....................                 case BOARD_MODE_TYPE_PRODUCTION: 
....................                 { 
....................                     SetModeProduction(); 
02952:  GOTO   24F2
....................                      
....................                     // Stuff IBC Command 
....................                     g_stIBCSendData.g_ui8ArrIBCData[0] = IBC_CMD_MODE_PROD; 
02956:  MOVLW  70
02958:  MOVLB  1
0295A:  MOVWF  x34
....................                     for(unsigned int8 ui8Loopcount = 1; ui8Loopcount < IBC_MSG_BYTE_COUNT; ui8Loopcount++) 
0295C:  MOVLW  01
0295E:  MOVLB  B
02960:  MOVWF  x3F
02962:  MOVF   x3F,W
02964:  SUBLW  04
02966:  BTFSS  FD8.0
02968:  GOTO   2982
....................                     { 
....................                         // Staff padding bytes 
....................                         g_stIBCSendData.g_ui8ArrIBCData[ui8Loopcount] = 0; 
0296C:  CLRF   03
0296E:  MOVF   x3F,W
02970:  ADDLW  34
02972:  MOVWF  FE9
02974:  MOVLW  01
02976:  ADDWFC 03,W
02978:  MOVWF  FEA
0297A:  CLRF   FEF
0297C:  INCF   x3F,F
0297E:  GOTO   2962
....................                     }  
....................                      
....................                     // Insert data in IBC Send queue 
....................                     //InsertSendQueue(&g_stIBCSendData);                     
....................                     InsertIBCMsgQueue(&g_stIBCSendQueue, &g_stIBCSendData); 
02982:  MOVLW  01
02984:  MOVWF  x49
02986:  MOVLW  88
02988:  MOVWF  x48
0298A:  MOVLW  01
0298C:  MOVWF  x4B
0298E:  MOVLW  34
02990:  MOVWF  x4A
02992:  MOVLB  0
02994:  CALL   0E5C
....................                      
....................  
....................                 } 
....................                 break; 
02998:  MOVLB  B
0299A:  GOTO   29F4
....................                 case BOARD_MODE_TYPE_CONFIGURATION:  
....................                 { 
....................                     SetModeConfiguration(); 
0299E:  GOTO   24FE
....................                                          
....................                      
....................  
....................                 //    output_bit(PIN_OUT_DO_04,0); 
....................                 } 
....................                 break; 
029A2:  MOVLB  B
029A4:  GOTO   29F4
....................                 case BOARD_MODE_TYPE_CALIBRATION: 
....................                 { 
....................                     SetModeCalibration(); 
029A8:  GOTO   250A
....................                      
....................                     // Stuff IBC Command 
....................                     g_stIBCSendData.g_ui8ArrIBCData[0] = IBC_CMD_MODE_CALIB; 
029AC:  MOVLW  65
029AE:  MOVLB  1
029B0:  MOVWF  x34
....................                     for(unsigned int8 ui8Loopcount = 1; ui8Loopcount < IBC_MSG_BYTE_COUNT; ui8Loopcount++) 
029B2:  MOVLW  01
029B4:  MOVLB  B
029B6:  MOVWF  x40
029B8:  MOVF   x40,W
029BA:  SUBLW  04
029BC:  BTFSS  FD8.0
029BE:  GOTO   29D8
....................                     { 
....................                         // Staff padding bytes 
....................                         g_stIBCSendData.g_ui8ArrIBCData[ui8Loopcount] = 0; 
029C2:  CLRF   03
029C4:  MOVF   x40,W
029C6:  ADDLW  34
029C8:  MOVWF  FE9
029CA:  MOVLW  01
029CC:  ADDWFC 03,W
029CE:  MOVWF  FEA
029D0:  CLRF   FEF
029D2:  INCF   x40,F
029D4:  GOTO   29B8
....................                     }  
....................                      
....................                     // Insert data in IBC Send queue 
....................                     //InsertSendQueue(&g_stIBCSendData);    
....................                     InsertIBCMsgQueue(&g_stIBCSendQueue, &g_stIBCSendData); 
029D8:  MOVLW  01
029DA:  MOVWF  x49
029DC:  MOVLW  88
029DE:  MOVWF  x48
029E0:  MOVLW  01
029E2:  MOVWF  x4B
029E4:  MOVLW  34
029E6:  MOVWF  x4A
029E8:  MOVLB  0
029EA:  CALL   0E5C
....................                      
....................                 } 
....................                 break; 
029EE:  MOVLB  B
029F0:  GOTO   29F4
....................             }; 
....................         } 
....................         break; 
029F4:  GOTO   2DFA
....................         case ADDRESS_FOR_SET_CONFIG_AVG_WT: 
....................         { 
....................             // Average weight received from HMI through Modbus. 
....................             g_ui16RegisterAvgWeight = ui16RegData; 
029F8:  MOVFF  B32,78
029FC:  MOVFF  B31,77
....................         } 
....................         break; 
02A00:  MOVLB  B
02A02:  GOTO   2DFA
....................         case ADDRESS_FOR_SET_CONFIG_TOL_PV: 
....................         { 
....................             // Positive Tolerance received from HMI through Modbus 
....................             g_ui16RegisterTolPv = ui16RegData;         
02A06:  MOVFF  B32,7A
02A0A:  MOVFF  B31,79
....................         } 
....................         break; 
02A0E:  MOVLB  B
02A10:  GOTO   2DFA
....................         case ADDRESS_FOR_SET_CONFIG_TOL_NV: 
....................         { 
....................              // Negative Tolerance  received from HMI through Modbus 
....................             g_ui16RegisterTolNv = ui16RegData;             
02A14:  MOVFF  B32,7C
02A18:  MOVFF  B31,7B
....................         } 
....................         break; 
02A1C:  MOVLB  B
02A1E:  GOTO   2DFA
....................         case ADDRESS_FOR_SET_CONFIG_INDEX: 
....................         { 
....................             g_ui16RegisterCurrProductIndex = ui16RegData; 
02A22:  MOVFF  B32,7E
02A26:  MOVFF  B31,7D
....................         } 
....................         break; 
02A2A:  MOVLB  B
02A2C:  GOTO   2DFA
....................         case ADDRESS_FOR_UPDATE_CALIB_TABLE: 
....................         { 
....................             // Stuff IBC command 
....................             //g_stIBCSendData.g_ui8ArrIBCData[0] = IBC_CMD_UPDATE_CALIB_TABLE; 
....................              
....................             // Staff padding bytes             
....................             for(unsigned int8 ui8LoopCount = 1; ui8LoopCount < IBC_MSG_BYTE_COUNT; ui8LoopCount++) 
02A30:  MOVLW  01
02A32:  MOVLB  B
02A34:  MOVWF  x41
02A36:  MOVF   x41,W
02A38:  SUBLW  04
02A3A:  BTFSS  FD8.0
02A3C:  GOTO   2A56
....................             {                 
....................                 g_stIBCSendData.g_ui8ArrIBCData[ui8LoopCount] = 0; 
02A40:  CLRF   03
02A42:  MOVF   x41,W
02A44:  ADDLW  34
02A46:  MOVWF  FE9
02A48:  MOVLW  01
02A4A:  ADDWFC 03,W
02A4C:  MOVWF  FEA
02A4E:  CLRF   FEF
02A50:  INCF   x41,F
02A52:  GOTO   2A36
....................             } 
....................             // Insert data in  IBC send queue to MCU0_ADC_Module 
....................             //InsertSendQueue(&g_stIBCSendData); 
....................             InsertIBCMsgQueue(&g_stIBCSendQueue, &g_stIBCSendData); 
02A56:  MOVLW  01
02A58:  MOVWF  x49
02A5A:  MOVLW  88
02A5C:  MOVWF  x48
02A5E:  MOVLW  01
02A60:  MOVWF  x4B
02A62:  MOVLW  34
02A64:  MOVWF  x4A
02A66:  MOVLB  0
02A68:  CALL   0E5C
....................         } 
....................         break; 
02A6C:  MOVLB  B
02A6E:  GOTO   2DFA
....................         case ADDRESS_FOR_SET_LOAD_CELL_FACTOR: 
....................         { 
....................             // Store current load cell factor value in RAM. 
....................             g_unIBCCurrLoadCellFactor.m_stLoadCellFactor.m_ui16CurrLoadCellFactor = ui16RegData; 
02A72:  MOVFF  B32,D4
02A76:  MOVFF  B31,D3
....................             g_unIBCCurrLoadCellFactor.m_stLoadCellFactor.m_ui16Padding = 0; 
02A7A:  CLRF   xD6
02A7C:  CLRF   xD5
....................              
....................             // Stuff IBC command 
....................             g_stIBCSendData.g_ui8ArrIBCData[0] = IBC_CMD_SET_LOAD_CELL_FACTOR; 
02A7E:  MOVLW  73
02A80:  MOVLB  1
02A82:  MOVWF  x34
....................              
....................             // Staff  bytes             
....................             for(unsigned int8 ui8LoopCount = 1; ui8LoopCount < IBC_MSG_BYTE_COUNT; ui8LoopCount++) 
02A84:  MOVLW  01
02A86:  MOVLB  B
02A88:  MOVWF  x42
02A8A:  MOVF   x42,W
02A8C:  SUBLW  04
02A8E:  BTFSS  FD8.0
02A90:  GOTO   2ACA
....................             {                 
....................                 g_stIBCSendData.g_ui8ArrIBCData[ui8LoopCount] = g_unIBCCurrLoadCellFactor.m_ui8Arr[ui8LoopCount - 1]; 
02A94:  CLRF   03
02A96:  MOVF   x42,W
02A98:  ADDLW  34
02A9A:  MOVWF  01
02A9C:  MOVLW  01
02A9E:  ADDWFC 03,F
02AA0:  MOVFF  03,B49
02AA4:  MOVLW  01
02AA6:  SUBWF  x42,W
02AA8:  CLRF   03
02AAA:  ADDLW  D3
02AAC:  MOVWF  FE9
02AAE:  MOVLW  00
02AB0:  ADDWFC 03,W
02AB2:  MOVWF  FEA
02AB4:  MOVFF  FEF,B4A
02AB8:  MOVFF  B49,FEA
02ABC:  MOVFF  01,FE9
02AC0:  MOVFF  B4A,FEF
02AC4:  INCF   x42,F
02AC6:  GOTO   2A8A
....................             } 
....................             // Insert data in  IBC send queue to MCU0_ADC_Module 
....................             //InsertSendQueue(&g_stIBCSendData); 
....................             InsertIBCMsgQueue(&g_stIBCSendQueue, &g_stIBCSendData); 
02ACA:  MOVLW  01
02ACC:  MOVWF  x49
02ACE:  MOVLW  88
02AD0:  MOVWF  x48
02AD2:  MOVLW  01
02AD4:  MOVWF  x4B
02AD6:  MOVLW  34
02AD8:  MOVWF  x4A
02ADA:  MOVLB  0
02ADC:  CALL   0E5C
....................         } 
....................         break; 
02AE0:  MOVLB  B
02AE2:  GOTO   2DFA
....................         case ADDRESS_FOR_PREV_CBB_COUNT_IN_PRODUCTION: 
....................         { 
....................             g_ui16CBBCountPrev = ui16RegData; 
02AE6:  MOVFF  B32,82
02AEA:  MOVFF  B31,81
....................              
.................... //           // Stuff IBC command 
.................... //            g_stIBCSendData.g_ui8ArrIBCData[0] = IBC_CMD_TARE_REQUEST; 
.................... //            // Staff padding bytes             
.................... //            for(unsigned int8 ui8LoopCount = 1; ui8LoopCount < IBC_MSG_BYTE_COUNT; ui8LoopCount++) 
.................... //            { 
.................... //                g_stIBCSendData.g_ui8ArrIBCData[ui8LoopCount] = 0; 
.................... //            } 
.................... //            // Insert data in  IBC send queue to MCU0_ADC_Module 
.................... //            //InsertSendQueue(&g_stIBCSendData); 
.................... //            InsertIBCMsgQueue(&g_stIBCSendQueue, &g_stIBCSendData);             
....................         } 
....................         break; 
02AEE:  MOVLB  B
02AF0:  GOTO   2DFA
....................         case ADDRESS_FOR_WRITE_TARE_VALUE: 
....................         { 
....................             g_ui16FlagForSetTareValue = ui16RegData; 
02AF4:  MOVFF  B32,8E
02AF8:  MOVFF  B31,8D
....................              
....................            // Stuff IBC command 
....................             g_stIBCSendData.g_ui8ArrIBCData[0] = IBC_CMD_TARE_REQUEST; 
02AFC:  MOVLW  6A
02AFE:  MOVLB  1
02B00:  MOVWF  x34
....................             // Staff padding bytes             
....................             for(unsigned int8 ui8LoopCount = 1; ui8LoopCount < IBC_MSG_BYTE_COUNT; ui8LoopCount++) 
02B02:  MOVLW  01
02B04:  MOVLB  B
02B06:  MOVWF  x43
02B08:  MOVF   x43,W
02B0A:  SUBLW  04
02B0C:  BTFSS  FD8.0
02B0E:  GOTO   2B28
....................             {                 
....................                 g_stIBCSendData.g_ui8ArrIBCData[ui8LoopCount] = 0; 
02B12:  CLRF   03
02B14:  MOVF   x43,W
02B16:  ADDLW  34
02B18:  MOVWF  FE9
02B1A:  MOVLW  01
02B1C:  ADDWFC 03,W
02B1E:  MOVWF  FEA
02B20:  CLRF   FEF
02B22:  INCF   x43,F
02B24:  GOTO   2B08
....................             } 
....................             // Insert data in  IBC send queue to MCU0_ADC_Module 
....................             //InsertSendQueue(&g_stIBCSendData); 
....................             InsertIBCMsgQueue(&g_stIBCSendQueue, &g_stIBCSendData);             
02B28:  MOVLW  01
02B2A:  MOVWF  x49
02B2C:  MOVLW  88
02B2E:  MOVWF  x48
02B30:  MOVLW  01
02B32:  MOVWF  x4B
02B34:  MOVLW  34
02B36:  MOVWF  x4A
02B38:  MOVLB  0
02B3A:  CALL   0E5C
....................              
....................         } 
....................         break; 
02B3E:  MOVLB  B
02B40:  GOTO   2DFA
....................         case ADDRESS_FOR_PRODUCTION_INDEX_PRE_PRODUCTION: 
....................         { 
....................             g_ui16CurrProdIndex = ui16RegData; 
02B44:  MOVFF  B32,9E
02B48:  MOVFF  B31,9D
....................             g_stGPRSMsgHeader.m_ui8Variety = g_ui16CurrProdIndex; 
02B4C:  MOVFF  9D,295
....................              
....................         } 
....................         break; 
02B50:  MOVLB  B
02B52:  GOTO   2DFA
....................         case ADDRESS_FOR_PRODUCTION_AVG_WT_PRE_PRODUCTION: 
....................         { 
....................             g_ui16CurrProdAvgWt = ui16RegData; 
02B56:  MOVFF  B32,A0
02B5A:  MOVFF  B31,9F
....................              
....................             // Insert data in Average weight node 
....................             g_unIBCAvgNode.m_stIBCAvgNode.m_i16AvgWt = (int16)g_ui16CurrProdAvgWt; 
02B5E:  MOVFF  A0,C0
02B62:  MOVFF  9F,BF
....................             g_unIBCAvgNode.m_stIBCAvgNode.m_i16Padding = 0; 
02B66:  CLRF   xC2
02B68:  CLRF   xC1
....................              
....................             // Stuff IBC command 
....................             g_stIBCSendData.g_ui8ArrIBCData[0] = IBC_CMD_PRE_PROD_AVG_WEIGHT; 
02B6A:  MOVLW  6C
02B6C:  MOVLB  1
02B6E:  MOVWF  x34
....................             for(unsigned int8 ui8LoopCount = 1; ui8LoopCount < IBC_MSG_BYTE_COUNT; ui8LoopCount++) 
02B70:  MOVLW  01
02B72:  MOVLB  B
02B74:  MOVWF  x44
02B76:  MOVF   x44,W
02B78:  SUBLW  04
02B7A:  BTFSS  FD8.0
02B7C:  GOTO   2BB6
....................             { 
....................                 g_stIBCSendData.g_ui8ArrIBCData[ui8LoopCount] = g_unIBCAvgNode.m_ui8Arr[ui8LoopCount - 1]; 
02B80:  CLRF   03
02B82:  MOVF   x44,W
02B84:  ADDLW  34
02B86:  MOVWF  01
02B88:  MOVLW  01
02B8A:  ADDWFC 03,F
02B8C:  MOVFF  03,B49
02B90:  MOVLW  01
02B92:  SUBWF  x44,W
02B94:  CLRF   03
02B96:  ADDLW  BF
02B98:  MOVWF  FE9
02B9A:  MOVLW  00
02B9C:  ADDWFC 03,W
02B9E:  MOVWF  FEA
02BA0:  MOVFF  FEF,B4A
02BA4:  MOVFF  B49,FEA
02BA8:  MOVFF  01,FE9
02BAC:  MOVFF  B4A,FEF
02BB0:  INCF   x44,F
02BB2:  GOTO   2B76
....................             } 
....................              
....................             // Insert data in  IBC send queue to MCU0_ADC_Module 
....................             //InsertSendQueue(&g_stIBCSendData); 
....................             InsertIBCMsgQueue(&g_stIBCSendQueue, &g_stIBCSendData); 
02BB6:  MOVLW  01
02BB8:  MOVWF  x49
02BBA:  MOVLW  88
02BBC:  MOVWF  x48
02BBE:  MOVLW  01
02BC0:  MOVWF  x4B
02BC2:  MOVLW  34
02BC4:  MOVWF  x4A
02BC6:  MOVLB  0
02BC8:  CALL   0E5C
....................         } 
....................         break; 
02BCC:  MOVLB  B
02BCE:  GOTO   2DFA
....................         case ADDRESS_FOR_PRODUCTION_PV_TOL_PRE_PRODUCTION: 
....................         { 
....................             g_ui16CurrProdPvTol = ui16RegData; 
02BD2:  MOVFF  B32,A2
02BD6:  MOVFF  B31,A1
....................              
....................             // Insert data in common Tolerance node 
....................             g_unIBCTolNode.m_stIBCTolNode.m_i16PositiveTol = (int16)g_ui16CurrProdPvTol; 
02BDA:  MOVFF  A2,C4
02BDE:  MOVFF  A1,C3
....................              
....................         } 
....................         break; 
02BE2:  MOVLB  B
02BE4:  GOTO   2DFA
....................         case ADDRESS_FOR_PRODUCTION_NV_TOL_PRE_PRODUCTION: 
....................         { 
....................             g_ui16CurrProdNvTol = ui16RegData; 
02BE8:  MOVFF  B32,A4
02BEC:  MOVFF  B31,A3
....................              
....................            // Insert data in common Tolerance node(LSB) 
....................             g_unIBCTolNode.m_stIBCTolNode.m_i16NegativeTol = (int16)g_ui16CurrProdNvTol; 
02BF0:  MOVFF  A4,C6
02BF4:  MOVFF  A3,C5
....................              
....................             // Stuff IBC command 
....................             g_stIBCSendData.g_ui8ArrIBCData[0] = IBC_CMD_PRE_PROD_TOLERANCE; 
02BF8:  MOVLW  6D
02BFA:  MOVLB  1
02BFC:  MOVWF  x34
....................             for(unsigned int8 ui8LoopCount = 1; ui8LoopCount < IBC_MSG_BYTE_COUNT; ui8LoopCount++) 
02BFE:  MOVLW  01
02C00:  MOVLB  B
02C02:  MOVWF  x45
02C04:  MOVF   x45,W
02C06:  SUBLW  04
02C08:  BTFSS  FD8.0
02C0A:  GOTO   2C44
....................             { 
....................                 g_stIBCSendData.g_ui8ArrIBCData[ui8LoopCount] = g_unIBCTolNode.m_ui8Arr[ui8LoopCount - 1];  
02C0E:  CLRF   03
02C10:  MOVF   x45,W
02C12:  ADDLW  34
02C14:  MOVWF  01
02C16:  MOVLW  01
02C18:  ADDWFC 03,F
02C1A:  MOVFF  03,B49
02C1E:  MOVLW  01
02C20:  SUBWF  x45,W
02C22:  CLRF   03
02C24:  ADDLW  C3
02C26:  MOVWF  FE9
02C28:  MOVLW  00
02C2A:  ADDWFC 03,W
02C2C:  MOVWF  FEA
02C2E:  MOVFF  FEF,B4A
02C32:  MOVFF  B49,FEA
02C36:  MOVFF  01,FE9
02C3A:  MOVFF  B4A,FEF
02C3E:  INCF   x45,F
02C40:  GOTO   2C04
....................             } 
....................              
....................             // Insert data in  IBC send queue to MCU0_ADC_Module 
....................             //InsertSendQueue(&g_stIBCSendData); 
....................             InsertIBCMsgQueue(&g_stIBCSendQueue, &g_stIBCSendData); 
02C44:  MOVLW  01
02C46:  MOVWF  x49
02C48:  MOVLW  88
02C4A:  MOVWF  x48
02C4C:  MOVLW  01
02C4E:  MOVWF  x4B
02C50:  MOVLW  34
02C52:  MOVWF  x4A
02C54:  MOVLB  0
02C56:  CALL   0E5C
....................              
....................         } 
....................         break; 
02C5A:  MOVLB  B
02C5C:  GOTO   2DFA
....................         case ADDRESS_FOR_YEAR: 
....................         { 
....................              g_ui16RegisterDateYY = ui16RegData; 
02C60:  MOVFF  B32,90
02C64:  MOVFF  B31,8F
....................         } 
....................         break; 
02C68:  MOVLB  B
02C6A:  GOTO   2DFA
....................         case ADDRESS_FOR_MONTH: 
....................         { 
....................              g_ui16RegisterDateMM = ui16RegData; 
02C6E:  MOVFF  B32,92
02C72:  MOVFF  B31,91
....................         } 
....................         break; 
02C76:  MOVLB  B
02C78:  GOTO   2DFA
....................         case ADDRESS_FOR_DATE: 
....................         { 
....................              g_ui16RegisterDateDD = ui16RegData; 
02C7C:  MOVFF  B32,94
02C80:  MOVFF  B31,93
....................         } 
....................         break; 
02C84:  MOVLB  B
02C86:  GOTO   2DFA
....................         case ADDRESS_FOR_HOUR: 
....................         { 
....................              g_ui16RegisterTime_HH = ui16RegData; 
02C8A:  MOVFF  B32,96
02C8E:  MOVFF  B31,95
....................         } 
....................         break; 
02C92:  MOVLB  B
02C94:  GOTO   2DFA
....................         case ADDRESS_FOR_MINUTE: 
....................         { 
....................              g_ui16RegisterTime_mm = ui16RegData; 
02C98:  MOVFF  B32,98
02C9C:  MOVFF  B31,97
....................         } 
....................         break; 
02CA0:  MOVLB  B
02CA2:  GOTO   2DFA
....................         case ADDRESS_FOR_SECOND: 
....................         { 
....................              g_ui16RegisterTime_ss = ui16RegData; 
02CA6:  MOVFF  B32,9A
02CAA:  MOVFF  B31,99
....................              // initialize time diff 
....................              g_ui16RegisterTime_Diff = 0;             
02CAE:  CLRF   x9C
02CB0:  CLRF   x9B
....................         } 
....................         break; 
02CB2:  MOVLB  B
02CB4:  GOTO   2DFA
....................         case ADDRESS_FOR_CURRENT_CALIBRATION_PT: 
....................         { 
....................             g_ui16RegisterCurrentCalibrationPoint = ui16RegData; 
02CB8:  MOVFF  B32,6B
02CBC:  MOVFF  B31,6A
....................         } 
....................         break; 
02CC0:  MOVLB  B
02CC2:  GOTO   2DFA
....................         case ADDRESS_FOR_CURRENT_CALIBRATION_WT: 
....................         { 
....................             g_ui16RegisterCurrentCalibrationWeight = ui16RegData; 
02CC6:  MOVFF  B32,69
02CCA:  MOVFF  B31,68
....................             // stub for M1  to M0 
....................             // Stuff IBC Command 
....................             g_unIBCResetCalib.m_stIBCResetCalibPoint.m_i16CalibPoint = g_ui16RegisterCurrentCalibrationWeight; 
02CCE:  MOVFF  69,C8
02CD2:  MOVFF  68,C7
....................             g_unIBCResetCalib.m_stIBCResetCalibPoint.m_i16CurrCalibPoint = g_ui16RegisterCurrentCalibrationPoint; 
02CD6:  MOVFF  6B,CA
02CDA:  MOVFF  6A,C9
.................... //            g_stIBCSendData.g_ui8ArrIBCData[0] = IBC_CMD_RESET_CALIB_POINT; 
.................... //            for(unsigned int8 ui8Loopcount = 1; ui8Loopcount < IBC_MSG_BYTE_COUNT; ui8Loopcount++) 
.................... //            { 
.................... //                // Staff padding bytes 
.................... //                g_stIBCSendData.g_ui8ArrIBCData[ui8Loopcount] = g_unIBCResetCalib.m_ui8Arr[ui8Loopcount-1]; 
.................... //            }  
....................  
....................             // Insert data in IBC Send queue 
....................             //InsertSendQueue(&g_stIBCSendData); 
....................            // InsertIBCMsgQueue(&g_stIBCSendQueue, &g_stIBCSendData); 
....................            // g_ui16CounterForAvgCalibrationWt = 0; 
....................         } 
....................         break; 
02CDE:  MOVLB  B
02CE0:  GOTO   2DFA
....................         case ADDRESS_FOR_START_CALIBRATION: 
....................         { 
....................             // Set variables. 
....................             g_fStartCalibration = 1; 
02CE4:  MOVLW  01
02CE6:  MOVWF  x6C
....................             g_ui32TareADCValueForCalibration = 0; 
02CE8:  CLRF   x70
02CEA:  CLRF   x6F
02CEC:  CLRF   x6E
02CEE:  CLRF   x6D
....................             g_ui32gWeightADCValueForCalibration = 0; 
02CF0:  CLRF   x74
02CF2:  CLRF   x73
02CF4:  CLRF   x72
02CF6:  CLRF   x71
....................              
....................             // Stuff IBC Command. 
....................             g_unIBCResetCalib.m_stIBCResetCalibPoint.m_i16CalibPoint = 0; 
02CF8:  CLRF   xC8
02CFA:  CLRF   xC7
....................             g_unIBCResetCalib.m_stIBCResetCalibPoint.m_i16CurrCalibPoint = 0; 
02CFC:  CLRF   xCA
02CFE:  CLRF   xC9
....................             g_stIBCSendData.g_ui8ArrIBCData[0] = IBC_CMD_RESET_CALIB_POINT; 
02D00:  MOVLW  68
02D02:  MOVLB  1
02D04:  MOVWF  x34
....................             for(unsigned int8 ui8Loopcount = 1; ui8Loopcount < IBC_MSG_BYTE_COUNT; ui8Loopcount++) 
02D06:  MOVLW  01
02D08:  MOVLB  B
02D0A:  MOVWF  x46
02D0C:  MOVF   x46,W
02D0E:  SUBLW  04
02D10:  BTFSS  FD8.0
02D12:  GOTO   2D4C
....................             { 
....................                 // Staff padding bytes 
....................                 g_stIBCSendData.g_ui8ArrIBCData[ui8Loopcount] = g_unIBCResetCalib.m_ui8Arr[ui8Loopcount-1]; 
02D16:  CLRF   03
02D18:  MOVF   x46,W
02D1A:  ADDLW  34
02D1C:  MOVWF  01
02D1E:  MOVLW  01
02D20:  ADDWFC 03,F
02D22:  MOVFF  03,B49
02D26:  MOVLW  01
02D28:  SUBWF  x46,W
02D2A:  CLRF   03
02D2C:  ADDLW  C7
02D2E:  MOVWF  FE9
02D30:  MOVLW  00
02D32:  ADDWFC 03,W
02D34:  MOVWF  FEA
02D36:  MOVFF  FEF,B4A
02D3A:  MOVFF  B49,FEA
02D3E:  MOVFF  01,FE9
02D42:  MOVFF  B4A,FEF
02D46:  INCF   x46,F
02D48:  GOTO   2D0C
....................             } 
....................              
....................             // Insert in IBC message queue. 
....................             InsertIBCMsgQueue(&g_stIBCSendQueue, &g_stIBCSendData); 
02D4C:  MOVLW  01
02D4E:  MOVWF  x49
02D50:  MOVLW  88
02D52:  MOVWF  x48
02D54:  MOVLW  01
02D56:  MOVWF  x4B
02D58:  MOVLW  34
02D5A:  MOVWF  x4A
02D5C:  MOVLB  0
02D5E:  CALL   0E5C
....................              
....................         } 
....................         break; 
02D62:  MOVLB  B
02D64:  GOTO   2DFA
....................         case ADDRESS_FOR_CALIBRATION_TYPE: 
....................         { 
....................             g_fAutoCalibrationMode = (ui16RegData == MODBUS_AUTO_CALIBRATION) ? MODBUS_AUTO_CALIBRATION : MODBUS_FIXED_CALIBRATION; 
02D68:  MOVLB  B
02D6A:  DECFSZ x31,W
02D6C:  GOTO   2D7E
02D70:  MOVF   x32,F
02D72:  BTFSS  FD8.2
02D74:  GOTO   2D7E
02D78:  MOVLW  01
02D7A:  GOTO   2D80
02D7E:  MOVLW  00
02D80:  MOVLB  0
02D82:  MOVWF  xA7
....................         } 
....................         break; 
02D84:  MOVLB  B
02D86:  GOTO   2DFA
....................         case ADDRESS_FOR_AUTO_CALIB_SAMPLE_COUNT: 
....................         { 
....................             g_ui16AutoCalibrationSampleCount = ui16RegData; 
02D8A:  MOVFF  B32,A9
02D8E:  MOVFF  B31,A8
....................  
....................             // Stuff IBC command 
....................             g_stIBCSendData.g_ui8ArrIBCData[0] = (MODBUS_AUTO_CALIBRATION == g_fAutoCalibrationMode) ? IBC_CMD_MODE_AUTO_CALIB : IBC_CMD_MODE_FIXED_CALIB; 
02D92:  DECFSZ xA7,W
02D94:  GOTO   2D9E
02D98:  MOVLW  6E
02D9A:  GOTO   2DA0
02D9E:  MOVLW  6F
02DA0:  MOVLB  1
02DA2:  MOVWF  x34
....................             g_stIBCSendData.g_ui8ArrIBCData[1] = (MODBUS_AUTO_CALIBRATION == g_fAutoCalibrationMode) ? (unsigned int8)(g_ui16AutoCalibrationSampleCount) : 0; 
02DA4:  MOVLB  0
02DA6:  DECFSZ xA7,W
02DA8:  GOTO   2DB2
02DAC:  MOVF   xA8,W
02DAE:  GOTO   2DB4
02DB2:  MOVLW  00
02DB4:  MOVLB  1
02DB6:  MOVWF  x35
....................             // Stuff padding bytes 
....................             for(unsigned int8 ui8Loopcount = 2; ui8Loopcount < IBC_MSG_BYTE_COUNT; ui8Loopcount++) 
02DB8:  MOVLW  02
02DBA:  MOVLB  B
02DBC:  MOVWF  x47
02DBE:  MOVF   x47,W
02DC0:  SUBLW  04
02DC2:  BTFSS  FD8.0
02DC4:  GOTO   2DDE
....................             { 
....................                 g_stIBCSendData.g_ui8ArrIBCData[ui8Loopcount] = 0; 
02DC8:  CLRF   03
02DCA:  MOVF   x47,W
02DCC:  ADDLW  34
02DCE:  MOVWF  FE9
02DD0:  MOVLW  01
02DD2:  ADDWFC 03,W
02DD4:  MOVWF  FEA
02DD6:  CLRF   FEF
02DD8:  INCF   x47,F
02DDA:  GOTO   2DBE
....................             } 
....................              
....................             // Insert data in IBC Send queue 
....................             //InsertSendQueue(&g_stIBCSendData); 
....................             InsertIBCMsgQueue(&g_stIBCSendQueue, &g_stIBCSendData); 
02DDE:  MOVLW  01
02DE0:  MOVWF  x49
02DE2:  MOVLW  88
02DE4:  MOVWF  x48
02DE6:  MOVLW  01
02DE8:  MOVWF  x4B
02DEA:  MOVLW  34
02DEC:  MOVWF  x4A
02DEE:  MOVLB  0
02DF0:  CALL   0E5C
....................         } 
....................         break;         
02DF4:  MOVLB  B
02DF6:  GOTO   2DFA
....................     }; 
02DFA:  MOVLB  0
02DFC:  GOTO   350E (RETURN)
.................... } 
....................  
.................... //unsigned int16 CalculateAvgForCalibration(void) 
.................... //{ 
.................... //    unsigned int16 ui16AvgWt; 
.................... //    g_ui16CounterForAvgCalibrationWt++; 
.................... //    if(HasRunningWeightArrayData()== 1) 
.................... //    { 
.................... //        if(g_ui16CounterForAvgCalibrationWt == 1) 
.................... //        { 
.................... //            ui16AvgWt = g_ui16RunningAvgWt; 
.................... //            InitRunningWeightArray(); 
.................... //        } 
.................... //        else if(g_ui16CounterForAvgCalibrationWt == 2) 
.................... //        { 
.................... //            ui16AvgWt = g_ui16RunningAvgWt; 
.................... //            InitRunningWeightArray(); 
.................... //        } 
.................... //        else if(g_ui16CounterForAvgCalibrationWt == 3) 
.................... //        { 
.................... //            ui16AvgWt = g_ui16RunningAvgWt; 
.................... //            InitRunningWeightArray(); 
.................... //        }         
.................... //    } 
.................... //    return ui16AvgWt; 
.................... //} 
....................  
.................... void SendOneRegisterValues(unsigned int16 ui16Address) 
.................... { 
....................     if(ui16Address == ADDRESS_FOR_CBB_COUNT_IN_PRODUCTION)  
*
01EBE:  MOVLB  B
01EC0:  MOVF   x2C,W
01EC2:  SUBLW  60
01EC4:  BTFSS  FD8.2
01EC6:  GOTO   1EF4
01ECA:  MOVF   x2D,W
01ECC:  SUBLW  05
01ECE:  BTFSS  FD8.2
01ED0:  GOTO   1EF4
....................     { 
....................         WriteToOneRegRS485 
....................         ( 
....................             SLAVE_ID, 
....................             RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................             2, 
....................             g_ui16CBBCount 
....................         ); 
01ED4:  MOVLW  01
01ED6:  MOVWF  x30
01ED8:  MOVLW  03
01EDA:  MOVWF  x31
01EDC:  MOVLW  02
01EDE:  MOVWF  x32
01EE0:  MOVFF  80,B34
01EE4:  MOVFF  7F,B33
01EE8:  MOVLB  0
01EEA:  CALL   1E68
....................     } 
01EEE:  GOTO   2086
01EF2:  MOVLB  B
....................     else if(ui16Address == ADDRESS_FOR_CURRENT_WT_IN_PRODUCTION)  
01EF4:  MOVF   x2C,W
01EF6:  SUBLW  62
01EF8:  BTFSS  FD8.2
01EFA:  GOTO   1F28
01EFE:  MOVF   x2D,W
01F00:  SUBLW  05
01F02:  BTFSS  FD8.2
01F04:  GOTO   1F28
....................     { 
....................         WriteToOneRegRS485 
....................         ( 
....................             SLAVE_ID, 
....................             RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................             2, 
....................             g_ui16CurrentWt 
....................         ); 
01F08:  MOVLW  01
01F0A:  MOVWF  x30
01F0C:  MOVLW  03
01F0E:  MOVWF  x31
01F10:  MOVLW  02
01F12:  MOVWF  x32
01F14:  MOVFF  84,B34
01F18:  MOVFF  83,B33
01F1C:  MOVLB  0
01F1E:  CALL   1E68
....................     } 
01F22:  GOTO   2086
01F26:  MOVLB  B
....................     else if(ui16Address == ADDRESS_FOR_PASS_STATUS_WT_IN_PRODUCTION)  
01F28:  MOVF   x2C,W
01F2A:  SUBLW  64
01F2C:  BTFSS  FD8.2
01F2E:  GOTO   1F5C
01F32:  MOVF   x2D,W
01F34:  SUBLW  05
01F36:  BTFSS  FD8.2
01F38:  GOTO   1F5C
....................     { 
....................         WriteToOneRegRS485 
....................         ( 
....................             SLAVE_ID, 
....................             RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................             2, 
....................             g_ui16CurrentPassStatus 
....................         ); 
01F3C:  MOVLW  01
01F3E:  MOVWF  x30
01F40:  MOVLW  03
01F42:  MOVWF  x31
01F44:  MOVLW  02
01F46:  MOVWF  x32
01F48:  MOVFF  86,B34
01F4C:  MOVFF  85,B33
01F50:  MOVLB  0
01F52:  CALL   1E68
....................     } 
01F56:  GOTO   2086
01F5A:  MOVLB  B
....................     else if(ui16Address == ADDRESS_FOR_RUNNING_AVG_WT_IN_PRODUCTION)  
01F5C:  MOVF   x2C,W
01F5E:  SUBLW  66
01F60:  BTFSS  FD8.2
01F62:  GOTO   1F90
01F66:  MOVF   x2D,W
01F68:  SUBLW  05
01F6A:  BTFSS  FD8.2
01F6C:  GOTO   1F90
....................     { 
....................         WriteToOneRegRS485 
....................         ( 
....................             SLAVE_ID, 
....................             RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................             2, 
....................             g_ui16RunningAvgWt 
....................         ); 
01F70:  MOVLW  01
01F72:  MOVWF  x30
01F74:  MOVLW  03
01F76:  MOVWF  x31
01F78:  MOVLW  02
01F7A:  MOVWF  x32
01F7C:  MOVFF  88,B34
01F80:  MOVFF  87,B33
01F84:  MOVLB  0
01F86:  CALL   1E68
....................     } 
01F8A:  GOTO   2086
01F8E:  MOVLB  B
....................     else if(ui16Address == ADDRESS_FOR_TARE_VALUE_IN_PRODUCTION)  
01F90:  MOVF   x2C,W
01F92:  SUBLW  68
01F94:  BTFSS  FD8.2
01F96:  GOTO   1FC4
01F9A:  MOVF   x2D,W
01F9C:  SUBLW  05
01F9E:  BTFSS  FD8.2
01FA0:  GOTO   1FC4
....................     { 
....................         WriteToOneRegRS485 
....................         ( 
....................             SLAVE_ID, 
....................             RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................             2, 
....................             g_ui16RunningTareValue 
....................         ); 
01FA4:  MOVLW  01
01FA6:  MOVWF  x30
01FA8:  MOVLW  03
01FAA:  MOVWF  x31
01FAC:  MOVLW  02
01FAE:  MOVWF  x32
01FB0:  MOVFF  8A,B34
01FB4:  MOVFF  89,B33
01FB8:  MOVLB  0
01FBA:  CALL   1E68
....................     } 
01FBE:  GOTO   2086
01FC2:  MOVLB  B
....................     else if(ui16Address == ADDRESS_FOR_SERVER_STATUS_WT_IN_PRODUCTION)  
01FC4:  MOVF   x2C,F
01FC6:  BTFSS  FD8.2
01FC8:  GOTO   1FF6
01FCC:  MOVF   x2D,W
01FCE:  SUBLW  07
01FD0:  BTFSS  FD8.2
01FD2:  GOTO   1FF6
....................     { 
....................         WriteToOneRegRS485 
....................         ( 
....................             SLAVE_ID, 
....................             RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................             2, 
....................             g_ui16ServerStatus 
....................         ); 
01FD6:  MOVLW  01
01FD8:  MOVWF  x30
01FDA:  MOVLW  03
01FDC:  MOVWF  x31
01FDE:  MOVLW  02
01FE0:  MOVWF  x32
01FE2:  MOVFF  8C,B34
01FE6:  MOVFF  8B,B33
01FEA:  MOVLB  0
01FEC:  CALL   1E68
....................     } 
01FF0:  GOTO   2086
01FF4:  MOVLB  B
....................     else if(ui16Address == ADDRESS_FOR_SET_CALIB_TARE) 
01FF6:  MOVF   x2C,W
01FF8:  SUBLW  96
01FFA:  BTFSS  FD8.2
01FFC:  GOTO   2032
02000:  MOVF   x2D,W
02002:  SUBLW  02
02004:  BTFSS  FD8.2
02006:  GOTO   2032
....................     { 
....................         WriteToOneRegRS485 
....................         ( 
....................             SLAVE_ID, 
....................             RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................             2, 
....................             g_ui32TareADCValueForCalibration 
....................         ); 
0200A:  MOVFF  6E,B2F
0200E:  MOVFF  6D,B2E
02012:  MOVLW  01
02014:  MOVWF  x30
02016:  MOVLW  03
02018:  MOVWF  x31
0201A:  MOVLW  02
0201C:  MOVWF  x32
0201E:  MOVFF  6E,B34
02022:  MOVFF  6D,B33
02026:  MOVLB  0
02028:  CALL   1E68
....................          
....................     } 
0202C:  GOTO   2086
02030:  MOVLB  B
....................     else if(ui16Address == ADDRESS_FOR_SET_CALIB_WEIGHT) 
02032:  MOVF   x2C,W
02034:  SUBLW  98
02036:  BTFSS  FD8.2
02038:  GOTO   206E
0203C:  MOVF   x2D,W
0203E:  SUBLW  02
02040:  BTFSS  FD8.2
02042:  GOTO   206E
....................     { 
....................         WriteToOneRegRS485 
....................         ( 
....................             SLAVE_ID, 
....................             RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................             2, 
....................             g_ui32gWeightADCValueForCalibration 
....................         ); 
02046:  MOVFF  72,B2F
0204A:  MOVFF  71,B2E
0204E:  MOVLW  01
02050:  MOVWF  x30
02052:  MOVLW  03
02054:  MOVWF  x31
02056:  MOVLW  02
02058:  MOVWF  x32
0205A:  MOVFF  72,B34
0205E:  MOVFF  71,B33
02062:  MOVLB  0
02064:  CALL   1E68
....................     } 
02068:  GOTO   2086
0206C:  MOVLB  B
....................      
.................... //    else if(ui16Address == ADDRESS_FOR_READ_COUNTER_AVG_CALIB) 
.................... //    { 
.................... //        WriteToOneRegRS485 
.................... //        ( 
.................... //            SLAVE_ID, 
.................... //            RS485_FUNCTION_READ_HOLDING_REGISTERS, 
.................... //            2, 
.................... //            g_ui8CounterForAvgCalibrationWt 
.................... //        ); 
.................... //         
.................... //    } 
....................     else  
....................     { 
....................         WriteToOneRegRS485 
....................         ( 
....................             SLAVE_ID, 
....................             RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................             2, 
....................             1 
....................         );                             
0206E:  MOVLW  01
02070:  MOVWF  x30
02072:  MOVLW  03
02074:  MOVWF  x31
02076:  MOVLW  02
02078:  MOVWF  x32
0207A:  CLRF   x34
0207C:  MOVLW  01
0207E:  MOVWF  x33
02080:  MOVLB  0
02082:  CALL   1E68
....................     }     
02086:  GOTO   349C (RETURN)
.................... } 
....................  
.................... void SendTwoRegisterValues(unsigned int16 ui16Address) 
.................... { 
....................     if(ui16Address == ADDRESS_FOR_SET_CALIB_0) 
*
020EC:  MOVLB  B
020EE:  MOVF   x2C,W
020F0:  SUBLW  72
020F2:  BTFSS  FD8.2
020F4:  GOTO   2134
020F8:  MOVF   x2D,W
020FA:  SUBLW  02
020FC:  BTFSS  FD8.2
020FE:  GOTO   2134
....................     { 
....................             g_ui16Register0_1 = g_ui16gAvgWtForCalibration; //CalculateAvgForCalibration(); 
02102:  MOVFF  76,3D
02106:  MOVFF  75,3C
....................             WriteToTwoRegRS485 
....................             ( 
....................                 SLAVE_ID, 
....................                 RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                 4, 
....................                 g_ui16Register0_1, 
....................                 g_ui16Register0_2 
....................             ); 
0210A:  MOVLW  01
0210C:  MOVWF  x2E
0210E:  MOVLW  03
02110:  MOVWF  x2F
02112:  MOVLW  04
02114:  MOVWF  x30
02116:  MOVFF  3D,B32
0211A:  MOVFF  3C,B31
0211E:  MOVFF  3F,B34
02122:  MOVFF  3E,B33
02126:  MOVLB  0
02128:  CALL   208A
....................             g_fStartCalibration = 0; 
0212C:  CLRF   x6C
....................     } 
0212E:  GOTO   23CA
02132:  MOVLB  B
....................     else if(ui16Address == ADDRESS_FOR_SET_CALIB_1000) 
02134:  MOVF   x2C,W
02136:  SUBLW  74
02138:  BTFSS  FD8.2
0213A:  GOTO   217A
0213E:  MOVF   x2D,W
02140:  SUBLW  02
02142:  BTFSS  FD8.2
02144:  GOTO   217A
....................     { 
....................             g_ui16Register1000_1 = g_ui16gAvgWtForCalibration; //CalculateAvgForCalibration(); 
02148:  MOVFF  76,41
0214C:  MOVFF  75,40
....................             WriteToTwoRegRS485 
....................             ( 
....................                 SLAVE_ID, 
....................                 RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                 4, 
....................                 g_ui16Register1000_1, 
....................                 g_ui16Register1000_2 
....................             ); 
02150:  MOVLW  01
02152:  MOVWF  x2E
02154:  MOVLW  03
02156:  MOVWF  x2F
02158:  MOVLW  04
0215A:  MOVWF  x30
0215C:  MOVFF  41,B32
02160:  MOVFF  40,B31
02164:  MOVFF  43,B34
02168:  MOVFF  42,B33
0216C:  MOVLB  0
0216E:  CALL   208A
....................             g_fStartCalibration = 0; 
02172:  CLRF   x6C
....................     } 
02174:  GOTO   23CA
02178:  MOVLB  B
....................     else if(ui16Address == ADDRESS_FOR_SET_CALIB_2000) 
0217A:  MOVF   x2C,W
0217C:  SUBLW  76
0217E:  BTFSS  FD8.2
02180:  GOTO   21C0
02184:  MOVF   x2D,W
02186:  SUBLW  02
02188:  BTFSS  FD8.2
0218A:  GOTO   21C0
....................     { 
....................             g_ui16Register2000_1 = g_ui16gAvgWtForCalibration; //CalculateAvgForCalibration(); 
0218E:  MOVFF  76,45
02192:  MOVFF  75,44
....................             WriteToTwoRegRS485 
....................             ( 
....................                 SLAVE_ID, 
....................                 RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                 4, 
....................                 g_ui16Register2000_1, 
....................                 g_ui16Register2000_2 
....................             ); 
02196:  MOVLW  01
02198:  MOVWF  x2E
0219A:  MOVLW  03
0219C:  MOVWF  x2F
0219E:  MOVLW  04
021A0:  MOVWF  x30
021A2:  MOVFF  45,B32
021A6:  MOVFF  44,B31
021AA:  MOVFF  47,B34
021AE:  MOVFF  46,B33
021B2:  MOVLB  0
021B4:  CALL   208A
....................             g_fStartCalibration = 0; 
021B8:  CLRF   x6C
....................     } 
021BA:  GOTO   23CA
021BE:  MOVLB  B
....................     else if(ui16Address == ADDRESS_FOR_SET_CALIB_3000) 
021C0:  MOVF   x2C,W
021C2:  SUBLW  78
021C4:  BTFSS  FD8.2
021C6:  GOTO   2206
021CA:  MOVF   x2D,W
021CC:  SUBLW  02
021CE:  BTFSS  FD8.2
021D0:  GOTO   2206
....................     { 
....................             g_ui16Register3000_1 = g_ui16gAvgWtForCalibration; //CalculateAvgForCalibration(); 
021D4:  MOVFF  76,49
021D8:  MOVFF  75,48
....................             WriteToTwoRegRS485 
....................             ( 
....................                 SLAVE_ID, 
....................                 RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                 4, 
....................                 g_ui16Register3000_1, 
....................                 g_ui16Register3000_2 
....................             ); 
021DC:  MOVLW  01
021DE:  MOVWF  x2E
021E0:  MOVLW  03
021E2:  MOVWF  x2F
021E4:  MOVLW  04
021E6:  MOVWF  x30
021E8:  MOVFF  49,B32
021EC:  MOVFF  48,B31
021F0:  MOVFF  4B,B34
021F4:  MOVFF  4A,B33
021F8:  MOVLB  0
021FA:  CALL   208A
....................             g_fStartCalibration = 0; 
021FE:  CLRF   x6C
....................     } 
02200:  GOTO   23CA
02204:  MOVLB  B
....................     else if(ui16Address == ADDRESS_FOR_SET_CALIB_4000) 
02206:  MOVF   x2C,W
02208:  SUBLW  80
0220A:  BTFSS  FD8.2
0220C:  GOTO   224C
02210:  MOVF   x2D,W
02212:  SUBLW  02
02214:  BTFSS  FD8.2
02216:  GOTO   224C
....................     { 
....................             g_ui16Register4000_1 = g_ui16gAvgWtForCalibration; //CalculateAvgForCalibration(); 
0221A:  MOVFF  76,4D
0221E:  MOVFF  75,4C
....................             WriteToTwoRegRS485 
....................             ( 
....................                 SLAVE_ID, 
....................                 RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                 4, 
....................                 g_ui16Register4000_1, 
....................                 g_ui16Register4000_2 
....................             ); 
02222:  MOVLW  01
02224:  MOVWF  x2E
02226:  MOVLW  03
02228:  MOVWF  x2F
0222A:  MOVLW  04
0222C:  MOVWF  x30
0222E:  MOVFF  4D,B32
02232:  MOVFF  4C,B31
02236:  MOVFF  4F,B34
0223A:  MOVFF  4E,B33
0223E:  MOVLB  0
02240:  CALL   208A
....................             g_fStartCalibration = 0; 
02244:  CLRF   x6C
....................     } 
02246:  GOTO   23CA
0224A:  MOVLB  B
.................... //    else if(ui16Address == ADDRESS_FOR_SET_CALIB_5000) 
.................... //    { 
.................... //            g_ui16Register5000_1 = g_ui16gAvgWtForCalibration; //CalculateAvgForCalibration(); 
.................... //            WriteToTwoRegRS485 
.................... //            ( 
.................... //                SLAVE_ID, 
.................... //                RS485_FUNCTION_READ_HOLDING_REGISTERS, 
.................... //                4, 
.................... //                g_ui16Register5000_1, 
.................... //                g_ui16Register5000_2 
.................... //            ); 
.................... //            g_fStartCalibration = 0; 
.................... //    } 
....................     else if(ui16Address == ADDRESS_FOR_SET_CALIB_6000) 
0224C:  MOVF   x2C,W
0224E:  SUBLW  84
02250:  BTFSS  FD8.2
02252:  GOTO   2292
02256:  MOVF   x2D,W
02258:  SUBLW  02
0225A:  BTFSS  FD8.2
0225C:  GOTO   2292
....................     { 
....................             g_ui16Register6000_1 = g_ui16gAvgWtForCalibration; //CalculateAvgForCalibration(); 
02260:  MOVFF  76,55
02264:  MOVFF  75,54
....................             WriteToTwoRegRS485 
....................             ( 
....................                 SLAVE_ID, 
....................                 RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                 4, 
....................                 g_ui16Register6000_1, 
....................                 g_ui16Register6000_2 
....................             ); 
02268:  MOVLW  01
0226A:  MOVWF  x2E
0226C:  MOVLW  03
0226E:  MOVWF  x2F
02270:  MOVLW  04
02272:  MOVWF  x30
02274:  MOVFF  55,B32
02278:  MOVFF  54,B31
0227C:  MOVFF  57,B34
02280:  MOVFF  56,B33
02284:  MOVLB  0
02286:  CALL   208A
....................             g_fStartCalibration = 0; 
0228A:  CLRF   x6C
....................     } 
0228C:  GOTO   23CA
02290:  MOVLB  B
....................     else if(ui16Address == ADDRESS_FOR_SET_CALIB_7000) 
02292:  MOVF   x2C,W
02294:  SUBLW  86
02296:  BTFSS  FD8.2
02298:  GOTO   22D8
0229C:  MOVF   x2D,W
0229E:  SUBLW  02
022A0:  BTFSS  FD8.2
022A2:  GOTO   22D8
....................     { 
....................             g_ui16Register7000_1 = g_ui16gAvgWtForCalibration; //CalculateAvgForCalibration(); 
022A6:  MOVFF  76,59
022AA:  MOVFF  75,58
....................             WriteToTwoRegRS485 
....................             ( 
....................                 SLAVE_ID, 
....................                 RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                 4, 
....................                 g_ui16Register7000_1,  
....................                 g_ui16Register7000_2         
....................             ); 
022AE:  MOVLW  01
022B0:  MOVWF  x2E
022B2:  MOVLW  03
022B4:  MOVWF  x2F
022B6:  MOVLW  04
022B8:  MOVWF  x30
022BA:  MOVFF  59,B32
022BE:  MOVFF  58,B31
022C2:  MOVFF  5B,B34
022C6:  MOVFF  5A,B33
022CA:  MOVLB  0
022CC:  CALL   208A
....................             g_fStartCalibration = 0; 
022D0:  CLRF   x6C
....................     } 
022D2:  GOTO   23CA
022D6:  MOVLB  B
....................     else if(ui16Address == ADDRESS_FOR_SET_CALIB_8000) 
022D8:  MOVF   x2C,W
022DA:  SUBLW  88
022DC:  BTFSS  FD8.2
022DE:  GOTO   231E
022E2:  MOVF   x2D,W
022E4:  SUBLW  02
022E6:  BTFSS  FD8.2
022E8:  GOTO   231E
....................     { 
....................             g_ui16Register8000_1 = g_ui16gAvgWtForCalibration; //CalculateAvgForCalibration(); 
022EC:  MOVFF  76,5D
022F0:  MOVFF  75,5C
....................             WriteToTwoRegRS485 
....................             ( 
....................                 SLAVE_ID, 
....................                 RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                 4, 
....................                 g_ui16Register8000_1, 
....................                 g_ui16Register8000_2 
....................             ); 
022F4:  MOVLW  01
022F6:  MOVWF  x2E
022F8:  MOVLW  03
022FA:  MOVWF  x2F
022FC:  MOVLW  04
022FE:  MOVWF  x30
02300:  MOVFF  5D,B32
02304:  MOVFF  5C,B31
02308:  MOVFF  5F,B34
0230C:  MOVFF  5E,B33
02310:  MOVLB  0
02312:  CALL   208A
....................             g_fStartCalibration = 0; 
02316:  CLRF   x6C
....................     } 
02318:  GOTO   23CA
0231C:  MOVLB  B
....................     else if(ui16Address == ADDRESS_FOR_SET_CALIB_9000) 
0231E:  MOVF   x2C,W
02320:  SUBLW  90
02322:  BTFSS  FD8.2
02324:  GOTO   2364
02328:  MOVF   x2D,W
0232A:  SUBLW  02
0232C:  BTFSS  FD8.2
0232E:  GOTO   2364
....................     { 
....................             g_ui16Register9000_1 = g_ui16gAvgWtForCalibration; //CalculateAvgForCalibration(); 
02332:  MOVFF  76,61
02336:  MOVFF  75,60
....................             WriteToTwoRegRS485 
....................             ( 
....................                 SLAVE_ID, 
....................                 RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                 4, 
....................                 g_ui16Register9000_1, 
....................                 g_ui16Register9000_2 
....................             ); 
0233A:  MOVLW  01
0233C:  MOVWF  x2E
0233E:  MOVLW  03
02340:  MOVWF  x2F
02342:  MOVLW  04
02344:  MOVWF  x30
02346:  MOVFF  61,B32
0234A:  MOVFF  60,B31
0234E:  MOVFF  63,B34
02352:  MOVFF  62,B33
02356:  MOVLB  0
02358:  CALL   208A
....................             g_fStartCalibration = 0; 
0235C:  CLRF   x6C
....................     } 
0235E:  GOTO   23CA
02362:  MOVLB  B
....................     else if(ui16Address == ADDRESS_FOR_SET_CALIB_10000) 
02364:  MOVF   x2C,W
02366:  SUBLW  92
02368:  BTFSS  FD8.2
0236A:  GOTO   23AA
0236E:  MOVF   x2D,W
02370:  SUBLW  02
02372:  BTFSS  FD8.2
02374:  GOTO   23AA
....................     { 
....................             g_ui16Register10000_1 = g_ui16gAvgWtForCalibration; //CalculateAvgForCalibration(); 
02378:  MOVFF  76,65
0237C:  MOVFF  75,64
....................             WriteToTwoRegRS485 
....................             ( 
....................                 SLAVE_ID, 
....................                 RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                 4, 
....................                 g_ui16Register10000_1, 
....................                 g_ui16Register10000_2 
....................             ); 
02380:  MOVLW  01
02382:  MOVWF  x2E
02384:  MOVLW  03
02386:  MOVWF  x2F
02388:  MOVLW  04
0238A:  MOVWF  x30
0238C:  MOVFF  65,B32
02390:  MOVFF  64,B31
02394:  MOVFF  67,B34
02398:  MOVFF  66,B33
0239C:  MOVLB  0
0239E:  CALL   208A
....................             g_fStartCalibration = 0; 
023A2:  CLRF   x6C
....................     } 
023A4:  GOTO   23CA
023A8:  MOVLB  B
....................     else  
....................     {     
....................         // Valid MSG, so return 
....................         WriteToTwoRegRS485 
....................         ( 
....................             SLAVE_ID, 
....................             RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................             4, 
....................             4464, 
....................             1 
....................         ); 
023AA:  MOVLW  01
023AC:  MOVWF  x2E
023AE:  MOVLW  03
023B0:  MOVWF  x2F
023B2:  MOVLW  04
023B4:  MOVWF  x30
023B6:  MOVLW  11
023B8:  MOVWF  x32
023BA:  MOVLW  70
023BC:  MOVWF  x31
023BE:  CLRF   x34
023C0:  MOVLW  01
023C2:  MOVWF  x33
023C4:  MOVLB  0
023C6:  CALL   208A
....................         //65535); 
....................     }     
023CA:  GOTO   34C2 (RETURN)
.................... } 
....................  
.................... void ReplyTwoRegisterValues(BYTE ui8Func, unsigned int16 ui16RegData, unsigned int16 ui16Address) 
.................... { 
....................     if(ui16Address == ADDRESS_FOR_SET_CALIB_0) 
*
02E7E:  MOVLB  B
02E80:  MOVF   x2F,W
02E82:  SUBLW  72
02E84:  BTFSS  FD8.2
02E86:  GOTO   2EC4
02E8A:  MOVF   x30,W
02E8C:  SUBLW  02
02E8E:  BTFSS  FD8.2
02E90:  GOTO   2EC4
....................     { 
....................         ReplyForTwoRegister 
....................         ( 
....................             SLAVE_ID, 
....................             ui8Func, 
....................             ui16RegData, 
....................             ui16Address,     
....................             g_ui16Register0_1, 
....................             g_ui16Register0_2 
....................         ); 
02E94:  MOVLW  01
02E96:  MOVWF  x31
02E98:  MOVFF  B2C,B32
02E9C:  MOVFF  B2D,B33
02EA0:  MOVFF  B30,B35
02EA4:  MOVFF  B2F,B34
02EA8:  MOVFF  3D,B37
02EAC:  MOVFF  3C,B36
02EB0:  MOVFF  3F,B39
02EB4:  MOVFF  3E,B38
02EB8:  MOVLB  0
02EBA:  CALL   2E00
....................     } 
02EBE:  GOTO   3196
02EC2:  MOVLB  B
....................     else if(ui16Address == ADDRESS_FOR_SET_CALIB_1000) 
02EC4:  MOVF   x2F,W
02EC6:  SUBLW  74
02EC8:  BTFSS  FD8.2
02ECA:  GOTO   2F08
02ECE:  MOVF   x30,W
02ED0:  SUBLW  02
02ED2:  BTFSS  FD8.2
02ED4:  GOTO   2F08
....................     { 
....................         ReplyForTwoRegister 
....................         ( 
....................             SLAVE_ID, 
....................             ui8Func, 
....................             ui16RegData, 
....................             ui16Address,     
....................             g_ui16Register1000_1, 
....................             g_ui16Register1000_2 
....................         ); 
02ED8:  MOVLW  01
02EDA:  MOVWF  x31
02EDC:  MOVFF  B2C,B32
02EE0:  MOVFF  B2D,B33
02EE4:  MOVFF  B30,B35
02EE8:  MOVFF  B2F,B34
02EEC:  MOVFF  41,B37
02EF0:  MOVFF  40,B36
02EF4:  MOVFF  43,B39
02EF8:  MOVFF  42,B38
02EFC:  MOVLB  0
02EFE:  CALL   2E00
....................     } 
02F02:  GOTO   3196
02F06:  MOVLB  B
....................     else if(ui16Address == ADDRESS_FOR_SET_CALIB_2000) 
02F08:  MOVF   x2F,W
02F0A:  SUBLW  76
02F0C:  BTFSS  FD8.2
02F0E:  GOTO   2F4C
02F12:  MOVF   x30,W
02F14:  SUBLW  02
02F16:  BTFSS  FD8.2
02F18:  GOTO   2F4C
....................     { 
....................         ReplyForTwoRegister 
....................         ( 
....................             SLAVE_ID, 
....................             ui8Func, 
....................             ui16RegData, 
....................             ui16Address,     
....................             g_ui16Register2000_1, 
....................             g_ui16Register2000_2 
....................         ); 
02F1C:  MOVLW  01
02F1E:  MOVWF  x31
02F20:  MOVFF  B2C,B32
02F24:  MOVFF  B2D,B33
02F28:  MOVFF  B30,B35
02F2C:  MOVFF  B2F,B34
02F30:  MOVFF  45,B37
02F34:  MOVFF  44,B36
02F38:  MOVFF  47,B39
02F3C:  MOVFF  46,B38
02F40:  MOVLB  0
02F42:  CALL   2E00
....................     } 
02F46:  GOTO   3196
02F4A:  MOVLB  B
....................     else if(ui16Address == ADDRESS_FOR_SET_CALIB_3000) 
02F4C:  MOVF   x2F,W
02F4E:  SUBLW  78
02F50:  BTFSS  FD8.2
02F52:  GOTO   2F90
02F56:  MOVF   x30,W
02F58:  SUBLW  02
02F5A:  BTFSS  FD8.2
02F5C:  GOTO   2F90
....................     { 
....................         ReplyForTwoRegister 
....................         ( 
....................             SLAVE_ID, 
....................             ui8Func, 
....................             ui16RegData, 
....................             ui16Address,     
....................             g_ui16Register3000_1, 
....................             g_ui16Register3000_2 
....................         ); 
02F60:  MOVLW  01
02F62:  MOVWF  x31
02F64:  MOVFF  B2C,B32
02F68:  MOVFF  B2D,B33
02F6C:  MOVFF  B30,B35
02F70:  MOVFF  B2F,B34
02F74:  MOVFF  49,B37
02F78:  MOVFF  48,B36
02F7C:  MOVFF  4B,B39
02F80:  MOVFF  4A,B38
02F84:  MOVLB  0
02F86:  CALL   2E00
....................     } 
02F8A:  GOTO   3196
02F8E:  MOVLB  B
....................     else if(ui16Address == ADDRESS_FOR_SET_CALIB_4000) 
02F90:  MOVF   x2F,W
02F92:  SUBLW  80
02F94:  BTFSS  FD8.2
02F96:  GOTO   2FD4
02F9A:  MOVF   x30,W
02F9C:  SUBLW  02
02F9E:  BTFSS  FD8.2
02FA0:  GOTO   2FD4
....................     { 
....................         ReplyForTwoRegister 
....................         ( 
....................             SLAVE_ID, 
....................             ui8Func, 
....................             ui16RegData, 
....................             ui16Address,     
....................             g_ui16Register4000_1,  
....................             g_ui16Register4000_2 
....................         ); 
02FA4:  MOVLW  01
02FA6:  MOVWF  x31
02FA8:  MOVFF  B2C,B32
02FAC:  MOVFF  B2D,B33
02FB0:  MOVFF  B30,B35
02FB4:  MOVFF  B2F,B34
02FB8:  MOVFF  4D,B37
02FBC:  MOVFF  4C,B36
02FC0:  MOVFF  4F,B39
02FC4:  MOVFF  4E,B38
02FC8:  MOVLB  0
02FCA:  CALL   2E00
....................     } 
02FCE:  GOTO   3196
02FD2:  MOVLB  B
....................     else if(ui16Address == ADDRESS_FOR_SET_CALIB_5000) 
02FD4:  MOVF   x2F,W
02FD6:  SUBLW  02
02FD8:  BTFSS  FD8.2
02FDA:  GOTO   3018
02FDE:  MOVF   x30,W
02FE0:  SUBLW  02
02FE2:  BTFSS  FD8.2
02FE4:  GOTO   3018
....................     { 
....................         ReplyForTwoRegister 
....................         ( 
....................             SLAVE_ID, 
....................             ui8Func, 
....................             ui16RegData, 
....................             ui16Address,     
....................             g_ui16Register5000_1, 
....................             g_ui16Register5000_2 
....................         ); 
02FE8:  MOVLW  01
02FEA:  MOVWF  x31
02FEC:  MOVFF  B2C,B32
02FF0:  MOVFF  B2D,B33
02FF4:  MOVFF  B30,B35
02FF8:  MOVFF  B2F,B34
02FFC:  MOVFF  51,B37
03000:  MOVFF  50,B36
03004:  MOVFF  53,B39
03008:  MOVFF  52,B38
0300C:  MOVLB  0
0300E:  CALL   2E00
....................     } 
03012:  GOTO   3196
03016:  MOVLB  B
....................     else if(ui16Address == ADDRESS_FOR_SET_CALIB_6000) 
03018:  MOVF   x2F,W
0301A:  SUBLW  84
0301C:  BTFSS  FD8.2
0301E:  GOTO   305C
03022:  MOVF   x30,W
03024:  SUBLW  02
03026:  BTFSS  FD8.2
03028:  GOTO   305C
....................     { 
....................         ReplyForTwoRegister 
....................         ( 
....................             SLAVE_ID, 
....................             ui8Func, 
....................             ui16RegData, 
....................             ui16Address,     
....................             g_ui16Register6000_1, 
....................             g_ui16Register6000_2 
....................         ); 
0302C:  MOVLW  01
0302E:  MOVWF  x31
03030:  MOVFF  B2C,B32
03034:  MOVFF  B2D,B33
03038:  MOVFF  B30,B35
0303C:  MOVFF  B2F,B34
03040:  MOVFF  55,B37
03044:  MOVFF  54,B36
03048:  MOVFF  57,B39
0304C:  MOVFF  56,B38
03050:  MOVLB  0
03052:  CALL   2E00
....................     } 
03056:  GOTO   3196
0305A:  MOVLB  B
....................     else if(ui16Address == ADDRESS_FOR_SET_CALIB_7000) 
0305C:  MOVF   x2F,W
0305E:  SUBLW  86
03060:  BTFSS  FD8.2
03062:  GOTO   30A0
03066:  MOVF   x30,W
03068:  SUBLW  02
0306A:  BTFSS  FD8.2
0306C:  GOTO   30A0
....................     { 
....................         ReplyForTwoRegister 
....................         ( 
....................             SLAVE_ID, 
....................             ui8Func, 
....................             ui16RegData, 
....................             ui16Address,     
....................             g_ui16Register7000_1, 
....................             g_ui16Register7000_2 
....................         ); 
03070:  MOVLW  01
03072:  MOVWF  x31
03074:  MOVFF  B2C,B32
03078:  MOVFF  B2D,B33
0307C:  MOVFF  B30,B35
03080:  MOVFF  B2F,B34
03084:  MOVFF  59,B37
03088:  MOVFF  58,B36
0308C:  MOVFF  5B,B39
03090:  MOVFF  5A,B38
03094:  MOVLB  0
03096:  CALL   2E00
....................     } 
0309A:  GOTO   3196
0309E:  MOVLB  B
....................     else if(ui16Address == ADDRESS_FOR_SET_CALIB_8000) 
030A0:  MOVF   x2F,W
030A2:  SUBLW  88
030A4:  BTFSS  FD8.2
030A6:  GOTO   30E4
030AA:  MOVF   x30,W
030AC:  SUBLW  02
030AE:  BTFSS  FD8.2
030B0:  GOTO   30E4
....................     { 
....................         ReplyForTwoRegister 
....................         ( 
....................             SLAVE_ID, 
....................             ui8Func, 
....................             ui16RegData, 
....................             ui16Address,     
....................             g_ui16Register8000_1, 
....................             g_ui16Register8000_2 
....................         ); 
030B4:  MOVLW  01
030B6:  MOVWF  x31
030B8:  MOVFF  B2C,B32
030BC:  MOVFF  B2D,B33
030C0:  MOVFF  B30,B35
030C4:  MOVFF  B2F,B34
030C8:  MOVFF  5D,B37
030CC:  MOVFF  5C,B36
030D0:  MOVFF  5F,B39
030D4:  MOVFF  5E,B38
030D8:  MOVLB  0
030DA:  CALL   2E00
....................     } 
030DE:  GOTO   3196
030E2:  MOVLB  B
....................     else if(ui16Address == ADDRESS_FOR_SET_CALIB_9000) 
030E4:  MOVF   x2F,W
030E6:  SUBLW  90
030E8:  BTFSS  FD8.2
030EA:  GOTO   3128
030EE:  MOVF   x30,W
030F0:  SUBLW  02
030F2:  BTFSS  FD8.2
030F4:  GOTO   3128
....................     { 
....................         ReplyForTwoRegister 
....................         ( 
....................             SLAVE_ID, 
....................             ui8Func, 
....................             ui16RegData, 
....................             ui16Address,     
....................             g_ui16Register9000_1, 
....................             g_ui16Register9000_2 
....................         ); 
030F8:  MOVLW  01
030FA:  MOVWF  x31
030FC:  MOVFF  B2C,B32
03100:  MOVFF  B2D,B33
03104:  MOVFF  B30,B35
03108:  MOVFF  B2F,B34
0310C:  MOVFF  61,B37
03110:  MOVFF  60,B36
03114:  MOVFF  63,B39
03118:  MOVFF  62,B38
0311C:  MOVLB  0
0311E:  CALL   2E00
....................     } 
03122:  GOTO   3196
03126:  MOVLB  B
....................     else if(ui16Address == ADDRESS_FOR_SET_CALIB_10000) 
03128:  MOVF   x2F,W
0312A:  SUBLW  92
0312C:  BTFSS  FD8.2
0312E:  GOTO   316C
03132:  MOVF   x30,W
03134:  SUBLW  02
03136:  BTFSS  FD8.2
03138:  GOTO   316C
....................     { 
....................         ReplyForTwoRegister 
....................         ( 
....................             SLAVE_ID, 
....................             ui8Func, 
....................             ui16RegData, 
....................             ui16Address,     
....................             g_ui16Register10000_1, 
....................             g_ui16Register10000_2 
....................         ); 
0313C:  MOVLW  01
0313E:  MOVWF  x31
03140:  MOVFF  B2C,B32
03144:  MOVFF  B2D,B33
03148:  MOVFF  B30,B35
0314C:  MOVFF  B2F,B34
03150:  MOVFF  65,B37
03154:  MOVFF  64,B36
03158:  MOVFF  67,B39
0315C:  MOVFF  66,B38
03160:  MOVLB  0
03162:  CALL   2E00
....................     } 
03166:  GOTO   3196
0316A:  MOVLB  B
....................     else { 
....................         ReplyForTwoRegister 
....................         ( 
....................             SLAVE_ID, 
....................             ui8Func, 
....................             ui16RegData, 
....................             ui16Address,     
....................             g_ui16Register0_1, 
....................             g_ui16Register0_2 
....................         ); 
0316C:  MOVLW  01
0316E:  MOVWF  x31
03170:  MOVFF  B2C,B32
03174:  MOVFF  B2D,B33
03178:  MOVFF  B30,B35
0317C:  MOVFF  B2F,B34
03180:  MOVFF  3D,B37
03184:  MOVFF  3C,B36
03188:  MOVFF  3F,B39
0318C:  MOVFF  3E,B38
03190:  MOVLB  0
03192:  CALL   2E00
....................     }     
03196:  GOTO   3542 (RETURN)
.................... } 
....................  
....................  
.................... void ProcessUART2ReceivedData(void) 
*
0330A:  MOVLB  B
0330C:  CLRF   x12
0330E:  MOVLW  01
03310:  MOVWF  x13
03312:  CLRF   x14
03314:  CLRF   x15
03316:  CLRF   x16
03318:  CLRF   x17
.................... { 
....................     BYTE ui8Temp                 = 0; 
....................     BYTE bIsQueueEmpty           = MSG_QUEUE_NOT_EMPTY; 
....................     BYTE bIsValidMSG             = FALSE; 
....................     int8 i8TempFront             = 0; 
....................     int8 i8MainProcessLoopStatue = 0; 
....................     int8 i8TempLen               = 0;   
....................      
....................      
....................     do 
....................     { 
....................         // Step 1: Seek for Slave ID 
....................         do 
....................         { 
....................             // Get Queue 
....................             ui8Temp = GetUART2Queue(&bIsQueueEmpty); 
0331A:  MOVLW  0B
0331C:  MOVWF  x2D
0331E:  MOVLW  13
03320:  MOVWF  x2C
03322:  MOVLB  0
03324:  GOTO   1C0C
03328:  MOVFF  01,B12
....................             if (MSG_QUEUE_EMPTY == bIsQueueEmpty) 
0332C:  MOVLB  B
0332E:  MOVF   x13,F
03330:  BTFSS  FD8.2
03332:  GOTO   333A
....................             { 
....................                 // Return 
....................                 break;    // Handle this break 
03336:  GOTO   3340
....................             } 
....................  
....................             // Check for Slave ID 
....................  
....................         } while (SLAVE_ID != ui8Temp); // If Slave ID not matched then continue 
0333A:  DECFSZ x12,W
0333C:  GOTO   331A
....................  
....................         // Handle Break 
....................         if (MSG_QUEUE_EMPTY == bIsQueueEmpty) 
03340:  MOVF   x13,F
03342:  BTFSS  FD8.2
03344:  GOTO   334C
....................         { 
....................             // Nothing to return 
....................             // This may be the Slave ID is not matched, So might be this is for other board 
....................             // So nothing to process 
....................             break; 
03348:  GOTO   3816
....................         } 
....................          
....................         // Step 2: Now Check for minimum length (Which is 8 for now, but it could go upto 12) 
....................         i8TempLen = GetQueueLength(); 
0334C:  MOVLB  0
0334E:  CALL   1C92
03352:  MOVFF  01,B17
....................         if (MODBUS_MASTER_QUERY_LENGTH_MIN > (i8TempLen + 1))  // +1 is just due to we have deleted one from queue 
03356:  MOVLW  01
03358:  MOVLB  B
0335A:  ADDWF  x17,W
0335C:  SUBLW  07
0335E:  BTFSS  FD8.0
03360:  GOTO   3370
....................         { 
....................             // Empty the message buffer queue 
....................             EmptyQueue(); 
03364:  MOVLB  0
03366:  CALL   1CD0
....................              
....................             // Break from ProcessUART2ReceivedData function 
....................             break; 
0336A:  MOVLB  B
0336C:  GOTO   3816
....................         } 
....................          
....................         // We have available message in queue 
....................          
....................         // Should insert slave ID in temp buffer for CRC check. 
....................          
....................         // Slave ID Matched 
....................         // Step 3: Look for the Function Code 
....................         i8TempFront = g_stUART2RcvBuffModbus.m_i8Front; 
03370:  MOVFF  280,B15
....................         ui8Temp = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront];  // g_ui8TempArrForCRCValidation 
03374:  CLRF   03
03376:  MOVF   x15,W
03378:  ADDLW  4E
0337A:  MOVWF  FE9
0337C:  MOVLW  02
0337E:  ADDWFC 03,W
03380:  MOVWF  FEA
03382:  MOVFF  FEF,B12
....................              
....................          
.................... 	//value assign in transmit buffer of RS485 
....................         int8 i8TempLen                = 0;   
....................         unsigned int16 ui16Address    = 0; 
....................         unsigned int16 ui16RegData    = 0; 
03386:  CLRF   x18
03388:  CLRF   x1A
0338A:  CLRF   x19
0338C:  CLRF   x1C
0338E:  CLRF   x1B
....................  
....................  
....................         i8TempFront = g_stUART2RcvBuffModbus.m_i8Front;     
03390:  MOVFF  280,B15
....................         ui8Temp     = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront];  // g_ui8TempArrForCRCValidation 
03394:  CLRF   03
03396:  MOVF   x15,W
03398:  ADDLW  4E
0339A:  MOVWF  FE9
0339C:  MOVLW  02
0339E:  ADDWFC 03,W
033A0:  MOVWF  FEA
033A2:  MOVFF  FEF,B12
....................         i8TempLen   = GetQueueLength(); 
033A6:  MOVLB  0
033A8:  CALL   1C92
033AC:  MOVFF  01,B18
....................  
....................         int8 i8AddH = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_TWO - 1]; 
....................         int8 i8AddL = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_THREE - 1]; 
033B0:  MOVLW  02
033B2:  MOVLB  B
033B4:  ADDWF  x15,W
033B6:  ADDLW  FF
033B8:  CLRF   03
033BA:  ADDLW  4E
033BC:  MOVWF  FE9
033BE:  MOVLW  02
033C0:  ADDWFC 03,W
033C2:  MOVWF  FEA
033C4:  MOVFF  FEF,B1D
033C8:  MOVLW  03
033CA:  ADDWF  x15,W
033CC:  ADDLW  FF
033CE:  CLRF   03
033D0:  ADDLW  4E
033D2:  MOVWF  FE9
033D4:  MOVLW  02
033D6:  ADDWFC 03,W
033D8:  MOVWF  FEA
033DA:  MOVFF  FEF,B1E
....................  
....................         ui16Address = i8AddH; 
033DE:  CLRF   x1A
033E0:  MOVFF  B1D,B19
....................         ui16Address <<= 8; 
033E4:  MOVFF  B19,B1A
033E8:  CLRF   x19
....................         ui16Address += i8AddL; 
033EA:  MOVF   x1E,W
033EC:  ADDWF  x19,F
033EE:  MOVLW  00
033F0:  ADDWFC x1A,F
....................  
....................  
....................         int8 i8DataH = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_FOUR -1]; 
....................         int8 i8DataL = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_FIVE -1]; 
....................  
....................         unsigned int16 ui16WriteAddress = ui16Address + 1; 
033F2:  MOVLW  04
033F4:  ADDWF  x15,W
033F6:  ADDLW  FF
033F8:  CLRF   03
033FA:  ADDLW  4E
033FC:  MOVWF  FE9
033FE:  MOVLW  02
03400:  ADDWFC 03,W
03402:  MOVWF  FEA
03404:  MOVFF  FEF,B1F
03408:  MOVLW  05
0340A:  ADDWF  x15,W
0340C:  ADDLW  FF
0340E:  CLRF   03
03410:  ADDLW  4E
03412:  MOVWF  FE9
03414:  MOVLW  02
03416:  ADDWFC 03,W
03418:  MOVWF  FEA
0341A:  MOVFF  FEF,B20
0341E:  MOVLW  01
03420:  ADDWF  x19,W
03422:  MOVWF  x21
03424:  MOVLW  00
03426:  ADDWFC x1A,W
03428:  MOVWF  x22
....................  
....................         ui16RegData = i8DataH; 
0342A:  CLRF   x1C
0342C:  MOVFF  B1F,B1B
....................         ui16RegData <<= 8; 
03430:  MOVFF  B1B,B1C
03434:  CLRF   x1B
....................         ui16RegData += i8DataL;         
03436:  MOVF   x20,W
03438:  ADDWF  x1B,F
0343A:  MOVLW  00
0343C:  ADDWFC x1C,F
....................          
....................         // Now check for the available function code 
....................         switch(ui8Temp) 
0343E:  MOVF   x12,W
03440:  XORLW  03
03442:  MOVLB  0
03444:  BTFSC  FD8.2
03446:  GOTO   3466
0344A:  XORLW  05
0344C:  BTFSC  FD8.2
0344E:  GOTO   34FA
03452:  XORLW  09
03454:  BTFSC  FD8.2
03456:  GOTO   3514
0345A:  XORLW  1F
0345C:  BTFSC  FD8.2
0345E:  GOTO   3578
03462:  GOTO   37F4
....................         { 
....................             case RS485_FUNCTION_READ_HOLDING_REGISTERS: 
....................                 // Check queue length here if full message is received or not. 
....................                  
....................                 // Insert function code in the temp buffer. 
....................                 // For this function code fetch next four consecutive bytes in temp buffer. 
....................                 bIsValidMSG = CheckValidityForReadReg(); 
03466:  GOTO   1D8E
0346A:  MOVFF  01,B14
....................                 if(bIsValidMSG) 
0346E:  MOVLB  B
03470:  MOVF   x14,F
03472:  BTFSC  FD8.2
03474:  GOTO   34F6
....................                 { 
....................                      
....................                     // Empty the message buffer queue 
....................                     EmptyQueue(); 
03478:  MOVLB  0
0347A:  CALL   1CD0
....................                     
....................                     if(ui16RegData == 1) 
0347E:  MOVLB  B
03480:  DECFSZ x1B,W
03482:  GOTO   34A2
03486:  MOVF   x1C,F
03488:  BTFSS  FD8.2
0348A:  GOTO   34A2
....................                     {                  
....................                        SendOneRegisterValues(ui16Address); 
0348E:  MOVFF  B1A,B2D
03492:  MOVFF  B19,B2C
03496:  MOVLB  0
03498:  GOTO   1EBE
....................                     } 
0349C:  GOTO   34F2
034A0:  MOVLB  B
....................                     else if(ui16RegData == 2) 
034A2:  MOVF   x1B,W
034A4:  SUBLW  02
034A6:  BTFSS  FD8.2
034A8:  GOTO   34C8
034AC:  MOVF   x1C,F
034AE:  BTFSS  FD8.2
034B0:  GOTO   34C8
....................                     { 
....................                         SendTwoRegisterValues(ui16Address); 
034B4:  MOVFF  B1A,B2D
034B8:  MOVFF  B19,B2C
034BC:  MOVLB  0
034BE:  GOTO   20EC
....................                     } 
034C2:  GOTO   34F2
034C6:  MOVLB  B
....................                     else  
....................                     { 
....................                         // Valid MSG, so return 
....................                         WriteToThreeRegRS485( 
....................                             SLAVE_ID, 
....................                             RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                             6,                                      //TODO********************************************** 
....................                             g_ui16DOStatus, 
....................                             g_ui16DIStatus, 
....................                             g_ui16ErrorStatus); 
034C8:  MOVLW  01
034CA:  MOVWF  x2C
034CC:  MOVLW  03
034CE:  MOVWF  x2D
034D0:  MOVLW  06
034D2:  MOVWF  x2E
034D4:  MOVFF  B2,B30
034D8:  MOVFF  B1,B2F
034DC:  MOVFF  B0,B32
034E0:  MOVFF  AF,B31
034E4:  MOVFF  B4,B34
034E8:  MOVFF  B3,B33
034EC:  MOVLB  0
034EE:  GOTO   23CE
....................                     } 
....................                     // Update main loop process status. 
....................                     i8MainProcessLoopStatue = 0; 
034F2:  MOVLB  B
034F4:  CLRF   x16
....................                 } 
....................                 break; 
034F6:  GOTO   3802
....................             case RS485_FUNCTION_WRITE_SINGLE_REGISTER: 
....................             { 
....................                 // Insert function code in the temp buffer. 
....................                 // For this function code fetch next four consecutive bytes in temp buffer. 
....................                 //bIsValidMSG = CheckValidityForWriteSingleReg(); 
....................                 delay_us(20); 
034FA:  CLRWDT
034FC:  MOVLW  20
034FE:  MOVWF  00
03500:  DECFSZ 00,F
03502:  BRA    3500
03504:  BRA    3506
....................        		 	SendRS485Response(); 
03506:  CALL   243A
....................                 ProcessSingleRegister(); 
0350A:  GOTO   2516
....................             } 
....................             break; 
0350E:  MOVLB  B
03510:  GOTO   3802
....................             case RS485_FUNCTION_READ_MULTIPLE_REGISTERS: 
....................             { 
....................                 if(ui16RegData == 2) 
03514:  MOVLB  B
03516:  MOVF   x1B,W
03518:  SUBLW  02
0351A:  BTFSS  FD8.2
0351C:  GOTO   3548
03520:  MOVF   x1C,F
03522:  BTFSS  FD8.2
03524:  GOTO   3548
....................                 { 
....................                     ReplyTwoRegisterValues(ui8Temp,ui16RegData,ui16Address); 
03528:  MOVFF  B12,B2C
0352C:  MOVFF  B1C,B2E
03530:  MOVFF  B1B,B2D
03534:  MOVFF  B1A,B30
03538:  MOVFF  B19,B2F
0353C:  MOVLB  0
0353E:  GOTO   2E7E
....................                 } 
03542:  GOTO   3572
03546:  MOVLB  B
....................                 else  
....................                 { 
....................                         ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register0_1, //TODO********************************************** 
....................                             g_ui16Register0_2); 
03548:  MOVLW  01
0354A:  MOVWF  x31
0354C:  MOVFF  B12,B32
03550:  MOVFF  B1B,B33
03554:  MOVFF  B1A,B35
03558:  MOVFF  B19,B34
0355C:  MOVFF  3D,B37
03560:  MOVFF  3C,B36
03564:  MOVFF  3F,B39
03568:  MOVFF  3E,B38
0356C:  MOVLB  0
0356E:  CALL   2E00
....................                 } 
....................             } 
....................             break; 
03572:  MOVLB  B
03574:  GOTO   3802
....................             case RS485_FUNCTION_WRITE_MULTIPLE_REGISTERS: 
....................             { 
....................                 SendRS485ResponseForMultipleRegWrite(); 
03578:  GOTO   3208
....................                  
....................                 unsigned int16 ui16RegDataLen    = ui16RegData; 
....................                 int8 i8DataLen = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_SIX - 1]; 
....................  
....................                 int8 i8DataH = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_SEVEN -1]; 
....................                 int8 i8DataL = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_8 -1]; 
....................  
....................                 unsigned int16 ui16RegDataValue1 = 0; 
0357C:  MOVFF  B1C,B24
03580:  MOVFF  B1B,B23
03584:  MOVLW  06
03586:  MOVLB  B
03588:  ADDWF  x15,W
0358A:  ADDLW  FF
0358C:  CLRF   03
0358E:  ADDLW  4E
03590:  MOVWF  FE9
03592:  MOVLW  02
03594:  ADDWFC 03,W
03596:  MOVWF  FEA
03598:  MOVFF  FEF,B25
0359C:  MOVLW  07
0359E:  ADDWF  x15,W
035A0:  ADDLW  FF
035A2:  CLRF   03
035A4:  ADDLW  4E
035A6:  MOVWF  FE9
035A8:  MOVLW  02
035AA:  ADDWFC 03,W
035AC:  MOVWF  FEA
035AE:  MOVFF  FEF,B26
035B2:  MOVLW  08
035B4:  ADDWF  x15,W
035B6:  ADDLW  FF
035B8:  CLRF   03
035BA:  ADDLW  4E
035BC:  MOVWF  FE9
035BE:  MOVLW  02
035C0:  ADDWFC 03,W
035C2:  MOVWF  FEA
035C4:  MOVFF  FEF,B27
035C8:  CLRF   x29
035CA:  CLRF   x28
....................  
....................                 ui16RegDataValue1 = i8DataH; 
035CC:  CLRF   x29
035CE:  MOVFF  B26,B28
....................                 ui16RegDataValue1 <<= 8; 
035D2:  MOVFF  B28,B29
035D6:  CLRF   x28
....................                 ui16RegDataValue1 += i8DataL;   
035D8:  MOVF   x27,W
035DA:  ADDWF  x28,F
035DC:  MOVLW  00
035DE:  ADDWFC x29,F
....................                  
....................                 i8DataH = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_9 -1]; 
035E0:  MOVLW  09
035E2:  ADDWF  x15,W
035E4:  ADDLW  FF
035E6:  CLRF   03
035E8:  ADDLW  4E
035EA:  MOVWF  FE9
035EC:  MOVLW  02
035EE:  ADDWFC 03,W
035F0:  MOVWF  FEA
035F2:  MOVFF  FEF,B26
....................                 i8DataL = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_10 -1]; 
035F6:  MOVLW  0A
035F8:  ADDWF  x15,W
035FA:  ADDLW  FF
035FC:  CLRF   03
035FE:  ADDLW  4E
03600:  MOVWF  FE9
03602:  MOVLW  02
03604:  ADDWFC 03,W
03606:  MOVWF  FEA
03608:  MOVFF  FEF,B27
....................  
....................                 unsigned int16 ui16RegDataValue2 = 0; 
0360C:  CLRF   x2B
0360E:  CLRF   x2A
....................  
....................                 ui16RegDataValue2 = i8DataH; 
03610:  CLRF   x2B
03612:  MOVFF  B26,B2A
....................                 ui16RegDataValue2 <<= 8; 
03616:  MOVFF  B2A,B2B
0361A:  CLRF   x2A
....................                 ui16RegDataValue2 += i8DataL;    
0361C:  MOVF   x27,W
0361E:  ADDWF  x2A,F
03620:  MOVLW  00
03622:  ADDWFC x2B,F
....................                  
....................                 if(ui16RegDataLen == 2) 
03624:  MOVF   x23,W
03626:  SUBLW  02
03628:  BTFSS  FD8.2
0362A:  GOTO   37EE
0362E:  MOVF   x24,F
03630:  BTFSS  FD8.2
03632:  GOTO   37EE
....................                 { 
....................                     if(ui16Address == ADDRESS_FOR_SET_CALIB_0) 
03636:  MOVF   x19,W
03638:  SUBLW  72
0363A:  BTFSS  FD8.2
0363C:  GOTO   365E
03640:  MOVF   x1A,W
03642:  SUBLW  02
03644:  BTFSS  FD8.2
03646:  GOTO   365E
....................                     { 
....................                         g_ui16Register0_1 = ui16RegDataValue1; 
0364A:  MOVFF  B29,3D
0364E:  MOVFF  B28,3C
....................                         g_ui16Register0_2 = ui16RegDataValue2;                         
03652:  MOVFF  B2B,3F
03656:  MOVFF  B2A,3E
....................                     } 
0365A:  GOTO   37EE
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_1000) 
0365E:  MOVF   x19,W
03660:  SUBLW  74
03662:  BTFSS  FD8.2
03664:  GOTO   3686
03668:  MOVF   x1A,W
0366A:  SUBLW  02
0366C:  BTFSS  FD8.2
0366E:  GOTO   3686
....................                     { 
....................                         g_ui16Register1000_1 = ui16RegDataValue1; 
03672:  MOVFF  B29,41
03676:  MOVFF  B28,40
....................                         g_ui16Register1000_2 = ui16RegDataValue2;                         
0367A:  MOVFF  B2B,43
0367E:  MOVFF  B2A,42
....................                     } 
03682:  GOTO   37EE
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_2000) 
03686:  MOVF   x19,W
03688:  SUBLW  76
0368A:  BTFSS  FD8.2
0368C:  GOTO   36AE
03690:  MOVF   x1A,W
03692:  SUBLW  02
03694:  BTFSS  FD8.2
03696:  GOTO   36AE
....................                     { 
....................                         g_ui16Register2000_1 = ui16RegDataValue1; 
0369A:  MOVFF  B29,45
0369E:  MOVFF  B28,44
....................                         g_ui16Register2000_2 = ui16RegDataValue2;                         
036A2:  MOVFF  B2B,47
036A6:  MOVFF  B2A,46
....................                     } 
036AA:  GOTO   37EE
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_3000) 
036AE:  MOVF   x19,W
036B0:  SUBLW  78
036B2:  BTFSS  FD8.2
036B4:  GOTO   36D6
036B8:  MOVF   x1A,W
036BA:  SUBLW  02
036BC:  BTFSS  FD8.2
036BE:  GOTO   36D6
....................                     { 
....................                         g_ui16Register3000_1 = ui16RegDataValue1; 
036C2:  MOVFF  B29,49
036C6:  MOVFF  B28,48
....................                         g_ui16Register3000_2 = ui16RegDataValue2;                         
036CA:  MOVFF  B2B,4B
036CE:  MOVFF  B2A,4A
....................                     } 
036D2:  GOTO   37EE
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_4000) 
036D6:  MOVF   x19,W
036D8:  SUBLW  80
036DA:  BTFSS  FD8.2
036DC:  GOTO   36FE
036E0:  MOVF   x1A,W
036E2:  SUBLW  02
036E4:  BTFSS  FD8.2
036E6:  GOTO   36FE
....................                     { 
....................                         g_ui16Register4000_1 = ui16RegDataValue1; 
036EA:  MOVFF  B29,4D
036EE:  MOVFF  B28,4C
....................                         g_ui16Register4000_2 = ui16RegDataValue2;                         
036F2:  MOVFF  B2B,4F
036F6:  MOVFF  B2A,4E
....................                     } 
036FA:  GOTO   37EE
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_5000) 
036FE:  MOVF   x19,W
03700:  SUBLW  02
03702:  BTFSS  FD8.2
03704:  GOTO   3726
03708:  MOVF   x1A,W
0370A:  SUBLW  02
0370C:  BTFSS  FD8.2
0370E:  GOTO   3726
....................                     { 
....................                         g_ui16Register5000_1 = ui16RegDataValue1; 
03712:  MOVFF  B29,51
03716:  MOVFF  B28,50
....................                         g_ui16Register5000_2 = ui16RegDataValue2;                         
0371A:  MOVFF  B2B,53
0371E:  MOVFF  B2A,52
....................                     } 
03722:  GOTO   37EE
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_6000) 
03726:  MOVF   x19,W
03728:  SUBLW  84
0372A:  BTFSS  FD8.2
0372C:  GOTO   374E
03730:  MOVF   x1A,W
03732:  SUBLW  02
03734:  BTFSS  FD8.2
03736:  GOTO   374E
....................                     { 
....................                         g_ui16Register6000_1 = ui16RegDataValue1; 
0373A:  MOVFF  B29,55
0373E:  MOVFF  B28,54
....................                         g_ui16Register6000_2 = ui16RegDataValue2;                         
03742:  MOVFF  B2B,57
03746:  MOVFF  B2A,56
....................                     } 
0374A:  GOTO   37EE
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_7000) 
0374E:  MOVF   x19,W
03750:  SUBLW  86
03752:  BTFSS  FD8.2
03754:  GOTO   3776
03758:  MOVF   x1A,W
0375A:  SUBLW  02
0375C:  BTFSS  FD8.2
0375E:  GOTO   3776
....................                     { 
....................                         g_ui16Register7000_1 = ui16RegDataValue1; 
03762:  MOVFF  B29,59
03766:  MOVFF  B28,58
....................                         g_ui16Register7000_2 = ui16RegDataValue2;                         
0376A:  MOVFF  B2B,5B
0376E:  MOVFF  B2A,5A
....................                     } 
03772:  GOTO   37EE
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_8000) 
03776:  MOVF   x19,W
03778:  SUBLW  88
0377A:  BTFSS  FD8.2
0377C:  GOTO   379E
03780:  MOVF   x1A,W
03782:  SUBLW  02
03784:  BTFSS  FD8.2
03786:  GOTO   379E
....................                     { 
....................                         g_ui16Register8000_1 = ui16RegDataValue1; 
0378A:  MOVFF  B29,5D
0378E:  MOVFF  B28,5C
....................                         g_ui16Register8000_2 = ui16RegDataValue2;                         
03792:  MOVFF  B2B,5F
03796:  MOVFF  B2A,5E
....................                     } 
0379A:  GOTO   37EE
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_9000) 
0379E:  MOVF   x19,W
037A0:  SUBLW  90
037A2:  BTFSS  FD8.2
037A4:  GOTO   37C6
037A8:  MOVF   x1A,W
037AA:  SUBLW  02
037AC:  BTFSS  FD8.2
037AE:  GOTO   37C6
....................                     { 
....................                         g_ui16Register9000_1 = ui16RegDataValue1; 
037B2:  MOVFF  B29,61
037B6:  MOVFF  B28,60
....................                         g_ui16Register9000_2 = ui16RegDataValue2;                         
037BA:  MOVFF  B2B,63
037BE:  MOVFF  B2A,62
....................                     } 
037C2:  GOTO   37EE
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_10000) 
037C6:  MOVF   x19,W
037C8:  SUBLW  92
037CA:  BTFSS  FD8.2
037CC:  GOTO   37EE
037D0:  MOVF   x1A,W
037D2:  SUBLW  02
037D4:  BTFSS  FD8.2
037D6:  GOTO   37EE
....................                     { 
....................                         g_ui16Register10000_1 = ui16RegDataValue1; 
037DA:  MOVFF  B29,65
037DE:  MOVFF  B28,64
....................                         g_ui16Register10000_2 = ui16RegDataValue2;                         
037E2:  MOVFF  B2B,67
037E6:  MOVFF  B2A,66
....................                     } 
037EA:  GOTO   37EE
....................                     else { 
.................... //                        ReplyForTwoRegister( 
.................... //                            SLAVE_ID, 
.................... //                            ui8Temp, 
.................... //                            ui16RegData, 
.................... //                            ui16Address,     
.................... //                            g_ui16Register0_1, //TODO********************************************** 
.................... //                            g_ui16Register0_2); 
....................                     } 
....................                 } 
....................             } 
....................             break; 
037EE:  GOTO   3802
037F2:  MOVLB  0
....................             default:   // Function Code is not Matching 
....................                 // Continue the ProcessUART2ReceivedData from beginning 
....................                 SendRS485Response(); 
037F4:  CALL   243A
....................                 i8MainProcessLoopStatue = 1; 
037F8:  MOVLW  01
037FA:  MOVLB  B
037FC:  MOVWF  x16
....................                 break; 
037FE:  GOTO   3802
....................         } 
....................          
....................         // If Function Code not Matching 
....................         if (i8MainProcessLoopStatue) 
03802:  MOVF   x16,F
03804:  BTFSC  FD8.2
03806:  GOTO   380E
....................         { 
....................             // Then continue from beginning 
....................             continue; 
0380A:  GOTO   380E
....................         } 
....................          
....................          
....................         // If the message is not valid 
....................         // Start  
....................     } while (i8MainProcessLoopStatue); 
0380E:  MOVF   x16,F
03810:  BTFSS  FD8.2
03812:  GOTO   331A
03816:  MOVLB  0
03818:  GOTO   6586 (RETURN)
....................      
.................... } 
.................... ////=============================== END NEW CODE ====================================================== 
....................  
.................... #endif /* _VI_RS485_CONFIG_H_ */ 
....................  
....................  
.................... #include "vmTimerConfig.h" 
.................... #ifndef _VM_TIMER_CONFIG_H_ 
.................... #define _VM_TIMER_CONFIG_H_ 
....................  
....................  
.................... //#include "vmCommon.h"   //TESTING 
.................... #include "../Common/viShiftRegister.h" 
.................... #include "../Common/vmModbusGlobal.h" 
.................... //#include "../Common/vmRS485Config.h" 
.................... #include "vmM1Common.h" 
.................... #include "../Common/vmIBCConfig.h" 
....................  
....................  
.................... #define T0_DIV_PRESCALE                     T0_DIV_8  
.................... #define TIMER_0_VALUE_LOAD_FOR_1MS          0xFD8F 
.................... #define ALL_TIMER_TEST_VAL_FOR_100_US       (0xFFFF - 0x003F + 1) 
.................... #define ALL_TIMER_TEST_VAL_FOR_70_US        (0xFFFF - 0x002C + 1) 
....................  
....................  
.................... #define FLAG_DI_STATE_CHANGED               11 
.................... #define FLAG_DI_STATE_NOT_CHANGED           12 
....................  
.................... #define ISR_TOTAL_BYTE_RECEIVE_TIME             9 //5 
.................... #define ISR_RECEIVED_ALL_BYTE                   21 
.................... #define ISR_PROCESSED_ALL_BYTE                  22 
.................... #define ISR_IS_READY                            40 
.................... #define ISR_IS_NOT_READY                        41 
....................  
.................... #define CHECK_FOR_AT_RESPONSE                   15 
.................... #define DO_NOT_CHECK_FOR_AT_RESPONSE            16 
.................... #define AT_RESPONSE_CHECK_INTRVL_TIMEOUT        60 
....................  
.................... #define MILLISECOND_TIMEOUT                     1000 
.................... #define SECOND_TIMEOUT                          60 
....................  
.................... #define SHOULD_SEND_DATA                        25 
.................... #define SHOULD_NOT_SEND_DATA                    26 
.................... #define DATA_SEND_INTERVAL_TIMEOUT              30 
....................  
.................... #define GPRS_CONNECTED                          1 
.................... #define GPRS_NOT_CONNECTED                      0 
....................  
.................... #define  GPRS_QUEUE_EMPTY_TIME_COUNT_START      80 
.................... #define  GPRS_QUEUE_EMPTY_TIME_COUNT_STOP       81 
.................... #define  GPRS_QUEUE_EMPTY_TIMEOUT               15 
....................  
.................... #define  SHOULD_CHECK_GPRS_CONNECTIVITY         55 
.................... #define  SHOULD_NOT_CHECK_GPRS_CONNECTIVITY     56 
....................  
.................... #define  REDAY_TO_RESTART_MCU                   33 
.................... #define  DO_NOT_RESTART_MCU                     34 
.................... #define  RESTART_MCU_INTERVAL_TIME              15  // In Minutes. Two Consecutive MCU restart will takes place at an interval of 15 minutes. 
....................  
.................... #define  GPRS_CONNECTION_QUERY_TIMEOUT          3  // In seconds. 
.................... #define  HTTP_URL_PARAMETER_SET_TIMEOUT         2 
.................... #define  HTTP_GET_SESSION_TIMEOUT               8 
.................... #define  DATA_RESEND_INTRVL_TIMEOUT             10 
....................  
.................... // ***************************************************************************** 
.................... // ***************** Below -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
.................... unsigned int16 g_ui16StackerEmptyDelayCount           = 0; 
.................... unsigned int8  g_fIsReadyToReceiveByte                = ISR_IS_NOT_READY; 
.................... unsigned int8  g_ui8ISRReceiveByteTimeCounter         = 0; 
.................... unsigned int8  g_fISRAllByteReceived                  = ISR_PROCESSED_ALL_BYTE; 
.................... unsigned int8  g_fDIChangeState                       = FLAG_DI_STATE_NOT_CHANGED; 
.................... unsigned int8  g_fShouldCheckForAtResponse            = CHECK_FOR_AT_RESPONSE; 
.................... unsigned int16 g_ui16MillisecondToSecondCounter       = 0; 
.................... unsigned int8  g_ui8SecondToMinuteCounter             = 0; 
.................... unsigned int8  g_ui8ATResponseCheckTimeInterval       = 0; 
.................... unsigned int16 g_ui16TimeOutMilliseconds              = 0; 
.................... unsigned int8  g_fShouldLookForTimeOut                = 0; 
.................... unsigned int16 g_ui16ShouldLookTimerCounter           = 0; 
.................... unsigned int8  g_fIsTimedOut                          = 0; 
.................... unsigned int8  g_fShouldSendData                      = SHOULD_NOT_SEND_DATA; 
.................... unsigned int16 g_ui16DataSendIntervalTime             = 0; 
.................... //unsigned int8  g_fIsGPRSConnected                     = 0; 
.................... unsigned int8  g_ui8GPRSQueueEmptyTimeCounter         = 0; 
.................... unsigned int8  g_fCheckGPRSConnectivity               = SHOULD_NOT_CHECK_GPRS_CONNECTIVITY; 
.................... unsigned int8  g_fGPRSQueueEmptyTimeStatus            = 0; 
.................... unsigned int8  g_fIsReadyToRestartMCU                 = DO_NOT_RESTART_MCU; 
.................... unsigned int8  g_ui8RestartMCUIntrvlTimeCounter       = 0; 
.................... unsigned int8  g_ui8RS485ByteCnt                      = 0; 
.................... unsigned int8  g_ui8RTSOnCountBefore                  = 0; 
.................... unsigned int8  g_ui8RTSOnCountAfter                   = 0; 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ***************** Above -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //**************** Below -> Timer Initialization Function ********************** 
.................... //****************************************************************************** 
....................  
.................... //Initialize 1MS Timer. 
.................... void Init1MSTimer(void) 
.................... { 
.................... 	//setup timer0 for 1MS time. 
.................... 	setup_timer_0( T0_INTERNAL | T0_DIV_PRESCALE ); 
.................... 	set_timer0(TIMER_0_VALUE_LOAD_FOR_1MS); 
....................  
.................... 	//Enable timer0 
.................... 	clear_interrupt( INT_TIMER0 ); 
.................... 	enable_interrupts( INT_TIMER0 ); 
.................... } 
....................  
.................... #INT_TIMER0 
.................... void timer0_isr(void) 
.................... {    
....................      
.................... 	// Increase millisecond counter at each millisecond. 
....................     g_ui16MillisecondToSecondCounter++;  //=========================================  1 
....................      
.................... ////    if (IBC_TIMER_0_CRITICAL_ON == g_ui8fTimer0State) 
.................... ////    { 
.................... ////        // Reset Timer0. 
.................... ////        set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS ); 
.................... ////        clear_interrupt( INT_TIMER0 ); 
.................... ////         
.................... ////        return; 
.................... ////    } 
....................      
....................      // Check if millisecond counter overflows 
....................     if(g_ui16MillisecondToSecondCounter >= MILLISECOND_TIMEOUT)  //==================== 2 
....................     { 
....................         // Reset counter. 
....................         g_ui16MillisecondToSecondCounter = 0; 
....................          
....................         // 1000MS i.e. 1second completed.. put stuff here that repeats after every second. 
....................          
....................         // Increase each second counter 
....................         g_ui8SecondToMinuteCounter++; 
....................          
....................         // If data should not send through GPRS then count data send interval time 
....................         if(SHOULD_NOT_SEND_DATA == g_fShouldSendData) 
....................         { 
....................             // Increase data send interval time. 
....................             g_ui16DataSendIntervalTime++; 
....................         } 
....................          
....................         // Increment counter to Sync with HMI Time to get proper timestamp. 
....................         g_ui16RegisterTime_Diff++; 
....................     }    
....................      
....................     // Check If There is data ready to send HMI through RS485 
....................     if (FLAG_RS485_DATA_READY == g_fRS485DataReady) // =================================== 4 
....................     { 
....................         // Raise RTS Pin On to hold the bus 
....................         output_bit(PIN_RS485_RTS, 1); 
....................         if (g_ui8RTSOnCountBefore++ >= DELAY_TIME_RTS_BEFORE) 
....................         { 
....................             g_ui8RTSOnCountBefore = 0; 
....................             g_ui8RS485ByteCnt = 0; 
....................             g_ui8fRS485DataSend = FLAG_RS485_DATA_SEND_ON; 
....................             g_fRS485DataReady = FLAG_RS485_DATA_NOT_READY; 
....................              
....................         } 
....................          
....................     } 
....................      
....................     // Check for RTS Flag 
....................     if (FLAG_RS485_DATA_SEND_DONE == g_ui8fRS485DataSend) // ================================ 5 
....................     { 
....................  
....................         if (g_ui8RTSOnCountAfter++ >= DELAY_TIME_RTS_AFTER) 
....................         { 
....................             // Release RTS Pin 
....................             output_bit(PIN_RS485_RTS,0); 
....................             g_ui8RTSOnCountAfter = 0; 
....................             g_ui8fRS485DataSend = FLAG_RS485_DATA_SEND_OFF; 
....................         } 
....................     } 
....................      
....................     // AR start 
....................     // Checking ISR received byte flag. 
....................     if(ISR_IS_READY == g_fIsReadyToReceiveByte) // =========================================== 
....................     { 
....................         // Increase the counter. 
....................         g_ui8ISRReceiveByteTimeCounter++; 
....................     } 
....................      
....................     if(ISR_TOTAL_BYTE_RECEIVE_TIME == g_ui8ISRReceiveByteTimeCounter) // ============================ 
....................     { 
....................         // Update all received byte flag. 
....................         g_fISRAllByteReceived = ISR_RECEIVED_ALL_BYTE; 
....................          
....................         // Update Is received byte flag.  
....................         g_fIsReadyToReceiveByte =  ISR_IS_NOT_READY; 
....................          
....................         // Reset Counter 
....................         g_ui8ISRReceiveByteTimeCounter = 0; 
....................     } 
....................     // AR end 
....................      
....................     if (IBC_TIMER_0_CRITICAL_ON == g_ui8fTimer0State) 
....................     { 
....................         // Reset Timer0. 
....................         set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS ); 
....................         clear_interrupt( INT_TIMER0 ); 
....................          
....................         return; 
....................     } 
....................      
....................     // ############################### Non Critical ############################### 
....................  
....................      
....................     // Check if second counter overflows 
....................     if(g_ui8SecondToMinuteCounter >= SECOND_TIMEOUT) 
....................     { 
....................         // Reset counter 
....................         g_ui8SecondToMinuteCounter = 0; 
....................          
....................         // 60Seconds i.e. 1 Minute completed.. put stuff here that repeats after every minute. 
....................          
....................         // Increase AT response check time interval counter..allows upto 60 minutes i.e. for 1 hour 
....................         g_ui8ATResponseCheckTimeInterval++; 
....................          
....................         // Check GPRS queue empty time status 
....................         if(GPRS_QUEUE_EMPTY_TIME_COUNT_START == g_fGPRSQueueEmptyTimeStatus) 
....................         { 
....................             // Increase time count 
....................             g_ui8GPRSQueueEmptyTimeCounter++; 
....................         } 
....................         else if(GPRS_QUEUE_EMPTY_TIME_COUNT_STOP == g_fGPRSQueueEmptyTimeStatus) 
....................         { 
....................             // when data available..reset time count 
....................             g_ui8GPRSQueueEmptyTimeCounter = 0; 
....................         } 
....................          
....................         // Check ready to restart MCU flag. 
....................         if(g_fIsReadyToRestartMCU >= DO_NOT_RESTART_MCU) 
....................         { 
....................             // Increment counter. 
....................             g_ui8RestartMCUIntrvlTimeCounter++; 
....................         } 
....................     } 
....................      
....................     // Check if AT response check interval time overflow. 
....................     if(AT_RESPONSE_CHECK_INTRVL_TIMEOUT == g_ui8ATResponseCheckTimeInterval) 
....................     { 
....................         // Reset counter 
....................         g_ui8ATResponseCheckTimeInterval = 0; 
....................          
....................         // Update AT response check flag. 
....................         g_fShouldCheckForAtResponse = CHECK_FOR_AT_RESPONSE; 
....................     } 
....................      
....................  
....................      
....................     // Check if timer should look for timeout 
....................     if(g_fShouldLookForTimeOut) 
....................     { 
....................         // Increase timer counter 
....................         g_ui16ShouldLookTimerCounter++; 
....................          
....................         // Check if timer counter reached timeout value 
....................         if(g_ui16ShouldLookTimerCounter >= g_ui16TimeOutMilliseconds) 
....................         { 
....................             // Set flag denoting that timer declares set time is timed out 
....................             g_fIsTimedOut = 1; 
....................              
....................             // Reset variables 
....................             g_fShouldLookForTimeOut      = 0; 
....................             g_ui16ShouldLookTimerCounter = 0; 
....................             g_ui16TimeOutMilliseconds    = 0; 
....................         } 
....................     } 
....................      
....................     // Check GPRS queue empty time count 
....................     if(GPRS_QUEUE_EMPTY_TIMEOUT == g_ui8GPRSQueueEmptyTimeCounter) 
....................     { 
....................         // Set flag that data is not available in GPRS queue for 15 minutes..check GPRS connection 
....................         g_fCheckGPRSConnectivity = SHOULD_CHECK_GPRS_CONNECTIVITY; 
....................          
....................         // Reset counter 
....................         g_ui8GPRSQueueEmptyTimeCounter = 0; 
....................     } 
....................      
....................     // Check if data send interval time reached timeout 
....................     if(DATA_SEND_INTERVAL_TIMEOUT == g_ui16DataSendIntervalTime) 
....................     { 
....................         // Update should send data flag 
....................         g_fShouldSendData = SHOULD_SEND_DATA; 
....................          
....................         // Reset variable 
....................         g_ui16DataSendIntervalTime = 0; 
....................     } 
....................      
....................     // Check restart MCU interval time counter. 
....................     if(g_ui8RestartMCUIntrvlTimeCounter >= RESTART_MCU_INTERVAL_TIME) 
....................     { 
....................         // Update flag status. 
....................         g_fIsReadyToRestartMCU = REDAY_TO_RESTART_MCU; 
....................          
....................         // Reset counter. 
....................         g_ui8RestartMCUIntrvlTimeCounter = 0; 
....................     } 
....................      
....................     // TESTING 
.................... 	//output_toggle(PIN_IN_EXT_DI_00); 
....................      
.................... 	// Reset Timer0. 
....................     set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS ); 
....................     clear_interrupt( INT_TIMER0 );	 
.................... } 
....................  
.................... //////// TESTING Start 
.................... //////void InitTIMER1(void) 
.................... //////{ 
.................... //////     // Setup Timer0 at 1 ms Time. 
.................... //////    setup_timer_1( T1_INTERNAL | T1_DIV_BY_8 ); 
.................... //////    set_timer0( ALL_TIMER_TEST_VAL_FOR_70_US ); 
.................... //////    // Enable Timer0. 
.................... //////    clear_interrupt( INT_TIMER1 ); 
.................... //////    enable_interrupts( INT_TIMER1 ); 
.................... //////} 
.................... ////// 
.................... //////void InitTIMER3(void) 
.................... //////{ 
.................... //////     // Setup Timer0 at 1 ms Time. 
.................... //////    setup_timer_3( T3_INTERNAL | T3_DIV_BY_8 ); 
.................... //////    set_timer0( ALL_TIMER_TEST_VAL_FOR_70_US ); 
.................... //////    // Enable Timer0. 
.................... //////    clear_interrupt( INT_TIMER3 ); 
.................... //////    enable_interrupts( INT_TIMER3 ); 
.................... //////} 
.................... ////// 
.................... //////// TESTING End. 
....................  
.................... //****************************************************************************** 
.................... //**************** Above -> Timer Initialization Function ********************** 
.................... //****************************************************************************** 
....................  
....................  
....................  
....................  
.................... void ExecuteALLDOs(void) 
.................... { 
.................... //    delay_us(10); 
.................... //    output_bit(PIN_OUT_DO_00, g_unDOState.m_stAllDOBits.m_ui1HWDOCn00); // Solenoid opeartion. 
.................... //    //output_bit(PIN_OUT_DO_01, g_unDOState.m_stAllDOBits.m_ui1HWDOCn01); // Shipper rejection RED LED. 
.................... //    //output_bit(PIN_OUT_DO_02, g_unDOState.m_stAllDOBits.m_ui1HWDOCn02); 
.................... //    output_bit(PIN_OUT_DO_03, g_unDOState.m_stAllDOBits.m_ui1HWDOCn03); // Ready To Feed. 
.................... //    //output_bit(PIN_OUT_DO_04, g_unDOState.m_stAllDOBits.m_ui1HWDOCn04); 
.................... //    //output_bit(PIN_OUT_DO_05, g_unDOState.m_stAllDOBits.m_ui1HWDOCn05); 
.................... //    //output_bit(PIN_OUT_DO_06, g_unDOState.m_stAllDOBits.m_ui1HWDOCn06); 
.................... //    //output_bit(PIN_OUT_DO_07, g_unDOState.m_stAllDOBits.m_ui1HWDOCn07);    
.................... } 
....................  
.................... //****************************************************************************** 
.................... //******************* Below -> 1MS Timer Implementation ************************ 
.................... //****************************************************************************** 
....................  
.................... ////////#INT_TIMER0 
.................... ////////void timer0_isr(void) 
.................... ////////{    
.................... ////////     
.................... ////////	// Increase millisecond counter at each millisecond. 
.................... ////////    g_ui16MillisecondToSecondCounter++;  //=========================================  1 
.................... ////////     
.................... ////////    // Check if millisecond counter overflows 
.................... ////////    if(g_ui16MillisecondToSecondCounter >= MILLISECOND_TIMEOUT)  //==================== 2 
.................... ////////    { 
.................... ////////        // Reset counter. 
.................... ////////        g_ui16MillisecondToSecondCounter = 0; 
.................... ////////         
.................... ////////        // 1000MS i.e. 1second completed.. put stuff here that repeats after every second. 
.................... ////////         
.................... ////////        // Increase each second counter 
.................... ////////        g_ui8SecondToMinuteCounter++; 
.................... ////////         
.................... ////////        // If data should not send through GPRS then count data send interval time 
.................... ////////        if(SHOULD_NOT_SEND_DATA == g_fShouldSendData) 
.................... ////////        { 
.................... ////////            // Increase data send interval time. 
.................... ////////            g_ui16DataSendIntervalTime++; 
.................... ////////        } 
.................... ////////         
.................... ////////        // Increment counter to Sync with HMI Time to get proper timestamp. 
.................... ////////        g_ui16RegisterTime_Diff++; 
.................... ////////    } 
.................... ////////     
.................... ////////    // Check if second counter overflows 
.................... ////////    if(SECOND_TIMEOUT == g_ui8SecondToMinuteCounter) // =============================== 3 
.................... ////////    { 
.................... ////////        // Reset counter 
.................... ////////        g_ui8SecondToMinuteCounter = 0; 
.................... ////////         
.................... ////////        // 60Seconds i.e. 1 Minute completed.. put stuff here that repeats after every minute. 
.................... ////////         
.................... ////////        // Increase AT response check time interval counter..allows upto 60 minutes i.e. for 1 hour 
.................... ////////        g_ui8ATResponseCheckTimeInterval++; 
.................... ////////         
.................... ////////        // Check GPRS queue empty time status 
.................... ////////        if(GPRS_QUEUE_EMPTY_TIME_COUNT_START == g_fGPRSQueueEmptyTimeStatus) 
.................... ////////        { 
.................... ////////            // Increase time count 
.................... ////////            g_ui8GPRSQueueEmptyTimeCounter++; 
.................... ////////        } 
.................... ////////        else if(GPRS_QUEUE_EMPTY_TIME_COUNT_STOP == g_fGPRSQueueEmptyTimeStatus) 
.................... ////////        { 
.................... ////////            // when data available..reset time count 
.................... ////////            g_ui8GPRSQueueEmptyTimeCounter = 0; 
.................... ////////        } 
.................... ////////         
.................... ////////        // Check ready to restart MCU flag. 
.................... ////////        if(DO_NOT_RESTART_MCU == g_fIsReadyToRestartMCU) 
.................... ////////        { 
.................... ////////            // Increment counter. 
.................... ////////            g_ui8RestartMCUIntrvlTimeCounter++; 
.................... ////////        } 
.................... ////////    } 
.................... ////////     
.................... ////////    // Check If There is data ready to send HMI through RS485 
.................... ////////    if (FLAG_RS485_DATA_READY == g_fRS485DataReady) // =================================== 4 
.................... ////////    { 
.................... ////////        // Raise RTS Pin On to hold the bus 
.................... ////////        output_bit(PIN_RS485_RTS, 1); 
.................... ////////        if (g_ui8RTSOnCountBefore++ >= DELAY_TIME_RTS_BEFORE) 
.................... ////////        { 
.................... ////////            g_ui8RTSOnCountBefore = 0; 
.................... ////////            g_ui8RS485ByteCnt = 0; 
.................... ////////            g_ui8fRS485DataSend = FLAG_RS485_DATA_SEND_ON; 
.................... ////////            g_fRS485DataReady = FLAG_RS485_DATA_NOT_READY; 
.................... ////////             
.................... ////////        } 
.................... ////////         
.................... ////////    } 
.................... ////////         
.................... //////// 
.................... //////// 
.................... ////////    // Check for RTS Flag 
.................... ////////    if (FLAG_RS485_DATA_SEND_DONE == g_ui8fRS485DataSend) // ================================ 5 
.................... ////////    { 
.................... //////// 
.................... ////////        if (g_ui8RTSOnCountAfter++ >= DELAY_TIME_RTS_AFTER) 
.................... ////////        { 
.................... ////////            // Release RTS Pin 
.................... ////////            output_bit(PIN_RS485_RTS,0); 
.................... ////////            g_ui8RTSOnCountAfter = 0; 
.................... ////////            g_ui8fRS485DataSend = FLAG_RS485_DATA_SEND_OFF; 
.................... ////////        } 
.................... ////////    } 
.................... ////////    // Check if AT response check interval time overflow. 
.................... ////////    if(AT_RESPONSE_CHECK_INTRVL_TIMEOUT == g_ui8ATResponseCheckTimeInterval) 
.................... ////////    { 
.................... ////////        // Reset counter 
.................... ////////        g_ui8ATResponseCheckTimeInterval = 0; 
.................... ////////         
.................... ////////        // Update AT response check flag. 
.................... ////////        g_fShouldCheckForAtResponse = CHECK_FOR_AT_RESPONSE; 
.................... ////////    } 
.................... ////////     
.................... ////////    // AR start 
.................... ////////    // Checking ISR received byte flag. 
.................... ////////    if(ISR_IS_READY == g_fIsReadyToReceiveByte) // =========================================== 
.................... ////////    { 
.................... ////////        // Increase the counter. 
.................... ////////        g_ui8ISRReceiveByteTimeCounter++; 
.................... ////////    } 
.................... ////////     
.................... ////////    if(ISR_TOTAL_BYTE_RECEIVE_TIME == g_ui8ISRReceiveByteTimeCounter) // ============================ 
.................... ////////    { 
.................... ////////        // Update all received byte flag. 
.................... ////////        g_fISRAllByteReceived = ISR_RECEIVED_ALL_BYTE; 
.................... ////////         
.................... ////////        // Update Is received byte flag.  
.................... ////////        g_fIsReadyToReceiveByte =  ISR_IS_NOT_READY; 
.................... ////////         
.................... ////////        // Reset Counter 
.................... ////////        g_ui8ISRReceiveByteTimeCounter = 0; 
.................... ////////    } 
.................... ////////    // AR end 
.................... ////////     
.................... ////////    // Check if timer should look for timeout 
.................... ////////    if(g_fShouldLookForTimeOut) 
.................... ////////    { 
.................... ////////        // Increase timer counter 
.................... ////////        g_ui16ShouldLookTimerCounter++; 
.................... ////////         
.................... ////////        // Check if timer counter reached timeout value 
.................... ////////        if(g_ui16ShouldLookTimerCounter >= g_ui16TimeOutMilliseconds) 
.................... ////////        { 
.................... ////////            // Set flag denoting that timer declares set time is timed out 
.................... ////////            g_fIsTimedOut = 1; 
.................... ////////             
.................... ////////            // Reset variables 
.................... ////////            g_fShouldLookForTimeOut      = 0; 
.................... ////////            g_ui16ShouldLookTimerCounter = 0; 
.................... ////////            g_ui16TimeOutMilliseconds    = 0; 
.................... ////////        } 
.................... ////////    } 
.................... ////////     
.................... ////////    // Check GPRS queue empty time count 
.................... ////////    if(GPRS_QUEUE_EMPTY_TIMEOUT == g_ui8GPRSQueueEmptyTimeCounter) 
.................... ////////    { 
.................... ////////        // Set flag that data is not available in GPRS queue for 15 minutes..check GPRS connection 
.................... ////////        g_fCheckGPRSConnectivity = SHOULD_CHECK_GPRS_CONNECTIVITY; 
.................... ////////         
.................... ////////        // Reset counter 
.................... ////////        g_ui8GPRSQueueEmptyTimeCounter = 0; 
.................... ////////    } 
.................... ////////     
.................... ////////    // Check if data send interval time reached timeout 
.................... ////////    if(DATA_SEND_INTERVAL_TIMEOUT == g_ui16DataSendIntervalTime) 
.................... ////////    { 
.................... ////////        // Update should send data flag 
.................... ////////        g_fShouldSendData = SHOULD_SEND_DATA; 
.................... ////////         
.................... ////////        // Reset variable 
.................... ////////        g_ui16DataSendIntervalTime = 0; 
.................... ////////    } 
.................... ////////     
.................... ////////    // Check restart MCU interval time counter. 
.................... ////////    if(g_ui8RestartMCUIntrvlTimeCounter >= RESTART_MCU_INTERVAL_TIME) 
.................... ////////    { 
.................... ////////        // Update flag status. 
.................... ////////        g_fIsReadyToRestartMCU = REDAY_TO_RESTART_MCU; 
.................... ////////         
.................... ////////        // Reset counter. 
.................... ////////        g_ui8RestartMCUIntrvlTimeCounter = 0; 
.................... ////////    } 
.................... ////////     
.................... ////////    // TESTING 
.................... ////////	//output_toggle(PIN_IN_EXT_DI_00); 
.................... ////////     
.................... ////////	// Reset Timer0. 
.................... ////////    set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS ); 
.................... ////////    clear_interrupt( INT_TIMER0 );	 
.................... ////////} 
....................  
.................... //////// TESTING Start 
.................... //////#INT_TIMER1 
.................... //////void timer_1_isr(void) 
.................... //////{ 
.................... //////    output_toggle(PIN_IN_EXT_DI_01); 
.................... //////     
.................... //////     // Reset Timer1. 
.................... //////    set_timer1( ALL_TIMER_TEST_VAL_FOR_70_US ); 
.................... //////    clear_interrupt( INT_TIMER1 ); 
.................... //////} 
.................... ////// 
.................... ////// 
.................... //////#INT_TIMER3 
.................... //////void timer_3_isr(void) 
.................... //////{ 
.................... //////    output_toggle(PIN_IN_EXT_DI_02); 
.................... //////     
.................... //////     // Reset Timer1. 
.................... //////    set_timer3( ALL_TIMER_TEST_VAL_FOR_70_US ); 
.................... //////    clear_interrupt( INT_TIMER3 ); 
.................... //////} 
.................... //////// TESTING End 
....................  
.................... //****************************************************************************** 
.................... //******************* Above -> 1MS Timer Implementation ************************ 
.................... //****************************************************************************** 
....................  
.................... void SetTimeout(unsigned int8 ui8TimedOutSeconds) 
.................... { 
....................     // Convert timeout seconds into milliseconds 
....................     g_ui16TimeOutMilliseconds = ui8TimedOutSeconds * 1000; 
....................      
....................     // Set flag denoting now timer should look for timeout value 
....................     g_fShouldLookForTimeOut = 1; 
.................... } 
....................  
....................  
.................... #endif /* _VM_TIMER_CONFIG_H_ */ 
....................  
....................  
.................... #include "vmDigitalIOPortPinConfig.h" 
.................... #ifndef _VM_DIGITAL_IO_PORT_PIN_CONFIG_H_ 
.................... #define _VM_DIGITAL_IO_PORT_PIN_CONFIG_H_ 
....................  
.................... //#include "18F46K80.h" 
....................  
.................... // For setting of TRIS resister. 
.................... // Set bit = 1 - makes port as Digital Input. 
.................... #define SET_TO_1_TRIS_BIT0     0x01 // 0000 0001 binary. 
.................... #define SET_TO_1_TRIS_BIT1     0x02 // 0000 0010 binary.     
.................... #define SET_TO_1_TRIS_BIT2     0x04 // 0000 0100 binary.       
.................... #define SET_TO_1_TRIS_BIT3     0x08 // 0000 1000 binary.       
.................... #define SET_TO_1_TRIS_BIT4     0x10 // 0001 0000 binary.      
.................... #define SET_TO_1_TRIS_BIT5     0x20 // 0010 0000 binary.       
.................... #define SET_TO_1_TRIS_BIT6     0x40 // 0100 0000 binary.       
.................... #define SET_TO_1_TRIS_BIT7     0x80 // 1000 0000 binary.       
....................   
.................... // For setting of TRIS resister. 
.................... // Reset bit = 0 - makes port as Digital Output. 
.................... #define RESET_TO_0_TRIS_BIT0   0xFE // 1111 1110 binary. 
.................... #define RESET_TO_0_TRIS_BIT1   0xFD // 1111 1101 binary. 
.................... #define RESET_TO_0_TRIS_BIT2   0xFB // 1111 1011 binary. 
.................... #define RESET_TO_0_TRIS_BIT3   0xF7 // 1111 0111 binary. 
.................... #define RESET_TO_0_TRIS_BIT4   0xEF // 1110 1111 binary. 
.................... #define RESET_TO_0_TRIS_BIT5   0xDF // 1101 1111 binary. 
.................... #define RESET_TO_0_TRIS_BIT6   0xBF // 1011 1111 binary. 
.................... #define RESET_TO_0_TRIS_BIT7   0x7F // 0111 1111 binary. 
....................  
.................... #define SET_PORT_PIN_AS_DIGITAL_INPUT(portName,bitNumber)  \ 
....................    (set_tris_##portName##(get_tris_##portName##() |  SET_TO_1_TRIS_BIT##bitNumber)) 
....................  
.................... #define SET_PORT_PIN_AS_DIGITAL_OUTPUT(portName,bitNumber) \ 
....................    (set_tris_##portName##(get_tris_##portName##() &  RESET_TO_0_TRIS_BIT##bitNumber)) 
....................  
....................  
.................... void SetDigitalInputPortPinsOfMicro(void) 
.................... { 
....................     SET_PORT_PIN_AS_DIGITAL_INPUT(A,0); 
....................     SET_PORT_PIN_AS_DIGITAL_INPUT(A,1); 
....................     SET_PORT_PIN_AS_DIGITAL_INPUT(A,2); 
....................     SET_PORT_PIN_AS_DIGITAL_INPUT(A,3); 
....................    // SET_PORT_PIN_AS_DIGITAL_INPUT(B,1); 
....................     SET_PORT_PIN_AS_DIGITAL_INPUT(A,5); 
....................     SET_PORT_PIN_AS_DIGITAL_INPUT(E,0); 
....................     SET_PORT_PIN_AS_DIGITAL_INPUT(E,1); 
....................     SET_PORT_PIN_AS_DIGITAL_INPUT(E,2); 
....................    // SET_PORT_PIN_AS_DIGITAL_INPUT(A,6); 
....................     SET_PORT_PIN_AS_DIGITAL_INPUT(C,0); 
....................     SET_PORT_PIN_AS_DIGITAL_INPUT(C,1); 
....................     SET_PORT_PIN_AS_DIGITAL_INPUT(C,2); 
....................     SET_PORT_PIN_AS_DIGITAL_INPUT(C,3); 
....................     SET_PORT_PIN_AS_DIGITAL_INPUT(D,0); 
....................     SET_PORT_PIN_AS_DIGITAL_INPUT(D,1); 
.................... } 
....................  
.................... void SetDigitalOutputPortPinsOfMicro(void) 
.................... { 
....................     SET_PORT_PIN_AS_DIGITAL_OUTPUT(D,2); 
....................     SET_PORT_PIN_AS_DIGITAL_OUTPUT(D,3); 
....................     SET_PORT_PIN_AS_DIGITAL_OUTPUT(C,4); 
....................     SET_PORT_PIN_AS_DIGITAL_OUTPUT(C,5); 
....................    // SET_PORT_PIN_AS_DIGITAL_OUTPUT(D,4); 
....................    // SET_PORT_PIN_AS_DIGITAL_OUTPUT(D,5); 
.................... } 
....................  
.................... void SetShiftRegisterPortPinsOfMicro(void) 
.................... { 
....................     SET_PORT_PIN_AS_DIGITAL_OUTPUT(B,4); 
....................     SET_PORT_PIN_AS_DIGITAL_OUTPUT(B,5); 
.................... } 
....................  
.................... void SetRS485PortPinOfMicro(void) 
.................... { 
....................     SET_PORT_PIN_AS_DIGITAL_OUTPUT(C,6); 
*
00B10:  MOVF   F94,W
00B12:  ANDLW  BF
00B14:  MOVLB  B
00B16:  MOVWF  F94
....................     SET_PORT_PIN_AS_DIGITAL_INPUT(C,7); 
00B18:  MOVF   F94,W
00B1A:  IORLW  80
00B1C:  MOVWF  F94
....................     //SET_PORT_PIN_AS_DIGITAL_OUTPUT(B,6); 
....................     SET_PORT_PIN_AS_DIGITAL_OUTPUT(B,4); 
00B1E:  MOVF   F93,W
00B20:  ANDLW  EF
00B22:  MOVWF  F93
00B24:  MOVLB  0
00B26:  GOTO   643E (RETURN)
.................... } 
....................  
.................... #endif /* _VM_DIGITAL_IO_PORT_PIN_CONFIG_H_ */ 
....................   
....................  
.................... #include "vmGSMM66Config.h" 
.................... /*  
....................  * File:   vmGSMM66Config.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on January 18, 2019, 5:10 PM 
....................  */ 
....................  
.................... #ifndef VM_GSM_M66_CONFIG_H 
.................... #define	VM_GSM_M66_CONFIG_H 
....................  
.................... #include "vmGSMM66_GPRSConfig.h" 
.................... /*  
....................  * File:   vmGSMM66_GPRSConfig.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on January 22, 2019, 6:50 PM 
....................  */ 
....................  
.................... #ifndef VM_GSMM66_GPRS_CONFIG_H 
.................... #define	VM_GSMM66_GPRS_CONFIG_H 
....................  
.................... #include "vmSIM900_GPRSConfig.h" 
.................... /*  
....................  * File:   vmSIM900_GPRSConfig.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on December 12, 2018, 4:05 PM 
....................  */ 
....................  
.................... #ifndef VM_SIM900_GPRS_CONFIG_H 
.................... #define	VM_SIM900_GPRS_CONFIG_H 
....................  
.................... #include "vmTimerConfig.h" 
.................... #ifndef _VM_TIMER_CONFIG_H_ 
.................... #define _VM_TIMER_CONFIG_H_ 
....................  
....................  
.................... //#include "vmCommon.h"   //TESTING 
.................... #include "../Common/viShiftRegister.h" 
.................... #include "../Common/vmModbusGlobal.h" 
.................... //#include "../Common/vmRS485Config.h" 
.................... #include "vmM1Common.h" 
.................... #include "../Common/vmIBCConfig.h" 
....................  
....................  
.................... #define T0_DIV_PRESCALE                     T0_DIV_8  
.................... #define TIMER_0_VALUE_LOAD_FOR_1MS          0xFD8F 
.................... #define ALL_TIMER_TEST_VAL_FOR_100_US       (0xFFFF - 0x003F + 1) 
.................... #define ALL_TIMER_TEST_VAL_FOR_70_US        (0xFFFF - 0x002C + 1) 
....................  
....................  
.................... #define FLAG_DI_STATE_CHANGED               11 
.................... #define FLAG_DI_STATE_NOT_CHANGED           12 
....................  
.................... #define ISR_TOTAL_BYTE_RECEIVE_TIME             9 //5 
.................... #define ISR_RECEIVED_ALL_BYTE                   21 
.................... #define ISR_PROCESSED_ALL_BYTE                  22 
.................... #define ISR_IS_READY                            40 
.................... #define ISR_IS_NOT_READY                        41 
....................  
.................... #define CHECK_FOR_AT_RESPONSE                   15 
.................... #define DO_NOT_CHECK_FOR_AT_RESPONSE            16 
.................... #define AT_RESPONSE_CHECK_INTRVL_TIMEOUT        60 
....................  
.................... #define MILLISECOND_TIMEOUT                     1000 
.................... #define SECOND_TIMEOUT                          60 
....................  
.................... #define SHOULD_SEND_DATA                        25 
.................... #define SHOULD_NOT_SEND_DATA                    26 
.................... #define DATA_SEND_INTERVAL_TIMEOUT              30 
....................  
.................... #define GPRS_CONNECTED                          1 
.................... #define GPRS_NOT_CONNECTED                      0 
....................  
.................... #define  GPRS_QUEUE_EMPTY_TIME_COUNT_START      80 
.................... #define  GPRS_QUEUE_EMPTY_TIME_COUNT_STOP       81 
.................... #define  GPRS_QUEUE_EMPTY_TIMEOUT               15 
....................  
.................... #define  SHOULD_CHECK_GPRS_CONNECTIVITY         55 
.................... #define  SHOULD_NOT_CHECK_GPRS_CONNECTIVITY     56 
....................  
.................... #define  REDAY_TO_RESTART_MCU                   33 
.................... #define  DO_NOT_RESTART_MCU                     34 
.................... #define  RESTART_MCU_INTERVAL_TIME              15  // In Minutes. Two Consecutive MCU restart will takes place at an interval of 15 minutes. 
....................  
.................... #define  GPRS_CONNECTION_QUERY_TIMEOUT          3  // In seconds. 
.................... #define  HTTP_URL_PARAMETER_SET_TIMEOUT         2 
.................... #define  HTTP_GET_SESSION_TIMEOUT               8 
.................... #define  DATA_RESEND_INTRVL_TIMEOUT             10 
....................  
.................... // ***************************************************************************** 
.................... // ***************** Below -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
.................... unsigned int16 g_ui16StackerEmptyDelayCount           = 0; 
.................... unsigned int8  g_fIsReadyToReceiveByte                = ISR_IS_NOT_READY; 
.................... unsigned int8  g_ui8ISRReceiveByteTimeCounter         = 0; 
.................... unsigned int8  g_fISRAllByteReceived                  = ISR_PROCESSED_ALL_BYTE; 
.................... unsigned int8  g_fDIChangeState                       = FLAG_DI_STATE_NOT_CHANGED; 
.................... unsigned int8  g_fShouldCheckForAtResponse            = CHECK_FOR_AT_RESPONSE; 
.................... unsigned int16 g_ui16MillisecondToSecondCounter       = 0; 
.................... unsigned int8  g_ui8SecondToMinuteCounter             = 0; 
.................... unsigned int8  g_ui8ATResponseCheckTimeInterval       = 0; 
.................... unsigned int16 g_ui16TimeOutMilliseconds              = 0; 
.................... unsigned int8  g_fShouldLookForTimeOut                = 0; 
.................... unsigned int16 g_ui16ShouldLookTimerCounter           = 0; 
.................... unsigned int8  g_fIsTimedOut                          = 0; 
.................... unsigned int8  g_fShouldSendData                      = SHOULD_NOT_SEND_DATA; 
.................... unsigned int16 g_ui16DataSendIntervalTime             = 0; 
.................... //unsigned int8  g_fIsGPRSConnected                     = 0; 
.................... unsigned int8  g_ui8GPRSQueueEmptyTimeCounter         = 0; 
.................... unsigned int8  g_fCheckGPRSConnectivity               = SHOULD_NOT_CHECK_GPRS_CONNECTIVITY; 
.................... unsigned int8  g_fGPRSQueueEmptyTimeStatus            = 0; 
.................... unsigned int8  g_fIsReadyToRestartMCU                 = DO_NOT_RESTART_MCU; 
.................... unsigned int8  g_ui8RestartMCUIntrvlTimeCounter       = 0; 
.................... unsigned int8  g_ui8RS485ByteCnt                      = 0; 
.................... unsigned int8  g_ui8RTSOnCountBefore                  = 0; 
.................... unsigned int8  g_ui8RTSOnCountAfter                   = 0; 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ***************** Above -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //**************** Below -> Timer Initialization Function ********************** 
.................... //****************************************************************************** 
....................  
.................... //Initialize 1MS Timer. 
.................... void Init1MSTimer(void) 
.................... { 
.................... 	//setup timer0 for 1MS time. 
.................... 	setup_timer_0( T0_INTERNAL | T0_DIV_PRESCALE ); 
.................... 	set_timer0(TIMER_0_VALUE_LOAD_FOR_1MS); 
....................  
.................... 	//Enable timer0 
.................... 	clear_interrupt( INT_TIMER0 ); 
.................... 	enable_interrupts( INT_TIMER0 ); 
.................... } 
....................  
.................... #INT_TIMER0 
.................... void timer0_isr(void) 
.................... {    
....................      
.................... 	// Increase millisecond counter at each millisecond. 
....................     g_ui16MillisecondToSecondCounter++;  //=========================================  1 
....................      
.................... ////    if (IBC_TIMER_0_CRITICAL_ON == g_ui8fTimer0State) 
.................... ////    { 
.................... ////        // Reset Timer0. 
.................... ////        set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS ); 
.................... ////        clear_interrupt( INT_TIMER0 ); 
.................... ////         
.................... ////        return; 
.................... ////    } 
....................      
....................      // Check if millisecond counter overflows 
....................     if(g_ui16MillisecondToSecondCounter >= MILLISECOND_TIMEOUT)  //==================== 2 
....................     { 
....................         // Reset counter. 
....................         g_ui16MillisecondToSecondCounter = 0; 
....................          
....................         // 1000MS i.e. 1second completed.. put stuff here that repeats after every second. 
....................          
....................         // Increase each second counter 
....................         g_ui8SecondToMinuteCounter++; 
....................          
....................         // If data should not send through GPRS then count data send interval time 
....................         if(SHOULD_NOT_SEND_DATA == g_fShouldSendData) 
....................         { 
....................             // Increase data send interval time. 
....................             g_ui16DataSendIntervalTime++; 
....................         } 
....................          
....................         // Increment counter to Sync with HMI Time to get proper timestamp. 
....................         g_ui16RegisterTime_Diff++; 
....................     }    
....................      
....................     // Check If There is data ready to send HMI through RS485 
....................     if (FLAG_RS485_DATA_READY == g_fRS485DataReady) // =================================== 4 
....................     { 
....................         // Raise RTS Pin On to hold the bus 
....................         output_bit(PIN_RS485_RTS, 1); 
....................         if (g_ui8RTSOnCountBefore++ >= DELAY_TIME_RTS_BEFORE) 
....................         { 
....................             g_ui8RTSOnCountBefore = 0; 
....................             g_ui8RS485ByteCnt = 0; 
....................             g_ui8fRS485DataSend = FLAG_RS485_DATA_SEND_ON; 
....................             g_fRS485DataReady = FLAG_RS485_DATA_NOT_READY; 
....................              
....................         } 
....................          
....................     } 
....................      
....................     // Check for RTS Flag 
....................     if (FLAG_RS485_DATA_SEND_DONE == g_ui8fRS485DataSend) // ================================ 5 
....................     { 
....................  
....................         if (g_ui8RTSOnCountAfter++ >= DELAY_TIME_RTS_AFTER) 
....................         { 
....................             // Release RTS Pin 
....................             output_bit(PIN_RS485_RTS,0); 
....................             g_ui8RTSOnCountAfter = 0; 
....................             g_ui8fRS485DataSend = FLAG_RS485_DATA_SEND_OFF; 
....................         } 
....................     } 
....................      
....................     // AR start 
....................     // Checking ISR received byte flag. 
....................     if(ISR_IS_READY == g_fIsReadyToReceiveByte) // =========================================== 
....................     { 
....................         // Increase the counter. 
....................         g_ui8ISRReceiveByteTimeCounter++; 
....................     } 
....................      
....................     if(ISR_TOTAL_BYTE_RECEIVE_TIME == g_ui8ISRReceiveByteTimeCounter) // ============================ 
....................     { 
....................         // Update all received byte flag. 
....................         g_fISRAllByteReceived = ISR_RECEIVED_ALL_BYTE; 
....................          
....................         // Update Is received byte flag.  
....................         g_fIsReadyToReceiveByte =  ISR_IS_NOT_READY; 
....................          
....................         // Reset Counter 
....................         g_ui8ISRReceiveByteTimeCounter = 0; 
....................     } 
....................     // AR end 
....................      
....................     if (IBC_TIMER_0_CRITICAL_ON == g_ui8fTimer0State) 
....................     { 
....................         // Reset Timer0. 
....................         set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS ); 
....................         clear_interrupt( INT_TIMER0 ); 
....................          
....................         return; 
....................     } 
....................      
....................     // ############################### Non Critical ############################### 
....................  
....................      
....................     // Check if second counter overflows 
....................     if(g_ui8SecondToMinuteCounter >= SECOND_TIMEOUT) 
....................     { 
....................         // Reset counter 
....................         g_ui8SecondToMinuteCounter = 0; 
....................          
....................         // 60Seconds i.e. 1 Minute completed.. put stuff here that repeats after every minute. 
....................          
....................         // Increase AT response check time interval counter..allows upto 60 minutes i.e. for 1 hour 
....................         g_ui8ATResponseCheckTimeInterval++; 
....................          
....................         // Check GPRS queue empty time status 
....................         if(GPRS_QUEUE_EMPTY_TIME_COUNT_START == g_fGPRSQueueEmptyTimeStatus) 
....................         { 
....................             // Increase time count 
....................             g_ui8GPRSQueueEmptyTimeCounter++; 
....................         } 
....................         else if(GPRS_QUEUE_EMPTY_TIME_COUNT_STOP == g_fGPRSQueueEmptyTimeStatus) 
....................         { 
....................             // when data available..reset time count 
....................             g_ui8GPRSQueueEmptyTimeCounter = 0; 
....................         } 
....................          
....................         // Check ready to restart MCU flag. 
....................         if(g_fIsReadyToRestartMCU >= DO_NOT_RESTART_MCU) 
....................         { 
....................             // Increment counter. 
....................             g_ui8RestartMCUIntrvlTimeCounter++; 
....................         } 
....................     } 
....................      
....................     // Check if AT response check interval time overflow. 
....................     if(AT_RESPONSE_CHECK_INTRVL_TIMEOUT == g_ui8ATResponseCheckTimeInterval) 
....................     { 
....................         // Reset counter 
....................         g_ui8ATResponseCheckTimeInterval = 0; 
....................          
....................         // Update AT response check flag. 
....................         g_fShouldCheckForAtResponse = CHECK_FOR_AT_RESPONSE; 
....................     } 
....................      
....................  
....................      
....................     // Check if timer should look for timeout 
....................     if(g_fShouldLookForTimeOut) 
....................     { 
....................         // Increase timer counter 
....................         g_ui16ShouldLookTimerCounter++; 
....................          
....................         // Check if timer counter reached timeout value 
....................         if(g_ui16ShouldLookTimerCounter >= g_ui16TimeOutMilliseconds) 
....................         { 
....................             // Set flag denoting that timer declares set time is timed out 
....................             g_fIsTimedOut = 1; 
....................              
....................             // Reset variables 
....................             g_fShouldLookForTimeOut      = 0; 
....................             g_ui16ShouldLookTimerCounter = 0; 
....................             g_ui16TimeOutMilliseconds    = 0; 
....................         } 
....................     } 
....................      
....................     // Check GPRS queue empty time count 
....................     if(GPRS_QUEUE_EMPTY_TIMEOUT == g_ui8GPRSQueueEmptyTimeCounter) 
....................     { 
....................         // Set flag that data is not available in GPRS queue for 15 minutes..check GPRS connection 
....................         g_fCheckGPRSConnectivity = SHOULD_CHECK_GPRS_CONNECTIVITY; 
....................          
....................         // Reset counter 
....................         g_ui8GPRSQueueEmptyTimeCounter = 0; 
....................     } 
....................      
....................     // Check if data send interval time reached timeout 
....................     if(DATA_SEND_INTERVAL_TIMEOUT == g_ui16DataSendIntervalTime) 
....................     { 
....................         // Update should send data flag 
....................         g_fShouldSendData = SHOULD_SEND_DATA; 
....................          
....................         // Reset variable 
....................         g_ui16DataSendIntervalTime = 0; 
....................     } 
....................      
....................     // Check restart MCU interval time counter. 
....................     if(g_ui8RestartMCUIntrvlTimeCounter >= RESTART_MCU_INTERVAL_TIME) 
....................     { 
....................         // Update flag status. 
....................         g_fIsReadyToRestartMCU = REDAY_TO_RESTART_MCU; 
....................          
....................         // Reset counter. 
....................         g_ui8RestartMCUIntrvlTimeCounter = 0; 
....................     } 
....................      
....................     // TESTING 
.................... 	//output_toggle(PIN_IN_EXT_DI_00); 
....................      
.................... 	// Reset Timer0. 
....................     set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS ); 
....................     clear_interrupt( INT_TIMER0 );	 
.................... } 
....................  
.................... //////// TESTING Start 
.................... //////void InitTIMER1(void) 
.................... //////{ 
.................... //////     // Setup Timer0 at 1 ms Time. 
.................... //////    setup_timer_1( T1_INTERNAL | T1_DIV_BY_8 ); 
.................... //////    set_timer0( ALL_TIMER_TEST_VAL_FOR_70_US ); 
.................... //////    // Enable Timer0. 
.................... //////    clear_interrupt( INT_TIMER1 ); 
.................... //////    enable_interrupts( INT_TIMER1 ); 
.................... //////} 
.................... ////// 
.................... //////void InitTIMER3(void) 
.................... //////{ 
.................... //////     // Setup Timer0 at 1 ms Time. 
.................... //////    setup_timer_3( T3_INTERNAL | T3_DIV_BY_8 ); 
.................... //////    set_timer0( ALL_TIMER_TEST_VAL_FOR_70_US ); 
.................... //////    // Enable Timer0. 
.................... //////    clear_interrupt( INT_TIMER3 ); 
.................... //////    enable_interrupts( INT_TIMER3 ); 
.................... //////} 
.................... ////// 
.................... //////// TESTING End. 
....................  
.................... //****************************************************************************** 
.................... //**************** Above -> Timer Initialization Function ********************** 
.................... //****************************************************************************** 
....................  
....................  
....................  
....................  
.................... void ExecuteALLDOs(void) 
.................... { 
.................... //    delay_us(10); 
.................... //    output_bit(PIN_OUT_DO_00, g_unDOState.m_stAllDOBits.m_ui1HWDOCn00); // Solenoid opeartion. 
.................... //    //output_bit(PIN_OUT_DO_01, g_unDOState.m_stAllDOBits.m_ui1HWDOCn01); // Shipper rejection RED LED. 
.................... //    //output_bit(PIN_OUT_DO_02, g_unDOState.m_stAllDOBits.m_ui1HWDOCn02); 
.................... //    output_bit(PIN_OUT_DO_03, g_unDOState.m_stAllDOBits.m_ui1HWDOCn03); // Ready To Feed. 
.................... //    //output_bit(PIN_OUT_DO_04, g_unDOState.m_stAllDOBits.m_ui1HWDOCn04); 
.................... //    //output_bit(PIN_OUT_DO_05, g_unDOState.m_stAllDOBits.m_ui1HWDOCn05); 
.................... //    //output_bit(PIN_OUT_DO_06, g_unDOState.m_stAllDOBits.m_ui1HWDOCn06); 
.................... //    //output_bit(PIN_OUT_DO_07, g_unDOState.m_stAllDOBits.m_ui1HWDOCn07);    
.................... } 
....................  
.................... //****************************************************************************** 
.................... //******************* Below -> 1MS Timer Implementation ************************ 
.................... //****************************************************************************** 
....................  
.................... ////////#INT_TIMER0 
.................... ////////void timer0_isr(void) 
.................... ////////{    
.................... ////////     
.................... ////////	// Increase millisecond counter at each millisecond. 
.................... ////////    g_ui16MillisecondToSecondCounter++;  //=========================================  1 
.................... ////////     
.................... ////////    // Check if millisecond counter overflows 
.................... ////////    if(g_ui16MillisecondToSecondCounter >= MILLISECOND_TIMEOUT)  //==================== 2 
.................... ////////    { 
.................... ////////        // Reset counter. 
.................... ////////        g_ui16MillisecondToSecondCounter = 0; 
.................... ////////         
.................... ////////        // 1000MS i.e. 1second completed.. put stuff here that repeats after every second. 
.................... ////////         
.................... ////////        // Increase each second counter 
.................... ////////        g_ui8SecondToMinuteCounter++; 
.................... ////////         
.................... ////////        // If data should not send through GPRS then count data send interval time 
.................... ////////        if(SHOULD_NOT_SEND_DATA == g_fShouldSendData) 
.................... ////////        { 
.................... ////////            // Increase data send interval time. 
.................... ////////            g_ui16DataSendIntervalTime++; 
.................... ////////        } 
.................... ////////         
.................... ////////        // Increment counter to Sync with HMI Time to get proper timestamp. 
.................... ////////        g_ui16RegisterTime_Diff++; 
.................... ////////    } 
.................... ////////     
.................... ////////    // Check if second counter overflows 
.................... ////////    if(SECOND_TIMEOUT == g_ui8SecondToMinuteCounter) // =============================== 3 
.................... ////////    { 
.................... ////////        // Reset counter 
.................... ////////        g_ui8SecondToMinuteCounter = 0; 
.................... ////////         
.................... ////////        // 60Seconds i.e. 1 Minute completed.. put stuff here that repeats after every minute. 
.................... ////////         
.................... ////////        // Increase AT response check time interval counter..allows upto 60 minutes i.e. for 1 hour 
.................... ////////        g_ui8ATResponseCheckTimeInterval++; 
.................... ////////         
.................... ////////        // Check GPRS queue empty time status 
.................... ////////        if(GPRS_QUEUE_EMPTY_TIME_COUNT_START == g_fGPRSQueueEmptyTimeStatus) 
.................... ////////        { 
.................... ////////            // Increase time count 
.................... ////////            g_ui8GPRSQueueEmptyTimeCounter++; 
.................... ////////        } 
.................... ////////        else if(GPRS_QUEUE_EMPTY_TIME_COUNT_STOP == g_fGPRSQueueEmptyTimeStatus) 
.................... ////////        { 
.................... ////////            // when data available..reset time count 
.................... ////////            g_ui8GPRSQueueEmptyTimeCounter = 0; 
.................... ////////        } 
.................... ////////         
.................... ////////        // Check ready to restart MCU flag. 
.................... ////////        if(DO_NOT_RESTART_MCU == g_fIsReadyToRestartMCU) 
.................... ////////        { 
.................... ////////            // Increment counter. 
.................... ////////            g_ui8RestartMCUIntrvlTimeCounter++; 
.................... ////////        } 
.................... ////////    } 
.................... ////////     
.................... ////////    // Check If There is data ready to send HMI through RS485 
.................... ////////    if (FLAG_RS485_DATA_READY == g_fRS485DataReady) // =================================== 4 
.................... ////////    { 
.................... ////////        // Raise RTS Pin On to hold the bus 
.................... ////////        output_bit(PIN_RS485_RTS, 1); 
.................... ////////        if (g_ui8RTSOnCountBefore++ >= DELAY_TIME_RTS_BEFORE) 
.................... ////////        { 
.................... ////////            g_ui8RTSOnCountBefore = 0; 
.................... ////////            g_ui8RS485ByteCnt = 0; 
.................... ////////            g_ui8fRS485DataSend = FLAG_RS485_DATA_SEND_ON; 
.................... ////////            g_fRS485DataReady = FLAG_RS485_DATA_NOT_READY; 
.................... ////////             
.................... ////////        } 
.................... ////////         
.................... ////////    } 
.................... ////////         
.................... //////// 
.................... //////// 
.................... ////////    // Check for RTS Flag 
.................... ////////    if (FLAG_RS485_DATA_SEND_DONE == g_ui8fRS485DataSend) // ================================ 5 
.................... ////////    { 
.................... //////// 
.................... ////////        if (g_ui8RTSOnCountAfter++ >= DELAY_TIME_RTS_AFTER) 
.................... ////////        { 
.................... ////////            // Release RTS Pin 
.................... ////////            output_bit(PIN_RS485_RTS,0); 
.................... ////////            g_ui8RTSOnCountAfter = 0; 
.................... ////////            g_ui8fRS485DataSend = FLAG_RS485_DATA_SEND_OFF; 
.................... ////////        } 
.................... ////////    } 
.................... ////////    // Check if AT response check interval time overflow. 
.................... ////////    if(AT_RESPONSE_CHECK_INTRVL_TIMEOUT == g_ui8ATResponseCheckTimeInterval) 
.................... ////////    { 
.................... ////////        // Reset counter 
.................... ////////        g_ui8ATResponseCheckTimeInterval = 0; 
.................... ////////         
.................... ////////        // Update AT response check flag. 
.................... ////////        g_fShouldCheckForAtResponse = CHECK_FOR_AT_RESPONSE; 
.................... ////////    } 
.................... ////////     
.................... ////////    // AR start 
.................... ////////    // Checking ISR received byte flag. 
.................... ////////    if(ISR_IS_READY == g_fIsReadyToReceiveByte) // =========================================== 
.................... ////////    { 
.................... ////////        // Increase the counter. 
.................... ////////        g_ui8ISRReceiveByteTimeCounter++; 
.................... ////////    } 
.................... ////////     
.................... ////////    if(ISR_TOTAL_BYTE_RECEIVE_TIME == g_ui8ISRReceiveByteTimeCounter) // ============================ 
.................... ////////    { 
.................... ////////        // Update all received byte flag. 
.................... ////////        g_fISRAllByteReceived = ISR_RECEIVED_ALL_BYTE; 
.................... ////////         
.................... ////////        // Update Is received byte flag.  
.................... ////////        g_fIsReadyToReceiveByte =  ISR_IS_NOT_READY; 
.................... ////////         
.................... ////////        // Reset Counter 
.................... ////////        g_ui8ISRReceiveByteTimeCounter = 0; 
.................... ////////    } 
.................... ////////    // AR end 
.................... ////////     
.................... ////////    // Check if timer should look for timeout 
.................... ////////    if(g_fShouldLookForTimeOut) 
.................... ////////    { 
.................... ////////        // Increase timer counter 
.................... ////////        g_ui16ShouldLookTimerCounter++; 
.................... ////////         
.................... ////////        // Check if timer counter reached timeout value 
.................... ////////        if(g_ui16ShouldLookTimerCounter >= g_ui16TimeOutMilliseconds) 
.................... ////////        { 
.................... ////////            // Set flag denoting that timer declares set time is timed out 
.................... ////////            g_fIsTimedOut = 1; 
.................... ////////             
.................... ////////            // Reset variables 
.................... ////////            g_fShouldLookForTimeOut      = 0; 
.................... ////////            g_ui16ShouldLookTimerCounter = 0; 
.................... ////////            g_ui16TimeOutMilliseconds    = 0; 
.................... ////////        } 
.................... ////////    } 
.................... ////////     
.................... ////////    // Check GPRS queue empty time count 
.................... ////////    if(GPRS_QUEUE_EMPTY_TIMEOUT == g_ui8GPRSQueueEmptyTimeCounter) 
.................... ////////    { 
.................... ////////        // Set flag that data is not available in GPRS queue for 15 minutes..check GPRS connection 
.................... ////////        g_fCheckGPRSConnectivity = SHOULD_CHECK_GPRS_CONNECTIVITY; 
.................... ////////         
.................... ////////        // Reset counter 
.................... ////////        g_ui8GPRSQueueEmptyTimeCounter = 0; 
.................... ////////    } 
.................... ////////     
.................... ////////    // Check if data send interval time reached timeout 
.................... ////////    if(DATA_SEND_INTERVAL_TIMEOUT == g_ui16DataSendIntervalTime) 
.................... ////////    { 
.................... ////////        // Update should send data flag 
.................... ////////        g_fShouldSendData = SHOULD_SEND_DATA; 
.................... ////////         
.................... ////////        // Reset variable 
.................... ////////        g_ui16DataSendIntervalTime = 0; 
.................... ////////    } 
.................... ////////     
.................... ////////    // Check restart MCU interval time counter. 
.................... ////////    if(g_ui8RestartMCUIntrvlTimeCounter >= RESTART_MCU_INTERVAL_TIME) 
.................... ////////    { 
.................... ////////        // Update flag status. 
.................... ////////        g_fIsReadyToRestartMCU = REDAY_TO_RESTART_MCU; 
.................... ////////         
.................... ////////        // Reset counter. 
.................... ////////        g_ui8RestartMCUIntrvlTimeCounter = 0; 
.................... ////////    } 
.................... ////////     
.................... ////////    // TESTING 
.................... ////////	//output_toggle(PIN_IN_EXT_DI_00); 
.................... ////////     
.................... ////////	// Reset Timer0. 
.................... ////////    set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS ); 
.................... ////////    clear_interrupt( INT_TIMER0 );	 
.................... ////////} 
....................  
.................... //////// TESTING Start 
.................... //////#INT_TIMER1 
.................... //////void timer_1_isr(void) 
.................... //////{ 
.................... //////    output_toggle(PIN_IN_EXT_DI_01); 
.................... //////     
.................... //////     // Reset Timer1. 
.................... //////    set_timer1( ALL_TIMER_TEST_VAL_FOR_70_US ); 
.................... //////    clear_interrupt( INT_TIMER1 ); 
.................... //////} 
.................... ////// 
.................... ////// 
.................... //////#INT_TIMER3 
.................... //////void timer_3_isr(void) 
.................... //////{ 
.................... //////    output_toggle(PIN_IN_EXT_DI_02); 
.................... //////     
.................... //////     // Reset Timer1. 
.................... //////    set_timer3( ALL_TIMER_TEST_VAL_FOR_70_US ); 
.................... //////    clear_interrupt( INT_TIMER3 ); 
.................... //////} 
.................... //////// TESTING End 
....................  
.................... //****************************************************************************** 
.................... //******************* Above -> 1MS Timer Implementation ************************ 
.................... //****************************************************************************** 
....................  
.................... void SetTimeout(unsigned int8 ui8TimedOutSeconds) 
.................... { 
....................     // Convert timeout seconds into milliseconds 
....................     g_ui16TimeOutMilliseconds = ui8TimedOutSeconds * 1000; 
....................      
....................     // Set flag denoting now timer should look for timeout value 
....................     g_fShouldLookForTimeOut = 1; 
.................... } 
....................  
....................  
.................... #endif /* _VM_TIMER_CONFIG_H_ */ 
....................  
.................... //#include "vmCalibrationConfig.h" 
.................... #include "viRS485Config.h" 
.................... #ifndef _VI_RS485_CONFIG_H_ 
.................... #define _VI_RS485_CONFIG_H_ 
....................  
.................... #include "vmCRCConfig.h" 
.................... #include "viModbusGlobal.h" 
.................... #include "vmIBCGlobal.h" 
.................... #include "vmTimerConfig.h" 
.................... //#include "vmHMIBoardModbusSetup.h" 
....................  
.................... #define RS485_TX_BUFF_SIZE 		20 
.................... #define RS485_RX_BUFF_SIZE 		50 
....................  
.................... //#define PIN_HIGH     			0 
.................... //#define PIN_LOW      			1 
.................... #define MODBUS_ADDRESS_FOR_SET_AVG_CALIBRATION_POINT        0x296 
.................... #define SLAVE_ID                                            0x1 
....................  
.................... #define MODE_ADDRESS                            0x05 
.................... #define ADDRESS_COUNTER_SEND_DATA               0x04 
....................  
.................... #define ADDRESS_FOR_SET_CALIB_0                 0x272 
.................... #define ADDRESS_FOR_SET_CALIB_1000              0x274 
.................... #define ADDRESS_FOR_SET_CALIB_2000              0x276 
.................... #define ADDRESS_FOR_SET_CALIB_3000              0x278 
.................... #define ADDRESS_FOR_SET_CALIB_4000              0x280 
.................... #define ADDRESS_FOR_SET_CALIB_5000              0x282 
.................... #define ADDRESS_FOR_SET_CALIB_6000              0x284 
.................... #define ADDRESS_FOR_SET_CALIB_7000              0x286 
.................... #define ADDRESS_FOR_SET_CALIB_8000              0x288 
.................... #define ADDRESS_FOR_SET_CALIB_9000              0x290 
.................... #define ADDRESS_FOR_SET_CALIB_10000             0x292 
.................... #define ADDRESS_FOR_SET_CALIB_DATA              0x296 
....................  
.................... #define ADDRESS_FOR_SET_CONFIG_AVG_WT           0x250 
.................... #define ADDRESS_FOR_SET_CONFIG_TOL_PV           0x252 
.................... #define ADDRESS_FOR_SET_CONFIG_TOL_NV           0x254 
.................... #define ADDRESS_FOR_SET_CONFIG_INDEX            0x256 
....................  
.................... #define DELAY_TIME_RTS_AFTER                        2 
.................... #define DELAY_TIME_RTS_BEFORE                       2 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... #define SIZE_TEMP_ARR_CRC_VALID                        15 
.................... #define MSG_QUEUE_EMPTY                                 0 
.................... #define MSG_QUEUE_NOT_EMPTY                             1 
.................... #define MODBUS_MASTER_QUERY_LENGTH_MIN                  8 
.................... #define MODBUS_MASTER_QUERY_LENGTH_MIX                 12 
.................... #define MODBUS_MASTER_QUERY_READ_REG_LENGTH             8 
.................... #define MODBUS_MASTER_QUERY_SINGLE_WRITE_REG_LENGTH     8 
....................  
.................... #define MODBUS_OFFSET_ONE       1 
.................... #define MODBUS_OFFSET_TWO       2 
.................... #define MODBUS_OFFSET_THREE     3 
.................... #define MODBUS_OFFSET_FOUR      4 
.................... #define MODBUS_OFFSET_FIVE      5 
.................... #define MODBUS_OFFSET_SIX       6 
.................... #define MODBUS_OFFSET_SEVEN     7 
.................... #define MODBUS_OFFSET_8         8 
.................... #define MODBUS_OFFSET_9         9 
.................... #define MODBUS_OFFSET_10        10 
.................... #define MODBUS_OFFSET_11        11 
.................... #define MODBUS_OFFSET_12        12 
.................... #define MODBUS_OFFSET_13        13 
.................... #define MODBUS_OFFSET_14        14 
.................... #define MODBUS_OFFSET_15        15 
.................... #define MODBUS_OFFSET_16        16 
....................  
.................... typedef struct _ST_ISR_QUEUE_MEMBERS 
.................... { 
....................     unsigned int8 m_ui8Arr[RS485_RX_BUFF_SIZE]; 
....................     int8 m_i8Front; 
....................     int8 m_i8Rear; 
....................      
.................... }ST_ISR_QUEUE_MEMBERS; 
....................  
.................... ST_ISR_QUEUE_MEMBERS g_stUART2RcvBuffModbus; 
.................... unsigned int8 g_ui8TempByte = 0; 
.................... unsigned int8 g_ui8TempArrForCRCValidation[SIZE_TEMP_ARR_CRC_VALID] = {0}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #define REG_DATA_LO_TO_HI                       1 // 1 = lo byte first, 2 = lo byte last 
....................  
.................... unsigned int8 g_RS485TxBuffer[RS485_TX_BUFF_SIZE] = {0}; 
.................... unsigned int8 g_RS485RxBuffer[RS485_RX_BUFF_SIZE] = {0}; 
.................... unsigned int8 g_ui8RS485RxByteCount               = 0; 
.................... unsigned int8 g_ui8ReceivedModbusResponse         = 0; 
.................... unsigned int8 g_ui8RS485MaxByteCount              = 8; 
.................... unsigned int8 g_ui8RS485Done              		  = 0; 
.................... unsigned int8 g_uiInputOutputMatch				  = 0; 
....................  
.................... unsigned int8 g_ui8Front                          = 0; 
.................... unsigned int8 g_ui8End                            = 0; 
....................  
....................  
....................  
....................  
....................  
.................... // init interept 
.................... void InitRS485RxInterrupt(void) 
.................... { 
....................     // Enable RS485 interrupt. 
....................     //clear_interrupt(INT_RDA); 
.................... 	//enable_interrupts(INT_RDA); 
....................      
....................     // Initialize Queue 
....................     g_stUART2RcvBuffModbus.m_i8Front = g_stUART2RcvBuffModbus.m_i8Rear = -1; 
....................     memset(g_stUART2RcvBuffModbus.m_ui8Arr, 0, RS485_RX_BUFF_SIZE); 
....................  
....................     clear_interrupt(INT_RDA2); 
.................... 	enable_interrupts(INT_RDA2); 
.................... } 
....................  
.................... void Delay_milisecond(unsigned int16 ui16DelayTime) 
.................... { 
.................... 	unsigned int16 ui16Counter = 0; 
.................... 	while(ui16Counter < ui16DelayTime) 
.................... 	{ 
.................... 		delay_ms(1); 
.................... 		ui16Counter++; 
.................... 	} 
.................... } 
....................  
.................... // reset buffer 
.................... void ResetRS485RxBuffer(void) 
.................... { 
....................     // Reset Rx Byte count. 
....................   //  g_ui8RS485RxByteCount       = 0; 
....................     // Set 0 to Rx Buffer. 
....................  //   memset(g_RS485RxBuffer, 0, RS485_RX_BUFF_SIZE); 
....................     g_ui8ReceivedModbusResponse--; 
....................     if(g_ui8ReceivedModbusResponse < 0) 
....................     { 
....................         g_ui8ReceivedModbusResponse = 0; 
....................     } 
....................     g_ui8RS485MaxByteCount = 8; 
....................      
....................     if((g_ui8Front == g_ui8End) && (g_ui8Front!=0)) 
....................     { 
....................         g_ui8Front = 0; 
....................         g_ui8End = 0; 
....................         g_ui8RS485RxByteCount = 0; 
....................     } 
....................      
....................     // Check if Rx Byte count is equal to the Rx Buffer capacity. 
....................     if(g_ui8RS485RxByteCount >= RS485_RX_BUFF_SIZE - 15) //g_ui8RS485MaxByteCount) 
....................     { 
....................         // Reset Rx Byte count to prevent buffer overflow. 
....................     //    g_ui8Front = 0; 
....................         g_ui8End = 0; 
....................         g_ui8RS485RxByteCount = g_ui8End;  
....................     } 
....................  
....................     // Reset holding buffer 
....................     g_ui8RS485Done = 0; 
....................    	clear_interrupt(INT_RDA2); 
.................... } 
....................  
.................... void SetHILowRS485() 
.................... {	 
....................   	//set transmit active. 
.................... 	output_bit(PIN_RS485_RTS,1); 
.................... 	delay_ms(4); 
.................... 	 
.................... 	//set transmit inactive. 
.................... 	output_bit(PIN_RS485_RTS,0); 
.................... 	delay_ms(4); 
.................... } 
....................  
.................... void TestPollRS485( 
....................                    unsigned int8 ui8SlaveID,  
....................                    unsigned int8 ui8FunctionType,  
....................                    unsigned int16 ui16StartAddress, 
....................                    unsigned int16 ui16RegisterData) 
.................... { 
.................... 	// function for send data to server/master 
.................... 	unsigned int16 ui16CRCvalue = 0; 
.................... 	 
.................... 	//value assign in transmit buffer of RS485 
....................   	g_RS485TxBuffer[0]  = ui8SlaveID; 
....................   	g_RS485TxBuffer[1]  = ui8FunctionType; //3;//Function code;read holding register. 3 for read, 6 for write 
....................   	g_RS485TxBuffer[2]  = (unsigned int8)((ui16StartAddress >> 8) & 0xFF); 
....................   	g_RS485TxBuffer[3]  = (unsigned int8)((ui16StartAddress >> 0) & 0xFF); // Address of the register. 
....................  
....................   	g_RS485TxBuffer[4]  = (unsigned int8)((ui16RegisterData >> 8) & 0xFF); 
....................   	g_RS485TxBuffer[5]  = (unsigned int8)((ui16RegisterData >> 0) & 0xFF); 
....................    	g_RS485TxBuffer[6]  = 0; 
....................   	g_RS485TxBuffer[7]  = 0; 
....................   	 
.................... 	//Calculate CRC values using function call.  
....................   	ui16CRCvalue = calculateCrc(g_RS485TxBuffer,6);  
....................   	 
.................... 	//assign CRC values in transmit buffer. 
....................   	g_RS485TxBuffer[6]  = (unsigned int8)((ui16CRCvalue >> 0) & 0xFF); 
....................   	g_RS485TxBuffer[7]  = (unsigned int8)((ui16CRCvalue >> 8) & 0xFF); 
....................   	 
....................   	//set transmit active. 
....................   	delay_ms(DELAY_TIME_RTS_BEFORE); 
.................... 	output_bit(PIN_RS485_RTS,1); 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... 	//send bytes. 
.................... 	for(unsigned int8 ui8SendBytes = 0; ui8SendBytes<8; ui8SendBytes++) 
.................... 	{ 
.................... 		fputc(g_RS485TxBuffer[ui8SendBytes],RS485); 
.................... 	} 
.................... 	//hold to bytes properly transmit. 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... 	//set transmit inactive. 
.................... 	output_bit(PIN_RS485_RTS,0); 
.................... //	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... } 
....................  
.................... // wirte to register 
.................... void WriteToOneRegRS485( 
....................                         unsigned int8 ui8SlaveID,  
....................                         unsigned int8 ui8FunctionType,  
....................                         unsigned int8 ui8Len, 
....................                         unsigned int16 ui16RegisterData) 
.................... { 
.................... 	unsigned int16 ui16CRCvalue = 0; 
.................... 	 
.................... 	//value assign in transmit buffer of RS485 
....................   	g_RS485TxBuffer[0]  = ui8SlaveID;  //37; 
....................   	g_RS485TxBuffer[1]  = ui8FunctionType;  //3; 
....................   	g_RS485TxBuffer[2]  = ui8Len;  //2; 
....................  
....................   	g_RS485TxBuffer[3]  = (unsigned int8)((ui16RegisterData >> 8) & 0xFF); 
....................   	g_RS485TxBuffer[4]  = (unsigned int8)((ui16RegisterData >> 0) & 0xFF); 
....................   	g_RS485TxBuffer[5]  = 0; 
....................    	g_RS485TxBuffer[6]  = 0; 
....................   	g_RS485TxBuffer[7]  = 0; 
....................   	 
.................... 	//Calculate CRC values using function call.  
....................   	ui16CRCvalue = calculateCrc(g_RS485TxBuffer,5);  
....................   	 
.................... 	//assign CRC values in transmit buffer. 
....................   	g_RS485TxBuffer[5]  = (unsigned int8)((ui16CRCvalue >> 0) & 0xFF); 
....................   	g_RS485TxBuffer[6]  = (unsigned int8)((ui16CRCvalue >> 8) & 0xFF); 
....................   	 
....................   	//set transmit active. 
....................   	delay_ms(DELAY_TIME_RTS_BEFORE); 
.................... 	output_bit(PIN_RS485_RTS,1); 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... 	//send bytes. 
.................... 	for(unsigned int8 ui8SendBytes = 0; ui8SendBytes<7; ui8SendBytes++) 
.................... 	{ 
.................... 		fputc(g_RS485TxBuffer[ui8SendBytes],RS485); 
.................... 	} 
.................... 	//hold to bytes properly transmit. 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... 	//set transmit inactive. 
.................... 	output_bit(PIN_RS485_RTS,0); 
.................... //	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... } 
....................  
.................... // write to a register 
.................... void WriteToTwoRegRS485( 
....................                         unsigned int8 ui8SlaveID,  
....................                         unsigned int8 ui8FunctionType,  
....................                         unsigned int8 ui8Len, 
....................                         unsigned int16 ui16RegisterData1,  
....................                         unsigned int16 ui16RegisterData2) 
.................... { 
.................... 	unsigned int16 ui16CRCvalue = 0; 
.................... 	 
.................... 	//value assign in transmit buffer of RS485 
....................   	g_RS485TxBuffer[0]  = ui8SlaveID; 
....................   	g_RS485TxBuffer[1]  = ui8FunctionType; 
....................   	g_RS485TxBuffer[2]  = ui8Len; 
....................  
....................   	g_RS485TxBuffer[3]  = (unsigned int8)((ui16RegisterData1 >> 8) & 0xFF); 
....................   	g_RS485TxBuffer[4]  = (unsigned int8)((ui16RegisterData1 >> 0) & 0xFF); 
....................   	 
....................   	g_RS485TxBuffer[5]  = (unsigned int8)((ui16RegisterData2 >> 8) & 0xFF); 
....................   	g_RS485TxBuffer[6]  = (unsigned int8)((ui16RegisterData2 >> 0) & 0xFF); 
....................  
....................    	g_RS485TxBuffer[7]  = 0; 
....................   	g_RS485TxBuffer[8]  = 0; 
....................   	 
.................... 	//Calculate CRC values using function call.  
....................   	ui16CRCvalue        = calculateCrc(g_RS485TxBuffer,7);  
....................   	 
.................... 	//assign CRC values in transmit buffer. 
....................   	g_RS485TxBuffer[7]  = (unsigned int8)((ui16CRCvalue >> 0) & 0xFF); 
....................   	g_RS485TxBuffer[8]  = (unsigned int8)((ui16CRCvalue >> 8) & 0xFF); 
....................   	 
....................   	//set transmit active. 
....................   	delay_ms(DELAY_TIME_RTS_BEFORE); 
.................... 	output_bit(PIN_RS485_RTS,1); 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... 	//send bytes. 
.................... 	for(unsigned int8 ui8SendBytes = 0; ui8SendBytes<9; ui8SendBytes++) 
.................... 	{ 
.................... 		fputc(g_RS485TxBuffer[ui8SendBytes],RS485); 
.................... 	} 
.................... 	//hold to bytes properly transmit. 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... 	//set transmit inactive. 
.................... 	output_bit(PIN_RS485_RTS,0); 
.................... //	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... } 
....................  
.................... // write to a register 
.................... void WriteToThreeRegRS485( 
....................     unsigned int8  ui8SlaveID, 
....................     unsigned int8  ui8FunctionType, 
....................     unsigned int8  ui8Len, 
....................     unsigned int16 ui16RegisterData1, 
....................     unsigned int16 ui16RegisterData2, 
....................     unsigned int16 ui16RegisterData3) 
.................... { 
.................... 	unsigned int16 ui16CRCvalue = 0; 
.................... 	 
.................... 	//value assign in transmit buffer of RS485 
....................   	g_RS485TxBuffer[0]  = ui8SlaveID; 
....................   	g_RS485TxBuffer[1]  = ui8FunctionType; 
....................   	g_RS485TxBuffer[2]  = ui8Len; 
....................  
....................   	g_RS485TxBuffer[3]  = (unsigned int8)((ui16RegisterData1 >> 8) & 0x00FF); 
....................   	g_RS485TxBuffer[4]  = (unsigned int8)((ui16RegisterData1 >> 0) & 0x00FF); 
....................   	 
....................   	g_RS485TxBuffer[5]  = (unsigned int8)((ui16RegisterData2 >> 8) & 0x00FF); 
....................   	g_RS485TxBuffer[6]  = (unsigned int8)((ui16RegisterData2 >> 0) & 0x00FF); 
....................  
....................    	g_RS485TxBuffer[7]  = (unsigned int8)((ui16RegisterData3 >> 8) & 0x00FF); 
....................   	g_RS485TxBuffer[8]  = (unsigned int8)((ui16RegisterData3 >> 0) & 0x00FF); 
....................   	 
.................... 	//Calculate CRC values using function call.  
....................   	ui16CRCvalue        = calculateCrc(g_RS485TxBuffer,9);  
....................   	 
.................... 	//assign CRC values in transmit buffer. 
....................   	g_RS485TxBuffer[9]   = (unsigned int8)((ui16CRCvalue >> 0) & 0x00FF); 
....................   	g_RS485TxBuffer[10]  = (unsigned int8)((ui16CRCvalue >> 8) & 0x00FF); 
....................   	 
....................   	//set transmit active. 
....................   	delay_ms(DELAY_TIME_RTS_BEFORE); 
.................... 	output_bit(PIN_RS485_RTS,1); 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
....................     delay_ms(3); 
.................... 	//send bytes. 
.................... 	for(unsigned int8 ui8SendBytes = 0; ui8SendBytes<11; ui8SendBytes++) 
.................... 	{ 
.................... 		fputc(g_RS485TxBuffer[ui8SendBytes],RS485); 
.................... 	} 
.................... 	//hold to bytes properly transmit. 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... 	//set transmit inactive. 
.................... 	output_bit(PIN_RS485_RTS,0); 
.................... //	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... } 
....................  
.................... // write to a register 
.................... void ReplyForTwoRegister( 
....................                         unsigned int8 ui8SlaveID,  
....................                         unsigned int8 ui8FunctionType,  
....................                         unsigned int8 ui8Len, 
....................                         unsigned int16 ui16RegisterAddress,  
....................                         unsigned int16 ui16RegisterData1,  
....................                         unsigned int16 ui16RegisterData2) 
.................... { 
.................... 	unsigned int16 ui16CRCvalue = 0; 
.................... 	 
.................... 	//value assign in transmit buffer of RS485 
....................   	g_RS485TxBuffer[0]  = ui8SlaveID; 
....................   	g_RS485TxBuffer[1]  = ui8FunctionType; 
....................   	g_RS485TxBuffer[2]  = (unsigned int8)((ui16RegisterAddress >> 8) & 0xFF); 
....................   	g_RS485TxBuffer[3]  = (unsigned int8)((ui16RegisterAddress >> 0) & 0xFF); 
....................   	g_RS485TxBuffer[4]  = (unsigned int8)((ui8Len >> 8) & 0xFF); 
....................   	g_RS485TxBuffer[5]  = (unsigned int8)((ui8Len >> 0) & 0xFF); 
....................      
....................   	g_RS485TxBuffer[6]  = 2 * ui8Len; 
....................  
....................   	g_RS485TxBuffer[7]  = (unsigned int8)((ui16RegisterData1 >> 8) & 0xFF); 
....................   	g_RS485TxBuffer[8]  = (unsigned int8)((ui16RegisterData1 >> 0) & 0xFF); 
....................   	 
....................   	g_RS485TxBuffer[9]  = (unsigned int8)((ui16RegisterData2 >> 8) & 0xFF); 
....................   	g_RS485TxBuffer[10]  = (unsigned int8)((ui16RegisterData2 >> 0) & 0xFF); 
....................  
....................    	g_RS485TxBuffer[11]  = 0; 
....................   	g_RS485TxBuffer[12]  = 0; 
....................   	 
.................... 	//Calculate CRC values using function call.  
....................   	ui16CRCvalue        = calculateCrc(g_RS485TxBuffer,11);  
....................   	 
.................... 	//assign CRC values in transmit buffer. 
....................   	g_RS485TxBuffer[11]  = (unsigned int8)((ui16CRCvalue >> 0) & 0xFF); 
....................   	g_RS485TxBuffer[12]  = (unsigned int8)((ui16CRCvalue >> 8) & 0xFF); 
....................   	 
....................   	//set transmit active. 
....................   	delay_ms(DELAY_TIME_RTS_BEFORE); 
.................... 	output_bit(PIN_RS485_RTS,1); 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... 	//send bytes. 
.................... 	for(unsigned int8 ui8SendBytes = 0; ui8SendBytes<13; ui8SendBytes++) 
.................... 	{ 
.................... 		fputc(g_RS485TxBuffer[ui8SendBytes],RS485); 
.................... 	} 
.................... 	//hold to bytes properly transmit. 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... 	//set transmit inactive. 
.................... 	output_bit(PIN_RS485_RTS,0); 
.................... //	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... } 
....................  
.................... // is bit is on a data 
.................... int8 IsBitOn(int8 uiBitIndex, int16 u16RegData) 
.................... { 
.................... 	int8 uiRetVal   = 1; 
.................... 	int8 uiMaxBits  = 15; 
.................... 	 
.................... 	int16 u16Data   = u16RegData << (uiMaxBits-uiBitIndex); 
.................... 	 
.................... 	u16Data         = u16Data >> uiMaxBits; 
.................... 	 
.................... 	if(u16Data == 1)  
.................... 		uiRetVal = 0; 
.................... 	else  
.................... 		uiRetVal = 1;	 
.................... 	return uiRetVal; 
.................... } 
....................  
.................... // set bit on in a data 
.................... int32 SetBitOn(int8 uiBitIndex, int32 u32RegData) 
.................... { 
.................... 	int32 uiRetVal = u32RegData; 
.................... 	int8 uiMaxBits = 31; 
.................... 	 
.................... 	if(uiBitIndex > uiMaxBits)  
....................     { 
.................... 		return uiRetVal; 
.................... 	} 
.................... 	uiRetVal = uiRetVal | (1 << uiBitIndex); 
.................... 	 
.................... 	return uiRetVal; 
.................... } 
....................  
.................... // dlear a bit from data 
.................... int32 ClearBitOn(int8 uiBitIndex, int32 u32RegData) 
.................... { 
.................... 	int32 uiRetVal = u32RegData; 
.................... 	int8 uiMaxBits = 31; 
.................... 	 
.................... 	if(uiBitIndex > uiMaxBits) { 
.................... 		return uiRetVal; 
.................... 	} 
.................... 	uiRetVal = uiRetVal & ~(1 << uiBitIndex); 
.................... 	 
.................... 	return uiRetVal; 
.................... } 
....................  
.................... // toggle bit on 
.................... int32 ToggleBitOn(int8 uiBitIndex, int32 u32RegData) 
.................... { 
.................... 	int32 uiRetVal = u32RegData; 
.................... 	int8 uiMaxBits = 31; 
.................... 	 
.................... 	if(uiBitIndex > uiMaxBits) { 
.................... 		return uiRetVal; 
.................... 	} 
.................... 	uiRetVal = uiRetVal ^ (1 << uiBitIndex); 
.................... 	 
.................... 	return uiRetVal; 
.................... } 
....................  
.................... //// wait for movement completion 
.................... //int8 WaitForMovementCompletion() 
.................... //{ 
.................... //	int8 uiRetVal = 0; 
.................... //	if((SLAVE_ID != SLAVE_ID_FOR_LA_1) && (SLAVE_ID != SLAVE_ID_FOR_LA_2)) 
.................... //	{ 
.................... //		return; 
.................... //	} 
.................... //		 
.................... //	delay_ms(1000); 
.................... //	int8 uiDIVal7   = 1; 
.................... //	 
.................... //	int8 uiIndex    = 0; 
.................... //	 
.................... //	while(1) 
.................... //	{ 
.................... //		uiIndex++; 
.................... //		uiDIVal7 = input(PIN_IN_DI_06);  
.................... //		if(uiDIVal7 == 0) 
.................... //		{ 
.................... //			uiRetVal = 1; 
.................... //			break; 
.................... //		} 
.................... //		if(uiIndex == 100)  
.................... //		{ 
.................... //			break; 
.................... //		} 
.................... //	} 
.................... //	 
.................... //	// if ok then return 1 
.................... //	return uiRetVal; 
.................... //} 
....................  
....................  
.................... void PollRS485( 
....................                 unsigned int8 uiFunctionCode,  
....................                 unsigned int16 ui16StartAddress,  
....................                 unsigned int16 ui16FirstRegisterData,  
....................                 unsigned int16 ui16SecondregisterData) 
.................... { 
.................... 	// function for polling data 
.................... 	unsigned int16 ui16CRCvalue = 0; 
.................... 	 
.................... 	//Reset the receiver buffer. 
.................... 	ResetRS485RxBuffer(); 
.................... 	 
.................... 	g_RS485TxBuffer[0]  = SLAVE_ID; 
.................... 	g_RS485TxBuffer[1]  = uiFunctionCode;// Function code. 
.................... 	g_RS485TxBuffer[2]  = ((ui16StartAddress >> 8)& 0xFF); 
.................... 	g_RS485TxBuffer[3]  = ((ui16StartAddress >> 0)& 0xFF); 
.................... 	g_RS485TxBuffer[4]  = 0x00; 
.................... 	g_RS485TxBuffer[5]  = 0x02;// Number of registers to write. 
.................... 	g_RS485TxBuffer[6]  = 0x04;// Number of bytes to write.  
.................... 	g_RS485TxBuffer[7]  = (unsigned int8)((ui16FirstRegisterData >> 8)& 0xFF); 
.................... 	g_RS485TxBuffer[8]  = (unsigned int8)((ui16FirstRegisterData >> 0)& 0xFF);// Data of the first register. 
.................... 	g_RS485TxBuffer[9]  = (unsigned int8)((ui16SecondregisterData >> 8)& 0xFF); 
.................... 	g_RS485TxBuffer[10] = (unsigned int8)((ui16SecondregisterData >> 0)& 0xFF);// Data of the second register.  
.................... 	g_RS485TxBuffer[11] = 0; 
.................... 	g_RS485TxBuffer[12] = 0; 
.................... 	 
.................... 	//Function call CRC calculation. 
.................... 	ui16CRCvalue = ModbusCRC16(g_RS485TxBuffer,11); 
.................... 	 
.................... 	g_RS485TxBuffer[11] = (unsigned int8)((ui16CRCvalue >> 0)& 0xFF); 
.................... 	g_RS485TxBuffer[12] = (unsigned int8)((ui16CRCvalue >> 8)& 0xFF); 
....................  
.................... 	//set transmit active. 
.................... 	delay_ms(2); 
.................... 	output_bit(PIN_RS485_RTS,1); 
.................... 	delay_ms(3); 
.................... 	//send bytes. 
.................... 	for(unsigned int8 ui8SendBytes = 0; ui8SendBytes<13; ui8SendBytes++) 
.................... 	{ 
.................... 		fputc(g_RS485TxBuffer[ui8SendBytes],RS485); 
.................... 	} 
.................... 	//hold to bytes properly transmit. 
.................... 	delay_ms(3); 
.................... 	//set transmit inactive. 
.................... 	output_bit(PIN_RS485_RTS,0); 
.................... 	delay_ms(3); 
.................... } 
....................  
.................... ////=============================== START NEW CODE ====================================================== 
.................... #INT_RDA2 
.................... void RS485_RxByteReady_ISR2(void) 
.................... { 
....................      
....................     // Checking for Is ISR ready flag. 
....................     if(ISR_IS_NOT_READY == g_fIsReadyToReceiveByte) 
....................     { 
....................         g_fIsReadyToReceiveByte = ISR_IS_READY; 
....................     } 
....................      
....................     g_ui8TempByte = fgetc(RS485); 
....................      
....................     // Checking queue boundary conditions. 
....................     if(g_stUART2RcvBuffModbus.m_i8Front == -1 && g_stUART2RcvBuffModbus.m_i8Rear == -1) 
....................     { 
....................         // Initialize queue front and rear. 
....................         g_stUART2RcvBuffModbus.m_i8Front = g_stUART2RcvBuffModbus.m_i8Rear = 0; 
....................          
....................         // Inserting first element. 
....................         g_stUART2RcvBuffModbus.m_ui8Arr[g_stUART2RcvBuffModbus.m_i8Rear] = g_ui8TempByte; 
....................     }  
....................     else if((RS485_RX_BUFF_SIZE - 1) == g_stUART2RcvBuffModbus.m_i8Rear && g_stUART2RcvBuffModbus.m_i8Front > 0) 
....................     { 
....................         // Rear reached last position..initialize it. 
....................         g_stUART2RcvBuffModbus.m_i8Rear = 0; 
....................         // Then insert data. 
....................         g_stUART2RcvBuffModbus.m_ui8Arr[g_stUART2RcvBuffModbus.m_i8Rear] = g_ui8TempByte; 
....................     } 
....................     else if(((RS485_RX_BUFF_SIZE - 1) == g_stUART2RcvBuffModbus.m_i8Rear && g_stUART2RcvBuffModbus.m_i8Front == 0) || 
....................             (g_stUART2RcvBuffModbus.m_i8Rear == g_stUART2RcvBuffModbus.m_i8Front - 1)) 
....................     { 
....................         // Queue is full 
....................         //TODO Handle This 
....................     } 
....................     else  
....................     { 
....................         g_stUART2RcvBuffModbus.m_i8Rear++; 
....................         g_stUART2RcvBuffModbus.m_ui8Arr[g_stUART2RcvBuffModbus.m_i8Rear] = g_ui8TempByte; 
....................     } 
....................      
.................... 	// Clear interrupt. 
.................... 	clear_interrupt(INT_RDA2); 
.................... } 
....................  
.................... BYTE GetUART2Queue(BYTE* pbIsQueueEmpty ) 
.................... { 
....................     BYTE bData = 0; 
....................      
....................     *pbIsQueueEmpty = MSG_QUEUE_NOT_EMPTY; 
....................  
....................     if (-1 == g_stUART2RcvBuffModbus.m_i8Front) 
....................     { 
....................         // Queue is empty 
....................         *pbIsQueueEmpty = MSG_QUEUE_EMPTY; 
....................         return 0; 
....................     } 
....................      
....................     bData = g_stUART2RcvBuffModbus.m_ui8Arr[g_stUART2RcvBuffModbus.m_i8Front]; 
....................     g_stUART2RcvBuffModbus.m_ui8Arr[g_stUART2RcvBuffModbus.m_i8Front] = 0;  // Fill the Queue by 0 
....................      
....................     if (g_stUART2RcvBuffModbus.m_i8Front == g_stUART2RcvBuffModbus.m_i8Rear) 
....................     { 
....................         g_stUART2RcvBuffModbus.m_i8Front = g_stUART2RcvBuffModbus.m_i8Rear = -1; 
....................     } 
....................     else if ((RS485_RX_BUFF_SIZE - 1) == g_stUART2RcvBuffModbus.m_i8Front) 
....................     { 
....................         g_stUART2RcvBuffModbus.m_i8Front = 0; 
....................     } 
....................     else 
....................     { 
....................         g_stUART2RcvBuffModbus.m_i8Front++; 
....................     } 
....................      
....................     // Return Data 
....................     return bData; 
.................... } 
....................  
.................... int8 GetQueueLength() 
.................... { 
....................     // Check if Front is less then rear, Normal case 
....................     if (g_stUART2RcvBuffModbus.m_i8Front < g_stUART2RcvBuffModbus.m_i8Rear) 
....................     { 
....................         return (g_stUART2RcvBuffModbus.m_i8Rear - g_stUART2RcvBuffModbus.m_i8Front + 1); 
....................     } 
....................     // Else if the Rear precedes front 
....................     else if (g_stUART2RcvBuffModbus.m_i8Front > g_stUART2RcvBuffModbus.m_i8Rear) 
....................     { 
....................         return ((RS485_RX_BUFF_SIZE - g_stUART2RcvBuffModbus.m_i8Front) + 
....................                 g_stUART2RcvBuffModbus.m_i8Rear + 1); 
....................          
....................     } 
....................     // If the queue is empty 
....................     return 0; 
.................... } 
....................  
.................... void EmptyQueue() 
.................... { 
....................     g_stUART2RcvBuffModbus.m_i8Front = g_stUART2RcvBuffModbus.m_i8Rear = -1; 
.................... } 
....................  
.................... unsigned int8 CheckValidityForReadReg(void) 
.................... { 
....................     unsigned int16 ui16CRCValue       = 0; 
....................     BYTE           bIsQueueEmpty      = MSG_QUEUE_NOT_EMPTY; 
....................     BYTE           bTemp              = 0; 
....................     unsigned int8  ui8IsValidResponse = 0; 
....................     int8           i8LoopCount        = 0; 
....................     int8           i8TempFront        = g_stUART2RcvBuffModbus.m_i8Front; 
....................      
....................     // Step 1: Populate the Message in a temporary array 
....................     g_ui8TempArrForCRCValidation[0] = SLAVE_ID; 
....................     for(i8LoopCount = 1; i8LoopCount != MODBUS_MASTER_QUERY_READ_REG_LENGTH - 2; i8LoopCount++) 
....................     { 
....................         g_ui8TempArrForCRCValidation[i8LoopCount] = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront++]; 
....................     } 
....................      
....................     // Calculate CRC value with received bytes for validation. 
....................     ui16CRCValue = calculateCrc(g_ui8TempArrForCRCValidation, MODBUS_MASTER_QUERY_READ_REG_LENGTH - 2); 
....................      
....................     // Match with received first CRC byte 
....................     bTemp = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront++]; 
....................     if(bTemp == (unsigned int8)((ui16CRCValue >> 0) & 0xFF)) 
....................     { 
....................         // Match with received second CRC byte. 
....................         bTemp = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront]; 
....................         if(bTemp == (unsigned int8)((ui16CRCValue >> 8) & 0xFF)) 
....................         { 
....................             // Update flag denote CRC bytes matched..valid response. 
....................             ui8IsValidResponse = 1; 
....................         } 
....................     } 
....................      
....................     return ui8IsValidResponse; 
.................... } 
....................  
.................... // send response 
.................... void SendRS485Response() 
.................... { 
.................... 	// function for sending reply 
.................... 	 
.................... 	//value assign in transmit buffer of RS485 
....................     int8 i8TempFront             = 0; 
....................     BYTE ui8Temp                 = 0; 
....................     int8 i8TempLen               = 0;   
....................     int8 i8IndexTx               = 0;   
....................              
....................     i8TempFront = g_stUART2RcvBuffModbus.m_i8Front;     
....................     ui8Temp     = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront];  // g_ui8TempArrForCRCValidation 
....................     i8TempLen   = GetQueueLength(); 
....................      
....................     g_RS485TxBuffer[i8IndexTx] = SLAVE_ID; 
....................     i8IndexTx++; 
.................... 	for(int8 i8Index = i8TempFront; i8Index <= i8TempLen; i8Index++) 
.................... 	{ 
.................... 		g_RS485TxBuffer[i8IndexTx]= g_stUART2RcvBuffModbus.m_ui8Arr[i8Index];  
....................         i8IndexTx++; 
.................... 	} 
.................... 	 
....................   	//set transmit active. 
....................   	delay_ms(DELAY_TIME_RTS_BEFORE); 
.................... 	output_bit(PIN_RS485_RTS,1); 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... 	 
.................... 	//send bytes. 
.................... 	for(unsigned int8 ui8SendBytes = 0; ui8SendBytes <= i8TempLen; ui8SendBytes++) // g_ui8RS485MaxByteCount 
.................... 	{ 
.................... 		fputc(g_RS485TxBuffer[ui8SendBytes],RS485); 
.................... 	} 
.................... 	 
.................... 	//hold to bytes properly transmit. 
.................... 	 
.................... 	//set transmit inactive. 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... 	output_bit(PIN_RS485_RTS,0); 
.................... //	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... } 
....................  
.................... // send response 
.................... void SendRS485ResponseForMultipleRegWrite() 
.................... { 
.................... 	// function for sending reply 
.................... 	 
.................... 	//value assign in transmit buffer of RS485 
....................     int8 i8TempFront             = 0; 
....................     BYTE ui8Temp                 = 0; 
....................     int8 i8TempLen               = 0;   
....................     int8 i8IndexTx               = 0;   
....................             	// function for polling data 
.................... 	unsigned int16 ui16CRCvalue = 0; 
....................      
....................     i8TempFront = g_stUART2RcvBuffModbus.m_i8Front;     
....................     ui8Temp     = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront];  // g_ui8TempArrForCRCValidation 
....................     i8TempLen   = 6; 
....................      
....................     g_RS485TxBuffer[i8IndexTx] = SLAVE_ID; 
....................     i8IndexTx++; 
.................... 	for(int8 i8Index = i8TempFront; i8IndexTx < i8TempLen; i8Index++) 
.................... 	{ 
.................... 		g_RS485TxBuffer[i8IndexTx]= g_stUART2RcvBuffModbus.m_ui8Arr[i8Index];  
....................         i8IndexTx++; 
.................... 	} 
.................... 	 
....................     	//Function call CRC calculation. 
.................... 	ui16CRCvalue = ModbusCRC16(g_RS485TxBuffer,6); 
.................... 	 
.................... 	g_RS485TxBuffer[6] = (unsigned int8)((ui16CRCvalue >> 0)& 0xFF); 
.................... 	g_RS485TxBuffer[7] = (unsigned int8)((ui16CRCvalue >> 8)& 0xFF); 
....................  
....................   	//set transmit active. 
....................   	delay_ms(DELAY_TIME_RTS_BEFORE); 
.................... 	output_bit(PIN_RS485_RTS,1); 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... 	 
.................... 	//send bytes. 
.................... 	for(unsigned int8 ui8SendBytes = 0; ui8SendBytes <= 7; ui8SendBytes++) // g_ui8RS485MaxByteCount 
.................... 	{ 
.................... 		fputc(g_RS485TxBuffer[ui8SendBytes],RS485); 
.................... 	} 
.................... 	 
.................... 	//hold to bytes properly transmit. 
.................... 	 
.................... 	//set transmit inactive. 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... 	output_bit(PIN_RS485_RTS,0); 
.................... //	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... } 
....................  
.................... void MakeData(void) 
.................... { 
.................... 	//value assign in transmit buffer of RS485 
....................     int8 i8TempFront             = 0; 
....................     BYTE ui8Temp                 = 0; 
....................     int8 i8TempLen               = 0;   
....................     unsigned int16 ui16Address    = 0; 
....................     unsigned int16 ui16RegData    = 0; 
....................      
....................     g_ModbusRx.ui8Slaveid = SLAVE_ID; 
....................     g_ModbusRx.func = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_ONE]; 
....................              
....................     i8TempFront = g_stUART2RcvBuffModbus.m_i8Front;     
....................     ui8Temp     = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront];  // g_ui8TempArrForCRCValidation 
....................     i8TempLen   = GetQueueLength(); 
....................      
.................... 	int8 i8AddH = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_TWO]; 
.................... 	int8 i8AddL = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_THREE]; 
.................... 	 
....................     g_ModbusRx.u16Address = i8AddH; 
.................... 	g_ModbusRx.u16Address <<= 8; 
.................... 	g_ModbusRx.u16Address += i8AddL; 
.................... 	 
.................... 	int8 i8DataH = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_FOUR]; 
.................... 	int8 i8DataL = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_FIVE]; 
.................... 	 
.................... 	unsigned int16 ui16WriteAddress = ui16Address + 1; 
.................... 	 
.................... 	g_ModbusRx.u16LenData = i8DataH; 
.................... 	g_ModbusRx.u16LenData <<= 8; 
.................... 	g_ModbusRx.u16LenData += i8DataL; 
....................      
....................      
....................     	// prepare data for multiple register or coils 
.................... 	if((g_ModbusRx.func == RS485_FUNCTION_WRITE_MULTIPLE_REGISTERS) || (g_ModbusRx.func == RS485_FUNCTION_READ_MULTIPLE_REGISTERS))  
.................... 	{ 
.................... 		g_ModbusRx.ui8NoRegDataBytes = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_SIX]; 
.................... 		int8 iStartIndx = i8TempFront+7; 
.................... 		int8 iRegIndx = 0; 
.................... 	 
.................... 		for(int i = 0; i < g_ModbusRx.ui8NoRegDataBytes; )  
.................... 		{ 
.................... 			int8 i8DataH = g_stUART2RcvBuffModbus.m_ui8Arr[iStartIndx]; 
.................... 			int8 i8DataL = g_stUART2RcvBuffModbus.m_ui8Arr[iStartIndx+MODBUS_OFFSET_ONE]; 
.................... 	 
.................... 			unsigned int16 u16LenData = i8DataH; 
.................... 			u16LenData <<= 8; 
.................... 			u16LenData += i8DataL; 
.................... 			 
.................... 			g_ModbusRx.ui16RegisterDataArr[iRegIndx] = u16LenData; 
.................... 			 
.................... 			iStartIndx +=2; 
.................... 			iRegIndx++; 
.................... 			i +=2; 
.................... 		} 
.................... 	 
.................... 		unsigned int32 u32RegData = 0; 
.................... 		 
.................... 		if(REG_DATA_LO_TO_HI == 1)  
.................... 		{ 
.................... 			int8 j = iRegIndx-1; 
.................... 			 
.................... 			for(int8 count = 0; count < iRegIndx; count++)  
.................... 			{ 
.................... 				unsigned int16 u16LenData = g_ModbusRx.ui16RegisterDataArr[j]; 
.................... 					 
.................... 				if(j == (iRegIndx-1))  
.................... 				{ 
.................... 					u32RegData = u16LenData; 
.................... 				} 
.................... 				else  
.................... 				{ 
.................... 					u32RegData <<= 16; 
.................... 					u32RegData += u16LenData; 
.................... 				} 
.................... 				j--; 
.................... 			} 
.................... 		} 
.................... 		else  
.................... 		{ 
.................... 			int8 j = 0; 
.................... 			 
.................... 			for(int8 count = 0; count < iRegIndx; count++)  
.................... 			{ 
.................... 				unsigned int16 u16LenData = g_ModbusRx.ui16RegisterDataArr[j]; 
.................... 					 
.................... 				if(j == 0)  
.................... 				{ 
.................... 					u32RegData = u16LenData; 
.................... 				} 
.................... 				else  
.................... 				{ 
.................... 					u32RegData <<= 16; 
.................... 					u32RegData += u16LenData; 
.................... 				} 
.................... 				j++; 
.................... 			} 
.................... 		} 
.................... 		 
.................... 		g_ModbusRx.u32RegData = u32RegData; 
.................... 	} 
.................... 	else  
.................... 	{ 
.................... 		// prepare data for single register or coil 
.................... 		g_ModbusRx.ui8NoRegDataBytes = 0; 
.................... 		if(g_ModbusRx.func == RS485_FUNCTION_WRITE_SINGLE_REGISTER)  
.................... 		{ 
.................... 			g_ModbusRx.ui16RegisterDataArr[0] = g_ModbusRx.u16LenData; 
.................... 			g_ModbusRx.u32RegData = g_ModbusRx.u16LenData; 
.................... 		} 
.................... 	} 
.................... 		         
.................... } 
.................... void ProcessSingleRegister(void) 
.................... { 
.................... 	// function for process single register 
.................... 	 
.................... 	//value assign in transmit buffer of RS485 
....................     int8 i8TempFront              = 0; 
....................     BYTE ui8Temp                  = 0; 
....................     int8 i8TempLen                = 0;   
....................     unsigned int16 ui16Address    = 0; 
....................     unsigned int16 ui16RegData    = 0; 
....................      
....................              
....................     i8TempFront = g_stUART2RcvBuffModbus.m_i8Front;     
....................     ui8Temp     = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront];  // g_ui8TempArrForCRCValidation 
....................     i8TempLen   = GetQueueLength(); 
....................      
.................... 	int8 i8AddH = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_TWO - 1]; 
.................... 	int8 i8AddL = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_THREE - 1]; 
.................... 	 
....................     ui16Address = i8AddH; 
.................... 	ui16Address <<= 8; 
.................... 	ui16Address += i8AddL; 
....................      
.................... 	 
.................... 	int8 i8DataH = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_FOUR -1]; 
.................... 	int8 i8DataL = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_FIVE -1]; 
.................... 	 
.................... 	unsigned int16 ui16WriteAddress = ui16Address + 1; 
.................... 	 
.................... 	ui16RegData = i8DataH; 
.................... 	ui16RegData <<= 8; 
.................... 	ui16RegData += i8DataL; 
.................... 		     
....................     // set led on or off depending on received bytes 
....................     unsigned int8 ui8RetVal1  = IsBitOn(0,ui16RegData); 
....................     unsigned int8 ui8RetVal2  = IsBitOn(1,ui16RegData); 
....................     unsigned int8 ui8RetVal3  = IsBitOn(2,ui16RegData); 
....................     unsigned int8 ui8RetVal4  = IsBitOn(3,ui16RegData); 
....................     unsigned int8 ui8RetVal5  = IsBitOn(4,ui16RegData); 
....................     unsigned int8 ui8RetVal6  = IsBitOn(5,ui16RegData); 
....................     unsigned int8 ui8RetVal7  = IsBitOn(6,ui16RegData); 
....................     unsigned int8 ui8RetVal8  = IsBitOn(7,ui16RegData); 
....................     unsigned int8 ui8RetVal9  = IsBitOn(8,ui16RegData); 
....................     unsigned int8 ui8RetVal10 = IsBitOn(9,ui16RegData); 
....................     unsigned int8 ui8RetVal11 = IsBitOn(10,ui16RegData); 
....................     unsigned int8 ui8RetVal12 = IsBitOn(11,ui16RegData); 
....................     unsigned int8 ui8RetVal13 = IsBitOn(12,ui16RegData); 
....................     unsigned int8 ui8RetVal14 = IsBitOn(13,ui16RegData); 
....................     unsigned int8 ui8RetVal15 = IsBitOn(14,ui16RegData); 
....................     unsigned int8 ui8RetVal16 = IsBitOn(15,ui16RegData); 
....................      
....................     // Set Mode  
....................     switch(ui16Address) 
....................     { 
....................         case MODE_ADDRESS: 
....................         { 
....................             switch(ui16RegData) 
....................             { 
....................                 case MODE_TYPE_NOTHING: 
....................                 { 
....................                     SetModeNothing(); 
....................                    // output_bit(PIN_OUT_DO_00,0); 
....................                 } 
....................                 break; 
....................                 case MODE_TYPE_HOME: 
....................                 { 
....................                     SetModeHome(); 
....................                  //   output_bit(PIN_OUT_DO_01,0); 
....................                 } 
....................                 break; 
....................                 case MODE_TYPE_PRE_PRODUCTION: 
....................                 { 
....................                     SetModePreProduction(); 
....................                 //    output_bit(PIN_OUT_DO_02,0); 
....................                 } 
....................                 break; 
....................                 case MODE_TYPE_PRODUCTION: 
....................                 { 
....................                     SetModeProduction(); 
....................                 //    output_bit(PIN_OUT_DO_03,0); 
....................                 } 
....................                 break; 
....................                 case MODE_TYPE_CONFIGURATION:  
....................                 { 
....................                     SetModeConfiguration(); 
....................                 //    output_bit(PIN_OUT_DO_04,0); 
....................                 } 
....................                 break; 
....................                 case MODE_TYPE_CALIBRATION: 
....................                 { 
....................                     SetModeCalibration(); 
....................                 //    output_bit(PIN_OUT_DO_05,0); 
....................                 } 
....................                 break; 
....................             }; 
....................         } 
....................         break; 
....................         case ADDRESS_FOR_SET_CONFIG_AVG_WT: 
....................         { 
....................             g_ui16RegisterAvgWeight = ui16RegData; 
....................         } 
....................         break; 
....................         case ADDRESS_FOR_SET_CONFIG_TOL_PV: 
....................         { 
....................             g_ui16RegisterTolPv = ui16RegData; 
....................         } 
....................         break; 
....................         case ADDRESS_FOR_SET_CONFIG_TOL_NV: 
....................         { 
....................             g_ui16RegisterTolNv = ui16RegData; 
....................         } 
....................         break; 
....................         case ADDRESS_FOR_SET_CONFIG_INDEX: 
....................         { 
....................             g_ui16RegisterCurrProductIndex = ui16RegData; 
....................         } 
....................         break; 
....................  
....................     }; 
.................... } 
....................  
.................... void ProcessUART2ReceivedData(void) 
.................... { 
....................     BYTE ui8Temp                 = 0; 
....................     BYTE bIsQueueEmpty           = MSG_QUEUE_NOT_EMPTY; 
....................     BYTE bIsValidMSG             = FALSE; 
....................     int8 i8TempFront             = 0; 
....................     int8 i8MainProcessLoopStatue = 0; 
....................     int8 i8TempLen               = 0;   
....................      
....................      
....................     do 
....................     { 
....................         // Step 1: Seek for Slave ID 
....................         do 
....................         { 
....................             // Get Queue 
....................             ui8Temp = GetUART2Queue(&bIsQueueEmpty); 
....................             if (MSG_QUEUE_EMPTY == bIsQueueEmpty) 
....................             { 
....................                 // Return 
....................                 break;    // Handle this break 
....................             } 
....................  
....................             // Check for Slave ID 
....................  
....................         } while (SLAVE_ID != ui8Temp); // If Slave ID not matched then continue 
....................  
....................         // Handle Break 
....................         if (MSG_QUEUE_EMPTY == bIsQueueEmpty) 
....................         { 
....................             // Nothing to return 
....................             // This may be the Slave ID is not matched, So might be this is for other board 
....................             // So nothing to process 
....................             break; 
....................         } 
....................          
....................         // Step 2: Now Check for minimum length (Which is 8 for now, but it could go upto 12) 
....................         i8TempLen = GetQueueLength(); 
....................         if (MODBUS_MASTER_QUERY_LENGTH_MIN > (i8TempLen + 1))  // +1 is just due to we have deleted one from queue 
....................         { 
....................             // Empty the message buffer queue 
....................             EmptyQueue(); 
....................              
....................             // Break from ProcessUART2ReceivedData function 
....................             break; 
....................         } 
....................          
....................         // We have available message in queue 
....................          
....................         // Should insert slave ID in temp buffer for CRC check. 
....................          
....................         // Slave ID Matched 
....................         // Step 3: Look for the Function Code 
....................         i8TempFront = g_stUART2RcvBuffModbus.m_i8Front; 
....................         ui8Temp = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront];  // g_ui8TempArrForCRCValidation 
....................              
....................          
.................... 	//value assign in transmit buffer of RS485 
....................         int8 i8TempLen                = 0;   
....................         unsigned int16 ui16Address    = 0; 
....................         unsigned int16 ui16RegData    = 0; 
....................  
....................  
....................         i8TempFront = g_stUART2RcvBuffModbus.m_i8Front;     
....................         ui8Temp     = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront];  // g_ui8TempArrForCRCValidation 
....................         i8TempLen   = GetQueueLength(); 
....................  
....................         int8 i8AddH = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_TWO - 1]; 
....................         int8 i8AddL = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_THREE - 1]; 
....................  
....................         ui16Address = i8AddH; 
....................         ui16Address <<= 8; 
....................         ui16Address += i8AddL; 
....................  
....................  
....................         int8 i8DataH = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_FOUR -1]; 
....................         int8 i8DataL = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_FIVE -1]; 
....................  
....................         unsigned int16 ui16WriteAddress = ui16Address + 1; 
....................  
....................         ui16RegData = i8DataH; 
....................         ui16RegData <<= 8; 
....................         ui16RegData += i8DataL;         
....................          
....................         // Now check for the available function code 
....................         switch(ui8Temp) 
....................         { 
....................             case RS485_FUNCTION_READ_HOLDING_REGISTERS: 
....................                 // Check queue length here if full message is received or not. 
....................                  
....................                 // Insert function code in the temp buffer. 
....................                 // For this function code fetch next four consecutive bytes in temp buffer. 
....................                 bIsValidMSG = CheckValidityForReadReg(); 
....................                 if(bIsValidMSG) 
....................                 { 
....................                      
....................                     // Empty the message buffer queue 
....................                     EmptyQueue(); 
....................                     
....................                     if(ui16RegData == 1) 
....................                     {                  
....................                         WriteToOneRegRS485( 
....................                             SLAVE_ID, 
....................                             RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                             2, 
....................                             4464 //TODO********************************************** 
....................                             ); 
....................                             //65535);                         
....................                     } 
....................                     else if(ui16RegData == 2) 
....................                     { 
....................                         if(ui16Address == ADDRESS_FOR_SET_CALIB_DATA)  
....................                         { 
....................                             if(g_ui16RegisterForCount == 1)  
....................                             { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16RegisterForCounter1_1, //TODO********************************************** 
....................                                     g_ui16RegisterForCounter1_2); 
....................                             } 
....................                             else if(g_ui16RegisterForCount == 2)  
....................                             { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16RegisterForCounter2_1, //TODO********************************************** 
....................                                     g_ui16RegisterForCounter2_2); 
....................                             } 
....................                             else if(g_ui16RegisterForCount == 3)  
....................                             { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16RegisterForCounter3_1, //TODO********************************************** 
....................                                     g_ui16RegisterForCounter3_2); 
....................                             } 
....................                         } 
....................                         else if(ui16Address == ADDRESS_FOR_SET_CALIB_0) 
....................                         { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16Register0_1, //TODO********************************************** 
....................                                     g_ui16Register0_2); 
....................                         } 
....................                         else if(ui16Address == ADDRESS_FOR_SET_CALIB_1000) 
....................                         { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16Register1000_1, //TODO********************************************** 
....................                                     g_ui16Register1000_2); 
....................                         } 
....................                         else if(ui16Address == ADDRESS_FOR_SET_CALIB_2000) 
....................                         { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16Register2000_1, //TODO********************************************** 
....................                                     g_ui16Register2000_2); 
....................                         } 
....................                         else if(ui16Address == ADDRESS_FOR_SET_CALIB_3000) 
....................                         { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16Register3000_1, //TODO********************************************** 
....................                                     g_ui16Register3000_2); 
....................                         } 
....................                         else if(ui16Address == ADDRESS_FOR_SET_CALIB_4000) 
....................                         { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16Register4000_1, //TODO********************************************** 
....................                                     g_ui16Register4000_2); 
....................                         } 
....................                         else if(ui16Address == ADDRESS_FOR_SET_CALIB_5000) 
....................                         { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16Register5000_1, //TODO********************************************** 
....................                                     g_ui16Register5000_2); 
....................                         } 
....................                         else if(ui16Address == ADDRESS_FOR_SET_CALIB_6000) 
....................                         { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16Register6000_1, //TODO********************************************** 
....................                                     g_ui16Register6000_2); 
....................                         } 
....................                         else if(ui16Address == ADDRESS_FOR_SET_CALIB_7000) 
....................                         { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16Register7000_1, //TODO********************************************** 
....................                                     g_ui16Register7000_2); 
....................                         } 
....................                         else if(ui16Address == ADDRESS_FOR_SET_CALIB_8000) 
....................                         { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16Register8000_1, //TODO********************************************** 
....................                                     g_ui16Register8000_2); 
....................                         } 
....................                         else if(ui16Address == ADDRESS_FOR_SET_CALIB_9000) 
....................                         { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16Register9000_1, //TODO********************************************** 
....................                                     g_ui16Register9000_2); 
....................                         } 
....................                         else if(ui16Address == ADDRESS_FOR_SET_CALIB_10000) 
....................                         { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16Register10000_1, //TODO********************************************** 
....................                                     g_ui16Register10000_2); 
....................                         } 
....................                         else  
....................                         {     
....................                             // Valid MSG, so return 
....................                             WriteToTwoRegRS485( 
....................                                 SLAVE_ID, 
....................                                 RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                 4, 
....................                                 4464, //TODO********************************************** 
....................                                 1); 
....................                                 //65535); 
....................                         } 
....................                     } 
....................                     else  
....................                     { 
....................                         // Valid MSG, so return 
....................                         WriteToThreeRegRS485( 
....................                             SLAVE_ID, 
....................                             RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                             6,                                      //TODO********************************************** 
....................                             g_ui16DOStatus, 
....................                             g_ui16DIStatus, 
....................                             g_ui16ErrorStatus); 
....................                     } 
....................                     // Update main loop process status. 
....................                     i8MainProcessLoopStatue = 0; 
....................                 } 
....................                 break; 
....................             case RS485_FUNCTION_WRITE_SINGLE_REGISTER: 
....................             { 
....................                 // Insert function code in the temp buffer. 
....................                 // For this function code fetch next four consecutive bytes in temp buffer. 
....................                 //bIsValidMSG = CheckValidityForWriteSingleReg(); 
....................        		 	SendRS485Response(); 
....................                 ProcessSingleRegister(); 
....................             } 
....................             break; 
....................             case RS485_FUNCTION_READ_MULTIPLE_REGISTERS: 
....................             { 
....................                 if(ui16RegData == 2) 
....................                 { 
....................                     if(ui16Address == ADDRESS_FOR_SET_CALIB_0) 
....................                     { 
....................                             ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register0_1, //TODO********************************************** 
....................                             g_ui16Register0_2); 
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_1000) 
....................                     { 
....................                             ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register1000_1, //TODO********************************************** 
....................                             g_ui16Register1000_2); 
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_2000) 
....................                     { 
....................                             ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register2000_1, //TODO********************************************** 
....................                             g_ui16Register2000_2); 
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_3000) 
....................                     { 
....................                             ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register3000_1, //TODO********************************************** 
....................                             g_ui16Register3000_2); 
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_4000) 
....................                     { 
....................                             ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register4000_1, //TODO********************************************** 
....................                             g_ui16Register4000_2); 
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_5000) 
....................                     { 
....................                             ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register5000_1, //TODO********************************************** 
....................                             g_ui16Register5000_2); 
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_6000) 
....................                     { 
....................                             ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register6000_1, //TODO********************************************** 
....................                             g_ui16Register6000_2); 
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_7000) 
....................                     { 
....................                             ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register7000_1, //TODO********************************************** 
....................                             g_ui16Register7000_2); 
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_8000) 
....................                     { 
....................                             ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register8000_1, //TODO********************************************** 
....................                             g_ui16Register8000_2); 
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_9000) 
....................                     { 
....................                             ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register9000_1, //TODO********************************************** 
....................                             g_ui16Register9000_2); 
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_10000) 
....................                     { 
....................                             ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register10000_1, //TODO********************************************** 
....................                             g_ui16Register10000_2); 
....................                     } 
....................                     else { 
....................                         ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register0_1, //TODO********************************************** 
....................                             g_ui16Register0_2); 
....................                     } 
....................                 } 
....................                 else  
....................                 { 
....................                         ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register0_1, //TODO********************************************** 
....................                             g_ui16Register0_2); 
....................                 } 
....................             } 
....................             break; 
....................             case RS485_FUNCTION_WRITE_MULTIPLE_REGISTERS: 
....................             { 
....................                 SendRS485ResponseForMultipleRegWrite(); 
....................                  
....................                 unsigned int16 ui16RegDataLen    = ui16RegData; 
....................                 int8 i8DataLen = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_SIX - 1]; 
....................  
....................                 int8 i8DataH = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_SEVEN -1]; 
....................                 int8 i8DataL = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_8 -1]; 
....................  
....................                 unsigned int16 ui16RegDataValue1 = 0; 
....................  
....................                 ui16RegDataValue1 = i8DataH; 
....................                 ui16RegDataValue1 <<= 8; 
....................                 ui16RegDataValue1 += i8DataL;   
....................                  
....................                 i8DataH = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_9 -1]; 
....................                 i8DataL = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_10 -1]; 
....................  
....................                 unsigned int16 ui16RegDataValue2 = 0; 
....................  
....................                 ui16RegDataValue2 = i8DataH; 
....................                 ui16RegDataValue2 <<= 8; 
....................                 ui16RegDataValue2 += i8DataL;    
....................                  
....................                 if(ui16RegDataLen == 2) 
....................                 { 
....................                     if(ui16Address == ADDRESS_FOR_SET_CALIB_0) 
....................                     { 
....................                         g_ui16Register0_1 = ui16RegDataValue1; 
....................                         g_ui16Register0_2 = ui16RegDataValue2;                         
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_1000) 
....................                     { 
....................                         g_ui16Register1000_1 = ui16RegDataValue1; 
....................                         g_ui16Register1000_2 = ui16RegDataValue2;                         
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_2000) 
....................                     { 
....................                         g_ui16Register2000_1 = ui16RegDataValue1; 
....................                         g_ui16Register2000_2 = ui16RegDataValue2;                         
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_3000) 
....................                     { 
....................                         g_ui16Register3000_1 = ui16RegDataValue1; 
....................                         g_ui16Register3000_2 = ui16RegDataValue2;                         
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_4000) 
....................                     { 
....................                         g_ui16Register4000_1 = ui16RegDataValue1; 
....................                         g_ui16Register4000_2 = ui16RegDataValue2;                         
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_5000) 
....................                     { 
....................                         g_ui16Register5000_1 = ui16RegDataValue1; 
....................                         g_ui16Register5000_2 = ui16RegDataValue2;                         
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_6000) 
....................                     { 
....................                         g_ui16Register6000_1 = ui16RegDataValue1; 
....................                         g_ui16Register6000_2 = ui16RegDataValue2;                         
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_7000) 
....................                     { 
....................                         g_ui16Register7000_1 = ui16RegDataValue1; 
....................                         g_ui16Register7000_2 = ui16RegDataValue2;                         
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_8000) 
....................                     { 
....................                         g_ui16Register8000_1 = ui16RegDataValue1; 
....................                         g_ui16Register8000_2 = ui16RegDataValue2;                         
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_9000) 
....................                     { 
....................                         g_ui16Register9000_1 = ui16RegDataValue1; 
....................                         g_ui16Register9000_2 = ui16RegDataValue2;                         
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_10000) 
....................                     { 
....................                         g_ui16Register10000_1 = ui16RegDataValue1; 
....................                         g_ui16Register10000_2 = ui16RegDataValue2;                         
....................                     } 
....................                     else { 
....................                         ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register0_1, //TODO********************************************** 
....................                             g_ui16Register0_2); 
....................                     } 
....................                 } 
....................             } 
....................             break; 
....................             default:   // Function Code is not Matching 
....................                 // Continue the ProcessUART2ReceivedData from beginning 
....................                 SendRS485Response(); 
....................                 i8MainProcessLoopStatue = 1; 
....................                 break; 
....................         } 
....................          
....................         // If Function Code not Matching 
....................         if (i8MainProcessLoopStatue) 
....................         { 
....................             // Then continue from beginning 
....................             continue; 
....................         } 
....................          
....................          
....................         // If the message is not valid 
....................         // Start  
....................     } while (i8MainProcessLoopStatue); 
....................      
.................... } 
.................... ////=============================== END NEW CODE ====================================================== 
....................  
.................... #endif /* _VI_RS485_CONFIG_H_ */ 
....................  
....................  
....................  
.................... #define   SIM900_RX_BUFF_SIZE                   500 
....................  
....................  
.................... #define   IN_MOTION_MACHINE_ID                  1 
.................... #define   GPRS_RQSTTYPE_SEND_2_SERVER           1 
....................  
.................... #define  GPRS_CONNECTION_FAILS                  30 
.................... #define  GPRS_HTTP_ENABLE_FAILS                 31 
.................... #define  GPRS_SET_BEARER_ID_FAILS               32 
.................... #define  GPRS_SET_WEB_SERVICE_URL_FAILS         33 
.................... #define  GPRS_START_HTTP_GET_SESSION_FAILS      34 
.................... #define  VYOMEC_250_LOO118_MACHINE_ID           1 
....................  
....................  
.................... //typedef struct _ST_GPRS_DATA_NODE 
.................... //{ 
.................... //    unsigned int32 m_ui32TimeStamp; 
.................... //    unsigned int16 m_ui16SequenceNo; 
.................... //    unsigned int16 m_ui16ItemWeight; 
.................... //    unsigned int8  m_ui8RejectionStatus; 
.................... //} ST_GPRS_DATA_NODE; 
.................... // 
.................... //typedef struct _ST_GPRS_MSG_SEND_QUEUE 
.................... //{ 
.................... //    ST_GPRS_DATA_NODE m_stArrGPRSDataNode[SIZE_GPRS_DATA_NODE_QUEUE]; 
.................... //    int8              m_i8Front; 
.................... //    int8              m_i8Rear; 
.................... //} ST_GPRS_MSG_SEND_QUEUE; 
....................  
.................... //typedef struct _ST_PROD_M_CURR_BOX_DATA 
.................... //{ 
.................... //    int16             m_i16BoxWeight; 
.................... //    unsigned int16    m_ui16SequenceNo; 
.................... //    unsigned int16    m_ui16RejectionStatus; 
.................... //    unsigned int32    m_ui32TimeStamp; 
.................... //} ST_PROD_M_CURR_BOX_DATA; 
....................  
.................... // ***************************************************************************** 
.................... // ***************** Below -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
.................... unsigned int8      g_ui8SIM900RxBuffer[SIM900_RX_BUFF_SIZE] = {0}; 
.................... unsigned int16     g_ui16SIM900RxByteCount                  = 0; 
.................... //unsigned int16     g_ui16HTTPData                           = 0; 
.................... //unsigned int8      g_ui8GPRSRqstType                        = GPRS_RQSTTYPE_SEND_2_SERVER; 
.................... unsigned int8      g_fIsLastElementInGPRSQueue              = 0; 
.................... //unsigned int8      g_fGPRSSequence                          = 0; 
.................... //unsigned int8      g_fGPRSFailureBit                        = 0; 
.................... //unsigned int8      g_ui8DataQueueLen                        = 0; 
....................  
....................  
.................... //ST_GPRS_DATA_NODE  g_stGPRSDataNode; 
.................... //ST_GPRS_MSG_SEND_QUEUE   g_stGPRSMsgSendQueue; 
.................... //ST_PROD_M_CURR_BOX_DATA  g_stProdModeCurrBoxData; 
....................  
.................... // ***************************************************************************** 
.................... // ***************** Above -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
.................... void Delay_milisecond_(unsigned int16 ui16DelayTime) 
.................... { 
.................... 	unsigned int16 ui16Counter = 0; 
.................... 	while(ui16Counter < ui16DelayTime) 
.................... 	{ 
.................... 		// Reset WDT 
....................    		restart_wdt(); 
....................      
.................... 		delay_ms(1); 
.................... 		ui16Counter++; 
.................... 	} 
.................... } 
....................  
.................... void ResetSIM900RxBuffer(void) 
.................... { 
....................     // Reset Rx Byte count. 
....................     g_ui16SIM900RxByteCount = 0; 
....................     // Flush all data in SIM900 Rx buffer 
....................     memset(g_ui8SIM900RxBuffer, 0, SIM900_RX_BUFF_SIZE); 
.................... } 
....................  
....................  
....................  
.................... //void StuffGPRSMSgQueueDummy(void) 
.................... //{ 
.................... //    unsigned int8  ui8NoOfMessage     = 2; 
.................... //    unsigned int16 ui16MachineID      = 1; 
.................... //    unsigned int8  ui8Variety         = 6; 
.................... //     
.................... //    unsigned int32 ui32TimeStamp       = 454545; 
.................... //    unsigned int16 ui16SequenceNo      = 1; 
.................... //    int16          i16Itemweight       = 7000; 
.................... //    unsigned int16 ui16Rejectionstatus = 1; 
.................... //     
.................... //    // Stuff dummy message header 
.................... //    g_stGPRSMsgHeader.m_ui8NoOfMessages = ui8NoOfMessage; 
.................... //    g_stGPRSMsgHeader.m_ui16MachineID   = ui16MachineID; 
.................... //    g_stGPRSMsgHeader.m_ui8Variety      = ui8Variety; 
.................... //     
.................... //    for(unsigned int8 ui8LoopCount = 0; ui8LoopCount <= 30; ui8LoopCount++) 
.................... //    { 
.................... //        g_stGPRSMsgSendQueue.m_i8Rear++; 
.................... //         
.................... //        // Stuff data 
.................... //        g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui32TimeStamp = ui32TimeStamp++; 
.................... //        g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16SequenceNo = ui16SequenceNo++; 
.................... //        g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16ItemWeight = i16Itemweight++; 
.................... //        g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui8RejectionStatus = ui16Rejectionstatus; 
.................... //    } 
.................... //     
.................... //    g_stGPRSMsgSendQueue.m_i8Front = 0; 
.................... //} 
....................  
.................... //void StuffDummyTimeStamp(void) 
.................... //{ 
.................... //    unsigned int32 ui32TimeStamp       = 8080; 
.................... //    int8           i8TempRear          = 0; 
.................... //     
.................... //    i8TempRear = g_stGPRSMsgSendQueue.m_i8Rear; 
.................... //    for(unsigned int8 ui8LoopCount = 0; ui8LoopCount < SIZE_GPRS_DATA_NODE_QUEUE; ui8LoopCount++) 
.................... //    { 
.................... //        i8TempRear++; 
.................... //         
.................... //        // Stuff data 
.................... //        g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[i8TempRear].m_ui32TimeStamp = ui32TimeStamp++; 
.................... //         
.................... //    } 
.................... //     
.................... //} 
....................  
.................... void StuffDummyHeader(void) 
.................... { 
....................     unsigned int16 ui16MachineID      = VYOMEC_250_LOO118_MACHINE_ID; 
....................     unsigned int8  ui8Variety         = 6; 
....................      
....................     // Stuff dummy message header 
....................     //g_stGPRSMsgHeader.m_ui8NoOfMessages = ui8NoOfMessage; 
....................     g_stGPRSMsgHeader.m_ui16MachineID   = ui16MachineID; 
....................     g_stGPRSMsgHeader.m_ui8Variety      = ui8Variety; 
....................      
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... // ############################################################# GPRS Connection Driver ################################################################## 
....................  
.................... unsigned int8 SetConnectionType(void) 
.................... { 
.................... 	unsigned int8 ui8fIsOKfound = 1; 
.................... 	g_fIsTimedOut = 0; 
.................... 	 
.................... 	// Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
.................... 	// Set connection type to GPRS. 
.................... 	//fputs("AT+SAPBR=3,1,\"CONTYPE\",\"GPRS\"\r", SIM900); 
.................... 	// Set timeout. 
.................... 	SetTimeout(5); 
.................... 	// Wait for response. 
.................... 	while(ui8fIsOKfound == 1 && g_fIsTimedOut == 0) 
.................... 	{ 
.................... 		// Restart WDT. 
....................         restart_wdt(); 
....................         for(unsigned int16 ui16ByteCount = 0;  ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................         { 
....................         	// Check for "OK". 
....................             if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................             { 
....................                 // Mark flag denoting "OK" was found. 
....................                 ui8fIsOKfound = 0; 
....................                 break; 
....................             } 
....................         } 
....................          
.................... 	} 
.................... 	 
.................... 	return ui8fIsOKfound; 
.................... } 
....................  
.................... unsigned int8 SetAPN(void) 
.................... { 
.................... 	unsigned int8 ui8fIsOKfound = 1; 
.................... 	g_fIsTimedOut = 0; 
.................... 	 
.................... 	// Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
.................... 	// Set APN. 
....................     //fputs("AT+SAPBR=3,1,\"APN\",\"www\"\r",SIM900); 
....................     // Set timeout. 
.................... 	SetTimeout(5); 
.................... 	// Wait for response. 
.................... 	while(ui8fIsOKfound == 1 && g_fIsTimedOut == 0) 
.................... 	{ 
.................... 		// Restart WDT. 
....................         restart_wdt(); 
....................         for(unsigned int16 ui16ByteCount = 0;  ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................         { 
....................         	// Check for "OK". 
....................             if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................             { 
....................                 // Mark flag denoting "OK" was found. 
....................                 ui8fIsOKfound = 0; 
....................                 break; 
....................             } 
....................         } 
.................... 	} 
.................... 	 
.................... 	return ui8fIsOKfound; 
.................... 	 
.................... } 
....................  
.................... unsigned int8 EnableGPRS(void) 
.................... { 
.................... 	unsigned int8 ui8fIsOKfound = 1; 
.................... 	g_fIsTimedOut = 0; 
.................... 	 
.................... 	// Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
.................... 	// Enable GPRS. 
....................     //fputs("AT+SAPBR=1,1\r", SIM900); 
....................     // Set timeout. 
.................... 	SetTimeout(5); 
.................... 	// Wait for response. 
.................... 	while(ui8fIsOKfound == 1 && g_fIsTimedOut == 0) 
.................... 	{ 
.................... 		// Restart WDT. 
....................         restart_wdt(); 
....................         for(unsigned int16 ui16ByteCount = 0;  ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................         { 
....................         	// Check for "OK". 
....................             if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................             { 
....................                 // Mark flag denoting "OK" was found. 
....................                 ui8fIsOKfound = 0; 
....................                 break; 
....................             } 
....................         } 
....................         
.................... 	} 
.................... 	 
.................... 	return ui8fIsOKfound; 
.................... } 
....................  
.................... unsigned int8 CheckGPRSConnection(void) 
.................... { 
.................... 	unsigned int8 ui8fIsOKFound = 1; 
....................     unsigned int8 ui8fIsFirstCharFound = 0; 
....................     unsigned int8 ui8FirstCharIndex = 0; 
....................     unsigned int8 ui8fIsSecondCharFound = 0; 
....................     unsigned int8 ui8StopCount = 0; 
....................     g_fIsTimedOut = 0; 
....................      
....................     // Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
....................     // Check GPRS Connection. 
....................     //fputs("AT+SAPBR=2,1\r",SIM900);    
....................     // Set timeout. 
....................     SetTimeout(5); 
....................     // Wait for response. 
....................     while(ui8fIsOKFound == 1 && g_fIsTimedOut == 0) 
....................     { 
....................     	// Restart WDT. 
....................         restart_wdt(); 
....................         // Reset variables. 
....................         ui8fIsFirstCharFound = 0; 
....................         ui8FirstCharIndex = 0; 
....................         ui8fIsSecondCharFound = 0; 
....................         ui8StopCount = 0; 
....................          
....................         // Loop Thorugh entire receive buffer. 
....................         for(unsigned int16 ui16ByteCount = 0;  ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................         { 
....................         	// Check for first character sequence. 
....................         	if(ui8fIsFirstCharFound == 0 && ui8fIsSecondCharFound == 0) 
....................         	{ 
....................                 // To check bearer after connect GPRS 
....................         		if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == '"' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == ',' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == '1' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == ',' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 4)] == '1' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 5)] == 0x20 && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 6)] == ':') 
....................                  { 
....................                  	// Set flag denoting first charcter sequence found. 
....................                  	ui8fIsFirstCharFound = 1; 
....................                  	// Copy the first character sequence index. 
....................                  	ui8FirstCharIndex = ui16ByteCount; 
....................                  } 
....................                  
....................         	} 
....................         	// Check for second character sequence. 
....................         	else if(ui8fIsFirstCharFound == 1 && ui8fIsSecondCharFound == 0)  // First character already found.  
....................         	{ 
....................         		if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == '"') 
....................         		{ 
....................         			// Loop from first character to second character to check if IP was received. 
....................                     for(unsigned int8 ui8LoopCount = ui8FirstCharIndex; ui8LoopCount <= ui16ByteCount; ui8LoopCount++) 
....................                     { 
....................                         // Check how many . is received.....should be 3. 
....................                         if(g_ui8SIM900RxBuffer[ui8LoopCount] == '.') 
....................                         { 
....................                             ui8StopCount++; 
....................                             // Check if all 3 stops have been received. 
....................                             if(ui8StopCount == 3) 
....................                             { 
....................                                 ui8fIsSecondCharFound = 1; 
....................                             } 
....................                         } 
....................                     } 
....................         		} 
....................         	} 
....................         	// First and second character both found........check for "OK". 
....................         	else if(ui8fIsFirstCharFound == 1 && ui8fIsSecondCharFound == 1) 
....................         	{ 
....................         		// Check for "OK". 
....................                 if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................                 { 
....................                     // Mark flag denoting "OK" was found. 
....................                     ui8fIsOKFound = 0; 
....................                 } 
....................         	} 
....................         } 
....................     } 
....................  
.................... 	return ui8fIsOKFound; 
.................... } 
....................  
.................... void SendCheckGPRSConnectionQuery(void) 
.................... { 
....................     g_fIsTimedOut = 0; 
....................      
....................     // Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
....................     // Check GPRS Connection. 
....................     //fputs("AT+SAPBR=2,1\r",SIM900);    
....................     // Set timeout. 
....................     SetTimeout(3); 
.................... } 
....................  
.................... unsigned int8 GPRSConnectionCheckQueryResponse() 
.................... { 
....................     unsigned int8 ui8fIsOKFound = 1; 
....................     unsigned int8 ui8fIsFirstCharFound = 0; 
....................     unsigned int8 ui8FirstCharIndex = 0; 
....................     unsigned int8 ui8fIsSecondCharFound = 0; 
....................     unsigned int8 ui8StopCount = 0; 
....................      
....................      
....................     // Loop through entire SIM900 Rx buffer 
....................     for(unsigned int16 ui16ByteCount = 0;  ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................     { 
....................         // Check for first character sequence. 
....................         if(ui8fIsFirstCharFound == 0 && ui8fIsSecondCharFound == 0) 
....................         { 
....................             // To check bearer after connect GPRS 
....................             if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == '"' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == ',' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == '1' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == ',' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 4)] == '1' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 5)] == 0x20 && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 6)] == ':') 
....................              { 
....................                 // Set flag denoting first charcter sequence found. 
....................                 ui8fIsFirstCharFound = 1; 
....................                 // Copy the first character sequence index. 
....................                 ui8FirstCharIndex = ui16ByteCount; 
....................              } 
....................  
....................         } 
....................         // Check for second character sequence. 
....................         else if(ui8fIsFirstCharFound == 1 && ui8fIsSecondCharFound == 0)  // First character already found.  
....................         { 
....................             if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == '"') 
....................             { 
....................                 // Loop from first character to second character to check if IP was received. 
....................                 for(unsigned int8 ui8LoopCount = ui8FirstCharIndex; ui8LoopCount <= ui16ByteCount; ui8LoopCount++) 
....................                 { 
....................                     // Check how many . is received.....should be 3. 
....................                     if(g_ui8SIM900RxBuffer[ui8LoopCount] == '.') 
....................                     { 
....................                         ui8StopCount++; 
....................                         // Check if all 3 stops have been received. 
....................                         if(ui8StopCount == 3) 
....................                         { 
....................                             ui8fIsSecondCharFound = 1; 
....................                         } 
....................                     } 
....................                 } 
....................             } 
....................         } 
....................         // First and second character both found........check for "OK". 
....................         else if(ui8fIsFirstCharFound == 1 && ui8fIsSecondCharFound == 1) 
....................         { 
....................             // Check for "OK". 
....................             if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................             { 
....................                 // Mark flag denoting "OK" was found. 
....................                 ui8fIsOKFound = 0; 
....................             } 
....................         } 
....................     }     
....................      
....................     return ui8fIsOKFound; 
.................... } 
....................  
.................... unsigned int8 DisconnectGPRS(void) 
.................... { 
.................... 	unsigned int8 ui8fIsOKFound = 2; 
.................... 	g_fIsTimedOut = 0; 
.................... 	 
.................... 	// Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
.................... 	// Disconnect GPRS. 
....................     //fputs("AT+SAPBR=0,1\r",SIM900); 
....................     Delay_milisecond_(5000);  
....................     // Set timeout. 
....................     SetTimeout(15); 
....................     // Wait for Response. 
....................     while(g_fIsTimedOut == 0 && ui8fIsOKFound == 2) 
....................     { 
....................     	// Restart WDT. 
....................         restart_wdt(); 
....................         // Loop through entire SIM900 Rx buffer. 
....................         for(unsigned int16 ui16ByteCount = 0;  ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................         { 
....................         	// Check for "OK". 
....................             if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................             { 
....................                 // Mark flag denoting "OK" was found. 
....................                 ui8fIsOKFound = 3; 
....................                 break; 
....................             } 
....................         } 
....................     }   
....................      
.................... 	return ui8fIsOKFound; 	 
.................... } 
....................  
.................... unsigned int8 CheckGPRSDisconnection(void) 
.................... { 
.................... 	unsigned int8 ui8fIsOKFound = 1; 
....................     unsigned int8 ui8fIsFirstCharFound = 0; 
....................     unsigned int8 ui8FirstCharIndex = 0; 
....................     unsigned int8 ui8fIsSecondCharFound = 0; 
....................     unsigned int8 ui8StopCount = 0; 
....................     g_fIsTimedOut = 0; 
....................      
....................     // Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
....................     // Check GPRS Connection. 
....................     //fputs("AT+SAPBR=2,1\r",SIM900);    
....................     // Set timeout. 
....................     SetTimeout(15); 
....................     // Wait for response. 
....................     while(ui8fIsOKFound == 1 && g_fIsTimedOut == 0) 
....................     { 
....................     	// Restart WDT. 
....................         restart_wdt(); 
....................         // Reset variables. 
....................         ui8fIsFirstCharFound = 0; 
....................         ui8FirstCharIndex = 0; 
....................         ui8fIsSecondCharFound = 0; 
....................         ui8StopCount = 0; 
....................          
....................         // Loop Thorugh entire receive buffer. 
....................         for(unsigned int16 ui16ByteCount = 0;  ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................         { 
....................         	// Check for first character sequence. 
....................         	if(ui8fIsFirstCharFound == 0 && ui8fIsSecondCharFound == 0) 
....................         	{ 
....................                 // To check bearer after connect GPRS 
....................         		if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == '"' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == ',' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == '3' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == ',' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 4)] == '1' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 5)] == 0x20 && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 6)] == ':') 
....................                  { 
....................                  	// Set flag denoting first charcter sequence found. 
....................                  	ui8fIsFirstCharFound = 1; 
....................                  	// Copy the first character sequence index. 
....................                  	ui8FirstCharIndex = ui16ByteCount; 
....................                  } 
....................                  
....................         	} 
....................         	// Check for second character sequence. 
....................         	else if(ui8fIsFirstCharFound == 1 && ui8fIsSecondCharFound == 0)  // First character already found.  
....................         	{ 
....................         		if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == '"') 
....................         		{ 
....................         			// Loop from first character to second character to check if IP was received. 
....................                     for(unsigned int8 ui8LoopCount = ui8FirstCharIndex; ui8LoopCount <= ui16ByteCount; ui8LoopCount++) 
....................                     { 
....................                         // Check how many . is received.....should be 3. 
....................                         if(g_ui8SIM900RxBuffer[ui8LoopCount] == '.') 
....................                         { 
....................                             ui8StopCount++; 
....................                             // Check if all 3 stops have been received. 
....................                             if(ui8StopCount == 3) 
....................                             { 
....................                                 ui8fIsSecondCharFound = 1; 
....................                             } 
....................                         } 
....................                     } 
....................         		} 
....................         	} 
....................         	// First and second character both found........check for "OK". 
....................         	else if(ui8fIsFirstCharFound == 1 && ui8fIsSecondCharFound == 1) 
....................         	{ 
....................         		// Check for "OK". 
....................                 if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................                 { 
....................                     // Mark flag denoting "OK" was found. 
....................                     ui8fIsOKFound = 0; 
....................                 } 
....................         	} 
....................         } 
....................     } 
....................  
.................... 	return ui8fIsOKFound; 
.................... } 
....................  
.................... // ############################################ End of GPRS Connection Driver ############################################################ 
....................  
....................  
.................... // ############################################# HTTP Application Driver #################################################################### 
....................  
.................... unsigned int8 EnableHttpMode(void) 
.................... { 
.................... 	unsigned int8 ui8fIsOKFound = 1; 
.................... 	g_fIsTimedOut = 0; 
....................  
.................... 	// Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
....................     // Enable HTTP Mode. 
....................     //fputs("AT+HTTPINIT\r",SIM900); 
....................     // Set timeout. 
....................     SetTimeout(5); 
....................     // Wait for response. 
....................     while(g_fIsTimedOut == 0 && ui8fIsOKFound == 1) 
....................     { 
....................         // Restart WDT. 
....................         restart_wdt(); 
....................         // Loop through the entire SIM900 Rx buffer. 
....................         for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................         { 
....................             // Check for "OK". 
....................             if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................             { 
....................                 // Mark flag denoting "OK" was found. 
....................                 ui8fIsOKFound = 0; 
....................                 break; 
....................             } 
....................         } 
....................     } 
....................     
....................     return ui8fIsOKFound; 
....................  
.................... }  
....................  
.................... void SendEnableHTTPModeRequest(void) 
.................... { 
....................     g_fIsTimedOut = 0; 
....................  
.................... 	// Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
....................     // Enable HTTP Mode. 
....................     //fputs("AT+HTTPINIT\r",SIM900); 
....................     // Set timeout. 
....................     SetTimeout(2); 
.................... } 
....................  
.................... unsigned int8 CheckEnableHTTPModeReqResponse(void) 
.................... { 
....................     unsigned int8 ui8fIsOKFound = 1; 
....................      
....................     for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................     { 
....................         // Check for "OK". 
....................         if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................            g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................            g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................            g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................         { 
....................             // Mark flag denoting "OK" was found. 
....................             ui8fIsOKFound = 0; 
....................             break; 
....................         } 
....................     } 
....................      
....................     return ui8fIsOKFound; 
.................... } 
....................  
.................... unsigned int8 EnableSecureHttpMode(void) 
.................... { 
.................... 	unsigned int8 ui8fIsOKFound = 1; 
.................... 	g_fIsTimedOut = 0; 
.................... 	 
.................... 	// Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
.................... 	// Enable HTTPS Mode. 
.................... 	//fputs("AT+HTTPSSL=1\r",SIM900); 
.................... 	// Set timeout. 
....................     SetTimeout(5); 
....................     // Wait for response. 
....................     while(g_fIsTimedOut == 0 && ui8fIsOKFound == 1) 
....................     {    
.................... 		  // Restart WDT. 
.................... 	       restart_wdt(); 
.................... 	       // Loop through the entire SIM900 Rx buffer. 
.................... 	       for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
.................... 	       {   
.................... 		  		// Check for "OK". 
.................... 		  		if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... 		     	   g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... 		     	   g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... 		     	   g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... 		  		{ 
.................... 		      		// Mark flag denoting "OK" was found. 
.................... 		      		ui8fIsOKFound = 0; 
.................... 		      		break; 
.................... 		  		} 
.................... 	   	  } 
.................... 	}	   
.................... 	 
.................... 	return ui8fIsOKFound; 
.................... } 
....................  
.................... unsigned int8 SetHTTPBearerProfileID(void) 
.................... { 
.................... 	unsigned int8 ui8fIsOKFound = 1; 
.................... 	g_fIsTimedOut = 0; 
....................  
.................... 	// Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
....................     // Set HTTP Bearer Profile ID. 
....................     ///fputs("AT+HTTPPARA=\"CID\",1\r",SIM900); 
....................     // Set timeout. 
....................     SetTimeout(5); 
....................     // Wait for response. 
....................     while(g_fIsTimedOut == 0 && ui8fIsOKFound == 1) 
....................     { 
....................         // Restart WDT. 
....................         restart_wdt(); 
....................         // Loop through the entire SIM900 Rx buffer. 
....................         for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................         { 
....................             // Check for "OK". 
....................             if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................             { 
....................                 // Mark flag denoting "OK" was found. 
....................                 ui8fIsOKFound = 0; 
....................                 break; 
....................             } 
....................         } 
....................     } 
....................      
....................     return ui8fIsOKFound; 
.................... } 
....................  
.................... void SendSetHTTPBearerProfileIDRequest(void) 
.................... { 
....................     g_fIsTimedOut = 0; 
....................      
....................     // Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
....................     // Set HTTP Bearer Profile ID. 
....................     //fputs("AT+HTTPPARA=\"CID\",1\r",SIM900); 
....................     // Set timeout. 
....................     SetTimeout(2); 
.................... } 
....................  
.................... unsigned int8 SetHTTPBearerProfileIDReqResponse(void) 
.................... { 
....................     unsigned int8 ui8fIsOKFound = 1; 
....................      
....................     // Loop through entire SIM900 Rx buffer 
....................     for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................     { 
....................         // Check for "OK". 
....................         if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................            g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................            g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................            g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................         { 
....................             // Mark flag denoting "OK" was found. 
....................             ui8fIsOKFound = 0; 
....................             break; 
....................         } 
....................     } 
....................      
....................     return ui8fIsOKFound; 
....................     ; 
.................... } 
....................  
.................... //unsigned int8 SetWebServiceURL(void) 
.................... //{ 
.................... //    unsigned int8 ui8fIsOKFound   = 1; 
.................... //    unsigned int8 ui8DataQueueLen = 0; 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //     
.................... //    //Increase GPRS send msg queue front. 
.................... //    if(g_stGPRSMsgSendQueue.m_i8Front != 0) 
.................... //    { 
.................... //        g_stGPRSMsgSendQueue.m_i8Front++; 
.................... //    }     
.................... //     
.................... //    // Check remaining data length of queue 
.................... //    ui8DataQueueLen = (g_stGPRSMsgSendQueue.m_i8Rear - g_stGPRSMsgSendQueue.m_i8Front + 1); 
.................... //     
.................... //    if(ui8DataQueueLen >= 3) 
.................... //    {    
.................... //        // Set number of message to send in message header 
.................... //        g_stGPRSMsgHeader.m_ui8NoOfMessages = 3; 
.................... //        // Set Web Service URL. 
.................... //        //unsigned int16 ui16StopID = 4; 
.................... //        fprintf (SIM900, "AT+HTTPPARA=\"URL\",\"http://www.trackweights.com/api/GetCtlrData.php?a=%u&b=%Lu&c=%u&m=%Lu$%Lu$%Lu$%u|%Lu$%Lu$%Lu$%u|%Lu$%Lu$%Lu$%u\"\r", g_stGPRSMsgHeader.m_ui8NoOfMessages, g_stGPRSMsgHeader.m_ui16MachineID, g_stGPRSMsgHeader.m_ui8Variety,  
.................... //                                                                                                                                                                     g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front++].m_ui8RejectionStatus, 
.................... //                                                                                                                                                                     g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front++].m_ui8RejectionStatus 
.................... //                                                                                                                                                                     g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui8RejectionStatus); 
.................... //        //fprintf (SIM900, "AT+HTTPPARA=\"URL\",\"http://www.vyomainnovus.com/ServiceSet.php?%Lu\"\r", g_ui16HTTPData++); 
.................... //        //fputs("AT+HTTPPARA=\"URL\",\"http://www.vyomainnovus.com/BusStandService.php?id=81\"\r",SIM900); 
.................... //    }  
.................... //    else  
.................... //    { 
.................... //        // Set number of message to send in message header. 
.................... //        g_stGPRSMsgHeader.m_ui8NoOfMessages = 1; 
.................... //        // Set Web Service URL. 
.................... //        fprintf (SIM900, "AT+HTTPPARA=\"URL\",\"http://www.trackweights.com/api/GetCtlrData.php?a=%u&b=%Lu&c=%u&m=%Lu$%Lu$%Lu$%u\"\r", g_stGPRSMsgHeader.m_ui8NoOfMessages, g_stGPRSMsgHeader.m_ui16MachineID, g_stGPRSMsgHeader.m_ui8Variety,  
.................... //                                                                                                                                       g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui8RejectionStatus); 
.................... //    }     
.................... //    // Set timeout. 
.................... //    SetTimeout(5); 
.................... //    // Wait for response. 
.................... //    while(g_fIsTimedOut == 0 && ui8fIsOKFound == 1) 
.................... //    { 
.................... //        // Restart WDT. 
.................... //        restart_wdt(); 
.................... //        // Loop through the entire SIM900 Rx buffer. 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            // Check for "OK". 
.................... //            if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... //               g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... //               g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... //               g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... //            { 
.................... //                // Mark flag denoting "OK" was found. 
.................... //                ui8fIsOKFound = 0; 
.................... //            }                
.................... //        } 
.................... //    } 
.................... //    
.................... //    return ui8fIsOKFound; 
.................... //} 
.................... // 
.................... //void SendSetWebServiceURLrequest(void) 
.................... //{ 
.................... //    //unsigned int8 ui8DataQueueLen = 0; 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //    //Increase GPRS send msg queue front. 
.................... //    g_stGPRSMsgSendQueue.m_i8Front++; 
.................... //     
.................... //     // Check remaining data length of queue 
.................... //    g_ui8DataQueueLen = (g_stGPRSMsgSendQueue.m_i8Rear - g_stGPRSMsgSendQueue.m_i8Front + 1); 
.................... //     
.................... //     
.................... //     if(g_ui8DataQueueLen >= 5) 
.................... //    {    
.................... //        // Set number of message to send in message header 
.................... //\ 
.................... //         g_stGPRSMsgHeader.m_ui8NoOfMessages = 5; 
.................... //        // Set Web Service URL. 
.................... //        //unsigned int16 ui16StopID = 4; 
.................... //        fprintf (SIM900, "AT+HTTPPARA=\"URL\",\"http://www.trackweights.com/api/GetCtlrData.php?a=%u&b=%Lu&c=%u&m=%Lu$%Lu$%Lu$%u|%Lu$%Lu$%Lu$%u|%Lu$%Lu$%Lu$%u|%Lu$%Lu$%Lu$%u|%Lu$%Lu$%Lu$%u\"\r", g_stGPRSMsgHeader.m_ui8NoOfMessages, g_stGPRSMsgHeader.m_ui16MachineID, g_stGPRSMsgHeader.m_ui8Variety,  
.................... //                                                                                                                                                                                                   g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front++].m_ui8RejectionStatus, 
.................... //                                                                                                                                                                                                   g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front++].m_ui8RejectionStatus, 
.................... //                                                                                                                                                                                                   g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front++].m_ui8RejectionStatus, 
.................... //                                                                                                                                                                                                   g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front++].m_ui8RejectionStatus, 
.................... //                                                                                                                                                                                                   g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui8RejectionStatus); 
.................... //        //fprintf (SIM900, "AT+HTTPPARA=\"URL\",\"http://www.vyomainnovus.com/ServiceSet.php?%Lu\"\r", g_ui16HTTPData++); 
.................... //        //fputs("AT+HTTPPARA=\"URL\",\"http://www.vyomainnovus.com/BusStandService.php?id=81\"\r",SIM900); 
.................... //    }  
.................... //    else  
.................... //    { 
.................... //        // Set number of message to send in message header. 
.................... //        g_stGPRSMsgHeader.m_ui8NoOfMessages = 1; 
.................... //        // Set Web Service URL. 
.................... //        fprintf (SIM900, "AT+HTTPPARA=\"URL\",\"http://www.trackweights.com/api/GetCtlrData.php?a=%u&b=%Lu&c=%u&m=%Lu$%Lu$%Lu$%u\"\r", g_stGPRSMsgHeader.m_ui8NoOfMessages, g_stGPRSMsgHeader.m_ui16MachineID, g_stGPRSMsgHeader.m_ui8Variety,  
.................... //                                                                                                                                       g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui8RejectionStatus); 
.................... //         
.................... //         
.................... //    }     
.................... //    // Set timeout. 
.................... //    SetTimeout(2); 
.................... //} 
....................  
.................... unsigned int8 SetWebServiceURLReqresponse(void) 
.................... { 
....................     unsigned int8 ui8fIsOKFound   = 1; 
....................      
....................     // Loop through entire SIM900 Rx buffer 
....................     for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................     { 
....................         // Check for "OK". 
....................         if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................            g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................            g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................            g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................         { 
....................             // Mark flag denoting "OK" was found. 
....................             ui8fIsOKFound = 0; 
....................         }    
....................     } 
....................      
....................     return ui8fIsOKFound; 
.................... } 
....................  
.................... unsigned int8 GetWebServiceURL(void) 
.................... { 
.................... 	unsigned int8 ui8fIsOKFound = 1; 
.................... 	g_fIsTimedOut = 0; 
.................... 	 
.................... 	// Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
.................... 	// Set the URL to Read data. 
.................... 	//fputs("AT+HTTPPARA=\"URL\",\"http://www.vyomainnovus.com/Service.php\"\r", SIM900); 
.................... 	// Set Timeout. 
.................... 	SetTimeout(15); 
.................... 	// Wait for Response. 
.................... 	while(g_fIsTimedOut == 0 && ui8fIsOKFound == 1) 
.................... 	{ 
.................... 		// Restart WDT. 
....................         restart_wdt(); 
....................         // Loop through the entire SIM900 Rx buffer. 
....................         for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................         { 
....................         	// Check for "OK". 
....................             if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................             { 
....................                 // Mark flag denoting "OK" was found. 
....................                 ui8fIsOKFound = 0; 
....................                 break; 
....................             } 
....................         } 
.................... 	} 
.................... 	 
.................... 	return ui8fIsOKFound; 
.................... }  
....................  
....................  
.................... unsigned int8 StartHTTPGETSession(void) 
.................... { 
.................... 	unsigned int8 ui8fIsOKFound 	 = 1; 
....................     unsigned int8 ui8IsColonFound 	 = 0; 
....................     unsigned int8 ui8CommaCount 	 = 0; 
....................     unsigned int8 ui8IsCommaFound 	 = 0; 
....................     unsigned int8 ui8FirstCommaIndex = 0;  
....................      
....................      
....................     // Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
.................... 	// Set Web Service Action. 
....................     //fputs("AT+HTTPACTION=0\r",SIM900); 
....................     // Wait for 10 seconds to properly hit the URL. 
....................     Delay_milisecond_(5000);  /* This will take sometimes more time */ 
....................     // Set timeout. 
....................     SetTimeout(10); 
....................     // Reset variable. 
....................     g_fIsTimedOut = 0; 
....................     // Wait for response. 
....................     while(g_fIsTimedOut == 0 && ui8fIsOKFound == 1) 
....................     { 
....................     	// Restart WDT. 
....................         restart_wdt(); 
....................         // Reset variables. 
....................         ui8IsColonFound = 0; 
....................         ui8CommaCount = 0; 
....................         ui8IsCommaFound = 0; 
....................         ui8FirstCommaIndex = 0; 
....................          
....................         // Loop through the entire SIM900 Rx buffer. 
....................         for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................         { 
....................         	// Looking for First character sequence..i.e ':' 
....................         	if(ui8IsColonFound == 0 && ui8IsCommaFound == 0) 
....................         	{ 
....................         		if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == ':' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 'N' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'O' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'I' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 4)] == 'T' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 5)] == 'C' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 6)] == 'A' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 7)] == 'P' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 8)] == 'T' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 9)] == 'T' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 10)] == 'H' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 11)] == '+' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 12)] == 0x0A && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 13)] == 0x0D && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 14)] == 0x0A && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 15)] == 0x0D && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 16)] == 'K' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 17)] == 'O') 
....................                 { 
....................                     // Mark flag denoting colon is found. 
....................                     ui8IsColonFound = 1; 
....................                 } 
....................         	} 
....................         	// Looking for second character sequence..i.e ',' 
....................         	else if (ui8IsColonFound == 1 && ui8IsCommaFound == 0) // First character sequence found. 
....................         	{ 
.................... 	        	// Look for comma..',' 
....................         		if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == ',') 
....................         		{ 
.................... 	        		if(!ui8FirstCommaIndex) 
.................... 	        		{ 
.................... 	        			// Copy the index of the first comma. 
.................... 	        			ui8FirstCommaIndex = ui16ByteCount; 
.................... 	        		} 
....................         			// Comma found...increment counter. 
....................                     ui8CommaCount++; 
....................                     // Check if 2 comma were received. 
....................                     if(ui8CommaCount == 2) 
....................                     { 
....................                     	// Mark flag denoting second comma found. 
....................                     	ui8IsCommaFound = 1; 
....................                     } 
....................         		} 
....................         	} 
....................         	// Both First and second character sequence found..check the received data. 
....................         	else if(ui8IsColonFound == 1 && ui8IsCommaFound == 1) 
....................         	{ 
....................         		if(g_ui8SIM900RxBuffer[(ui8FirstCommaIndex - 1)] == '0') 
....................         		{ 
....................         			if(g_ui8SIM900RxBuffer[(ui8FirstCommaIndex + 1)] == '2' && 
....................         			   g_ui8SIM900RxBuffer[(ui8FirstCommaIndex + 2)] == '0' && 
....................         			   g_ui8SIM900RxBuffer[(ui8FirstCommaIndex + 3)] == '0') 
....................         			{ 
....................         				// Mark flag denoting all received data is ok...send data successfully. 
....................         				ui8fIsOKFound = 0; 
....................         				break; 
....................         			} 
....................         		} 
....................         	} 
....................         } 
....................      
....................     } 
....................      
....................     return ui8fIsOKFound; 
.................... } 
....................  
.................... void SendStartHTTPGetSessionRequest(void) 
.................... { 
....................     g_fIsTimedOut = 0; 
....................      
....................     // Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
.................... 	// Set Web Service Action. 
....................     //fputs("AT+HTTPACTION=0\r",SIM900); 
....................     // Set timeout. 
....................     SetTimeout(20); 
....................      
.................... } 
....................  
.................... unsigned int8 StartHTTPGetSessionReqResponse(void) 
.................... { 
....................     unsigned int8 ui8fIsOKFound 	 = 1; 
....................     unsigned int8 ui8IsColonFound 	 = 0; 
....................     unsigned int8 ui8CommaCount 	 = 0; 
....................     unsigned int8 ui8IsCommaFound 	 = 0; 
....................     unsigned int8 ui8FirstCommaIndex = 0;  
....................      
....................      
....................     // Loop through the entire SIM900 Rx buffer. 
....................     for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................     { 
....................     // Looking for First character sequence..i.e ':' 
....................         if(ui8IsColonFound == 0 && ui8IsCommaFound == 0) 
....................         { 
....................             if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == ':' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 'N' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'O' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'I' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 4)] == 'T' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 5)] == 'C' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 6)] == 'A' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 7)] == 'P' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 8)] == 'T' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 9)] == 'T' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 10)] == 'H' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 11)] == '+' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 12)] == 0x0A && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 13)] == 0x0D && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 14)] == 0x0A && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 15)] == 0x0D && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 16)] == 'K' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 17)] == 'O') 
....................             { 
....................                 // Mark flag denoting colon is found. 
....................                 ui8IsColonFound = 1; 
....................             } 
....................         } 
....................         // Looking for second character sequence..i.e ',' 
....................         else if (ui8IsColonFound == 1 && ui8IsCommaFound == 0) // First character sequence found. 
....................         { 
....................             // Look for comma..',' 
....................             if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == ',') 
....................             { 
....................                 if(!ui8FirstCommaIndex) 
....................                 { 
....................                     // Copy the index of the first comma. 
....................                     ui8FirstCommaIndex = ui16ByteCount; 
....................                 } 
....................                 // Comma found...increment counter. 
....................                 ui8CommaCount++; 
....................                 // Check if 2 comma were received. 
....................                 if(ui8CommaCount == 2) 
....................                 { 
....................                     // Mark flag denoting second comma found. 
....................                     ui8IsCommaFound = 1; 
....................                 } 
....................             } 
....................         } 
....................         // Both First and second character sequence found..check the received data. 
....................         else if(ui8IsColonFound == 1 && ui8IsCommaFound == 1) 
....................         { 
....................             if(g_ui8SIM900RxBuffer[(ui8FirstCommaIndex - 1)] == '0') 
....................             { 
....................                 if(g_ui8SIM900RxBuffer[(ui8FirstCommaIndex + 1)] == '2' && 
....................                    g_ui8SIM900RxBuffer[(ui8FirstCommaIndex + 2)] == '0' && 
....................                    g_ui8SIM900RxBuffer[(ui8FirstCommaIndex + 3)] == '0') 
....................                 { 
....................                     // Mark flag denoting all received data is ok...send data successfully. 
....................                     ui8fIsOKFound = 0; 
....................                     break; 
....................                 } 
....................             } 
....................         } 
....................     } 
....................      
....................     return ui8fIsOKFound; 
.................... } 
....................  
.................... void TerminateHttpSession(void) 
.................... { 
....................     // Set command to terminate HTTP Session. 
....................     //fputs("AT+HTTPTERM\r",SIM900); 
....................     delay_ms(3000); 
.................... } 
....................  
.................... void TermHTTPSession(void) 
.................... { 
....................     // Set command to terminate HTTP Session. 
....................     //fputs("AT+HTTPTERM\r",SIM900); 
....................      
....................     // Set timeout 
....................     //SetTimeout(3); 
.................... } 
....................  
.................... // ########################################################## End of HTTP Application Driver ############################################################# 
....................  
.................... #endif	/* VM_SIM900_GPRS_CONFIG_H */ 
....................  
....................  
.................... #include "viRS485Config.h" 
.................... #ifndef _VI_RS485_CONFIG_H_ 
.................... #define _VI_RS485_CONFIG_H_ 
....................  
.................... #include "vmCRCConfig.h" 
.................... #include "viModbusGlobal.h" 
.................... #include "vmIBCGlobal.h" 
.................... #include "vmTimerConfig.h" 
.................... //#include "vmHMIBoardModbusSetup.h" 
....................  
.................... #define RS485_TX_BUFF_SIZE 		20 
.................... #define RS485_RX_BUFF_SIZE 		50 
....................  
.................... //#define PIN_HIGH     			0 
.................... //#define PIN_LOW      			1 
.................... #define MODBUS_ADDRESS_FOR_SET_AVG_CALIBRATION_POINT        0x296 
.................... #define SLAVE_ID                                            0x1 
....................  
.................... #define MODE_ADDRESS                            0x05 
.................... #define ADDRESS_COUNTER_SEND_DATA               0x04 
....................  
.................... #define ADDRESS_FOR_SET_CALIB_0                 0x272 
.................... #define ADDRESS_FOR_SET_CALIB_1000              0x274 
.................... #define ADDRESS_FOR_SET_CALIB_2000              0x276 
.................... #define ADDRESS_FOR_SET_CALIB_3000              0x278 
.................... #define ADDRESS_FOR_SET_CALIB_4000              0x280 
.................... #define ADDRESS_FOR_SET_CALIB_5000              0x282 
.................... #define ADDRESS_FOR_SET_CALIB_6000              0x284 
.................... #define ADDRESS_FOR_SET_CALIB_7000              0x286 
.................... #define ADDRESS_FOR_SET_CALIB_8000              0x288 
.................... #define ADDRESS_FOR_SET_CALIB_9000              0x290 
.................... #define ADDRESS_FOR_SET_CALIB_10000             0x292 
.................... #define ADDRESS_FOR_SET_CALIB_DATA              0x296 
....................  
.................... #define ADDRESS_FOR_SET_CONFIG_AVG_WT           0x250 
.................... #define ADDRESS_FOR_SET_CONFIG_TOL_PV           0x252 
.................... #define ADDRESS_FOR_SET_CONFIG_TOL_NV           0x254 
.................... #define ADDRESS_FOR_SET_CONFIG_INDEX            0x256 
....................  
.................... #define DELAY_TIME_RTS_AFTER                        2 
.................... #define DELAY_TIME_RTS_BEFORE                       2 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... #define SIZE_TEMP_ARR_CRC_VALID                        15 
.................... #define MSG_QUEUE_EMPTY                                 0 
.................... #define MSG_QUEUE_NOT_EMPTY                             1 
.................... #define MODBUS_MASTER_QUERY_LENGTH_MIN                  8 
.................... #define MODBUS_MASTER_QUERY_LENGTH_MIX                 12 
.................... #define MODBUS_MASTER_QUERY_READ_REG_LENGTH             8 
.................... #define MODBUS_MASTER_QUERY_SINGLE_WRITE_REG_LENGTH     8 
....................  
.................... #define MODBUS_OFFSET_ONE       1 
.................... #define MODBUS_OFFSET_TWO       2 
.................... #define MODBUS_OFFSET_THREE     3 
.................... #define MODBUS_OFFSET_FOUR      4 
.................... #define MODBUS_OFFSET_FIVE      5 
.................... #define MODBUS_OFFSET_SIX       6 
.................... #define MODBUS_OFFSET_SEVEN     7 
.................... #define MODBUS_OFFSET_8         8 
.................... #define MODBUS_OFFSET_9         9 
.................... #define MODBUS_OFFSET_10        10 
.................... #define MODBUS_OFFSET_11        11 
.................... #define MODBUS_OFFSET_12        12 
.................... #define MODBUS_OFFSET_13        13 
.................... #define MODBUS_OFFSET_14        14 
.................... #define MODBUS_OFFSET_15        15 
.................... #define MODBUS_OFFSET_16        16 
....................  
.................... typedef struct _ST_ISR_QUEUE_MEMBERS 
.................... { 
....................     unsigned int8 m_ui8Arr[RS485_RX_BUFF_SIZE]; 
....................     int8 m_i8Front; 
....................     int8 m_i8Rear; 
....................      
.................... }ST_ISR_QUEUE_MEMBERS; 
....................  
.................... ST_ISR_QUEUE_MEMBERS g_stUART2RcvBuffModbus; 
.................... unsigned int8 g_ui8TempByte = 0; 
.................... unsigned int8 g_ui8TempArrForCRCValidation[SIZE_TEMP_ARR_CRC_VALID] = {0}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #define REG_DATA_LO_TO_HI                       1 // 1 = lo byte first, 2 = lo byte last 
....................  
.................... unsigned int8 g_RS485TxBuffer[RS485_TX_BUFF_SIZE] = {0}; 
.................... unsigned int8 g_RS485RxBuffer[RS485_RX_BUFF_SIZE] = {0}; 
.................... unsigned int8 g_ui8RS485RxByteCount               = 0; 
.................... unsigned int8 g_ui8ReceivedModbusResponse         = 0; 
.................... unsigned int8 g_ui8RS485MaxByteCount              = 8; 
.................... unsigned int8 g_ui8RS485Done              		  = 0; 
.................... unsigned int8 g_uiInputOutputMatch				  = 0; 
....................  
.................... unsigned int8 g_ui8Front                          = 0; 
.................... unsigned int8 g_ui8End                            = 0; 
....................  
....................  
....................  
....................  
....................  
.................... // init interept 
.................... void InitRS485RxInterrupt(void) 
.................... { 
....................     // Enable RS485 interrupt. 
....................     //clear_interrupt(INT_RDA); 
.................... 	//enable_interrupts(INT_RDA); 
....................      
....................     // Initialize Queue 
....................     g_stUART2RcvBuffModbus.m_i8Front = g_stUART2RcvBuffModbus.m_i8Rear = -1; 
....................     memset(g_stUART2RcvBuffModbus.m_ui8Arr, 0, RS485_RX_BUFF_SIZE); 
....................  
....................     clear_interrupt(INT_RDA2); 
.................... 	enable_interrupts(INT_RDA2); 
.................... } 
....................  
.................... void Delay_milisecond(unsigned int16 ui16DelayTime) 
.................... { 
.................... 	unsigned int16 ui16Counter = 0; 
.................... 	while(ui16Counter < ui16DelayTime) 
.................... 	{ 
.................... 		delay_ms(1); 
.................... 		ui16Counter++; 
.................... 	} 
.................... } 
....................  
.................... // reset buffer 
.................... void ResetRS485RxBuffer(void) 
.................... { 
....................     // Reset Rx Byte count. 
....................   //  g_ui8RS485RxByteCount       = 0; 
....................     // Set 0 to Rx Buffer. 
....................  //   memset(g_RS485RxBuffer, 0, RS485_RX_BUFF_SIZE); 
....................     g_ui8ReceivedModbusResponse--; 
....................     if(g_ui8ReceivedModbusResponse < 0) 
....................     { 
....................         g_ui8ReceivedModbusResponse = 0; 
....................     } 
....................     g_ui8RS485MaxByteCount = 8; 
....................      
....................     if((g_ui8Front == g_ui8End) && (g_ui8Front!=0)) 
....................     { 
....................         g_ui8Front = 0; 
....................         g_ui8End = 0; 
....................         g_ui8RS485RxByteCount = 0; 
....................     } 
....................      
....................     // Check if Rx Byte count is equal to the Rx Buffer capacity. 
....................     if(g_ui8RS485RxByteCount >= RS485_RX_BUFF_SIZE - 15) //g_ui8RS485MaxByteCount) 
....................     { 
....................         // Reset Rx Byte count to prevent buffer overflow. 
....................     //    g_ui8Front = 0; 
....................         g_ui8End = 0; 
....................         g_ui8RS485RxByteCount = g_ui8End;  
....................     } 
....................  
....................     // Reset holding buffer 
....................     g_ui8RS485Done = 0; 
....................    	clear_interrupt(INT_RDA2); 
.................... } 
....................  
.................... void SetHILowRS485() 
.................... {	 
....................   	//set transmit active. 
.................... 	output_bit(PIN_RS485_RTS,1); 
.................... 	delay_ms(4); 
.................... 	 
.................... 	//set transmit inactive. 
.................... 	output_bit(PIN_RS485_RTS,0); 
.................... 	delay_ms(4); 
.................... } 
....................  
.................... void TestPollRS485( 
....................                    unsigned int8 ui8SlaveID,  
....................                    unsigned int8 ui8FunctionType,  
....................                    unsigned int16 ui16StartAddress, 
....................                    unsigned int16 ui16RegisterData) 
.................... { 
.................... 	// function for send data to server/master 
.................... 	unsigned int16 ui16CRCvalue = 0; 
.................... 	 
.................... 	//value assign in transmit buffer of RS485 
....................   	g_RS485TxBuffer[0]  = ui8SlaveID; 
....................   	g_RS485TxBuffer[1]  = ui8FunctionType; //3;//Function code;read holding register. 3 for read, 6 for write 
....................   	g_RS485TxBuffer[2]  = (unsigned int8)((ui16StartAddress >> 8) & 0xFF); 
....................   	g_RS485TxBuffer[3]  = (unsigned int8)((ui16StartAddress >> 0) & 0xFF); // Address of the register. 
....................  
....................   	g_RS485TxBuffer[4]  = (unsigned int8)((ui16RegisterData >> 8) & 0xFF); 
....................   	g_RS485TxBuffer[5]  = (unsigned int8)((ui16RegisterData >> 0) & 0xFF); 
....................    	g_RS485TxBuffer[6]  = 0; 
....................   	g_RS485TxBuffer[7]  = 0; 
....................   	 
.................... 	//Calculate CRC values using function call.  
....................   	ui16CRCvalue = calculateCrc(g_RS485TxBuffer,6);  
....................   	 
.................... 	//assign CRC values in transmit buffer. 
....................   	g_RS485TxBuffer[6]  = (unsigned int8)((ui16CRCvalue >> 0) & 0xFF); 
....................   	g_RS485TxBuffer[7]  = (unsigned int8)((ui16CRCvalue >> 8) & 0xFF); 
....................   	 
....................   	//set transmit active. 
....................   	delay_ms(DELAY_TIME_RTS_BEFORE); 
.................... 	output_bit(PIN_RS485_RTS,1); 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... 	//send bytes. 
.................... 	for(unsigned int8 ui8SendBytes = 0; ui8SendBytes<8; ui8SendBytes++) 
.................... 	{ 
.................... 		fputc(g_RS485TxBuffer[ui8SendBytes],RS485); 
.................... 	} 
.................... 	//hold to bytes properly transmit. 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... 	//set transmit inactive. 
.................... 	output_bit(PIN_RS485_RTS,0); 
.................... //	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... } 
....................  
.................... // wirte to register 
.................... void WriteToOneRegRS485( 
....................                         unsigned int8 ui8SlaveID,  
....................                         unsigned int8 ui8FunctionType,  
....................                         unsigned int8 ui8Len, 
....................                         unsigned int16 ui16RegisterData) 
.................... { 
.................... 	unsigned int16 ui16CRCvalue = 0; 
.................... 	 
.................... 	//value assign in transmit buffer of RS485 
....................   	g_RS485TxBuffer[0]  = ui8SlaveID;  //37; 
....................   	g_RS485TxBuffer[1]  = ui8FunctionType;  //3; 
....................   	g_RS485TxBuffer[2]  = ui8Len;  //2; 
....................  
....................   	g_RS485TxBuffer[3]  = (unsigned int8)((ui16RegisterData >> 8) & 0xFF); 
....................   	g_RS485TxBuffer[4]  = (unsigned int8)((ui16RegisterData >> 0) & 0xFF); 
....................   	g_RS485TxBuffer[5]  = 0; 
....................    	g_RS485TxBuffer[6]  = 0; 
....................   	g_RS485TxBuffer[7]  = 0; 
....................   	 
.................... 	//Calculate CRC values using function call.  
....................   	ui16CRCvalue = calculateCrc(g_RS485TxBuffer,5);  
....................   	 
.................... 	//assign CRC values in transmit buffer. 
....................   	g_RS485TxBuffer[5]  = (unsigned int8)((ui16CRCvalue >> 0) & 0xFF); 
....................   	g_RS485TxBuffer[6]  = (unsigned int8)((ui16CRCvalue >> 8) & 0xFF); 
....................   	 
....................   	//set transmit active. 
....................   	delay_ms(DELAY_TIME_RTS_BEFORE); 
.................... 	output_bit(PIN_RS485_RTS,1); 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... 	//send bytes. 
.................... 	for(unsigned int8 ui8SendBytes = 0; ui8SendBytes<7; ui8SendBytes++) 
.................... 	{ 
.................... 		fputc(g_RS485TxBuffer[ui8SendBytes],RS485); 
.................... 	} 
.................... 	//hold to bytes properly transmit. 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... 	//set transmit inactive. 
.................... 	output_bit(PIN_RS485_RTS,0); 
.................... //	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... } 
....................  
.................... // write to a register 
.................... void WriteToTwoRegRS485( 
....................                         unsigned int8 ui8SlaveID,  
....................                         unsigned int8 ui8FunctionType,  
....................                         unsigned int8 ui8Len, 
....................                         unsigned int16 ui16RegisterData1,  
....................                         unsigned int16 ui16RegisterData2) 
.................... { 
.................... 	unsigned int16 ui16CRCvalue = 0; 
.................... 	 
.................... 	//value assign in transmit buffer of RS485 
....................   	g_RS485TxBuffer[0]  = ui8SlaveID; 
....................   	g_RS485TxBuffer[1]  = ui8FunctionType; 
....................   	g_RS485TxBuffer[2]  = ui8Len; 
....................  
....................   	g_RS485TxBuffer[3]  = (unsigned int8)((ui16RegisterData1 >> 8) & 0xFF); 
....................   	g_RS485TxBuffer[4]  = (unsigned int8)((ui16RegisterData1 >> 0) & 0xFF); 
....................   	 
....................   	g_RS485TxBuffer[5]  = (unsigned int8)((ui16RegisterData2 >> 8) & 0xFF); 
....................   	g_RS485TxBuffer[6]  = (unsigned int8)((ui16RegisterData2 >> 0) & 0xFF); 
....................  
....................    	g_RS485TxBuffer[7]  = 0; 
....................   	g_RS485TxBuffer[8]  = 0; 
....................   	 
.................... 	//Calculate CRC values using function call.  
....................   	ui16CRCvalue        = calculateCrc(g_RS485TxBuffer,7);  
....................   	 
.................... 	//assign CRC values in transmit buffer. 
....................   	g_RS485TxBuffer[7]  = (unsigned int8)((ui16CRCvalue >> 0) & 0xFF); 
....................   	g_RS485TxBuffer[8]  = (unsigned int8)((ui16CRCvalue >> 8) & 0xFF); 
....................   	 
....................   	//set transmit active. 
....................   	delay_ms(DELAY_TIME_RTS_BEFORE); 
.................... 	output_bit(PIN_RS485_RTS,1); 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... 	//send bytes. 
.................... 	for(unsigned int8 ui8SendBytes = 0; ui8SendBytes<9; ui8SendBytes++) 
.................... 	{ 
.................... 		fputc(g_RS485TxBuffer[ui8SendBytes],RS485); 
.................... 	} 
.................... 	//hold to bytes properly transmit. 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... 	//set transmit inactive. 
.................... 	output_bit(PIN_RS485_RTS,0); 
.................... //	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... } 
....................  
.................... // write to a register 
.................... void WriteToThreeRegRS485( 
....................     unsigned int8  ui8SlaveID, 
....................     unsigned int8  ui8FunctionType, 
....................     unsigned int8  ui8Len, 
....................     unsigned int16 ui16RegisterData1, 
....................     unsigned int16 ui16RegisterData2, 
....................     unsigned int16 ui16RegisterData3) 
.................... { 
.................... 	unsigned int16 ui16CRCvalue = 0; 
.................... 	 
.................... 	//value assign in transmit buffer of RS485 
....................   	g_RS485TxBuffer[0]  = ui8SlaveID; 
....................   	g_RS485TxBuffer[1]  = ui8FunctionType; 
....................   	g_RS485TxBuffer[2]  = ui8Len; 
....................  
....................   	g_RS485TxBuffer[3]  = (unsigned int8)((ui16RegisterData1 >> 8) & 0x00FF); 
....................   	g_RS485TxBuffer[4]  = (unsigned int8)((ui16RegisterData1 >> 0) & 0x00FF); 
....................   	 
....................   	g_RS485TxBuffer[5]  = (unsigned int8)((ui16RegisterData2 >> 8) & 0x00FF); 
....................   	g_RS485TxBuffer[6]  = (unsigned int8)((ui16RegisterData2 >> 0) & 0x00FF); 
....................  
....................    	g_RS485TxBuffer[7]  = (unsigned int8)((ui16RegisterData3 >> 8) & 0x00FF); 
....................   	g_RS485TxBuffer[8]  = (unsigned int8)((ui16RegisterData3 >> 0) & 0x00FF); 
....................   	 
.................... 	//Calculate CRC values using function call.  
....................   	ui16CRCvalue        = calculateCrc(g_RS485TxBuffer,9);  
....................   	 
.................... 	//assign CRC values in transmit buffer. 
....................   	g_RS485TxBuffer[9]   = (unsigned int8)((ui16CRCvalue >> 0) & 0x00FF); 
....................   	g_RS485TxBuffer[10]  = (unsigned int8)((ui16CRCvalue >> 8) & 0x00FF); 
....................   	 
....................   	//set transmit active. 
....................   	delay_ms(DELAY_TIME_RTS_BEFORE); 
.................... 	output_bit(PIN_RS485_RTS,1); 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
....................     delay_ms(3); 
.................... 	//send bytes. 
.................... 	for(unsigned int8 ui8SendBytes = 0; ui8SendBytes<11; ui8SendBytes++) 
.................... 	{ 
.................... 		fputc(g_RS485TxBuffer[ui8SendBytes],RS485); 
.................... 	} 
.................... 	//hold to bytes properly transmit. 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... 	//set transmit inactive. 
.................... 	output_bit(PIN_RS485_RTS,0); 
.................... //	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... } 
....................  
.................... // write to a register 
.................... void ReplyForTwoRegister( 
....................                         unsigned int8 ui8SlaveID,  
....................                         unsigned int8 ui8FunctionType,  
....................                         unsigned int8 ui8Len, 
....................                         unsigned int16 ui16RegisterAddress,  
....................                         unsigned int16 ui16RegisterData1,  
....................                         unsigned int16 ui16RegisterData2) 
.................... { 
.................... 	unsigned int16 ui16CRCvalue = 0; 
.................... 	 
.................... 	//value assign in transmit buffer of RS485 
....................   	g_RS485TxBuffer[0]  = ui8SlaveID; 
....................   	g_RS485TxBuffer[1]  = ui8FunctionType; 
....................   	g_RS485TxBuffer[2]  = (unsigned int8)((ui16RegisterAddress >> 8) & 0xFF); 
....................   	g_RS485TxBuffer[3]  = (unsigned int8)((ui16RegisterAddress >> 0) & 0xFF); 
....................   	g_RS485TxBuffer[4]  = (unsigned int8)((ui8Len >> 8) & 0xFF); 
....................   	g_RS485TxBuffer[5]  = (unsigned int8)((ui8Len >> 0) & 0xFF); 
....................      
....................   	g_RS485TxBuffer[6]  = 2 * ui8Len; 
....................  
....................   	g_RS485TxBuffer[7]  = (unsigned int8)((ui16RegisterData1 >> 8) & 0xFF); 
....................   	g_RS485TxBuffer[8]  = (unsigned int8)((ui16RegisterData1 >> 0) & 0xFF); 
....................   	 
....................   	g_RS485TxBuffer[9]  = (unsigned int8)((ui16RegisterData2 >> 8) & 0xFF); 
....................   	g_RS485TxBuffer[10]  = (unsigned int8)((ui16RegisterData2 >> 0) & 0xFF); 
....................  
....................    	g_RS485TxBuffer[11]  = 0; 
....................   	g_RS485TxBuffer[12]  = 0; 
....................   	 
.................... 	//Calculate CRC values using function call.  
....................   	ui16CRCvalue        = calculateCrc(g_RS485TxBuffer,11);  
....................   	 
.................... 	//assign CRC values in transmit buffer. 
....................   	g_RS485TxBuffer[11]  = (unsigned int8)((ui16CRCvalue >> 0) & 0xFF); 
....................   	g_RS485TxBuffer[12]  = (unsigned int8)((ui16CRCvalue >> 8) & 0xFF); 
....................   	 
....................   	//set transmit active. 
....................   	delay_ms(DELAY_TIME_RTS_BEFORE); 
.................... 	output_bit(PIN_RS485_RTS,1); 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... 	//send bytes. 
.................... 	for(unsigned int8 ui8SendBytes = 0; ui8SendBytes<13; ui8SendBytes++) 
.................... 	{ 
.................... 		fputc(g_RS485TxBuffer[ui8SendBytes],RS485); 
.................... 	} 
.................... 	//hold to bytes properly transmit. 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... 	//set transmit inactive. 
.................... 	output_bit(PIN_RS485_RTS,0); 
.................... //	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... } 
....................  
.................... // is bit is on a data 
.................... int8 IsBitOn(int8 uiBitIndex, int16 u16RegData) 
.................... { 
.................... 	int8 uiRetVal   = 1; 
.................... 	int8 uiMaxBits  = 15; 
.................... 	 
.................... 	int16 u16Data   = u16RegData << (uiMaxBits-uiBitIndex); 
.................... 	 
.................... 	u16Data         = u16Data >> uiMaxBits; 
.................... 	 
.................... 	if(u16Data == 1)  
.................... 		uiRetVal = 0; 
.................... 	else  
.................... 		uiRetVal = 1;	 
.................... 	return uiRetVal; 
.................... } 
....................  
.................... // set bit on in a data 
.................... int32 SetBitOn(int8 uiBitIndex, int32 u32RegData) 
.................... { 
.................... 	int32 uiRetVal = u32RegData; 
.................... 	int8 uiMaxBits = 31; 
.................... 	 
.................... 	if(uiBitIndex > uiMaxBits)  
....................     { 
.................... 		return uiRetVal; 
.................... 	} 
.................... 	uiRetVal = uiRetVal | (1 << uiBitIndex); 
.................... 	 
.................... 	return uiRetVal; 
.................... } 
....................  
.................... // dlear a bit from data 
.................... int32 ClearBitOn(int8 uiBitIndex, int32 u32RegData) 
.................... { 
.................... 	int32 uiRetVal = u32RegData; 
.................... 	int8 uiMaxBits = 31; 
.................... 	 
.................... 	if(uiBitIndex > uiMaxBits) { 
.................... 		return uiRetVal; 
.................... 	} 
.................... 	uiRetVal = uiRetVal & ~(1 << uiBitIndex); 
.................... 	 
.................... 	return uiRetVal; 
.................... } 
....................  
.................... // toggle bit on 
.................... int32 ToggleBitOn(int8 uiBitIndex, int32 u32RegData) 
.................... { 
.................... 	int32 uiRetVal = u32RegData; 
.................... 	int8 uiMaxBits = 31; 
.................... 	 
.................... 	if(uiBitIndex > uiMaxBits) { 
.................... 		return uiRetVal; 
.................... 	} 
.................... 	uiRetVal = uiRetVal ^ (1 << uiBitIndex); 
.................... 	 
.................... 	return uiRetVal; 
.................... } 
....................  
.................... //// wait for movement completion 
.................... //int8 WaitForMovementCompletion() 
.................... //{ 
.................... //	int8 uiRetVal = 0; 
.................... //	if((SLAVE_ID != SLAVE_ID_FOR_LA_1) && (SLAVE_ID != SLAVE_ID_FOR_LA_2)) 
.................... //	{ 
.................... //		return; 
.................... //	} 
.................... //		 
.................... //	delay_ms(1000); 
.................... //	int8 uiDIVal7   = 1; 
.................... //	 
.................... //	int8 uiIndex    = 0; 
.................... //	 
.................... //	while(1) 
.................... //	{ 
.................... //		uiIndex++; 
.................... //		uiDIVal7 = input(PIN_IN_DI_06);  
.................... //		if(uiDIVal7 == 0) 
.................... //		{ 
.................... //			uiRetVal = 1; 
.................... //			break; 
.................... //		} 
.................... //		if(uiIndex == 100)  
.................... //		{ 
.................... //			break; 
.................... //		} 
.................... //	} 
.................... //	 
.................... //	// if ok then return 1 
.................... //	return uiRetVal; 
.................... //} 
....................  
....................  
.................... void PollRS485( 
....................                 unsigned int8 uiFunctionCode,  
....................                 unsigned int16 ui16StartAddress,  
....................                 unsigned int16 ui16FirstRegisterData,  
....................                 unsigned int16 ui16SecondregisterData) 
.................... { 
.................... 	// function for polling data 
.................... 	unsigned int16 ui16CRCvalue = 0; 
.................... 	 
.................... 	//Reset the receiver buffer. 
.................... 	ResetRS485RxBuffer(); 
.................... 	 
.................... 	g_RS485TxBuffer[0]  = SLAVE_ID; 
.................... 	g_RS485TxBuffer[1]  = uiFunctionCode;// Function code. 
.................... 	g_RS485TxBuffer[2]  = ((ui16StartAddress >> 8)& 0xFF); 
.................... 	g_RS485TxBuffer[3]  = ((ui16StartAddress >> 0)& 0xFF); 
.................... 	g_RS485TxBuffer[4]  = 0x00; 
.................... 	g_RS485TxBuffer[5]  = 0x02;// Number of registers to write. 
.................... 	g_RS485TxBuffer[6]  = 0x04;// Number of bytes to write.  
.................... 	g_RS485TxBuffer[7]  = (unsigned int8)((ui16FirstRegisterData >> 8)& 0xFF); 
.................... 	g_RS485TxBuffer[8]  = (unsigned int8)((ui16FirstRegisterData >> 0)& 0xFF);// Data of the first register. 
.................... 	g_RS485TxBuffer[9]  = (unsigned int8)((ui16SecondregisterData >> 8)& 0xFF); 
.................... 	g_RS485TxBuffer[10] = (unsigned int8)((ui16SecondregisterData >> 0)& 0xFF);// Data of the second register.  
.................... 	g_RS485TxBuffer[11] = 0; 
.................... 	g_RS485TxBuffer[12] = 0; 
.................... 	 
.................... 	//Function call CRC calculation. 
.................... 	ui16CRCvalue = ModbusCRC16(g_RS485TxBuffer,11); 
.................... 	 
.................... 	g_RS485TxBuffer[11] = (unsigned int8)((ui16CRCvalue >> 0)& 0xFF); 
.................... 	g_RS485TxBuffer[12] = (unsigned int8)((ui16CRCvalue >> 8)& 0xFF); 
....................  
.................... 	//set transmit active. 
.................... 	delay_ms(2); 
.................... 	output_bit(PIN_RS485_RTS,1); 
.................... 	delay_ms(3); 
.................... 	//send bytes. 
.................... 	for(unsigned int8 ui8SendBytes = 0; ui8SendBytes<13; ui8SendBytes++) 
.................... 	{ 
.................... 		fputc(g_RS485TxBuffer[ui8SendBytes],RS485); 
.................... 	} 
.................... 	//hold to bytes properly transmit. 
.................... 	delay_ms(3); 
.................... 	//set transmit inactive. 
.................... 	output_bit(PIN_RS485_RTS,0); 
.................... 	delay_ms(3); 
.................... } 
....................  
.................... ////=============================== START NEW CODE ====================================================== 
.................... #INT_RDA2 
.................... void RS485_RxByteReady_ISR2(void) 
.................... { 
....................      
....................     // Checking for Is ISR ready flag. 
....................     if(ISR_IS_NOT_READY == g_fIsReadyToReceiveByte) 
....................     { 
....................         g_fIsReadyToReceiveByte = ISR_IS_READY; 
....................     } 
....................      
....................     g_ui8TempByte = fgetc(RS485); 
....................      
....................     // Checking queue boundary conditions. 
....................     if(g_stUART2RcvBuffModbus.m_i8Front == -1 && g_stUART2RcvBuffModbus.m_i8Rear == -1) 
....................     { 
....................         // Initialize queue front and rear. 
....................         g_stUART2RcvBuffModbus.m_i8Front = g_stUART2RcvBuffModbus.m_i8Rear = 0; 
....................          
....................         // Inserting first element. 
....................         g_stUART2RcvBuffModbus.m_ui8Arr[g_stUART2RcvBuffModbus.m_i8Rear] = g_ui8TempByte; 
....................     }  
....................     else if((RS485_RX_BUFF_SIZE - 1) == g_stUART2RcvBuffModbus.m_i8Rear && g_stUART2RcvBuffModbus.m_i8Front > 0) 
....................     { 
....................         // Rear reached last position..initialize it. 
....................         g_stUART2RcvBuffModbus.m_i8Rear = 0; 
....................         // Then insert data. 
....................         g_stUART2RcvBuffModbus.m_ui8Arr[g_stUART2RcvBuffModbus.m_i8Rear] = g_ui8TempByte; 
....................     } 
....................     else if(((RS485_RX_BUFF_SIZE - 1) == g_stUART2RcvBuffModbus.m_i8Rear && g_stUART2RcvBuffModbus.m_i8Front == 0) || 
....................             (g_stUART2RcvBuffModbus.m_i8Rear == g_stUART2RcvBuffModbus.m_i8Front - 1)) 
....................     { 
....................         // Queue is full 
....................         //TODO Handle This 
....................     } 
....................     else  
....................     { 
....................         g_stUART2RcvBuffModbus.m_i8Rear++; 
....................         g_stUART2RcvBuffModbus.m_ui8Arr[g_stUART2RcvBuffModbus.m_i8Rear] = g_ui8TempByte; 
....................     } 
....................      
.................... 	// Clear interrupt. 
.................... 	clear_interrupt(INT_RDA2); 
.................... } 
....................  
.................... BYTE GetUART2Queue(BYTE* pbIsQueueEmpty ) 
.................... { 
....................     BYTE bData = 0; 
....................      
....................     *pbIsQueueEmpty = MSG_QUEUE_NOT_EMPTY; 
....................  
....................     if (-1 == g_stUART2RcvBuffModbus.m_i8Front) 
....................     { 
....................         // Queue is empty 
....................         *pbIsQueueEmpty = MSG_QUEUE_EMPTY; 
....................         return 0; 
....................     } 
....................      
....................     bData = g_stUART2RcvBuffModbus.m_ui8Arr[g_stUART2RcvBuffModbus.m_i8Front]; 
....................     g_stUART2RcvBuffModbus.m_ui8Arr[g_stUART2RcvBuffModbus.m_i8Front] = 0;  // Fill the Queue by 0 
....................      
....................     if (g_stUART2RcvBuffModbus.m_i8Front == g_stUART2RcvBuffModbus.m_i8Rear) 
....................     { 
....................         g_stUART2RcvBuffModbus.m_i8Front = g_stUART2RcvBuffModbus.m_i8Rear = -1; 
....................     } 
....................     else if ((RS485_RX_BUFF_SIZE - 1) == g_stUART2RcvBuffModbus.m_i8Front) 
....................     { 
....................         g_stUART2RcvBuffModbus.m_i8Front = 0; 
....................     } 
....................     else 
....................     { 
....................         g_stUART2RcvBuffModbus.m_i8Front++; 
....................     } 
....................      
....................     // Return Data 
....................     return bData; 
.................... } 
....................  
.................... int8 GetQueueLength() 
.................... { 
....................     // Check if Front is less then rear, Normal case 
....................     if (g_stUART2RcvBuffModbus.m_i8Front < g_stUART2RcvBuffModbus.m_i8Rear) 
....................     { 
....................         return (g_stUART2RcvBuffModbus.m_i8Rear - g_stUART2RcvBuffModbus.m_i8Front + 1); 
....................     } 
....................     // Else if the Rear precedes front 
....................     else if (g_stUART2RcvBuffModbus.m_i8Front > g_stUART2RcvBuffModbus.m_i8Rear) 
....................     { 
....................         return ((RS485_RX_BUFF_SIZE - g_stUART2RcvBuffModbus.m_i8Front) + 
....................                 g_stUART2RcvBuffModbus.m_i8Rear + 1); 
....................          
....................     } 
....................     // If the queue is empty 
....................     return 0; 
.................... } 
....................  
.................... void EmptyQueue() 
.................... { 
....................     g_stUART2RcvBuffModbus.m_i8Front = g_stUART2RcvBuffModbus.m_i8Rear = -1; 
.................... } 
....................  
.................... unsigned int8 CheckValidityForReadReg(void) 
.................... { 
....................     unsigned int16 ui16CRCValue       = 0; 
....................     BYTE           bIsQueueEmpty      = MSG_QUEUE_NOT_EMPTY; 
....................     BYTE           bTemp              = 0; 
....................     unsigned int8  ui8IsValidResponse = 0; 
....................     int8           i8LoopCount        = 0; 
....................     int8           i8TempFront        = g_stUART2RcvBuffModbus.m_i8Front; 
....................      
....................     // Step 1: Populate the Message in a temporary array 
....................     g_ui8TempArrForCRCValidation[0] = SLAVE_ID; 
....................     for(i8LoopCount = 1; i8LoopCount != MODBUS_MASTER_QUERY_READ_REG_LENGTH - 2; i8LoopCount++) 
....................     { 
....................         g_ui8TempArrForCRCValidation[i8LoopCount] = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront++]; 
....................     } 
....................      
....................     // Calculate CRC value with received bytes for validation. 
....................     ui16CRCValue = calculateCrc(g_ui8TempArrForCRCValidation, MODBUS_MASTER_QUERY_READ_REG_LENGTH - 2); 
....................      
....................     // Match with received first CRC byte 
....................     bTemp = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront++]; 
....................     if(bTemp == (unsigned int8)((ui16CRCValue >> 0) & 0xFF)) 
....................     { 
....................         // Match with received second CRC byte. 
....................         bTemp = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront]; 
....................         if(bTemp == (unsigned int8)((ui16CRCValue >> 8) & 0xFF)) 
....................         { 
....................             // Update flag denote CRC bytes matched..valid response. 
....................             ui8IsValidResponse = 1; 
....................         } 
....................     } 
....................      
....................     return ui8IsValidResponse; 
.................... } 
....................  
.................... // send response 
.................... void SendRS485Response() 
.................... { 
.................... 	// function for sending reply 
.................... 	 
.................... 	//value assign in transmit buffer of RS485 
....................     int8 i8TempFront             = 0; 
....................     BYTE ui8Temp                 = 0; 
....................     int8 i8TempLen               = 0;   
....................     int8 i8IndexTx               = 0;   
....................              
....................     i8TempFront = g_stUART2RcvBuffModbus.m_i8Front;     
....................     ui8Temp     = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront];  // g_ui8TempArrForCRCValidation 
....................     i8TempLen   = GetQueueLength(); 
....................      
....................     g_RS485TxBuffer[i8IndexTx] = SLAVE_ID; 
....................     i8IndexTx++; 
.................... 	for(int8 i8Index = i8TempFront; i8Index <= i8TempLen; i8Index++) 
.................... 	{ 
.................... 		g_RS485TxBuffer[i8IndexTx]= g_stUART2RcvBuffModbus.m_ui8Arr[i8Index];  
....................         i8IndexTx++; 
.................... 	} 
.................... 	 
....................   	//set transmit active. 
....................   	delay_ms(DELAY_TIME_RTS_BEFORE); 
.................... 	output_bit(PIN_RS485_RTS,1); 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... 	 
.................... 	//send bytes. 
.................... 	for(unsigned int8 ui8SendBytes = 0; ui8SendBytes <= i8TempLen; ui8SendBytes++) // g_ui8RS485MaxByteCount 
.................... 	{ 
.................... 		fputc(g_RS485TxBuffer[ui8SendBytes],RS485); 
.................... 	} 
.................... 	 
.................... 	//hold to bytes properly transmit. 
.................... 	 
.................... 	//set transmit inactive. 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... 	output_bit(PIN_RS485_RTS,0); 
.................... //	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... } 
....................  
.................... // send response 
.................... void SendRS485ResponseForMultipleRegWrite() 
.................... { 
.................... 	// function for sending reply 
.................... 	 
.................... 	//value assign in transmit buffer of RS485 
....................     int8 i8TempFront             = 0; 
....................     BYTE ui8Temp                 = 0; 
....................     int8 i8TempLen               = 0;   
....................     int8 i8IndexTx               = 0;   
....................             	// function for polling data 
.................... 	unsigned int16 ui16CRCvalue = 0; 
....................      
....................     i8TempFront = g_stUART2RcvBuffModbus.m_i8Front;     
....................     ui8Temp     = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront];  // g_ui8TempArrForCRCValidation 
....................     i8TempLen   = 6; 
....................      
....................     g_RS485TxBuffer[i8IndexTx] = SLAVE_ID; 
....................     i8IndexTx++; 
.................... 	for(int8 i8Index = i8TempFront; i8IndexTx < i8TempLen; i8Index++) 
.................... 	{ 
.................... 		g_RS485TxBuffer[i8IndexTx]= g_stUART2RcvBuffModbus.m_ui8Arr[i8Index];  
....................         i8IndexTx++; 
.................... 	} 
.................... 	 
....................     	//Function call CRC calculation. 
.................... 	ui16CRCvalue = ModbusCRC16(g_RS485TxBuffer,6); 
.................... 	 
.................... 	g_RS485TxBuffer[6] = (unsigned int8)((ui16CRCvalue >> 0)& 0xFF); 
.................... 	g_RS485TxBuffer[7] = (unsigned int8)((ui16CRCvalue >> 8)& 0xFF); 
....................  
....................   	//set transmit active. 
....................   	delay_ms(DELAY_TIME_RTS_BEFORE); 
.................... 	output_bit(PIN_RS485_RTS,1); 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... 	 
.................... 	//send bytes. 
.................... 	for(unsigned int8 ui8SendBytes = 0; ui8SendBytes <= 7; ui8SendBytes++) // g_ui8RS485MaxByteCount 
.................... 	{ 
.................... 		fputc(g_RS485TxBuffer[ui8SendBytes],RS485); 
.................... 	} 
.................... 	 
.................... 	//hold to bytes properly transmit. 
.................... 	 
.................... 	//set transmit inactive. 
.................... 	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... 	output_bit(PIN_RS485_RTS,0); 
.................... //	delay_ms(DELAY_TIME_RTS_AFTER); 
.................... } 
....................  
.................... void MakeData(void) 
.................... { 
.................... 	//value assign in transmit buffer of RS485 
....................     int8 i8TempFront             = 0; 
....................     BYTE ui8Temp                 = 0; 
....................     int8 i8TempLen               = 0;   
....................     unsigned int16 ui16Address    = 0; 
....................     unsigned int16 ui16RegData    = 0; 
....................      
....................     g_ModbusRx.ui8Slaveid = SLAVE_ID; 
....................     g_ModbusRx.func = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_ONE]; 
....................              
....................     i8TempFront = g_stUART2RcvBuffModbus.m_i8Front;     
....................     ui8Temp     = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront];  // g_ui8TempArrForCRCValidation 
....................     i8TempLen   = GetQueueLength(); 
....................      
.................... 	int8 i8AddH = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_TWO]; 
.................... 	int8 i8AddL = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_THREE]; 
.................... 	 
....................     g_ModbusRx.u16Address = i8AddH; 
.................... 	g_ModbusRx.u16Address <<= 8; 
.................... 	g_ModbusRx.u16Address += i8AddL; 
.................... 	 
.................... 	int8 i8DataH = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_FOUR]; 
.................... 	int8 i8DataL = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_FIVE]; 
.................... 	 
.................... 	unsigned int16 ui16WriteAddress = ui16Address + 1; 
.................... 	 
.................... 	g_ModbusRx.u16LenData = i8DataH; 
.................... 	g_ModbusRx.u16LenData <<= 8; 
.................... 	g_ModbusRx.u16LenData += i8DataL; 
....................      
....................      
....................     	// prepare data for multiple register or coils 
.................... 	if((g_ModbusRx.func == RS485_FUNCTION_WRITE_MULTIPLE_REGISTERS) || (g_ModbusRx.func == RS485_FUNCTION_READ_MULTIPLE_REGISTERS))  
.................... 	{ 
.................... 		g_ModbusRx.ui8NoRegDataBytes = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_SIX]; 
.................... 		int8 iStartIndx = i8TempFront+7; 
.................... 		int8 iRegIndx = 0; 
.................... 	 
.................... 		for(int i = 0; i < g_ModbusRx.ui8NoRegDataBytes; )  
.................... 		{ 
.................... 			int8 i8DataH = g_stUART2RcvBuffModbus.m_ui8Arr[iStartIndx]; 
.................... 			int8 i8DataL = g_stUART2RcvBuffModbus.m_ui8Arr[iStartIndx+MODBUS_OFFSET_ONE]; 
.................... 	 
.................... 			unsigned int16 u16LenData = i8DataH; 
.................... 			u16LenData <<= 8; 
.................... 			u16LenData += i8DataL; 
.................... 			 
.................... 			g_ModbusRx.ui16RegisterDataArr[iRegIndx] = u16LenData; 
.................... 			 
.................... 			iStartIndx +=2; 
.................... 			iRegIndx++; 
.................... 			i +=2; 
.................... 		} 
.................... 	 
.................... 		unsigned int32 u32RegData = 0; 
.................... 		 
.................... 		if(REG_DATA_LO_TO_HI == 1)  
.................... 		{ 
.................... 			int8 j = iRegIndx-1; 
.................... 			 
.................... 			for(int8 count = 0; count < iRegIndx; count++)  
.................... 			{ 
.................... 				unsigned int16 u16LenData = g_ModbusRx.ui16RegisterDataArr[j]; 
.................... 					 
.................... 				if(j == (iRegIndx-1))  
.................... 				{ 
.................... 					u32RegData = u16LenData; 
.................... 				} 
.................... 				else  
.................... 				{ 
.................... 					u32RegData <<= 16; 
.................... 					u32RegData += u16LenData; 
.................... 				} 
.................... 				j--; 
.................... 			} 
.................... 		} 
.................... 		else  
.................... 		{ 
.................... 			int8 j = 0; 
.................... 			 
.................... 			for(int8 count = 0; count < iRegIndx; count++)  
.................... 			{ 
.................... 				unsigned int16 u16LenData = g_ModbusRx.ui16RegisterDataArr[j]; 
.................... 					 
.................... 				if(j == 0)  
.................... 				{ 
.................... 					u32RegData = u16LenData; 
.................... 				} 
.................... 				else  
.................... 				{ 
.................... 					u32RegData <<= 16; 
.................... 					u32RegData += u16LenData; 
.................... 				} 
.................... 				j++; 
.................... 			} 
.................... 		} 
.................... 		 
.................... 		g_ModbusRx.u32RegData = u32RegData; 
.................... 	} 
.................... 	else  
.................... 	{ 
.................... 		// prepare data for single register or coil 
.................... 		g_ModbusRx.ui8NoRegDataBytes = 0; 
.................... 		if(g_ModbusRx.func == RS485_FUNCTION_WRITE_SINGLE_REGISTER)  
.................... 		{ 
.................... 			g_ModbusRx.ui16RegisterDataArr[0] = g_ModbusRx.u16LenData; 
.................... 			g_ModbusRx.u32RegData = g_ModbusRx.u16LenData; 
.................... 		} 
.................... 	} 
.................... 		         
.................... } 
.................... void ProcessSingleRegister(void) 
.................... { 
.................... 	// function for process single register 
.................... 	 
.................... 	//value assign in transmit buffer of RS485 
....................     int8 i8TempFront              = 0; 
....................     BYTE ui8Temp                  = 0; 
....................     int8 i8TempLen                = 0;   
....................     unsigned int16 ui16Address    = 0; 
....................     unsigned int16 ui16RegData    = 0; 
....................      
....................              
....................     i8TempFront = g_stUART2RcvBuffModbus.m_i8Front;     
....................     ui8Temp     = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront];  // g_ui8TempArrForCRCValidation 
....................     i8TempLen   = GetQueueLength(); 
....................      
.................... 	int8 i8AddH = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_TWO - 1]; 
.................... 	int8 i8AddL = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_THREE - 1]; 
.................... 	 
....................     ui16Address = i8AddH; 
.................... 	ui16Address <<= 8; 
.................... 	ui16Address += i8AddL; 
....................      
.................... 	 
.................... 	int8 i8DataH = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_FOUR -1]; 
.................... 	int8 i8DataL = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_FIVE -1]; 
.................... 	 
.................... 	unsigned int16 ui16WriteAddress = ui16Address + 1; 
.................... 	 
.................... 	ui16RegData = i8DataH; 
.................... 	ui16RegData <<= 8; 
.................... 	ui16RegData += i8DataL; 
.................... 		     
....................     // set led on or off depending on received bytes 
....................     unsigned int8 ui8RetVal1  = IsBitOn(0,ui16RegData); 
....................     unsigned int8 ui8RetVal2  = IsBitOn(1,ui16RegData); 
....................     unsigned int8 ui8RetVal3  = IsBitOn(2,ui16RegData); 
....................     unsigned int8 ui8RetVal4  = IsBitOn(3,ui16RegData); 
....................     unsigned int8 ui8RetVal5  = IsBitOn(4,ui16RegData); 
....................     unsigned int8 ui8RetVal6  = IsBitOn(5,ui16RegData); 
....................     unsigned int8 ui8RetVal7  = IsBitOn(6,ui16RegData); 
....................     unsigned int8 ui8RetVal8  = IsBitOn(7,ui16RegData); 
....................     unsigned int8 ui8RetVal9  = IsBitOn(8,ui16RegData); 
....................     unsigned int8 ui8RetVal10 = IsBitOn(9,ui16RegData); 
....................     unsigned int8 ui8RetVal11 = IsBitOn(10,ui16RegData); 
....................     unsigned int8 ui8RetVal12 = IsBitOn(11,ui16RegData); 
....................     unsigned int8 ui8RetVal13 = IsBitOn(12,ui16RegData); 
....................     unsigned int8 ui8RetVal14 = IsBitOn(13,ui16RegData); 
....................     unsigned int8 ui8RetVal15 = IsBitOn(14,ui16RegData); 
....................     unsigned int8 ui8RetVal16 = IsBitOn(15,ui16RegData); 
....................      
....................     // Set Mode  
....................     switch(ui16Address) 
....................     { 
....................         case MODE_ADDRESS: 
....................         { 
....................             switch(ui16RegData) 
....................             { 
....................                 case MODE_TYPE_NOTHING: 
....................                 { 
....................                     SetModeNothing(); 
....................                    // output_bit(PIN_OUT_DO_00,0); 
....................                 } 
....................                 break; 
....................                 case MODE_TYPE_HOME: 
....................                 { 
....................                     SetModeHome(); 
....................                  //   output_bit(PIN_OUT_DO_01,0); 
....................                 } 
....................                 break; 
....................                 case MODE_TYPE_PRE_PRODUCTION: 
....................                 { 
....................                     SetModePreProduction(); 
....................                 //    output_bit(PIN_OUT_DO_02,0); 
....................                 } 
....................                 break; 
....................                 case MODE_TYPE_PRODUCTION: 
....................                 { 
....................                     SetModeProduction(); 
....................                 //    output_bit(PIN_OUT_DO_03,0); 
....................                 } 
....................                 break; 
....................                 case MODE_TYPE_CONFIGURATION:  
....................                 { 
....................                     SetModeConfiguration(); 
....................                 //    output_bit(PIN_OUT_DO_04,0); 
....................                 } 
....................                 break; 
....................                 case MODE_TYPE_CALIBRATION: 
....................                 { 
....................                     SetModeCalibration(); 
....................                 //    output_bit(PIN_OUT_DO_05,0); 
....................                 } 
....................                 break; 
....................             }; 
....................         } 
....................         break; 
....................         case ADDRESS_FOR_SET_CONFIG_AVG_WT: 
....................         { 
....................             g_ui16RegisterAvgWeight = ui16RegData; 
....................         } 
....................         break; 
....................         case ADDRESS_FOR_SET_CONFIG_TOL_PV: 
....................         { 
....................             g_ui16RegisterTolPv = ui16RegData; 
....................         } 
....................         break; 
....................         case ADDRESS_FOR_SET_CONFIG_TOL_NV: 
....................         { 
....................             g_ui16RegisterTolNv = ui16RegData; 
....................         } 
....................         break; 
....................         case ADDRESS_FOR_SET_CONFIG_INDEX: 
....................         { 
....................             g_ui16RegisterCurrProductIndex = ui16RegData; 
....................         } 
....................         break; 
....................  
....................     }; 
.................... } 
....................  
.................... void ProcessUART2ReceivedData(void) 
.................... { 
....................     BYTE ui8Temp                 = 0; 
....................     BYTE bIsQueueEmpty           = MSG_QUEUE_NOT_EMPTY; 
....................     BYTE bIsValidMSG             = FALSE; 
....................     int8 i8TempFront             = 0; 
....................     int8 i8MainProcessLoopStatue = 0; 
....................     int8 i8TempLen               = 0;   
....................      
....................      
....................     do 
....................     { 
....................         // Step 1: Seek for Slave ID 
....................         do 
....................         { 
....................             // Get Queue 
....................             ui8Temp = GetUART2Queue(&bIsQueueEmpty); 
....................             if (MSG_QUEUE_EMPTY == bIsQueueEmpty) 
....................             { 
....................                 // Return 
....................                 break;    // Handle this break 
....................             } 
....................  
....................             // Check for Slave ID 
....................  
....................         } while (SLAVE_ID != ui8Temp); // If Slave ID not matched then continue 
....................  
....................         // Handle Break 
....................         if (MSG_QUEUE_EMPTY == bIsQueueEmpty) 
....................         { 
....................             // Nothing to return 
....................             // This may be the Slave ID is not matched, So might be this is for other board 
....................             // So nothing to process 
....................             break; 
....................         } 
....................          
....................         // Step 2: Now Check for minimum length (Which is 8 for now, but it could go upto 12) 
....................         i8TempLen = GetQueueLength(); 
....................         if (MODBUS_MASTER_QUERY_LENGTH_MIN > (i8TempLen + 1))  // +1 is just due to we have deleted one from queue 
....................         { 
....................             // Empty the message buffer queue 
....................             EmptyQueue(); 
....................              
....................             // Break from ProcessUART2ReceivedData function 
....................             break; 
....................         } 
....................          
....................         // We have available message in queue 
....................          
....................         // Should insert slave ID in temp buffer for CRC check. 
....................          
....................         // Slave ID Matched 
....................         // Step 3: Look for the Function Code 
....................         i8TempFront = g_stUART2RcvBuffModbus.m_i8Front; 
....................         ui8Temp = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront];  // g_ui8TempArrForCRCValidation 
....................              
....................          
.................... 	//value assign in transmit buffer of RS485 
....................         int8 i8TempLen                = 0;   
....................         unsigned int16 ui16Address    = 0; 
....................         unsigned int16 ui16RegData    = 0; 
....................  
....................  
....................         i8TempFront = g_stUART2RcvBuffModbus.m_i8Front;     
....................         ui8Temp     = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront];  // g_ui8TempArrForCRCValidation 
....................         i8TempLen   = GetQueueLength(); 
....................  
....................         int8 i8AddH = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_TWO - 1]; 
....................         int8 i8AddL = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_THREE - 1]; 
....................  
....................         ui16Address = i8AddH; 
....................         ui16Address <<= 8; 
....................         ui16Address += i8AddL; 
....................  
....................  
....................         int8 i8DataH = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_FOUR -1]; 
....................         int8 i8DataL = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_FIVE -1]; 
....................  
....................         unsigned int16 ui16WriteAddress = ui16Address + 1; 
....................  
....................         ui16RegData = i8DataH; 
....................         ui16RegData <<= 8; 
....................         ui16RegData += i8DataL;         
....................          
....................         // Now check for the available function code 
....................         switch(ui8Temp) 
....................         { 
....................             case RS485_FUNCTION_READ_HOLDING_REGISTERS: 
....................                 // Check queue length here if full message is received or not. 
....................                  
....................                 // Insert function code in the temp buffer. 
....................                 // For this function code fetch next four consecutive bytes in temp buffer. 
....................                 bIsValidMSG = CheckValidityForReadReg(); 
....................                 if(bIsValidMSG) 
....................                 { 
....................                      
....................                     // Empty the message buffer queue 
....................                     EmptyQueue(); 
....................                     
....................                     if(ui16RegData == 1) 
....................                     {                  
....................                         WriteToOneRegRS485( 
....................                             SLAVE_ID, 
....................                             RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                             2, 
....................                             4464 //TODO********************************************** 
....................                             ); 
....................                             //65535);                         
....................                     } 
....................                     else if(ui16RegData == 2) 
....................                     { 
....................                         if(ui16Address == ADDRESS_FOR_SET_CALIB_DATA)  
....................                         { 
....................                             if(g_ui16RegisterForCount == 1)  
....................                             { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16RegisterForCounter1_1, //TODO********************************************** 
....................                                     g_ui16RegisterForCounter1_2); 
....................                             } 
....................                             else if(g_ui16RegisterForCount == 2)  
....................                             { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16RegisterForCounter2_1, //TODO********************************************** 
....................                                     g_ui16RegisterForCounter2_2); 
....................                             } 
....................                             else if(g_ui16RegisterForCount == 3)  
....................                             { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16RegisterForCounter3_1, //TODO********************************************** 
....................                                     g_ui16RegisterForCounter3_2); 
....................                             } 
....................                         } 
....................                         else if(ui16Address == ADDRESS_FOR_SET_CALIB_0) 
....................                         { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16Register0_1, //TODO********************************************** 
....................                                     g_ui16Register0_2); 
....................                         } 
....................                         else if(ui16Address == ADDRESS_FOR_SET_CALIB_1000) 
....................                         { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16Register1000_1, //TODO********************************************** 
....................                                     g_ui16Register1000_2); 
....................                         } 
....................                         else if(ui16Address == ADDRESS_FOR_SET_CALIB_2000) 
....................                         { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16Register2000_1, //TODO********************************************** 
....................                                     g_ui16Register2000_2); 
....................                         } 
....................                         else if(ui16Address == ADDRESS_FOR_SET_CALIB_3000) 
....................                         { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16Register3000_1, //TODO********************************************** 
....................                                     g_ui16Register3000_2); 
....................                         } 
....................                         else if(ui16Address == ADDRESS_FOR_SET_CALIB_4000) 
....................                         { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16Register4000_1, //TODO********************************************** 
....................                                     g_ui16Register4000_2); 
....................                         } 
....................                         else if(ui16Address == ADDRESS_FOR_SET_CALIB_5000) 
....................                         { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16Register5000_1, //TODO********************************************** 
....................                                     g_ui16Register5000_2); 
....................                         } 
....................                         else if(ui16Address == ADDRESS_FOR_SET_CALIB_6000) 
....................                         { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16Register6000_1, //TODO********************************************** 
....................                                     g_ui16Register6000_2); 
....................                         } 
....................                         else if(ui16Address == ADDRESS_FOR_SET_CALIB_7000) 
....................                         { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16Register7000_1, //TODO********************************************** 
....................                                     g_ui16Register7000_2); 
....................                         } 
....................                         else if(ui16Address == ADDRESS_FOR_SET_CALIB_8000) 
....................                         { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16Register8000_1, //TODO********************************************** 
....................                                     g_ui16Register8000_2); 
....................                         } 
....................                         else if(ui16Address == ADDRESS_FOR_SET_CALIB_9000) 
....................                         { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16Register9000_1, //TODO********************************************** 
....................                                     g_ui16Register9000_2); 
....................                         } 
....................                         else if(ui16Address == ADDRESS_FOR_SET_CALIB_10000) 
....................                         { 
....................                                 WriteToTwoRegRS485( 
....................                                     SLAVE_ID, 
....................                                     RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                     4, 
....................                                     g_ui16Register10000_1, //TODO********************************************** 
....................                                     g_ui16Register10000_2); 
....................                         } 
....................                         else  
....................                         {     
....................                             // Valid MSG, so return 
....................                             WriteToTwoRegRS485( 
....................                                 SLAVE_ID, 
....................                                 RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                                 4, 
....................                                 4464, //TODO********************************************** 
....................                                 1); 
....................                                 //65535); 
....................                         } 
....................                     } 
....................                     else  
....................                     { 
....................                         // Valid MSG, so return 
....................                         WriteToThreeRegRS485( 
....................                             SLAVE_ID, 
....................                             RS485_FUNCTION_READ_HOLDING_REGISTERS, 
....................                             6,                                      //TODO********************************************** 
....................                             g_ui16DOStatus, 
....................                             g_ui16DIStatus, 
....................                             g_ui16ErrorStatus); 
....................                     } 
....................                     // Update main loop process status. 
....................                     i8MainProcessLoopStatue = 0; 
....................                 } 
....................                 break; 
....................             case RS485_FUNCTION_WRITE_SINGLE_REGISTER: 
....................             { 
....................                 // Insert function code in the temp buffer. 
....................                 // For this function code fetch next four consecutive bytes in temp buffer. 
....................                 //bIsValidMSG = CheckValidityForWriteSingleReg(); 
....................        		 	SendRS485Response(); 
....................                 ProcessSingleRegister(); 
....................             } 
....................             break; 
....................             case RS485_FUNCTION_READ_MULTIPLE_REGISTERS: 
....................             { 
....................                 if(ui16RegData == 2) 
....................                 { 
....................                     if(ui16Address == ADDRESS_FOR_SET_CALIB_0) 
....................                     { 
....................                             ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register0_1, //TODO********************************************** 
....................                             g_ui16Register0_2); 
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_1000) 
....................                     { 
....................                             ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register1000_1, //TODO********************************************** 
....................                             g_ui16Register1000_2); 
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_2000) 
....................                     { 
....................                             ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register2000_1, //TODO********************************************** 
....................                             g_ui16Register2000_2); 
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_3000) 
....................                     { 
....................                             ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register3000_1, //TODO********************************************** 
....................                             g_ui16Register3000_2); 
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_4000) 
....................                     { 
....................                             ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register4000_1, //TODO********************************************** 
....................                             g_ui16Register4000_2); 
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_5000) 
....................                     { 
....................                             ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register5000_1, //TODO********************************************** 
....................                             g_ui16Register5000_2); 
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_6000) 
....................                     { 
....................                             ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register6000_1, //TODO********************************************** 
....................                             g_ui16Register6000_2); 
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_7000) 
....................                     { 
....................                             ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register7000_1, //TODO********************************************** 
....................                             g_ui16Register7000_2); 
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_8000) 
....................                     { 
....................                             ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register8000_1, //TODO********************************************** 
....................                             g_ui16Register8000_2); 
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_9000) 
....................                     { 
....................                             ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register9000_1, //TODO********************************************** 
....................                             g_ui16Register9000_2); 
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_10000) 
....................                     { 
....................                             ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register10000_1, //TODO********************************************** 
....................                             g_ui16Register10000_2); 
....................                     } 
....................                     else { 
....................                         ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register0_1, //TODO********************************************** 
....................                             g_ui16Register0_2); 
....................                     } 
....................                 } 
....................                 else  
....................                 { 
....................                         ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register0_1, //TODO********************************************** 
....................                             g_ui16Register0_2); 
....................                 } 
....................             } 
....................             break; 
....................             case RS485_FUNCTION_WRITE_MULTIPLE_REGISTERS: 
....................             { 
....................                 SendRS485ResponseForMultipleRegWrite(); 
....................                  
....................                 unsigned int16 ui16RegDataLen    = ui16RegData; 
....................                 int8 i8DataLen = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_SIX - 1]; 
....................  
....................                 int8 i8DataH = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_SEVEN -1]; 
....................                 int8 i8DataL = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_8 -1]; 
....................  
....................                 unsigned int16 ui16RegDataValue1 = 0; 
....................  
....................                 ui16RegDataValue1 = i8DataH; 
....................                 ui16RegDataValue1 <<= 8; 
....................                 ui16RegDataValue1 += i8DataL;   
....................                  
....................                 i8DataH = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_9 -1]; 
....................                 i8DataL = g_stUART2RcvBuffModbus.m_ui8Arr[i8TempFront+MODBUS_OFFSET_10 -1]; 
....................  
....................                 unsigned int16 ui16RegDataValue2 = 0; 
....................  
....................                 ui16RegDataValue2 = i8DataH; 
....................                 ui16RegDataValue2 <<= 8; 
....................                 ui16RegDataValue2 += i8DataL;    
....................                  
....................                 if(ui16RegDataLen == 2) 
....................                 { 
....................                     if(ui16Address == ADDRESS_FOR_SET_CALIB_0) 
....................                     { 
....................                         g_ui16Register0_1 = ui16RegDataValue1; 
....................                         g_ui16Register0_2 = ui16RegDataValue2;                         
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_1000) 
....................                     { 
....................                         g_ui16Register1000_1 = ui16RegDataValue1; 
....................                         g_ui16Register1000_2 = ui16RegDataValue2;                         
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_2000) 
....................                     { 
....................                         g_ui16Register2000_1 = ui16RegDataValue1; 
....................                         g_ui16Register2000_2 = ui16RegDataValue2;                         
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_3000) 
....................                     { 
....................                         g_ui16Register3000_1 = ui16RegDataValue1; 
....................                         g_ui16Register3000_2 = ui16RegDataValue2;                         
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_4000) 
....................                     { 
....................                         g_ui16Register4000_1 = ui16RegDataValue1; 
....................                         g_ui16Register4000_2 = ui16RegDataValue2;                         
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_5000) 
....................                     { 
....................                         g_ui16Register5000_1 = ui16RegDataValue1; 
....................                         g_ui16Register5000_2 = ui16RegDataValue2;                         
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_6000) 
....................                     { 
....................                         g_ui16Register6000_1 = ui16RegDataValue1; 
....................                         g_ui16Register6000_2 = ui16RegDataValue2;                         
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_7000) 
....................                     { 
....................                         g_ui16Register7000_1 = ui16RegDataValue1; 
....................                         g_ui16Register7000_2 = ui16RegDataValue2;                         
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_8000) 
....................                     { 
....................                         g_ui16Register8000_1 = ui16RegDataValue1; 
....................                         g_ui16Register8000_2 = ui16RegDataValue2;                         
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_9000) 
....................                     { 
....................                         g_ui16Register9000_1 = ui16RegDataValue1; 
....................                         g_ui16Register9000_2 = ui16RegDataValue2;                         
....................                     } 
....................                     else if(ui16Address == ADDRESS_FOR_SET_CALIB_10000) 
....................                     { 
....................                         g_ui16Register10000_1 = ui16RegDataValue1; 
....................                         g_ui16Register10000_2 = ui16RegDataValue2;                         
....................                     } 
....................                     else { 
....................                         ReplyForTwoRegister( 
....................                             SLAVE_ID, 
....................                             ui8Temp, 
....................                             ui16RegData, 
....................                             ui16Address,     
....................                             g_ui16Register0_1, //TODO********************************************** 
....................                             g_ui16Register0_2); 
....................                     } 
....................                 } 
....................             } 
....................             break; 
....................             default:   // Function Code is not Matching 
....................                 // Continue the ProcessUART2ReceivedData from beginning 
....................                 SendRS485Response(); 
....................                 i8MainProcessLoopStatue = 1; 
....................                 break; 
....................         } 
....................          
....................         // If Function Code not Matching 
....................         if (i8MainProcessLoopStatue) 
....................         { 
....................             // Then continue from beginning 
....................             continue; 
....................         } 
....................          
....................          
....................         // If the message is not valid 
....................         // Start  
....................     } while (i8MainProcessLoopStatue); 
....................      
.................... } 
.................... ////=============================== END NEW CODE ====================================================== 
....................  
.................... #endif /* _VI_RS485_CONFIG_H_ */ 
....................  
....................  
....................  
.................... // Stuff Machine ID and Variety type in GPRS Message header. 
.................... // Amta plant(Line 2) -> Machine ID - 2 and Marie Gold variety Type - 3. 
.................... // Delta Foods Machine ID - 4 
.................... // Super Snacks Machine ID - 5 
.................... #define  MACHINE_ID                2  // Delta 
....................      
.................... #define   SIZE_GSMM66_RX_BUFFER                 500 
.................... #define   SIZE_GPRS_DATA_NODE_QUEUE             100 
....................  
.................... #define   GPRS_DATA_SENDING_SEQUENCE_1          1 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_2          2 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_3          3 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_4          4 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_5          5 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_6          6 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_7          7 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_8          8 
....................  
....................  
.................... typedef struct _ST_GPRS_DATA_NODE 
.................... { 
....................     unsigned int32 m_ui32TimeStamp; 
....................     unsigned int16 m_ui16SequenceNo; 
....................     unsigned int16 m_ui16ItemWeight; 
....................     unsigned int8  m_ui8RejectionStatus; 
.................... } ST_GPRS_DATA_NODE; 
....................  
.................... typedef struct _ST_GPRS_MSG_SEND_QUEUE 
.................... { 
....................     ST_GPRS_DATA_NODE m_stArrGPRSDataNode[SIZE_GPRS_DATA_NODE_QUEUE]; 
....................     int8              m_i8Front; 
....................     int8              m_i8Rear; 
.................... } ST_GPRS_MSG_SEND_QUEUE; 
....................  
.................... typedef struct _ST_PROD_M_CURR_BOX_DATA 
.................... { 
....................     int16             m_i16BoxWeight; 
....................     unsigned int16    m_ui16SequenceNo; 
....................     unsigned int16    m_ui16RejectionStatus; 
....................     unsigned int32    m_ui32TimeStamp; 
.................... } ST_PROD_M_CURR_BOX_DATA; 
....................  
.................... // ***************************************************************************** 
.................... // ***************** Below -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
.................... unsigned int8       g_ui8M66RxBuffer[SIZE_GSMM66_RX_BUFFER]               = {0}; 
.................... unsigned int16      g_ui16M66RxByteCount                                  = 0; 
.................... unsigned int8       g_ui8URLInputByteLength                               = 0; 
.................... unsigned int8       g_ui8URLInputTime                                     = 0; 
.................... //unsigned int8       g_ui8DataToSend                                       = 0; 
.................... unsigned int16      g_ui16Itm1SequenceNumber                              = 1; 
.................... unsigned int16      g_ui16Itm2SequenceNumber                              = 2; 
.................... unsigned int16      g_ui16ItemWeight                                      = 1999; 
.................... unsigned int8       g_ui8DataQueueLen                                     = 0; 
.................... unsigned int8       g_fGPRSSequence                                       = 0; 
.................... unsigned int8       g_fGPRSFailureBit                                     = 0; 
....................  
.................... ST_GPRS_MSG_SEND_QUEUE   g_stGPRSMsgSendQueue; 
.................... ST_PROD_M_CURR_BOX_DATA  g_stProdModeCurrBoxData; 
.................... // ***************************************************************************** 
.................... // ***************** Above -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
.................... void ResetGSMM66RxBuffer(void) 
.................... { 
....................     // Reset whole buffer. 
....................     memset(g_ui8M66RxBuffer, 0, SIZE_GSMM66_RX_BUFFER); 
*
01A5A:  MOVLW  04
01A5C:  MOVWF  FEA
01A5E:  MOVLW  94
01A60:  MOVWF  FE9
01A62:  CLRF   00
01A64:  MOVLW  01
01A66:  MOVWF  02
01A68:  MOVLW  F4
01A6A:  MOVWF  01
01A6C:  CALL   0AC2
....................      
....................     // Reset byte count 
....................     g_ui16M66RxByteCount = 0; 
01A70:  MOVLB  6
01A72:  CLRF   x89
01A74:  CLRF   x88
01A76:  MOVLB  0
01A78:  RETURN 0
.................... } 
....................  
.................... unsigned int8 CountDataSize(unsigned int32 ui32Data) 
*
0407A:  MOVLB  B
0407C:  CLRF   x1E
.................... { 
....................     unsigned int8 ui8DataLen = 0; 
....................      
....................     if(ui32Data <= 9) 
0407E:  MOVF   x1D,F
04080:  BTFSS  FD8.2
04082:  GOTO   40A8
04086:  MOVF   x1C,F
04088:  BTFSS  FD8.2
0408A:  GOTO   40A8
0408E:  MOVF   x1B,F
04090:  BTFSS  FD8.2
04092:  GOTO   40A8
04096:  MOVF   x1A,W
04098:  SUBLW  09
0409A:  BTFSS  FD8.0
0409C:  GOTO   40A8
....................     { 
....................         ui8DataLen = 1; 
040A0:  MOVLW  01
040A2:  MOVWF  x1E
....................     } 
040A4:  GOTO   42DA
....................     else if(ui32Data <= 99) 
040A8:  MOVF   x1D,F
040AA:  BTFSS  FD8.2
040AC:  GOTO   40D2
040B0:  MOVF   x1C,F
040B2:  BTFSS  FD8.2
040B4:  GOTO   40D2
040B8:  MOVF   x1B,F
040BA:  BTFSS  FD8.2
040BC:  GOTO   40D2
040C0:  MOVF   x1A,W
040C2:  SUBLW  63
040C4:  BTFSS  FD8.0
040C6:  GOTO   40D2
....................     { 
....................         ui8DataLen = 2; 
040CA:  MOVLW  02
040CC:  MOVWF  x1E
....................     } 
040CE:  GOTO   42DA
....................     else if(ui32Data <= 999) 
040D2:  MOVF   x1D,F
040D4:  BTFSS  FD8.2
040D6:  GOTO   4104
040DA:  MOVF   x1C,F
040DC:  BTFSS  FD8.2
040DE:  GOTO   4104
040E2:  MOVF   x1B,W
040E4:  SUBLW  03
040E6:  BTFSS  FD8.0
040E8:  GOTO   4104
040EC:  BTFSS  FD8.2
040EE:  GOTO   40FC
040F2:  MOVF   x1A,W
040F4:  SUBLW  E7
040F6:  BTFSS  FD8.0
040F8:  GOTO   4104
....................     { 
....................         ui8DataLen = 3; 
040FC:  MOVLW  03
040FE:  MOVWF  x1E
....................     } 
04100:  GOTO   42DA
....................     else if(ui32Data <= 9999) 
04104:  MOVF   x1D,F
04106:  BTFSS  FD8.2
04108:  GOTO   4136
0410C:  MOVF   x1C,F
0410E:  BTFSS  FD8.2
04110:  GOTO   4136
04114:  MOVF   x1B,W
04116:  SUBLW  27
04118:  BTFSS  FD8.0
0411A:  GOTO   4136
0411E:  BTFSS  FD8.2
04120:  GOTO   412E
04124:  MOVF   x1A,W
04126:  SUBLW  0F
04128:  BTFSS  FD8.0
0412A:  GOTO   4136
....................     { 
....................         ui8DataLen = 4; 
0412E:  MOVLW  04
04130:  MOVWF  x1E
....................     } 
04132:  GOTO   42DA
....................     else if(ui32Data <= 99999) 
04136:  MOVF   x1D,F
04138:  BTFSS  FD8.2
0413A:  GOTO   4170
0413E:  MOVF   x1C,W
04140:  SUBLW  01
04142:  BTFSS  FD8.0
04144:  GOTO   4170
04148:  BTFSS  FD8.2
0414A:  GOTO   4168
0414E:  MOVF   x1B,W
04150:  SUBLW  86
04152:  BTFSS  FD8.0
04154:  GOTO   4170
04158:  BTFSS  FD8.2
0415A:  GOTO   4168
0415E:  MOVF   x1A,W
04160:  SUBLW  9F
04162:  BTFSS  FD8.0
04164:  GOTO   4170
....................     { 
....................         ui8DataLen = 5; 
04168:  MOVLW  05
0416A:  MOVWF  x1E
....................     } 
0416C:  GOTO   42DA
....................     else if(ui32Data <= 999999) 
04170:  MOVF   x1D,F
04172:  BTFSS  FD8.2
04174:  GOTO   41AA
04178:  MOVF   x1C,W
0417A:  SUBLW  0F
0417C:  BTFSS  FD8.0
0417E:  GOTO   41AA
04182:  BTFSS  FD8.2
04184:  GOTO   41A2
04188:  MOVF   x1B,W
0418A:  SUBLW  42
0418C:  BTFSS  FD8.0
0418E:  GOTO   41AA
04192:  BTFSS  FD8.2
04194:  GOTO   41A2
04198:  MOVF   x1A,W
0419A:  SUBLW  3F
0419C:  BTFSS  FD8.0
0419E:  GOTO   41AA
....................     { 
....................         ui8DataLen = 6; 
041A2:  MOVLW  06
041A4:  MOVWF  x1E
....................     } 
041A6:  GOTO   42DA
....................     else if(ui32Data <= 9999999) 
041AA:  MOVF   x1D,F
041AC:  BTFSS  FD8.2
041AE:  GOTO   41E4
041B2:  MOVF   x1C,W
041B4:  SUBLW  98
041B6:  BTFSS  FD8.0
041B8:  GOTO   41E4
041BC:  BTFSS  FD8.2
041BE:  GOTO   41DC
041C2:  MOVF   x1B,W
041C4:  SUBLW  96
041C6:  BTFSS  FD8.0
041C8:  GOTO   41E4
041CC:  BTFSS  FD8.2
041CE:  GOTO   41DC
041D2:  MOVF   x1A,W
041D4:  SUBLW  7F
041D6:  BTFSS  FD8.0
041D8:  GOTO   41E4
....................     { 
....................         ui8DataLen = 7; 
041DC:  MOVLW  07
041DE:  MOVWF  x1E
....................     } 
041E0:  GOTO   42DA
....................     else if(ui32Data <= 99999999) 
041E4:  MOVF   x1D,W
041E6:  SUBLW  05
041E8:  BTFSS  FD8.0
041EA:  GOTO   4216
041EE:  BTFSS  FD8.2
041F0:  GOTO   420E
041F4:  MOVF   x1C,W
041F6:  SUBLW  F5
041F8:  BTFSS  FD8.0
041FA:  GOTO   4216
041FE:  BTFSS  FD8.2
04200:  GOTO   420E
04204:  MOVF   x1B,W
04206:  SUBLW  E0
04208:  BTFSS  FD8.0
0420A:  GOTO   4216
....................     { 
....................         ui8DataLen = 8; 
0420E:  MOVLW  08
04210:  MOVWF  x1E
....................     } 
04212:  GOTO   42DA
....................     else if(ui32Data <= 999999999) 
04216:  MOVF   x1D,W
04218:  SUBLW  3B
0421A:  BTFSS  FD8.0
0421C:  GOTO   4248
04220:  BTFSS  FD8.2
04222:  GOTO   4240
04226:  MOVF   x1C,W
04228:  SUBLW  9A
0422A:  BTFSS  FD8.0
0422C:  GOTO   4248
04230:  BTFSS  FD8.2
04232:  GOTO   4240
04236:  MOVF   x1B,W
04238:  SUBLW  C9
0423A:  BTFSS  FD8.0
0423C:  GOTO   4248
....................     { 
....................         ui8DataLen = 9; 
04240:  MOVLW  09
04242:  MOVWF  x1E
....................     } 
04244:  GOTO   42DA
....................     else if(ui32Data <= 9999999999) 
04248:  MOVF   x1D,W
0424A:  SUBLW  54
0424C:  BTFSS  FD8.0
0424E:  GOTO   427A
04252:  BTFSS  FD8.2
04254:  GOTO   4272
04258:  MOVF   x1C,W
0425A:  SUBLW  0B
0425C:  BTFSS  FD8.0
0425E:  GOTO   427A
04262:  BTFSS  FD8.2
04264:  GOTO   4272
04268:  MOVF   x1B,W
0426A:  SUBLW  E3
0426C:  BTFSS  FD8.0
0426E:  GOTO   427A
....................     { 
....................         ui8DataLen = 10; 
04272:  MOVLW  0A
04274:  MOVWF  x1E
....................     } 
04276:  GOTO   42DA
....................     else if(ui32Data <= 99999999999) 
0427A:  MOVF   x1D,W
0427C:  SUBLW  48
0427E:  BTFSS  FD8.0
04280:  GOTO   42AC
04284:  BTFSS  FD8.2
04286:  GOTO   42A4
0428A:  MOVF   x1C,W
0428C:  SUBLW  76
0428E:  BTFSS  FD8.0
04290:  GOTO   42AC
04294:  BTFSS  FD8.2
04296:  GOTO   42A4
0429A:  MOVF   x1B,W
0429C:  SUBLW  E7
0429E:  BTFSS  FD8.0
042A0:  GOTO   42AC
....................     { 
....................         ui8DataLen = 11; 
042A4:  MOVLW  0B
042A6:  MOVWF  x1E
....................     } 
042A8:  GOTO   42DA
....................     else if(ui32Data <= 999999999999) 
042AC:  MOVF   x1D,W
042AE:  SUBLW  D4
042B0:  BTFSS  FD8.0
042B2:  GOTO   42DA
042B6:  BTFSS  FD8.2
042B8:  GOTO   42D6
042BC:  MOVF   x1C,W
042BE:  SUBLW  A5
042C0:  BTFSS  FD8.0
042C2:  GOTO   42DA
042C6:  BTFSS  FD8.2
042C8:  GOTO   42D6
042CC:  MOVF   x1B,W
042CE:  SUBLW  0F
042D0:  BTFSS  FD8.0
042D2:  GOTO   42DA
....................     { 
....................         ui8DataLen = 12; 
042D6:  MOVLW  0C
042D8:  MOVWF  x1E
....................     } 
....................      
....................     return ui8DataLen; 
042DA:  MOVFF  B1E,01
042DE:  MOVLB  0
042E0:  RETURN 0
.................... } 
....................  
.................... void CheckURLInputByteLength(void) 
042E2:  MOVLB  B
042E4:  CLRF   x12
.................... { 
....................     unsigned int8 ui8DataByte = 0; 
....................      
....................     // Check remaining data in the GPRS queue is greater equals than five or not. 
....................     if(g_ui8DataQueueLen >= 5) 
042E6:  MOVLB  6
042E8:  MOVF   x92,W
042EA:  SUBLW  04
042EC:  BTFSC  FD8.0
042EE:  GOTO   44B0
....................     { 
....................         // Five accumulated data node has to send. 
....................         // Set number of messages to send is five. 
....................         g_stGPRSMsgHeader.m_ui8NoOfMessages = 5; 
042F2:  MOVLW  05
042F4:  MOVLB  2
042F6:  MOVWF  x92
....................          
....................         // Basic input byte has to send is 69 bytes. add up additional bytes per no of messages. 
....................         // Add data node separator "|" for input byte length. 
....................         g_ui8URLInputByteLength = g_ui8URLInputByteLength + (g_stGPRSMsgHeader.m_ui8NoOfMessages - 1); 
042F8:  MOVLW  01
042FA:  SUBWF  x92,W
042FC:  MOVLB  6
042FE:  ADDWF  x8A,F
....................         // Add data separator "$" for each data node. 
....................         g_ui8URLInputByteLength = g_ui8URLInputByteLength + (g_stGPRSMsgHeader.m_ui8NoOfMessages * 3); 
04300:  MOVLB  2
04302:  MOVF   x92,W
04304:  MULLW  03
04306:  MOVF   FF3,W
04308:  MOVLB  6
0430A:  ADDWF  x8A,F
....................         // Now loop through the data queue to count input byte length. 
....................         for(unsigned int8 ui8LoopCount = 0; ui8LoopCount < g_stGPRSMsgHeader.m_ui8NoOfMessages; ui8LoopCount++) 
0430C:  MOVLB  B
0430E:  CLRF   x13
04310:  MOVLB  2
04312:  MOVF   x92,W
04314:  MOVLB  B
04316:  SUBWF  x13,W
04318:  BTFSC  FD8.0
0431A:  GOTO   44AA
....................         { 
....................             // Check for TimeStamp. 
....................             ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front + ui8LoopCount].m_ui32TimeStamp); 
0431E:  MOVF   x13,W
04320:  MOVLB  A
04322:  ADDWF  x19,W
04324:  MOVLB  B
04326:  MOVWF  x15
04328:  CLRF   x4F
0432A:  MOVWF  x4E
0432C:  CLRF   x51
0432E:  MOVLW  09
04330:  MOVWF  x50
04332:  MOVLB  0
04334:  CALL   0B2A
04338:  MOVFF  02,B15
0433C:  MOVFF  01,B14
04340:  MOVLW  95
04342:  MOVLB  B
04344:  ADDWF  01,W
04346:  MOVWF  FE9
04348:  MOVLW  06
0434A:  ADDWFC 02,W
0434C:  MOVWF  FEA
0434E:  MOVFF  FEF,B16
04352:  MOVFF  FEC,B17
04356:  MOVFF  FEC,B18
0435A:  MOVFF  FEC,B19
0435E:  MOVFF  B19,B1D
04362:  MOVFF  B18,B1C
04366:  MOVFF  B17,B1B
0436A:  MOVFF  B16,B1A
0436E:  MOVLB  0
04370:  CALL   407A
04374:  MOVFF  01,B12
....................             // Add up data byte. 
....................             g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
04378:  MOVLB  B
0437A:  MOVF   x12,W
0437C:  MOVLB  6
0437E:  ADDWF  x8A,F
....................             // Check for Sequence number. 
....................             ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front + ui8LoopCount].m_ui16SequenceNo); 
04380:  MOVLB  B
04382:  MOVF   x13,W
04384:  MOVLB  A
04386:  ADDWF  x19,W
04388:  MOVLB  B
0438A:  MOVWF  x15
0438C:  CLRF   x4F
0438E:  MOVWF  x4E
04390:  CLRF   x51
04392:  MOVLW  09
04394:  MOVWF  x50
04396:  MOVLB  0
04398:  CALL   0B2A
0439C:  MOVFF  01,B14
043A0:  MOVLW  04
043A2:  MOVLB  B
043A4:  ADDWF  01,W
043A6:  MOVWF  01
043A8:  MOVLW  00
043AA:  ADDWFC 02,W
043AC:  MOVWF  03
043AE:  MOVF   01,W
043B0:  ADDLW  95
043B2:  MOVWF  FE9
043B4:  MOVLW  06
043B6:  ADDWFC 03,W
043B8:  MOVWF  FEA
043BA:  MOVFF  FEC,B15
043BE:  MOVF   FED,F
043C0:  MOVFF  FEF,B14
043C4:  CLRF   x1D
043C6:  CLRF   x1C
043C8:  MOVFF  B15,B1B
043CC:  MOVFF  B14,B1A
043D0:  MOVLB  0
043D2:  CALL   407A
043D6:  MOVFF  01,B12
....................             // Add up data byte. 
....................             g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
043DA:  MOVLB  B
043DC:  MOVF   x12,W
043DE:  MOVLB  6
043E0:  ADDWF  x8A,F
....................             // Check for Item weight. 
....................             ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front + ui8LoopCount].m_ui16ItemWeight); 
043E2:  MOVLB  B
043E4:  MOVF   x13,W
043E6:  MOVLB  A
043E8:  ADDWF  x19,W
043EA:  MOVLB  B
043EC:  MOVWF  x15
043EE:  CLRF   x4F
043F0:  MOVWF  x4E
043F2:  CLRF   x51
043F4:  MOVLW  09
043F6:  MOVWF  x50
043F8:  MOVLB  0
043FA:  CALL   0B2A
043FE:  MOVFF  01,B14
04402:  MOVLW  06
04404:  MOVLB  B
04406:  ADDWF  01,W
04408:  MOVWF  01
0440A:  MOVLW  00
0440C:  ADDWFC 02,W
0440E:  MOVWF  03
04410:  MOVF   01,W
04412:  ADDLW  95
04414:  MOVWF  FE9
04416:  MOVLW  06
04418:  ADDWFC 03,W
0441A:  MOVWF  FEA
0441C:  MOVFF  FEC,B15
04420:  MOVF   FED,F
04422:  MOVFF  FEF,B14
04426:  CLRF   x1D
04428:  CLRF   x1C
0442A:  MOVFF  B15,B1B
0442E:  MOVFF  B14,B1A
04432:  MOVLB  0
04434:  CALL   407A
04438:  MOVFF  01,B12
....................             // Add up data byte. 
....................             g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
0443C:  MOVLB  B
0443E:  MOVF   x12,W
04440:  MOVLB  6
04442:  ADDWF  x8A,F
....................             // Check for Rejection status. 
....................             ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front + ui8LoopCount].m_ui8RejectionStatus); 
04444:  MOVLB  B
04446:  MOVF   x13,W
04448:  MOVLB  A
0444A:  ADDWF  x19,W
0444C:  MOVLB  B
0444E:  MOVWF  x15
04450:  CLRF   x4F
04452:  MOVWF  x4E
04454:  CLRF   x51
04456:  MOVLW  09
04458:  MOVWF  x50
0445A:  MOVLB  0
0445C:  CALL   0B2A
04460:  MOVFF  02,B15
04464:  MOVFF  01,B14
04468:  MOVLW  08
0446A:  MOVLB  B
0446C:  ADDWF  01,W
0446E:  MOVWF  01
04470:  MOVLW  00
04472:  ADDWFC 02,W
04474:  MOVWF  03
04476:  MOVF   01,W
04478:  ADDLW  95
0447A:  MOVWF  FE9
0447C:  MOVLW  06
0447E:  ADDWFC 03,W
04480:  MOVWF  FEA
04482:  MOVFF  FEF,B14
04486:  CLRF   x1D
04488:  CLRF   x1C
0448A:  CLRF   x1B
0448C:  MOVFF  B14,B1A
04490:  MOVLB  0
04492:  CALL   407A
04496:  MOVFF  01,B12
....................             // Add up data byte. 
....................             g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
0449A:  MOVLB  B
0449C:  MOVF   x12,W
0449E:  MOVLB  6
044A0:  ADDWF  x8A,F
044A2:  MOVLB  B
044A4:  INCF   x13,F
044A6:  GOTO   4310
....................                  
....................         } 
....................     } 
044AA:  GOTO   4628
044AE:  MOVLB  6
....................     else 
....................     { 
....................         // Single data node has to send. 
....................         // Set number of messages to send is one. 
....................         g_stGPRSMsgHeader.m_ui8NoOfMessages = 1; 
044B0:  MOVLW  01
044B2:  MOVLB  2
044B4:  MOVWF  x92
....................          
....................         // Basic input byte has to send is 69 bytes. add up additional bytes per no of messages. 
....................         // No data node separator needed. Only data separator for each node will be counted. 
....................         // Add data separator "$" for each data node. 
....................         g_ui8URLInputByteLength = g_ui8URLInputByteLength + (g_stGPRSMsgHeader.m_ui8NoOfMessages * 3); 
044B6:  MOVF   x92,W
044B8:  MULLW  03
044BA:  MOVF   FF3,W
044BC:  MOVLB  6
044BE:  ADDWF  x8A,F
....................          
....................         // Now count data size of each data for single data node. 
....................         // Check for TimeStamp. 
....................         ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp); 
044C0:  MOVLB  B
044C2:  CLRF   x4F
044C4:  MOVFF  A19,B4E
044C8:  CLRF   x51
044CA:  MOVLW  09
044CC:  MOVWF  x50
044CE:  MOVLB  0
044D0:  CALL   0B2A
044D4:  MOVFF  02,B15
044D8:  MOVFF  01,B14
044DC:  MOVLW  95
044DE:  MOVLB  B
044E0:  ADDWF  01,W
044E2:  MOVWF  FE9
044E4:  MOVLW  06
044E6:  ADDWFC 02,W
044E8:  MOVWF  FEA
044EA:  MOVFF  FEF,B16
044EE:  MOVFF  FEC,B17
044F2:  MOVFF  FEC,B18
044F6:  MOVFF  FEC,B19
044FA:  MOVFF  B19,B1D
044FE:  MOVFF  B18,B1C
04502:  MOVFF  B17,B1B
04506:  MOVFF  B16,B1A
0450A:  MOVLB  0
0450C:  CALL   407A
04510:  MOVFF  01,B12
....................         // Add up data byte. 
....................         g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
04514:  MOVLB  B
04516:  MOVF   x12,W
04518:  MOVLB  6
0451A:  ADDWF  x8A,F
....................         // Check for Sequence number. 
....................         ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front ].m_ui16SequenceNo); 
0451C:  MOVLB  B
0451E:  CLRF   x4F
04520:  MOVFF  A19,B4E
04524:  CLRF   x51
04526:  MOVLW  09
04528:  MOVWF  x50
0452A:  MOVLB  0
0452C:  CALL   0B2A
04530:  MOVFF  01,B14
04534:  MOVLW  04
04536:  MOVLB  B
04538:  ADDWF  01,W
0453A:  MOVWF  01
0453C:  MOVLW  00
0453E:  ADDWFC 02,W
04540:  MOVWF  03
04542:  MOVF   01,W
04544:  ADDLW  95
04546:  MOVWF  FE9
04548:  MOVLW  06
0454A:  ADDWFC 03,W
0454C:  MOVWF  FEA
0454E:  MOVFF  FEC,B15
04552:  MOVF   FED,F
04554:  MOVFF  FEF,B14
04558:  CLRF   x1D
0455A:  CLRF   x1C
0455C:  MOVFF  B15,B1B
04560:  MOVFF  B14,B1A
04564:  MOVLB  0
04566:  CALL   407A
0456A:  MOVFF  01,B12
....................         // Add up data byte. 
....................         g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
0456E:  MOVLB  B
04570:  MOVF   x12,W
04572:  MOVLB  6
04574:  ADDWF  x8A,F
....................         // Check for Item weight. 
....................         ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight); 
04576:  MOVLB  B
04578:  CLRF   x4F
0457A:  MOVFF  A19,B4E
0457E:  CLRF   x51
04580:  MOVLW  09
04582:  MOVWF  x50
04584:  MOVLB  0
04586:  CALL   0B2A
0458A:  MOVFF  01,B14
0458E:  MOVLW  06
04590:  MOVLB  B
04592:  ADDWF  01,W
04594:  MOVWF  01
04596:  MOVLW  00
04598:  ADDWFC 02,W
0459A:  MOVWF  03
0459C:  MOVF   01,W
0459E:  ADDLW  95
045A0:  MOVWF  FE9
045A2:  MOVLW  06
045A4:  ADDWFC 03,W
045A6:  MOVWF  FEA
045A8:  MOVFF  FEC,B15
045AC:  MOVF   FED,F
045AE:  MOVFF  FEF,B14
045B2:  CLRF   x1D
045B4:  CLRF   x1C
045B6:  MOVFF  B15,B1B
045BA:  MOVFF  B14,B1A
045BE:  MOVLB  0
045C0:  CALL   407A
045C4:  MOVFF  01,B12
....................         // Add up data byte. 
....................         g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
045C8:  MOVLB  B
045CA:  MOVF   x12,W
045CC:  MOVLB  6
045CE:  ADDWF  x8A,F
....................         // Check for Rejection status. 
....................         ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui8RejectionStatus); 
045D0:  MOVLB  B
045D2:  CLRF   x4F
045D4:  MOVFF  A19,B4E
045D8:  CLRF   x51
045DA:  MOVLW  09
045DC:  MOVWF  x50
045DE:  MOVLB  0
045E0:  CALL   0B2A
045E4:  MOVFF  02,B15
045E8:  MOVFF  01,B14
045EC:  MOVLW  08
045EE:  MOVLB  B
045F0:  ADDWF  01,W
045F2:  MOVWF  01
045F4:  MOVLW  00
045F6:  ADDWFC 02,W
045F8:  MOVWF  03
045FA:  MOVF   01,W
045FC:  ADDLW  95
045FE:  MOVWF  FE9
04600:  MOVLW  06
04602:  ADDWFC 03,W
04604:  MOVWF  FEA
04606:  MOVFF  FEF,B14
0460A:  CLRF   x1D
0460C:  CLRF   x1C
0460E:  CLRF   x1B
04610:  MOVFF  B14,B1A
04614:  MOVLB  0
04616:  CALL   407A
0461A:  MOVFF  01,B12
....................         // Add up data byte. 
....................         g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
0461E:  MOVLB  B
04620:  MOVF   x12,W
04622:  MOVLB  6
04624:  ADDWF  x8A,F
04626:  MOVLB  B
....................          
....................     } 
04628:  MOVLB  0
0462A:  GOTO   477A (RETURN)
.................... } 
....................  
.................... void StuffDummyTimeStamp(void) 
*
00C4C:  MOVLW  2B
00C4E:  MOVLB  B
00C50:  MOVWF  x14
00C52:  MOVLW  67
00C54:  MOVWF  x13
00C56:  CLRF   x15
.................... { 
....................     unsigned int16 ui16DummyTimeStamp = 11111; 
....................     unsigned int8  ui8LoopCount       = 0; 
....................      
....................     for(ui8LoopCount = 0; ui8LoopCount < SIZE_GPRS_DATA_NODE_QUEUE; ui8LoopCount++) 
00C58:  CLRF   x15
00C5A:  MOVF   x15,W
00C5C:  SUBLW  63
00C5E:  BTFSS  FD8.0
00C60:  GOTO   0CA0
....................     { 
....................         // Stuff Data. 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui32TimeStamp = ui16DummyTimeStamp++; 
00C64:  CLRF   x4F
00C66:  MOVFF  B15,B4E
00C6A:  CLRF   x51
00C6C:  MOVLW  09
00C6E:  MOVWF  x50
00C70:  MOVLB  0
00C72:  CALL   0B2A
00C76:  MOVLW  95
00C78:  MOVLB  B
00C7A:  ADDWF  01,W
00C7C:  MOVWF  FE9
00C7E:  MOVLW  06
00C80:  ADDWFC 02,W
00C82:  MOVWF  FEA
00C84:  MOVFF  B14,03
00C88:  MOVF   x13,W
00C8A:  INCF   x13,F
00C8C:  BTFSC  FD8.2
00C8E:  INCF   x14,F
00C90:  MOVWF  FEF
00C92:  MOVFF  03,FEC
00C96:  CLRF   FEC
00C98:  CLRF   FEC
00C9A:  INCF   x15,F
00C9C:  GOTO   0C5A
....................     } 
00CA0:  MOVLB  0
00CA2:  RETURN 0
.................... } 
....................  
....................  
.................... void InitializeGPRSMsgQueue(void) 
.................... { 
....................     // Initialize front and rear of the queue 
....................     g_stGPRSMsgSendQueue.m_i8Front = -1; 
*
00B4C:  MOVLB  A
00B4E:  SETF   x19
....................     g_stGPRSMsgSendQueue.m_i8Rear = -1; 
00B50:  SETF   x1A
....................      
....................     // Initialize each queue element 
....................     for(unsigned int8 ui8LoopCount = 0; ui8LoopCount < SIZE_GPRS_DATA_NODE_QUEUE; ui8LoopCount++) 
00B52:  MOVLB  B
00B54:  CLRF   x13
00B56:  MOVF   x13,W
00B58:  SUBLW  63
00B5A:  BTFSS  FD8.0
00B5C:  GOTO   0C36
....................     { 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui16ItemWeight = 0; 
00B60:  CLRF   x4F
00B62:  MOVFF  B13,B4E
00B66:  CLRF   x51
00B68:  MOVLW  09
00B6A:  MOVWF  x50
00B6C:  MOVLB  0
00B6E:  CALL   0B2A
00B72:  MOVFF  01,B14
00B76:  MOVLW  06
00B78:  MOVLB  B
00B7A:  ADDWF  01,W
00B7C:  MOVWF  01
00B7E:  MOVLW  00
00B80:  ADDWFC 02,W
00B82:  MOVWF  03
00B84:  MOVF   01,W
00B86:  ADDLW  95
00B88:  MOVWF  FE9
00B8A:  MOVLW  06
00B8C:  ADDWFC 03,W
00B8E:  MOVWF  FEA
00B90:  CLRF   FEC
00B92:  MOVF   FED,F
00B94:  CLRF   FEF
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui16SequenceNo = 0; 
00B96:  CLRF   x4F
00B98:  MOVFF  B13,B4E
00B9C:  CLRF   x51
00B9E:  MOVLW  09
00BA0:  MOVWF  x50
00BA2:  MOVLB  0
00BA4:  CALL   0B2A
00BA8:  MOVFF  01,B14
00BAC:  MOVLW  04
00BAE:  MOVLB  B
00BB0:  ADDWF  01,W
00BB2:  MOVWF  01
00BB4:  MOVLW  00
00BB6:  ADDWFC 02,W
00BB8:  MOVWF  03
00BBA:  MOVF   01,W
00BBC:  ADDLW  95
00BBE:  MOVWF  FE9
00BC0:  MOVLW  06
00BC2:  ADDWFC 03,W
00BC4:  MOVWF  FEA
00BC6:  CLRF   FEC
00BC8:  MOVF   FED,F
00BCA:  CLRF   FEF
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui32TimeStamp  = 0; 
00BCC:  CLRF   x4F
00BCE:  MOVFF  B13,B4E
00BD2:  CLRF   x51
00BD4:  MOVLW  09
00BD6:  MOVWF  x50
00BD8:  MOVLB  0
00BDA:  CALL   0B2A
00BDE:  MOVLW  95
00BE0:  MOVLB  B
00BE2:  ADDWF  01,W
00BE4:  MOVWF  FE9
00BE6:  MOVLW  06
00BE8:  ADDWFC 02,W
00BEA:  MOVWF  FEA
00BEC:  MOVF   FEE,F
00BEE:  MOVF   FEE,F
00BF0:  CLRF   FEC
00BF2:  MOVF   FED,F
00BF4:  CLRF   FEF
00BF6:  MOVF   FED,F
00BF8:  CLRF   FEF
00BFA:  MOVF   FED,F
00BFC:  CLRF   FEF
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui8RejectionStatus = 0; 
00BFE:  CLRF   x4F
00C00:  MOVFF  B13,B4E
00C04:  CLRF   x51
00C06:  MOVLW  09
00C08:  MOVWF  x50
00C0A:  MOVLB  0
00C0C:  CALL   0B2A
00C10:  MOVFF  01,B14
00C14:  MOVLW  08
00C16:  MOVLB  B
00C18:  ADDWF  01,W
00C1A:  MOVWF  01
00C1C:  MOVLW  00
00C1E:  ADDWFC 02,W
00C20:  MOVWF  03
00C22:  MOVF   01,W
00C24:  ADDLW  95
00C26:  MOVWF  FE9
00C28:  MOVLW  06
00C2A:  ADDWFC 03,W
00C2C:  MOVWF  FEA
00C2E:  CLRF   FEF
00C30:  INCF   x13,F
00C32:  GOTO   0B56
....................     } 
00C36:  MOVLB  0
00C38:  RETURN 0
....................  
.................... } 
....................  
.................... unsigned int8 IsGPRSMsgQueueEmpty(void) 
*
0401E:  MOVLB  B
04020:  CLRF   x12
.................... { 
....................     unsigned int8 ui8QueueStatus = 0; 
....................      
....................     if(g_stGPRSMsgSendQueue.m_i8Rear == -1) /* Queue at initial state; queue is empty */ 
04022:  MOVLB  A
04024:  MOVF   x1A,W
04026:  SUBLW  FF
04028:  BTFSS  FD8.2
0402A:  GOTO   403A
....................     { 
....................         ui8QueueStatus = 1; 
0402E:  MOVLW  01
04030:  MOVLB  B
04032:  MOVWF  x12
....................     } 
04034:  GOTO   406C
04038:  MOVLB  A
....................     else if(g_stGPRSMsgSendQueue.m_i8Front == g_stGPRSMsgSendQueue.m_i8Rear) /* All data sent; queue is empty */ 
0403A:  MOVF   x1A,W
0403C:  SUBWF  x19,W
0403E:  BTFSS  FD8.2
04040:  GOTO   4050
....................     { 
....................         // Update flag that last element present in the queue. 
....................         g_fIsLastElementInGPRSQueue = 1; 
04044:  MOVLW  01
04046:  MOVLB  4
04048:  MOVWF  x93
....................          
....................         // Reset GPRS message queue 
....................         //InitializeGPRSMsgQueue(); 
....................          
....................         //ui8QueueStatus = 1; 
....................     } 
0404A:  GOTO   406E
0404E:  MOVLB  A
....................     else if(g_stGPRSMsgSendQueue.m_i8Front == g_stGPRSMsgSendQueue.m_i8Rear + 1) 
04050:  MOVLW  01
04052:  ADDWF  x1A,W
04054:  SUBWF  x19,W
04056:  BTFSS  FD8.2
04058:  GOTO   406C
....................     { 
....................         // Reset GPRS message queue 
....................         InitializeGPRSMsgQueue(); 
0405C:  MOVLB  0
0405E:  CALL   0B4C
....................         // Stuff dummy time stamp. 
....................         StuffDummyTimeStamp(); 
04062:  CALL   0C4C
....................          
....................         // Update data availability status in queue. 
....................         ui8QueueStatus = 1; 
04066:  MOVLW  01
04068:  MOVLB  B
0406A:  MOVWF  x12
0406C:  MOVLB  4
....................     } 
....................      
....................     return ui8QueueStatus; 
0406E:  MOVLB  B
04070:  MOVFF  B12,01
04074:  MOVLB  0
04076:  GOTO   6698 (RETURN)
.................... } 
....................  
.................... void InsertInGPRSMsgQueue() 
.................... { 
....................     if ((g_stGPRSMsgSendQueue.m_i8Front == 0 && g_stGPRSMsgSendQueue.m_i8Rear == SIZE_GPRS_DATA_NODE_QUEUE - 1) ||  
....................             (g_stGPRSMsgSendQueue.m_i8Front == g_stGPRSMsgSendQueue.m_i8Rear + 1))  
*
0148E:  MOVLB  A
01490:  MOVF   x19,F
01492:  BTFSS  FD8.2
01494:  GOTO   14A2
01498:  MOVF   x1A,W
0149A:  SUBLW  63
0149C:  BTFSC  FD8.2
0149E:  GOTO   14AE
014A2:  MOVLW  01
014A4:  ADDWF  x1A,W
014A6:  SUBWF  x19,W
014A8:  BTFSS  FD8.2
014AA:  GOTO   14B6
....................     {  
....................         //printf("\nQueue is Full");  
....................         return;  
014AE:  GOTO   16E6
....................     } 
014B2:  GOTO   16E6
....................      
....................     else if (g_stGPRSMsgSendQueue.m_i8Rear == -1) /* Insert First Element */ 
014B6:  MOVF   x1A,W
014B8:  SUBLW  FF
014BA:  BTFSS  FD8.2
014BC:  GOTO   1574
....................     {  
....................         // Initialize queue front and rear. 
....................         g_stGPRSMsgSendQueue.m_i8Rear = 0; 
014C0:  CLRF   x1A
....................         g_stGPRSMsgSendQueue.m_i8Front = 0; 
014C2:  CLRF   x19
....................          
....................         // Insert Data 
....................         //arr[g_stIBCDataSendQueue.m_i8Rear] = value; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16SequenceNo = g_stProdModeCurrBoxData.m_ui16SequenceNo; 
014C4:  MOVLB  B
014C6:  CLRF   x4F
014C8:  MOVFF  A1A,B4E
014CC:  CLRF   x51
014CE:  MOVLW  09
014D0:  MOVWF  x50
014D2:  MOVLB  0
014D4:  CALL   0B2A
014D8:  MOVFF  01,B1D
014DC:  MOVLW  04
014DE:  MOVLB  B
014E0:  ADDWF  01,W
014E2:  MOVWF  01
014E4:  MOVLW  00
014E6:  ADDWFC 02,W
014E8:  MOVWF  03
014EA:  MOVF   01,W
014EC:  ADDLW  95
014EE:  MOVWF  FE9
014F0:  MOVLW  06
014F2:  ADDWFC 03,W
014F4:  MOVWF  FEA
014F6:  MOVFF  A1E,FEC
014FA:  MOVF   FED,F
014FC:  MOVFF  A1D,FEF
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16ItemWeight = g_stProdModeCurrBoxData.m_i16BoxWeight; 
01500:  CLRF   x4F
01502:  MOVFF  A1A,B4E
01506:  CLRF   x51
01508:  MOVLW  09
0150A:  MOVWF  x50
0150C:  MOVLB  0
0150E:  CALL   0B2A
01512:  MOVFF  01,B1D
01516:  MOVLW  06
01518:  MOVLB  B
0151A:  ADDWF  01,W
0151C:  MOVWF  01
0151E:  MOVLW  00
01520:  ADDWFC 02,W
01522:  MOVWF  03
01524:  MOVF   01,W
01526:  ADDLW  95
01528:  MOVWF  FE9
0152A:  MOVLW  06
0152C:  ADDWFC 03,W
0152E:  MOVWF  FEA
01530:  MOVFF  A1C,FEC
01534:  MOVF   FED,F
01536:  MOVFF  A1B,FEF
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui8RejectionStatus = (unsigned int8)g_stProdModeCurrBoxData.m_ui16RejectionStatus; 
0153A:  CLRF   x4F
0153C:  MOVFF  A1A,B4E
01540:  CLRF   x51
01542:  MOVLW  09
01544:  MOVWF  x50
01546:  MOVLB  0
01548:  CALL   0B2A
0154C:  MOVFF  01,B1D
01550:  MOVLW  08
01552:  MOVLB  B
01554:  ADDWF  01,W
01556:  MOVWF  01
01558:  MOVLW  00
0155A:  ADDWFC 02,W
0155C:  MOVWF  03
0155E:  MOVF   01,W
01560:  ADDLW  95
01562:  MOVWF  FE9
01564:  MOVLW  06
01566:  ADDWFC 03,W
01568:  MOVWF  FEA
0156A:  MOVFF  A1F,FEF
....................         //g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui32TimeStamp = g_stProdModeCurrBoxData.m_ui32TimeStamp; 
....................     }  
0156E:  GOTO   16E4
01572:  MOVLB  A
....................      
....................     else if (g_stGPRSMsgSendQueue.m_i8Rear == SIZE_GPRS_DATA_NODE_QUEUE - 1 && g_stGPRSMsgSendQueue.m_i8Front != 0) /* Rear reached at last position */ 
01574:  MOVF   x1A,W
01576:  SUBLW  63
01578:  BTFSS  FD8.2
0157A:  GOTO   1638
0157E:  MOVF   x19,F
01580:  BTFSC  FD8.2
01582:  GOTO   1638
....................     {  
....................         // Make queue circular 
....................         g_stGPRSMsgSendQueue.m_i8Rear = 0;  
01586:  CLRF   x1A
....................          
....................         // Insert data 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16SequenceNo = g_stProdModeCurrBoxData.m_ui16SequenceNo; 
01588:  MOVLB  B
0158A:  CLRF   x4F
0158C:  MOVFF  A1A,B4E
01590:  CLRF   x51
01592:  MOVLW  09
01594:  MOVWF  x50
01596:  MOVLB  0
01598:  CALL   0B2A
0159C:  MOVFF  01,B1D
015A0:  MOVLW  04
015A2:  MOVLB  B
015A4:  ADDWF  01,W
015A6:  MOVWF  01
015A8:  MOVLW  00
015AA:  ADDWFC 02,W
015AC:  MOVWF  03
015AE:  MOVF   01,W
015B0:  ADDLW  95
015B2:  MOVWF  FE9
015B4:  MOVLW  06
015B6:  ADDWFC 03,W
015B8:  MOVWF  FEA
015BA:  MOVFF  A1E,FEC
015BE:  MOVF   FED,F
015C0:  MOVFF  A1D,FEF
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16ItemWeight = g_stProdModeCurrBoxData.m_i16BoxWeight; 
015C4:  CLRF   x4F
015C6:  MOVFF  A1A,B4E
015CA:  CLRF   x51
015CC:  MOVLW  09
015CE:  MOVWF  x50
015D0:  MOVLB  0
015D2:  CALL   0B2A
015D6:  MOVFF  01,B1D
015DA:  MOVLW  06
015DC:  MOVLB  B
015DE:  ADDWF  01,W
015E0:  MOVWF  01
015E2:  MOVLW  00
015E4:  ADDWFC 02,W
015E6:  MOVWF  03
015E8:  MOVF   01,W
015EA:  ADDLW  95
015EC:  MOVWF  FE9
015EE:  MOVLW  06
015F0:  ADDWFC 03,W
015F2:  MOVWF  FEA
015F4:  MOVFF  A1C,FEC
015F8:  MOVF   FED,F
015FA:  MOVFF  A1B,FEF
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui8RejectionStatus = (unsigned int8)g_stProdModeCurrBoxData.m_ui16RejectionStatus;  
015FE:  CLRF   x4F
01600:  MOVFF  A1A,B4E
01604:  CLRF   x51
01606:  MOVLW  09
01608:  MOVWF  x50
0160A:  MOVLB  0
0160C:  CALL   0B2A
01610:  MOVFF  01,B1D
01614:  MOVLW  08
01616:  MOVLB  B
01618:  ADDWF  01,W
0161A:  MOVWF  01
0161C:  MOVLW  00
0161E:  ADDWFC 02,W
01620:  MOVWF  03
01622:  MOVF   01,W
01624:  ADDLW  95
01626:  MOVWF  FE9
01628:  MOVLW  06
0162A:  ADDWFC 03,W
0162C:  MOVWF  FEA
0162E:  MOVFF  A1F,FEF
....................         //g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui32TimeStamp = g_stProdModeCurrBoxData.m_ui32TimeStamp; 
....................     }  
01632:  GOTO   16E4
01636:  MOVLB  A
....................      
....................     else 
....................     {  
....................         // Normal data insertion..not in boundary condition 
....................         g_stGPRSMsgSendQueue.m_i8Rear++;  
01638:  INCF   x1A,F
....................          
....................         // Insert data 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16SequenceNo = g_stProdModeCurrBoxData.m_ui16SequenceNo; 
0163A:  MOVLB  B
0163C:  CLRF   x4F
0163E:  MOVFF  A1A,B4E
01642:  CLRF   x51
01644:  MOVLW  09
01646:  MOVWF  x50
01648:  MOVLB  0
0164A:  CALL   0B2A
0164E:  MOVFF  01,B1D
01652:  MOVLW  04
01654:  MOVLB  B
01656:  ADDWF  01,W
01658:  MOVWF  01
0165A:  MOVLW  00
0165C:  ADDWFC 02,W
0165E:  MOVWF  03
01660:  MOVF   01,W
01662:  ADDLW  95
01664:  MOVWF  FE9
01666:  MOVLW  06
01668:  ADDWFC 03,W
0166A:  MOVWF  FEA
0166C:  MOVFF  A1E,FEC
01670:  MOVF   FED,F
01672:  MOVFF  A1D,FEF
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16ItemWeight = g_stProdModeCurrBoxData.m_i16BoxWeight; 
01676:  CLRF   x4F
01678:  MOVFF  A1A,B4E
0167C:  CLRF   x51
0167E:  MOVLW  09
01680:  MOVWF  x50
01682:  MOVLB  0
01684:  CALL   0B2A
01688:  MOVFF  01,B1D
0168C:  MOVLW  06
0168E:  MOVLB  B
01690:  ADDWF  01,W
01692:  MOVWF  01
01694:  MOVLW  00
01696:  ADDWFC 02,W
01698:  MOVWF  03
0169A:  MOVF   01,W
0169C:  ADDLW  95
0169E:  MOVWF  FE9
016A0:  MOVLW  06
016A2:  ADDWFC 03,W
016A4:  MOVWF  FEA
016A6:  MOVFF  A1C,FEC
016AA:  MOVF   FED,F
016AC:  MOVFF  A1B,FEF
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui8RejectionStatus = (unsigned int8)g_stProdModeCurrBoxData.m_ui16RejectionStatus; 
016B0:  CLRF   x4F
016B2:  MOVFF  A1A,B4E
016B6:  CLRF   x51
016B8:  MOVLW  09
016BA:  MOVWF  x50
016BC:  MOVLB  0
016BE:  CALL   0B2A
016C2:  MOVFF  01,B1D
016C6:  MOVLW  08
016C8:  MOVLB  B
016CA:  ADDWF  01,W
016CC:  MOVWF  01
016CE:  MOVLW  00
016D0:  ADDWFC 02,W
016D2:  MOVWF  03
016D4:  MOVF   01,W
016D6:  ADDLW  95
016D8:  MOVWF  FE9
016DA:  MOVLW  06
016DC:  ADDWFC 03,W
016DE:  MOVWF  FEA
016E0:  MOVFF  A1F,FEF
016E4:  MOVLB  A
....................         //g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui32TimeStamp = g_stProdModeCurrBoxData.m_ui32TimeStamp; 
....................     }  
016E6:  MOVLB  0
016E8:  GOTO   1966 (RETURN)
.................... } 
....................  
.................... void InitializeGPRSMsgHeader(void) 
.................... { 
....................     // Stuff Machine ID and Variety type in GPRS Message header. 
....................     // Amta plant(Line 2) -> Machine ID - 2 and Marie Gold variety Type - 3. 
....................     // Delta Foods Machine ID - 4 
....................     // Super Snacks Machine ID - 5 
....................     g_stGPRSMsgHeader.m_ui16MachineID = MACHINE_ID;  // Delta 
*
00C3A:  MOVLB  2
00C3C:  CLRF   x94
00C3E:  MOVLW  02
00C40:  MOVWF  x93
....................     g_stGPRSMsgHeader.m_ui8Variety = 4; 
00C42:  MOVLW  04
00C44:  MOVWF  x95
00C46:  MOVLB  0
00C48:  GOTO   0D4C (RETURN)
.................... } 
....................  
.................... void StuffGPRSMSgQueueDummy(void) 
.................... { 
....................     unsigned int8  ui8NoOfMessage     = 5; 
....................     unsigned int16 ui16MachineID      = 1; 
....................     unsigned int8  ui8Variety         = 6; 
....................      
....................     unsigned int32 ui32TimeStamp       = 4545; 
....................     unsigned int16 ui16SequenceNo      = 1; 
....................     int16          i16Itemweight       = 7000; 
....................     unsigned int16 ui16Rejectionstatus = 1; 
....................      
....................     // Stuff dummy message header 
....................     g_stGPRSMsgHeader.m_ui8NoOfMessages = ui8NoOfMessage; 
....................     g_stGPRSMsgHeader.m_ui16MachineID   = ui16MachineID; 
....................     g_stGPRSMsgHeader.m_ui8Variety      = ui8Variety; 
....................      
....................     for(unsigned int8 ui8LoopCount = 0; ui8LoopCount < SIZE_GPRS_DATA_NODE_QUEUE; ui8LoopCount++) 
....................     { 
....................         g_stGPRSMsgSendQueue.m_i8Rear++; 
....................          
....................         // Stuff data 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui32TimeStamp = ui32TimeStamp++; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16SequenceNo = ui16SequenceNo++; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16ItemWeight = i16Itemweight++; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui8RejectionStatus = ui16Rejectionstatus; 
....................     } 
....................      
....................     //g_stGPRSMsgSendQueue.m_i8Front = 0; 
.................... } 
....................  
....................  
....................  
.................... // ################################################################# Below GPRS Connection Driver ############################################################# 
....................  
.................... unsigned int8 SetPDPContext(void) 
*
03A64:  MOVLW  01
03A66:  MOVLB  B
03A68:  MOVWF  x13
.................... { 
....................     unsigned int8 ui8IsOKFound = 1; 
....................     g_fIsTimedOut = 0; 
03A6A:  MOVLB  2
03A6C:  CLRF   x34
....................      
....................     // Reset Rx buffer. 
....................     ResetGSMM66RxBuffer(); 
03A6E:  MOVLB  0
03A70:  CALL   1A5A
....................     // Set AT command for define PDP Context. 
....................     fputs("AT+CGDCONT=1,\"IP\",\"www\"\r", GSM_M66); 
03A74:  MOVLW  C2
03A76:  MOVWF  FF6
03A78:  MOVLW  07
03A7A:  MOVWF  FF7
03A7C:  CALL   1A7A
03A80:  MOVLW  0D
03A82:  CLRWDT
03A84:  BTFSS  F9E.4
03A86:  GOTO   3A82
03A8A:  MOVWF  FAD
03A8C:  MOVLW  0A
03A8E:  CLRWDT
03A90:  BTFSS  F9E.4
03A92:  GOTO   3A8E
03A96:  MOVWF  FAD
....................     // Set timeout. 
....................     SetTimeout(2); 
03A98:  MOVLW  02
03A9A:  MOVLB  B
03A9C:  MOVWF  x1B
03A9E:  MOVLB  0
03AA0:  CALL   1AA6
....................     // Wait for response. 
....................     while(g_fIsTimedOut == 0 && ui8IsOKFound == 1) 
03AA4:  MOVLB  2
03AA6:  MOVF   x34,F
03AA8:  BTFSS  FD8.2
03AAA:  GOTO   3B7E
03AAE:  MOVLB  B
03AB0:  DECFSZ x13,W
03AB2:  BRA    3AB6
03AB4:  BRA    3ABC
03AB6:  MOVLB  2
03AB8:  GOTO   3B7E
....................     { 
....................         // Loop through entire receive buffer. 
....................         for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
03ABC:  CLRF   x15
03ABE:  CLRF   x14
03AC0:  MOVF   x15,W
03AC2:  MOVLB  6
03AC4:  SUBWF  x89,W
03AC6:  BTFSS  FD8.0
03AC8:  GOTO   3B76
03ACC:  BTFSS  FD8.2
03ACE:  GOTO   3AE4
03AD2:  MOVF   x88,W
03AD4:  MOVLB  B
03AD6:  SUBWF  x14,W
03AD8:  BTFSS  FD8.0
03ADA:  BRA    3AE2
03ADC:  MOVLB  6
03ADE:  GOTO   3B76
03AE2:  MOVLB  6
....................         { 
....................             // Check for "OK". 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
03AE4:  MOVLW  94
03AE6:  MOVLB  B
03AE8:  ADDWF  x14,W
03AEA:  MOVWF  FE9
03AEC:  MOVLW  04
03AEE:  ADDWFC x15,W
03AF0:  MOVWF  FEA
03AF2:  MOVF   FEF,W
03AF4:  SUBLW  0A
03AF6:  BTFSS  FD8.2
03AF8:  GOTO   3B6C
03AFC:  MOVLW  01
03AFE:  SUBWF  x14,W
03B00:  MOVWF  x16
03B02:  MOVLW  00
03B04:  SUBWFB x15,W
03B06:  MOVWF  x17
03B08:  MOVLW  94
03B0A:  ADDWF  x16,W
03B0C:  MOVWF  FE9
03B0E:  MOVLW  04
03B10:  ADDWFC x17,W
03B12:  MOVWF  FEA
03B14:  MOVF   FEF,W
03B16:  SUBLW  0D
03B18:  BTFSS  FD8.2
03B1A:  GOTO   3B6C
03B1E:  MOVLW  02
03B20:  SUBWF  x14,W
03B22:  MOVWF  x18
03B24:  MOVLW  00
03B26:  SUBWFB x15,W
03B28:  MOVWF  x19
03B2A:  MOVLW  94
03B2C:  ADDWF  x18,W
03B2E:  MOVWF  FE9
03B30:  MOVLW  04
03B32:  ADDWFC x19,W
03B34:  MOVWF  FEA
03B36:  MOVF   FEF,W
03B38:  SUBLW  4B
03B3A:  BTFSS  FD8.2
03B3C:  GOTO   3B6C
03B40:  MOVLW  03
03B42:  SUBWF  x14,W
03B44:  MOVWF  x1A
03B46:  MOVLW  00
03B48:  SUBWFB x15,W
03B4A:  MOVWF  x1B
03B4C:  MOVLW  94
03B4E:  ADDWF  x1A,W
03B50:  MOVWF  FE9
03B52:  MOVLW  04
03B54:  ADDWFC x1B,W
03B56:  MOVWF  FEA
03B58:  MOVF   FEF,W
03B5A:  SUBLW  4F
03B5C:  BTFSS  FD8.2
03B5E:  GOTO   3B6C
....................                { 
....................                    // Set flag denoting 'OK' is found. 
....................                    ui8IsOKFound = 0; 
03B62:  CLRF   x13
....................                    break; 
03B64:  MOVLB  6
03B66:  GOTO   3B76
03B6A:  MOVLB  B
....................                } 
03B6C:  INCF   x14,F
03B6E:  BTFSC  FD8.2
03B70:  INCF   x15,F
03B72:  GOTO   3AC0
....................         } 
03B76:  MOVLB  0
03B78:  GOTO   3AA4
03B7C:  MOVLB  2
....................     } 
....................      
....................     return ui8IsOKFound; 
03B7E:  MOVLB  B
03B80:  MOVFF  B13,01
03B84:  MOVLB  0
03B86:  GOTO   3FCA (RETURN)
.................... } 
....................  
.................... unsigned int8 ActivatePDP(void) 
03B8A:  MOVLW  01
03B8C:  MOVLB  B
03B8E:  MOVWF  x13
.................... { 
....................     unsigned int8 ui8IsOKFound = 1; 
....................     g_fIsTimedOut = 0; 
03B90:  MOVLB  2
03B92:  CLRF   x34
....................      
....................     // Reset Rx buffer. 
....................     ResetGSMM66RxBuffer(); 
03B94:  MOVLB  0
03B96:  CALL   1A5A
....................     // Set AT command to activate PDP context. 
....................     fputs("AT+CGACT=1,1\r", GSM_M66); 
03B9A:  MOVLW  DC
03B9C:  MOVWF  FF6
03B9E:  MOVLW  07
03BA0:  MOVWF  FF7
03BA2:  CALL   1A7A
03BA6:  MOVLW  0D
03BA8:  CLRWDT
03BAA:  BTFSS  F9E.4
03BAC:  GOTO   3BA8
03BB0:  MOVWF  FAD
03BB2:  MOVLW  0A
03BB4:  CLRWDT
03BB6:  BTFSS  F9E.4
03BB8:  GOTO   3BB4
03BBC:  MOVWF  FAD
....................     // Set timeout. 
....................     SetTimeout(2); 
03BBE:  MOVLW  02
03BC0:  MOVLB  B
03BC2:  MOVWF  x1B
03BC4:  MOVLB  0
03BC6:  CALL   1AA6
....................     // Wait for response. 
....................     while(g_fIsTimedOut == 0 && ui8IsOKFound == 1) 
03BCA:  MOVLB  2
03BCC:  MOVF   x34,F
03BCE:  BTFSS  FD8.2
03BD0:  GOTO   3CA4
03BD4:  MOVLB  B
03BD6:  DECFSZ x13,W
03BD8:  BRA    3BDC
03BDA:  BRA    3BE2
03BDC:  MOVLB  2
03BDE:  GOTO   3CA4
....................     { 
....................         // Loop through entire receive buffer. 
....................         for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
03BE2:  CLRF   x15
03BE4:  CLRF   x14
03BE6:  MOVF   x15,W
03BE8:  MOVLB  6
03BEA:  SUBWF  x89,W
03BEC:  BTFSS  FD8.0
03BEE:  GOTO   3C9C
03BF2:  BTFSS  FD8.2
03BF4:  GOTO   3C0A
03BF8:  MOVF   x88,W
03BFA:  MOVLB  B
03BFC:  SUBWF  x14,W
03BFE:  BTFSS  FD8.0
03C00:  BRA    3C08
03C02:  MOVLB  6
03C04:  GOTO   3C9C
03C08:  MOVLB  6
....................         { 
....................             // Check for "OK". 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
03C0A:  MOVLW  94
03C0C:  MOVLB  B
03C0E:  ADDWF  x14,W
03C10:  MOVWF  FE9
03C12:  MOVLW  04
03C14:  ADDWFC x15,W
03C16:  MOVWF  FEA
03C18:  MOVF   FEF,W
03C1A:  SUBLW  0A
03C1C:  BTFSS  FD8.2
03C1E:  GOTO   3C92
03C22:  MOVLW  01
03C24:  SUBWF  x14,W
03C26:  MOVWF  x16
03C28:  MOVLW  00
03C2A:  SUBWFB x15,W
03C2C:  MOVWF  x17
03C2E:  MOVLW  94
03C30:  ADDWF  x16,W
03C32:  MOVWF  FE9
03C34:  MOVLW  04
03C36:  ADDWFC x17,W
03C38:  MOVWF  FEA
03C3A:  MOVF   FEF,W
03C3C:  SUBLW  0D
03C3E:  BTFSS  FD8.2
03C40:  GOTO   3C92
03C44:  MOVLW  02
03C46:  SUBWF  x14,W
03C48:  MOVWF  x18
03C4A:  MOVLW  00
03C4C:  SUBWFB x15,W
03C4E:  MOVWF  x19
03C50:  MOVLW  94
03C52:  ADDWF  x18,W
03C54:  MOVWF  FE9
03C56:  MOVLW  04
03C58:  ADDWFC x19,W
03C5A:  MOVWF  FEA
03C5C:  MOVF   FEF,W
03C5E:  SUBLW  4B
03C60:  BTFSS  FD8.2
03C62:  GOTO   3C92
03C66:  MOVLW  03
03C68:  SUBWF  x14,W
03C6A:  MOVWF  x1A
03C6C:  MOVLW  00
03C6E:  SUBWFB x15,W
03C70:  MOVWF  x1B
03C72:  MOVLW  94
03C74:  ADDWF  x1A,W
03C76:  MOVWF  FE9
03C78:  MOVLW  04
03C7A:  ADDWFC x1B,W
03C7C:  MOVWF  FEA
03C7E:  MOVF   FEF,W
03C80:  SUBLW  4F
03C82:  BTFSS  FD8.2
03C84:  GOTO   3C92
....................                { 
....................                    // Set flag denoting 'OK' is found. 
....................                    ui8IsOKFound = 0; 
03C88:  CLRF   x13
....................                    break; 
03C8A:  MOVLB  6
03C8C:  GOTO   3C9C
03C90:  MOVLB  B
....................                } 
03C92:  INCF   x14,F
03C94:  BTFSC  FD8.2
03C96:  INCF   x15,F
03C98:  GOTO   3BE6
....................         } 
03C9C:  MOVLB  0
03C9E:  GOTO   3BCA
03CA2:  MOVLB  2
....................     } 
....................      
....................     return ui8IsOKFound; 
03CA4:  MOVLB  B
03CA6:  MOVFF  B13,01
03CAA:  MOVLB  0
03CAC:  GOTO   3FE6 (RETURN)
.................... }  
....................  
.................... unsigned int8 ShowActivatedAddress(void) 
03CB0:  MOVLW  01
03CB2:  MOVLB  B
03CB4:  MOVWF  x13
03CB6:  CLRF   x14
03CB8:  CLRF   x15
03CBA:  CLRF   x16
03CBC:  CLRF   x17
.................... { 
....................     unsigned int8 ui8IsResponseFound            = 1; 
....................     unsigned int8 ui8FirstCharSequenceFound     = 0; 
....................     unsigned int8 ui8FirstCharSeqIndex          = 0; 
....................     unsigned int8 ui8SecondCharSequenceFound    = 0; 
....................     unsigned int8 ui8DoubleQuoteCount           = 0; 
....................     
....................      
....................     // Reset Rx buffer. 
....................     ResetGSMM66RxBuffer(); 
03CBE:  MOVLB  0
03CC0:  CALL   1A5A
....................     // Set AT command to Show activated PDP address. 
....................     fputs("AT+CGPADDR=1\r",GSM_M66); 
03CC4:  MOVLW  EA
03CC6:  MOVWF  FF6
03CC8:  MOVLW  07
03CCA:  MOVWF  FF7
03CCC:  CALL   1A7A
03CD0:  MOVLW  0D
03CD2:  CLRWDT
03CD4:  BTFSS  F9E.4
03CD6:  GOTO   3CD2
03CDA:  MOVWF  FAD
03CDC:  MOVLW  0A
03CDE:  CLRWDT
03CE0:  BTFSS  F9E.4
03CE2:  GOTO   3CDE
03CE6:  MOVWF  FAD
....................     delay_ms(2000); 
03CE8:  MOVLW  08
03CEA:  MOVLB  B
03CEC:  MOVWF  x1B
03CEE:  MOVLW  FA
03CF0:  MOVWF  x34
03CF2:  MOVLB  0
03CF4:  CALL   0DB2
03CF8:  MOVLB  B
03CFA:  DECFSZ x1B,F
03CFC:  BRA    3CEE
....................     // Set timeout. 
....................     SetTimeout(2); 
03CFE:  MOVLW  02
03D00:  MOVWF  x1B
03D02:  MOVLB  0
03D04:  CALL   1AA6
....................     // Reset timeout flag. 
....................      g_fIsTimedOut = 0; 
03D08:  MOVLB  2
03D0A:  CLRF   x34
....................     // Wait for response. 
....................     while(g_fIsTimedOut == 0 && ui8IsResponseFound == 1) 
03D0C:  MOVF   x34,F
03D0E:  BTFSS  FD8.2
03D10:  GOTO   3FB0
03D14:  MOVLB  B
03D16:  DECFSZ x13,W
03D18:  BRA    3D1C
03D1A:  BRA    3D22
03D1C:  MOVLB  2
03D1E:  GOTO   3FB0
....................     { 
....................         // Reset WDT 
....................         //restart_wdt(); 
....................         // Reset variables. 
....................         ui8FirstCharSequenceFound  = 0; 
03D22:  CLRF   x14
....................         ui8FirstCharSeqIndex       = 0; 
03D24:  CLRF   x15
....................         ui8SecondCharSequenceFound = 0; 
03D26:  CLRF   x16
....................          
....................         // Loop through entire receive buffer. 
....................         for(unsigned int16 ui16ByteCount = 0; ui16ByteCount <= g_ui16M66RxByteCount; ui16ByteCount++) 
03D28:  CLRF   x19
03D2A:  CLRF   x18
03D2C:  MOVF   x19,W
03D2E:  MOVLB  6
03D30:  SUBWF  x89,W
03D32:  BTFSS  FD8.0
03D34:  GOTO   3FAA
03D38:  BTFSS  FD8.2
03D3A:  GOTO   3D4C
03D3E:  MOVLB  B
03D40:  MOVF   x18,W
03D42:  MOVLB  6
03D44:  SUBWF  x88,W
03D46:  BTFSS  FD8.0
03D48:  GOTO   3FAA
....................         { 
....................             // Check for first character sequence. 
....................             if(ui8FirstCharSequenceFound == 0 && ui8SecondCharSequenceFound == 0) 
03D4C:  MOVLB  B
03D4E:  MOVF   x14,F
03D50:  BTFSS  FD8.2
03D52:  GOTO   3E90
03D56:  MOVF   x16,F
03D58:  BTFSS  FD8.2
03D5A:  GOTO   3E90
....................             { 
....................                 if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ':' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'R' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'D' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'D' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'A' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'P' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 6)] == 'G' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 7)] == 'C' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 8)] == '+') 
03D5E:  MOVLW  94
03D60:  ADDWF  x18,W
03D62:  MOVWF  FE9
03D64:  MOVLW  04
03D66:  ADDWFC x19,W
03D68:  MOVWF  FEA
03D6A:  MOVF   FEF,W
03D6C:  SUBLW  3A
03D6E:  BTFSS  FD8.2
03D70:  GOTO   3E8C
03D74:  MOVLW  01
03D76:  SUBWF  x18,W
03D78:  MOVWF  x1B
03D7A:  MOVLW  00
03D7C:  SUBWFB x19,W
03D7E:  MOVWF  x1C
03D80:  MOVLW  94
03D82:  ADDWF  x1B,W
03D84:  MOVWF  FE9
03D86:  MOVLW  04
03D88:  ADDWFC x1C,W
03D8A:  MOVWF  FEA
03D8C:  MOVF   FEF,W
03D8E:  SUBLW  52
03D90:  BTFSS  FD8.2
03D92:  GOTO   3E8C
03D96:  MOVLW  02
03D98:  SUBWF  x18,W
03D9A:  MOVWF  x1D
03D9C:  MOVLW  00
03D9E:  SUBWFB x19,W
03DA0:  MOVWF  x1E
03DA2:  MOVLW  94
03DA4:  ADDWF  x1D,W
03DA6:  MOVWF  FE9
03DA8:  MOVLW  04
03DAA:  ADDWFC x1E,W
03DAC:  MOVWF  FEA
03DAE:  MOVF   FEF,W
03DB0:  SUBLW  44
03DB2:  BTFSS  FD8.2
03DB4:  GOTO   3E8C
03DB8:  MOVLW  03
03DBA:  SUBWF  x18,W
03DBC:  MOVWF  x1F
03DBE:  MOVLW  00
03DC0:  SUBWFB x19,W
03DC2:  MOVWF  x20
03DC4:  MOVLW  94
03DC6:  ADDWF  x1F,W
03DC8:  MOVWF  FE9
03DCA:  MOVLW  04
03DCC:  ADDWFC x20,W
03DCE:  MOVWF  FEA
03DD0:  MOVF   FEF,W
03DD2:  SUBLW  44
03DD4:  BTFSS  FD8.2
03DD6:  GOTO   3E8C
03DDA:  MOVLW  04
03DDC:  SUBWF  x18,W
03DDE:  MOVWF  x21
03DE0:  MOVLW  00
03DE2:  SUBWFB x19,W
03DE4:  MOVWF  x22
03DE6:  MOVLW  94
03DE8:  ADDWF  x21,W
03DEA:  MOVWF  FE9
03DEC:  MOVLW  04
03DEE:  ADDWFC x22,W
03DF0:  MOVWF  FEA
03DF2:  MOVF   FEF,W
03DF4:  SUBLW  41
03DF6:  BTFSS  FD8.2
03DF8:  GOTO   3E8C
03DFC:  MOVLW  05
03DFE:  SUBWF  x18,W
03E00:  MOVWF  x23
03E02:  MOVLW  00
03E04:  SUBWFB x19,W
03E06:  MOVWF  x24
03E08:  MOVLW  94
03E0A:  ADDWF  x23,W
03E0C:  MOVWF  FE9
03E0E:  MOVLW  04
03E10:  ADDWFC x24,W
03E12:  MOVWF  FEA
03E14:  MOVF   FEF,W
03E16:  SUBLW  50
03E18:  BTFSS  FD8.2
03E1A:  GOTO   3E8C
03E1E:  MOVLW  06
03E20:  SUBWF  x18,W
03E22:  MOVWF  x25
03E24:  MOVLW  00
03E26:  SUBWFB x19,W
03E28:  MOVWF  x26
03E2A:  MOVLW  94
03E2C:  ADDWF  x25,W
03E2E:  MOVWF  FE9
03E30:  MOVLW  04
03E32:  ADDWFC x26,W
03E34:  MOVWF  FEA
03E36:  MOVF   FEF,W
03E38:  SUBLW  47
03E3A:  BTFSS  FD8.2
03E3C:  GOTO   3E8C
03E40:  MOVLW  07
03E42:  SUBWF  x18,W
03E44:  MOVWF  x27
03E46:  MOVLW  00
03E48:  SUBWFB x19,W
03E4A:  MOVWF  x28
03E4C:  MOVLW  94
03E4E:  ADDWF  x27,W
03E50:  MOVWF  FE9
03E52:  MOVLW  04
03E54:  ADDWFC x28,W
03E56:  MOVWF  FEA
03E58:  MOVF   FEF,W
03E5A:  SUBLW  43
03E5C:  BTFSS  FD8.2
03E5E:  GOTO   3E8C
03E62:  MOVLW  08
03E64:  SUBWF  x18,W
03E66:  MOVWF  x29
03E68:  MOVLW  00
03E6A:  SUBWFB x19,W
03E6C:  MOVWF  x2A
03E6E:  MOVLW  94
03E70:  ADDWF  x29,W
03E72:  MOVWF  FE9
03E74:  MOVLW  04
03E76:  ADDWFC x2A,W
03E78:  MOVWF  FEA
03E7A:  MOVF   FEF,W
03E7C:  SUBLW  2B
03E7E:  BTFSS  FD8.2
03E80:  GOTO   3E8C
....................                 { 
....................                     // Set flag denoting first character sequence has found. 
....................                     ui8FirstCharSequenceFound = 1; 
03E84:  MOVLW  01
03E86:  MOVWF  x14
....................                     // Copy the first character sequence index. 
....................                     ui8FirstCharSeqIndex = (ui16ByteCount - 0); 
03E88:  MOVFF  B18,B15
....................                 } 
....................             } 
03E8C:  GOTO   3FA0
....................              
....................             // Check for second character sequence set. 
....................             else if(ui8FirstCharSequenceFound == 1 && ui8SecondCharSequenceFound == 0) 
03E90:  DECFSZ x14,W
03E92:  GOTO   3F0E
03E96:  MOVF   x16,F
03E98:  BTFSS  FD8.2
03E9A:  GOTO   3F0E
....................             { 
....................                 if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '"') 
03E9E:  MOVLW  94
03EA0:  ADDWF  x18,W
03EA2:  MOVWF  FE9
03EA4:  MOVLW  04
03EA6:  ADDWFC x19,W
03EA8:  MOVWF  FEA
03EAA:  MOVF   FEF,W
03EAC:  SUBLW  22
03EAE:  BTFSS  FD8.2
03EB0:  GOTO   3F0A
....................                 { 
....................                     // Increment double quote count. 
....................                     ui8DoubleQuoteCount++; 
03EB4:  INCF   x17,F
....................                     // Check double quote count. 
....................                     if(2 == ui8DoubleQuoteCount) 
03EB6:  MOVF   x17,W
03EB8:  SUBLW  02
03EBA:  BTFSS  FD8.2
03EBC:  GOTO   3F0A
....................                     { 
....................                         // Reset double quote count. 
....................                         ui8DoubleQuoteCount = 0; 
03EC0:  CLRF   x17
....................                         // loop through to check second quote count. 
....................                         for(unsigned int8 ui8LoopCount = ui8FirstCharSeqIndex; ui8LoopCount < (ui16ByteCount - 0); ui8LoopCount++) 
03EC2:  MOVFF  B15,B1A
03EC6:  MOVF   x19,F
03EC8:  BTFSS  FD8.2
03ECA:  GOTO   3ED8
03ECE:  MOVF   x18,W
03ED0:  SUBWF  x1A,W
03ED2:  BTFSC  FD8.0
03ED4:  GOTO   3F0A
....................                         { 
....................                             // Check for stop count. 
....................                             if(g_ui8M66RxBuffer[(ui8LoopCount - 0)] == '.') 
03ED8:  MOVLW  94
03EDA:  ADDWF  x1A,W
03EDC:  MOVWF  FE9
03EDE:  MOVLW  04
03EE0:  MOVWF  FEA
03EE2:  BTFSC  FD8.0
03EE4:  INCF   FEA,F
03EE6:  MOVF   FEF,W
03EE8:  SUBLW  2E
03EEA:  BTFSS  FD8.2
03EEC:  GOTO   3F04
....................                             { 
....................                                 // Increase stop. 
....................                                 ui8DoubleQuoteCount++; 
03EF0:  INCF   x17,F
....................                                 // Check limiting stop count. 
....................                                 if(3 == ui8DoubleQuoteCount) 
03EF2:  MOVF   x17,W
03EF4:  SUBLW  03
03EF6:  BTFSS  FD8.2
03EF8:  GOTO   3F04
....................                                 { 
....................                                     // Set flag denoting second character sequence has found. 
....................                                     ui8SecondCharSequenceFound = 1; 
03EFC:  MOVLW  01
03EFE:  MOVWF  x16
....................                                     break; 
03F00:  GOTO   3F0A
....................                                 } 
....................                             }     
03F04:  INCF   x1A,F
03F06:  GOTO   3EC6
....................                         } 
....................                          
....................                          
....................                     } 
....................                 } 
....................             } 
03F0A:  GOTO   3FA0
....................              
....................             // Check for OK. 
....................             else if(ui8FirstCharSequenceFound == 1 && ui8SecondCharSequenceFound == 1) 
03F0E:  DECFSZ x14,W
03F10:  GOTO   3FA0
03F14:  DECFSZ x16,W
03F16:  GOTO   3FA0
....................             { 
....................                 if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
03F1A:  MOVLW  94
03F1C:  ADDWF  x18,W
03F1E:  MOVWF  FE9
03F20:  MOVLW  04
03F22:  ADDWFC x19,W
03F24:  MOVWF  FEA
03F26:  MOVF   FEF,W
03F28:  SUBLW  0A
03F2A:  BTFSS  FD8.2
03F2C:  GOTO   3FA0
03F30:  MOVLW  01
03F32:  SUBWF  x18,W
03F34:  MOVWF  x1B
03F36:  MOVLW  00
03F38:  SUBWFB x19,W
03F3A:  MOVWF  x1C
03F3C:  MOVLW  94
03F3E:  ADDWF  x1B,W
03F40:  MOVWF  FE9
03F42:  MOVLW  04
03F44:  ADDWFC x1C,W
03F46:  MOVWF  FEA
03F48:  MOVF   FEF,W
03F4A:  SUBLW  0D
03F4C:  BTFSS  FD8.2
03F4E:  GOTO   3FA0
03F52:  MOVLW  02
03F54:  SUBWF  x18,W
03F56:  MOVWF  x1D
03F58:  MOVLW  00
03F5A:  SUBWFB x19,W
03F5C:  MOVWF  x1E
03F5E:  MOVLW  94
03F60:  ADDWF  x1D,W
03F62:  MOVWF  FE9
03F64:  MOVLW  04
03F66:  ADDWFC x1E,W
03F68:  MOVWF  FEA
03F6A:  MOVF   FEF,W
03F6C:  SUBLW  4B
03F6E:  BTFSS  FD8.2
03F70:  GOTO   3FA0
03F74:  MOVLW  03
03F76:  SUBWF  x18,W
03F78:  MOVWF  x1F
03F7A:  MOVLW  00
03F7C:  SUBWFB x19,W
03F7E:  MOVWF  x20
03F80:  MOVLW  94
03F82:  ADDWF  x1F,W
03F84:  MOVWF  FE9
03F86:  MOVLW  04
03F88:  ADDWFC x20,W
03F8A:  MOVWF  FEA
03F8C:  MOVF   FEF,W
03F8E:  SUBLW  4F
03F90:  BTFSS  FD8.2
03F92:  GOTO   3FA0
....................                { 
....................                    // Set flag denoting 'OK' is found. 
....................                    ui8IsResponseFound = 0; 
03F96:  CLRF   x13
....................                    break; 
03F98:  MOVLB  6
03F9A:  GOTO   3FAA
03F9E:  MOVLB  B
....................                } 
....................             } 
03FA0:  INCF   x18,F
03FA2:  BTFSC  FD8.2
03FA4:  INCF   x19,F
03FA6:  GOTO   3D2C
....................         } 
03FAA:  MOVLB  2
03FAC:  GOTO   3D0C
....................          
....................     } 
....................      
....................     return ui8IsResponseFound; 
03FB0:  MOVLB  B
03FB2:  MOVFF  B13,01
03FB6:  MOVLB  0
03FB8:  GOTO   4002 (RETURN)
.................... } 
....................  
.................... void SendGPRSConnectionQuery(void) 
.................... { 
....................     g_fIsTimedOut = 0; 
*
0381C:  MOVLB  2
0381E:  CLRF   x34
....................      
....................      
....................     // Reset Rx buffer. 
....................     ResetGSMM66RxBuffer(); 
03820:  MOVLB  0
03822:  CALL   1A5A
....................     // Check GPRS Connection. 
....................     fputs("AT+CGACT?\r", GSM_M66); 
03826:  MOVLW  F8
03828:  MOVWF  FF6
0382A:  MOVLW  07
0382C:  MOVWF  FF7
0382E:  CALL   1A7A
03832:  MOVLW  0D
03834:  CLRWDT
03836:  BTFSS  F9E.4
03838:  GOTO   3834
0383C:  MOVWF  FAD
0383E:  MOVLW  0A
03840:  CLRWDT
03842:  BTFSS  F9E.4
03844:  GOTO   3840
03848:  MOVWF  FAD
0384A:  GOTO   65BA (RETURN)
....................     // Set timeout. 
....................     //SetTimeout(3); 
....................  
.................... } 
....................  
.................... //unsigned int8 CheckGPRSConnection(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsResponseFound = 5; 
.................... //    unsigned int8 ui8IsFirstCharSequenceFound = 0; 
.................... //    unsigned int8 ui8FirstCharSequenceIndex = 0; 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Check GPRS Connection. 
.................... //    fputs("AT+CGACT?\r", GSM_M66); 
.................... //    // Set timeout. 
.................... //    SetTimeout(2); 
.................... //    // Wait for response. 
.................... //    while(g_fIsTimedOut == 0 && ui8IsResponseFound == 5) 
.................... //    { 
.................... //        // Reset variables. 
.................... //        ui8IsFirstCharSequenceFound = 0; 
.................... //        ui8FirstCharSequenceIndex = 0; 
.................... //         
.................... //        // Loop through entire receive buffer. 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            // Check for first character sequence. 
.................... //            if(ui8IsFirstCharSequenceFound == 0) 
.................... //            { 
.................... //                if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ':'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'T'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount-  2)] == 'C'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'A'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'G'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'C'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 6)] == '+') 
.................... //                { 
.................... //                    // Set flag denoting first character sequence found. 
.................... //                    ui8IsFirstCharSequenceFound = 1; 
.................... //                    // Copy the index of the first character of the sequence. 
.................... //                    ui8FirstCharSequenceIndex = (ui16ByteCount - 0); 
.................... //                } 
.................... //            } 
.................... //            // Check for second character sequence. 
.................... //            else if(ui8IsFirstCharSequenceFound == 1) 
.................... //            { 
.................... //                if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '0'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 1)] == ','&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '1') 
.................... //                { 
.................... //                    // Set flag denoting particular response found. 
.................... //                    // and the response says GPRS not connected. 
.................... //                    ui8IsResponseFound = 0; 
.................... //                    break; 
.................... //                } 
.................... //                else if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '1'&& 
.................... //                        g_ui8M66RxBuffer[(ui16ByteCount - 1)] == ','&& 
.................... //                        g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '1') 
.................... //                { 
.................... //                    // Set flag denoting particular response found. 
.................... //                    // and the response says GPRS connected. 
.................... //                    ui8IsResponseFound = 1; 
.................... //                    break; 
.................... //                } 
.................... //            } 
.................... //        } 
.................... //    } 
.................... //     
.................... //    return ui8IsResponseFound; 
.................... //} 
....................  
.................... unsigned int8 CheckGPRSConnectionQueryResponse(void) 
0384E:  MOVLW  05
03850:  MOVLB  B
03852:  MOVWF  x12
03854:  CLRF   x13
03856:  CLRF   x14
.................... { 
....................     unsigned int8 ui8IsResponseFound = 5; 
....................     unsigned int8 ui8IsFirstCharSequenceFound = 0; 
....................     unsigned int8 ui8FirstCharSequenceIndex = 0; 
....................      
....................      
....................     // Loop through entire receive buffer. 
....................     for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
03858:  CLRF   x16
0385A:  CLRF   x15
0385C:  MOVF   x16,W
0385E:  MOVLB  6
03860:  SUBWF  x89,W
03862:  BTFSS  FD8.0
03864:  GOTO   3A58
03868:  BTFSS  FD8.2
0386A:  GOTO   3880
0386E:  MOVF   x88,W
03870:  MOVLB  B
03872:  SUBWF  x15,W
03874:  BTFSS  FD8.0
03876:  BRA    387E
03878:  MOVLB  6
0387A:  GOTO   3A58
0387E:  MOVLB  6
....................     { 
....................         // Check for first character sequence. 
....................         if(ui8IsFirstCharSequenceFound == 0) 
03880:  MOVLB  B
03882:  MOVF   x13,F
03884:  BTFSS  FD8.2
03886:  GOTO   3978
....................         { 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ':'&& 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'T'&& 
....................                g_ui8M66RxBuffer[(ui16ByteCount-  2)] == 'C'&& 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'A'&& 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'G'&& 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'C'&& 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 6)] == '+') 
0388A:  MOVLW  94
0388C:  ADDWF  x15,W
0388E:  MOVWF  FE9
03890:  MOVLW  04
03892:  ADDWFC x16,W
03894:  MOVWF  FEA
03896:  MOVF   FEF,W
03898:  SUBLW  3A
0389A:  BTFSS  FD8.2
0389C:  GOTO   3974
038A0:  MOVLW  01
038A2:  SUBWF  x15,W
038A4:  MOVWF  x17
038A6:  MOVLW  00
038A8:  SUBWFB x16,W
038AA:  MOVWF  x18
038AC:  MOVLW  94
038AE:  ADDWF  x17,W
038B0:  MOVWF  FE9
038B2:  MOVLW  04
038B4:  ADDWFC x18,W
038B6:  MOVWF  FEA
038B8:  MOVF   FEF,W
038BA:  SUBLW  54
038BC:  BTFSS  FD8.2
038BE:  GOTO   3974
038C2:  MOVLW  02
038C4:  SUBWF  x15,W
038C6:  MOVWF  x19
038C8:  MOVLW  00
038CA:  SUBWFB x16,W
038CC:  MOVWF  x1A
038CE:  MOVLW  94
038D0:  ADDWF  x19,W
038D2:  MOVWF  FE9
038D4:  MOVLW  04
038D6:  ADDWFC x1A,W
038D8:  MOVWF  FEA
038DA:  MOVF   FEF,W
038DC:  SUBLW  43
038DE:  BTFSS  FD8.2
038E0:  GOTO   3974
038E4:  MOVLW  03
038E6:  SUBWF  x15,W
038E8:  MOVWF  x1B
038EA:  MOVLW  00
038EC:  SUBWFB x16,W
038EE:  MOVWF  x1C
038F0:  MOVLW  94
038F2:  ADDWF  x1B,W
038F4:  MOVWF  FE9
038F6:  MOVLW  04
038F8:  ADDWFC x1C,W
038FA:  MOVWF  FEA
038FC:  MOVF   FEF,W
038FE:  SUBLW  41
03900:  BTFSS  FD8.2
03902:  GOTO   3974
03906:  MOVLW  04
03908:  SUBWF  x15,W
0390A:  MOVWF  x1D
0390C:  MOVLW  00
0390E:  SUBWFB x16,W
03910:  MOVWF  x1E
03912:  MOVLW  94
03914:  ADDWF  x1D,W
03916:  MOVWF  FE9
03918:  MOVLW  04
0391A:  ADDWFC x1E,W
0391C:  MOVWF  FEA
0391E:  MOVF   FEF,W
03920:  SUBLW  47
03922:  BTFSS  FD8.2
03924:  GOTO   3974
03928:  MOVLW  05
0392A:  SUBWF  x15,W
0392C:  MOVWF  x1F
0392E:  MOVLW  00
03930:  SUBWFB x16,W
03932:  MOVWF  x20
03934:  MOVLW  94
03936:  ADDWF  x1F,W
03938:  MOVWF  FE9
0393A:  MOVLW  04
0393C:  ADDWFC x20,W
0393E:  MOVWF  FEA
03940:  MOVF   FEF,W
03942:  SUBLW  43
03944:  BTFSS  FD8.2
03946:  GOTO   3974
0394A:  MOVLW  06
0394C:  SUBWF  x15,W
0394E:  MOVWF  x21
03950:  MOVLW  00
03952:  SUBWFB x16,W
03954:  MOVWF  x22
03956:  MOVLW  94
03958:  ADDWF  x21,W
0395A:  MOVWF  FE9
0395C:  MOVLW  04
0395E:  ADDWFC x22,W
03960:  MOVWF  FEA
03962:  MOVF   FEF,W
03964:  SUBLW  2B
03966:  BTFSS  FD8.2
03968:  GOTO   3974
....................             { 
....................                 // Set flag denoting first character sequence found. 
....................                 ui8IsFirstCharSequenceFound = 1; 
0396C:  MOVLW  01
0396E:  MOVWF  x13
....................                 // Copy the index of the first character of the sequence. 
....................                 ui8FirstCharSequenceIndex = (ui16ByteCount - 0); 
03970:  MOVFF  B15,B14
....................             } 
....................         } 
03974:  GOTO   3A4C
....................         // Check for second character sequence. 
....................         else if(ui8IsFirstCharSequenceFound == 1) 
03978:  DECFSZ x13,W
0397A:  GOTO   3A4C
....................         { 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '0'&& 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 1)] == ','&& 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '1') 
0397E:  MOVLW  94
03980:  ADDWF  x15,W
03982:  MOVWF  FE9
03984:  MOVLW  04
03986:  ADDWFC x16,W
03988:  MOVWF  FEA
0398A:  MOVF   FEF,W
0398C:  SUBLW  30
0398E:  BTFSS  FD8.2
03990:  GOTO   39E6
03994:  MOVLW  01
03996:  SUBWF  x15,W
03998:  MOVWF  x17
0399A:  MOVLW  00
0399C:  SUBWFB x16,W
0399E:  MOVWF  x18
039A0:  MOVLW  94
039A2:  ADDWF  x17,W
039A4:  MOVWF  FE9
039A6:  MOVLW  04
039A8:  ADDWFC x18,W
039AA:  MOVWF  FEA
039AC:  MOVF   FEF,W
039AE:  SUBLW  2C
039B0:  BTFSS  FD8.2
039B2:  GOTO   39E6
039B6:  MOVLW  02
039B8:  SUBWF  x15,W
039BA:  MOVWF  x19
039BC:  MOVLW  00
039BE:  SUBWFB x16,W
039C0:  MOVWF  x1A
039C2:  MOVLW  94
039C4:  ADDWF  x19,W
039C6:  MOVWF  FE9
039C8:  MOVLW  04
039CA:  ADDWFC x1A,W
039CC:  MOVWF  FEA
039CE:  MOVF   FEF,W
039D0:  SUBLW  31
039D2:  BTFSS  FD8.2
039D4:  GOTO   39E6
....................             { 
....................                 // Set flag denoting particular response found. 
....................                 // and the response says GPRS not connected. 
....................                 ui8IsResponseFound = 0; 
039D8:  CLRF   x12
....................                 break; 
039DA:  MOVLB  6
039DC:  GOTO   3A58
....................             } 
039E0:  GOTO   3A4A
039E4:  MOVLB  B
....................             else if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '1'&& 
....................                     g_ui8M66RxBuffer[(ui16ByteCount - 1)] == ','&& 
....................                     g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '1') 
039E6:  MOVLW  94
039E8:  ADDWF  x15,W
039EA:  MOVWF  FE9
039EC:  MOVLW  04
039EE:  ADDWFC x16,W
039F0:  MOVWF  FEA
039F2:  MOVF   FEF,W
039F4:  SUBLW  31
039F6:  BTFSS  FD8.2
039F8:  GOTO   3A4C
039FC:  MOVLW  01
039FE:  SUBWF  x15,W
03A00:  MOVWF  x17
03A02:  MOVLW  00
03A04:  SUBWFB x16,W
03A06:  MOVWF  x18
03A08:  MOVLW  94
03A0A:  ADDWF  x17,W
03A0C:  MOVWF  FE9
03A0E:  MOVLW  04
03A10:  ADDWFC x18,W
03A12:  MOVWF  FEA
03A14:  MOVF   FEF,W
03A16:  SUBLW  2C
03A18:  BTFSS  FD8.2
03A1A:  GOTO   3A4C
03A1E:  MOVLW  02
03A20:  SUBWF  x15,W
03A22:  MOVWF  x19
03A24:  MOVLW  00
03A26:  SUBWFB x16,W
03A28:  MOVWF  x1A
03A2A:  MOVLW  94
03A2C:  ADDWF  x19,W
03A2E:  MOVWF  FE9
03A30:  MOVLW  04
03A32:  ADDWFC x1A,W
03A34:  MOVWF  FEA
03A36:  MOVF   FEF,W
03A38:  SUBLW  31
03A3A:  BTFSS  FD8.2
03A3C:  GOTO   3A4C
....................             { 
....................                 // Set flag denoting particular response found. 
....................                 // and the response says GPRS connected. 
....................                 ui8IsResponseFound = 1; 
03A40:  MOVLW  01
03A42:  MOVWF  x12
....................                 break; 
03A44:  MOVLB  6
03A46:  GOTO   3A58
03A4A:  MOVLB  B
....................             } 
....................         } 
03A4C:  INCF   x15,F
03A4E:  BTFSC  FD8.2
03A50:  INCF   x16,F
03A52:  GOTO   385C
03A56:  MOVLB  6
....................     } 
....................      
....................     return ui8IsResponseFound; 
03A58:  MOVLB  B
03A5A:  MOVFF  B12,01
03A5E:  MOVLB  0
03A60:  GOTO   65EA (RETURN)
.................... } 
....................  
.................... // ########################################################## Above GPRS Connection Driver ############################################################### 
....................  
.................... // ########################################################## Below HTTP Application Driver ############################################################## 
....................  
.................... unsigned int8 SetHTTPURL(void) 
.................... { 
....................     unsigned int8 ui8IsSetURLOk = 1; 
....................     unsigned int8 ui8IsConnectionDone = 0; 
....................     g_ui8URLInputTime           = 60; 
....................     g_ui8URLInputByteLength     = 93; 
....................     g_fIsTimedOut               = 0; 
....................      
....................     // Reset Rx buffer. 
....................     ResetGSMM66RxBuffer(); 
....................     // Increment variables. 
....................     g_ui16Itm1SequenceNumber += 2; 
....................     g_ui16Itm2SequenceNumber += 2; 
....................     g_ui16ItemWeight++; 
....................     // Check URL input byte length. 
....................     CheckURLInputByteLength(); 
....................     // Set AT Commands to define web service URL. 
....................     fprintf(GSM_M66, "AT+QHTTPURL=%u,%u\r", g_ui8URLInputByteLength, g_ui8URLInputTime); 
....................     // Set timeout. 
....................     SetTimeout(2); 
....................     // Wait for response. 
....................     while(g_fIsTimedOut == 0 && ui8IsSetURLOk == 1) 
....................     { 
....................         // Loop through entire receive buffer. 
....................         for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
....................         { 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 'T' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'C' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'E' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'N' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'N' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'O' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 6)] == 'C') 
....................             { 
....................                 // Set flag denote connection is established. 
....................                 ui8IsConnectionDone = 1; 
....................                 break; 
....................             }        
....................         } 
....................          
....................         // set URL in buffer. 
....................         if(ui8IsConnectionDone) 
....................         { 
....................             // Set web service URL. 
....................             fprintf(GSM_M66, "http://mwm.itsinindia.com/api/Test/GetStringGetMethod?a=2&b=1&c=5&m=1000$%Lu$%Lu$1|1500$%Lu$%Lu$1", g_ui16Itm1SequenceNumber, g_ui16ItemWeight, g_ui16Itm2SequenceNumber, ++g_ui16ItemWeight); 
....................             delay_ms(300); 
....................             // Check for "OK". 
....................             for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
....................             { 
....................                 if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................                 { 
....................                     // Set flag denoting Set URL successfully. 
....................                     ui8IsSetURLOk = 0; 
....................                     break; 
....................                 } 
....................             }     
....................         } 
....................          
....................         
....................     } 
....................      
....................     return ui8IsSetURLOk; 
....................      
.................... } 
....................  
.................... void SetHTTPURLParameter(void) 
.................... { 
....................     g_ui8URLInputTime           = 60; 
*
046FE:  MOVLW  3C
04700:  MOVLB  6
04702:  MOVWF  x8B
....................     g_ui8URLInputByteLength     = 66; 
04704:  MOVLW  42
04706:  MOVWF  x8A
....................     g_fIsTimedOut               = 0; 
04708:  MOVLB  2
0470A:  CLRF   x34
....................      
....................     // Reset Rx buffer. 
....................     ResetGSMM66RxBuffer(); 
0470C:  MOVLB  0
0470E:  CALL   1A5A
....................      
.................... //    //Increase GPRS send msg queue front. 
.................... //    if(g_stGPRSMsgSendQueue.m_i8Front != 0) 
.................... //    { 
.................... //        g_stGPRSMsgSendQueue.m_i8Front++; 
.................... //    }   
....................      
....................     // Check remaining data length of queue. 
....................     // Count data length according to queue front and rear position. 
....................     if(g_stGPRSMsgSendQueue.m_i8Rear > g_stGPRSMsgSendQueue.m_i8Front) 
04712:  MOVLB  A
04714:  MOVF   x1A,W
04716:  SUBWF  x19,W
04718:  BTFSC  FD8.0
0471A:  GOTO   472E
....................     { 
....................         g_ui8DataQueueLen = (g_stGPRSMsgSendQueue.m_i8Rear - g_stGPRSMsgSendQueue.m_i8Front + 1); 
0471E:  MOVF   x19,W
04720:  SUBWF  x1A,W
04722:  ADDLW  01
04724:  MOVLB  6
04726:  MOVWF  x92
....................     } 
04728:  GOTO   475C
0472C:  MOVLB  A
....................     else if(g_stGPRSMsgSendQueue.m_i8Rear == g_stGPRSMsgSendQueue.m_i8Front) 
0472E:  MOVF   x19,W
04730:  SUBWF  x1A,W
04732:  BTFSS  FD8.2
04734:  GOTO   4744
....................     { 
....................         g_ui8DataQueueLen = 1; 
04738:  MOVLW  01
0473A:  MOVLB  6
0473C:  MOVWF  x92
....................     } 
0473E:  GOTO   475C
04742:  MOVLB  A
....................     else 
....................     { 
....................         g_ui8DataQueueLen = ((SIZE_GPRS_DATA_NODE_QUEUE - g_stGPRSMsgSendQueue.m_i8Front) + (g_stGPRSMsgSendQueue.m_i8Rear + 1)); 
04744:  MOVLW  64
04746:  BSF    FD8.0
04748:  SUBFWB x19,W
0474A:  MOVLB  B
0474C:  MOVWF  x12
0474E:  MOVLW  01
04750:  MOVLB  A
04752:  ADDWF  x1A,W
04754:  MOVLB  B
04756:  ADDWF  x12,W
04758:  MOVLB  6
0475A:  MOVWF  x92
....................     } 
....................      
....................     // If, queue front is very near to queue size i.e. less than 5 data though data length is 
....................     // more than 5 then to properly circulate queue front we need to send data one by one at this situation until it reaches queue end. 
....................     if((SIZE_GPRS_DATA_NODE_QUEUE - g_stGPRSMsgSendQueue.m_i8Front) < 5) 
0475C:  MOVLW  64
0475E:  BSF    FD8.0
04760:  MOVLB  A
04762:  SUBFWB x19,W
04764:  SUBLW  04
04766:  BTFSS  FD8.0
04768:  GOTO   4774
....................     { 
....................         g_ui8DataQueueLen = 1; 
0476C:  MOVLW  01
0476E:  MOVLB  6
04770:  MOVWF  x92
04772:  MOVLB  A
....................     } 
....................      
....................     // Check URL input byte length. 
....................     CheckURLInputByteLength(); 
04774:  MOVLB  0
04776:  GOTO   42E2
....................      
....................     // Set AT Commands to define web service URL. 
....................     fprintf(GSM_M66, "AT+QHTTPURL=%u,%u\r", g_ui8URLInputByteLength, g_ui8URLInputTime); 
0477A:  MOVLW  7A
0477C:  MOVWF  FF6
0477E:  MOVLW  08
04780:  MOVWF  FF7
04782:  MOVLW  0C
04784:  MOVLB  B
04786:  MOVWF  x4F
04788:  MOVLB  0
0478A:  CALL   462E
0478E:  MOVFF  68A,B4F
04792:  MOVLW  1B
04794:  MOVLB  B
04796:  MOVWF  x50
04798:  MOVLB  0
0479A:  CALL   465E
0479E:  MOVLW  2C
047A0:  CLRWDT
047A2:  BTFSS  F9E.4
047A4:  GOTO   47A0
047A8:  MOVWF  FAD
047AA:  MOVFF  68B,B4F
047AE:  MOVLW  1B
047B0:  MOVLB  B
047B2:  MOVWF  x50
047B4:  MOVLB  0
047B6:  CALL   465E
047BA:  MOVLW  0D
047BC:  CLRWDT
047BE:  BTFSS  F9E.4
047C0:  GOTO   47BC
047C4:  MOVWF  FAD
047C6:  GOTO   66B2 (RETURN)
....................     // Set timeout. 
....................     //SetTimeout(2); 
.................... } 
....................  
.................... unsigned int8 SetHTTPURLL(void) 
*
04A32:  MOVLW  01
04A34:  MOVLB  B
04A36:  MOVWF  x12
04A38:  CLRF   x13
.................... { 
....................     unsigned int8 ui8IsSetURLOk = 1; 
....................     unsigned int8 ui8IsConnectionDone = 0; 
....................      
....................     // Loop through entire receive buffer. 
....................     for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
04A3A:  CLRF   x15
04A3C:  CLRF   x14
04A3E:  MOVF   x15,W
04A40:  MOVLB  6
04A42:  SUBWF  x89,W
04A44:  BTFSS  FD8.0
04A46:  GOTO   4B5E
04A4A:  BTFSS  FD8.2
04A4C:  GOTO   4A62
04A50:  MOVF   x88,W
04A52:  MOVLB  B
04A54:  SUBWF  x14,W
04A56:  BTFSS  FD8.0
04A58:  BRA    4A60
04A5A:  MOVLB  6
04A5C:  GOTO   4B5E
04A60:  MOVLB  6
....................     { 
....................         if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 'T' && 
....................            g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'C' && 
....................            g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'E' && 
....................            g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'N' && 
....................            g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'N' && 
....................            g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'O' && 
....................            g_ui8M66RxBuffer[(ui16ByteCount - 6)] == 'C') 
04A62:  MOVLW  94
04A64:  MOVLB  B
04A66:  ADDWF  x14,W
04A68:  MOVWF  FE9
04A6A:  MOVLW  04
04A6C:  ADDWFC x15,W
04A6E:  MOVWF  FEA
04A70:  MOVF   FEF,W
04A72:  SUBLW  54
04A74:  BTFSS  FD8.2
04A76:  GOTO   4B52
04A7A:  MOVLW  01
04A7C:  SUBWF  x14,W
04A7E:  MOVWF  x18
04A80:  MOVLW  00
04A82:  SUBWFB x15,W
04A84:  MOVWF  x19
04A86:  MOVLW  94
04A88:  ADDWF  x18,W
04A8A:  MOVWF  FE9
04A8C:  MOVLW  04
04A8E:  ADDWFC x19,W
04A90:  MOVWF  FEA
04A92:  MOVF   FEF,W
04A94:  SUBLW  43
04A96:  BTFSS  FD8.2
04A98:  GOTO   4B52
04A9C:  MOVLW  02
04A9E:  SUBWF  x14,W
04AA0:  MOVWF  x1A
04AA2:  MOVLW  00
04AA4:  SUBWFB x15,W
04AA6:  MOVWF  x1B
04AA8:  MOVLW  94
04AAA:  ADDWF  x1A,W
04AAC:  MOVWF  FE9
04AAE:  MOVLW  04
04AB0:  ADDWFC x1B,W
04AB2:  MOVWF  FEA
04AB4:  MOVF   FEF,W
04AB6:  SUBLW  45
04AB8:  BTFSS  FD8.2
04ABA:  GOTO   4B52
04ABE:  MOVLW  03
04AC0:  SUBWF  x14,W
04AC2:  MOVWF  x1C
04AC4:  MOVLW  00
04AC6:  SUBWFB x15,W
04AC8:  MOVWF  x1D
04ACA:  MOVLW  94
04ACC:  ADDWF  x1C,W
04ACE:  MOVWF  FE9
04AD0:  MOVLW  04
04AD2:  ADDWFC x1D,W
04AD4:  MOVWF  FEA
04AD6:  MOVF   FEF,W
04AD8:  SUBLW  4E
04ADA:  BTFSS  FD8.2
04ADC:  GOTO   4B52
04AE0:  MOVLW  04
04AE2:  SUBWF  x14,W
04AE4:  MOVWF  x1E
04AE6:  MOVLW  00
04AE8:  SUBWFB x15,W
04AEA:  MOVWF  x1F
04AEC:  MOVLW  94
04AEE:  ADDWF  x1E,W
04AF0:  MOVWF  FE9
04AF2:  MOVLW  04
04AF4:  ADDWFC x1F,W
04AF6:  MOVWF  FEA
04AF8:  MOVF   FEF,W
04AFA:  SUBLW  4E
04AFC:  BTFSS  FD8.2
04AFE:  GOTO   4B52
04B02:  MOVLW  05
04B04:  SUBWF  x14,W
04B06:  MOVWF  x20
04B08:  MOVLW  00
04B0A:  SUBWFB x15,W
04B0C:  MOVWF  x21
04B0E:  MOVLW  94
04B10:  ADDWF  x20,W
04B12:  MOVWF  FE9
04B14:  MOVLW  04
04B16:  ADDWFC x21,W
04B18:  MOVWF  FEA
04B1A:  MOVF   FEF,W
04B1C:  SUBLW  4F
04B1E:  BTFSS  FD8.2
04B20:  GOTO   4B52
04B24:  MOVLW  06
04B26:  SUBWF  x14,W
04B28:  MOVWF  x22
04B2A:  MOVLW  00
04B2C:  SUBWFB x15,W
04B2E:  MOVWF  x23
04B30:  MOVLW  94
04B32:  ADDWF  x22,W
04B34:  MOVWF  FE9
04B36:  MOVLW  04
04B38:  ADDWFC x23,W
04B3A:  MOVWF  FEA
04B3C:  MOVF   FEF,W
04B3E:  SUBLW  43
04B40:  BTFSS  FD8.2
04B42:  GOTO   4B52
....................         { 
....................             // Set flag denote connection is established. 
....................             ui8IsConnectionDone = 1; 
04B46:  MOVLW  01
04B48:  MOVWF  x13
....................             break; 
04B4A:  MOVLB  6
04B4C:  GOTO   4B5E
04B50:  MOVLB  B
....................         }        
04B52:  INCF   x14,F
04B54:  BTFSC  FD8.2
04B56:  INCF   x15,F
04B58:  GOTO   4A3E
04B5C:  MOVLB  6
....................     } 
....................      
....................     // set URL in buffer. 
....................     if(ui8IsConnectionDone) 
04B5E:  MOVLB  B
04B60:  MOVF   x13,F
04B62:  BTFSC  FD8.2
04B64:  GOTO   5582
....................     { 
....................         if(g_ui8DataQueueLen > 5) 
04B68:  MOVLB  6
04B6A:  MOVF   x92,W
04B6C:  SUBLW  05
04B6E:  BTFSC  FD8.0
04B70:  GOTO   52DC
....................         { 
....................             // Set No of messages to send. 
....................             g_stGPRSMsgHeader.m_ui8NoOfMessages = 5; 
04B74:  MOVLW  05
04B76:  MOVLB  2
04B78:  MOVWF  x92
....................             // Set web service URL. 
....................             fprintf(GSM_M66, "http://trackweigher.com/api/Test/GetStringGetMethod?a=%u&b=%Lu&c=%u&m=%Lu$%Lu$%Lu$%u|%Lu$%Lu$%Lu$%u|%Lu$%Lu$%Lu$%u|%Lu$%Lu$%Lu$%u|%Lu$%Lu$%Lu$%u", g_stGPRSMsgHeader.m_ui8NoOfMessages, g_stGPRSMsgHeader.m_ui16MachineID, g_stGPRSMsgHeader.m_ui8Variety, 
....................                                                                                                                                                                                    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front++].m_ui8RejectionStatus,  
....................                                                                                                                                                                                    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front++].m_ui8RejectionStatus, 
....................                                                                                                                                                                                    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front++].m_ui8RejectionStatus, 
....................                                                                                                                                                                                    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front++].m_ui8RejectionStatus, 
....................                                                                                                                                                                                    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui8RejectionStatus); 
04B7A:  MOVLB  B
04B7C:  CLRF   x4F
04B7E:  MOVFF  A19,B4E
04B82:  CLRF   x51
04B84:  MOVLW  09
04B86:  MOVWF  x50
04B88:  MOVLB  0
04B8A:  CALL   0B2A
04B8E:  MOVFF  02,B19
04B92:  MOVFF  01,B18
04B96:  MOVLW  95
04B98:  MOVLB  B
04B9A:  ADDWF  01,W
04B9C:  MOVWF  FE9
04B9E:  MOVLW  06
04BA0:  ADDWFC 02,W
04BA2:  MOVWF  FEA
04BA4:  MOVFF  FEF,B1A
04BA8:  MOVFF  FEC,B1B
04BAC:  MOVFF  FEC,B1C
04BB0:  MOVFF  FEC,B1D
04BB4:  CLRF   x4F
04BB6:  MOVFF  A19,B4E
04BBA:  CLRF   x51
04BBC:  MOVLW  09
04BBE:  MOVWF  x50
04BC0:  MOVLB  0
04BC2:  CALL   0B2A
04BC6:  MOVFF  01,B1E
04BCA:  MOVLW  04
04BCC:  MOVLB  B
04BCE:  ADDWF  01,W
04BD0:  MOVWF  01
04BD2:  MOVLW  00
04BD4:  ADDWFC 02,W
04BD6:  MOVWF  03
04BD8:  MOVF   01,W
04BDA:  ADDLW  95
04BDC:  MOVWF  FE9
04BDE:  MOVLW  06
04BE0:  ADDWFC 03,W
04BE2:  MOVWF  FEA
04BE4:  MOVFF  FEC,B1F
04BE8:  MOVF   FED,F
04BEA:  MOVFF  FEF,B1E
04BEE:  CLRF   x4F
04BF0:  MOVFF  A19,B4E
04BF4:  CLRF   x51
04BF6:  MOVLW  09
04BF8:  MOVWF  x50
04BFA:  MOVLB  0
04BFC:  CALL   0B2A
04C00:  MOVFF  01,B20
04C04:  MOVLW  06
04C06:  MOVLB  B
04C08:  ADDWF  01,W
04C0A:  MOVWF  01
04C0C:  MOVLW  00
04C0E:  ADDWFC 02,W
04C10:  MOVWF  03
04C12:  MOVF   01,W
04C14:  ADDLW  95
04C16:  MOVWF  FE9
04C18:  MOVLW  06
04C1A:  ADDWFC 03,W
04C1C:  MOVWF  FEA
04C1E:  MOVFF  FEC,B21
04C22:  MOVF   FED,F
04C24:  MOVFF  FEF,B20
04C28:  MOVLB  A
04C2A:  MOVF   x19,W
04C2C:  INCF   x19,F
04C2E:  MOVLB  B
04C30:  MOVWF  x23
04C32:  CLRF   x4F
04C34:  MOVWF  x4E
04C36:  CLRF   x51
04C38:  MOVLW  09
04C3A:  MOVWF  x50
04C3C:  MOVLB  0
04C3E:  CALL   0B2A
04C42:  MOVFF  02,B23
04C46:  MOVFF  01,B22
04C4A:  MOVLW  08
04C4C:  MOVLB  B
04C4E:  ADDWF  01,W
04C50:  MOVWF  01
04C52:  MOVLW  00
04C54:  ADDWFC 02,W
04C56:  MOVWF  03
04C58:  MOVF   01,W
04C5A:  ADDLW  95
04C5C:  MOVWF  FE9
04C5E:  MOVLW  06
04C60:  ADDWFC 03,W
04C62:  MOVWF  FEA
04C64:  MOVFF  FEF,B22
04C68:  CLRF   x4F
04C6A:  MOVFF  A19,B4E
04C6E:  CLRF   x51
04C70:  MOVLW  09
04C72:  MOVWF  x50
04C74:  MOVLB  0
04C76:  CALL   0B2A
04C7A:  MOVFF  02,B24
04C7E:  MOVFF  01,B23
04C82:  MOVLW  95
04C84:  MOVLB  B
04C86:  ADDWF  01,W
04C88:  MOVWF  FE9
04C8A:  MOVLW  06
04C8C:  ADDWFC 02,W
04C8E:  MOVWF  FEA
04C90:  MOVFF  FEF,B25
04C94:  MOVFF  FEC,B26
04C98:  MOVFF  FEC,B27
04C9C:  MOVFF  FEC,B28
04CA0:  CLRF   x4F
04CA2:  MOVFF  A19,B4E
04CA6:  CLRF   x51
04CA8:  MOVLW  09
04CAA:  MOVWF  x50
04CAC:  MOVLB  0
04CAE:  CALL   0B2A
04CB2:  MOVFF  01,B29
04CB6:  MOVLW  04
04CB8:  MOVLB  B
04CBA:  ADDWF  01,W
04CBC:  MOVWF  01
04CBE:  MOVLW  00
04CC0:  ADDWFC 02,W
04CC2:  MOVWF  03
04CC4:  MOVF   01,W
04CC6:  ADDLW  95
04CC8:  MOVWF  FE9
04CCA:  MOVLW  06
04CCC:  ADDWFC 03,W
04CCE:  MOVWF  FEA
04CD0:  MOVFF  FEC,B2A
04CD4:  MOVF   FED,F
04CD6:  MOVFF  FEF,B29
04CDA:  CLRF   x4F
04CDC:  MOVFF  A19,B4E
04CE0:  CLRF   x51
04CE2:  MOVLW  09
04CE4:  MOVWF  x50
04CE6:  MOVLB  0
04CE8:  CALL   0B2A
04CEC:  MOVFF  01,B2B
04CF0:  MOVLW  06
04CF2:  MOVLB  B
04CF4:  ADDWF  01,W
04CF6:  MOVWF  01
04CF8:  MOVLW  00
04CFA:  ADDWFC 02,W
04CFC:  MOVWF  03
04CFE:  MOVF   01,W
04D00:  ADDLW  95
04D02:  MOVWF  FE9
04D04:  MOVLW  06
04D06:  ADDWFC 03,W
04D08:  MOVWF  FEA
04D0A:  MOVFF  FEC,B2C
04D0E:  MOVF   FED,F
04D10:  MOVFF  FEF,B2B
04D14:  MOVLB  A
04D16:  MOVF   x19,W
04D18:  INCF   x19,F
04D1A:  MOVLB  B
04D1C:  MOVWF  x2E
04D1E:  CLRF   x4F
04D20:  MOVWF  x4E
04D22:  CLRF   x51
04D24:  MOVLW  09
04D26:  MOVWF  x50
04D28:  MOVLB  0
04D2A:  CALL   0B2A
04D2E:  MOVFF  02,B2E
04D32:  MOVFF  01,B2D
04D36:  MOVLW  08
04D38:  MOVLB  B
04D3A:  ADDWF  01,W
04D3C:  MOVWF  01
04D3E:  MOVLW  00
04D40:  ADDWFC 02,W
04D42:  MOVWF  03
04D44:  MOVF   01,W
04D46:  ADDLW  95
04D48:  MOVWF  FE9
04D4A:  MOVLW  06
04D4C:  ADDWFC 03,W
04D4E:  MOVWF  FEA
04D50:  MOVFF  FEF,B2D
04D54:  CLRF   x4F
04D56:  MOVFF  A19,B4E
04D5A:  CLRF   x51
04D5C:  MOVLW  09
04D5E:  MOVWF  x50
04D60:  MOVLB  0
04D62:  CALL   0B2A
04D66:  MOVFF  02,B2F
04D6A:  MOVFF  01,B2E
04D6E:  MOVLW  95
04D70:  MOVLB  B
04D72:  ADDWF  01,W
04D74:  MOVWF  FE9
04D76:  MOVLW  06
04D78:  ADDWFC 02,W
04D7A:  MOVWF  FEA
04D7C:  MOVFF  FEF,B30
04D80:  MOVFF  FEC,B31
04D84:  MOVFF  FEC,B32
04D88:  MOVFF  FEC,B33
04D8C:  CLRF   x4F
04D8E:  MOVFF  A19,B4E
04D92:  CLRF   x51
04D94:  MOVLW  09
04D96:  MOVWF  x50
04D98:  MOVLB  0
04D9A:  CALL   0B2A
04D9E:  MOVFF  01,B34
04DA2:  MOVLW  04
04DA4:  MOVLB  B
04DA6:  ADDWF  01,W
04DA8:  MOVWF  01
04DAA:  MOVLW  00
04DAC:  ADDWFC 02,W
04DAE:  MOVWF  03
04DB0:  MOVF   01,W
04DB2:  ADDLW  95
04DB4:  MOVWF  FE9
04DB6:  MOVLW  06
04DB8:  ADDWFC 03,W
04DBA:  MOVWF  FEA
04DBC:  MOVFF  FEC,B35
04DC0:  MOVF   FED,F
04DC2:  MOVFF  FEF,B34
04DC6:  CLRF   x4F
04DC8:  MOVFF  A19,B4E
04DCC:  CLRF   x51
04DCE:  MOVLW  09
04DD0:  MOVWF  x50
04DD2:  MOVLB  0
04DD4:  CALL   0B2A
04DD8:  MOVFF  01,B36
04DDC:  MOVLW  06
04DDE:  MOVLB  B
04DE0:  ADDWF  01,W
04DE2:  MOVWF  01
04DE4:  MOVLW  00
04DE6:  ADDWFC 02,W
04DE8:  MOVWF  03
04DEA:  MOVF   01,W
04DEC:  ADDLW  95
04DEE:  MOVWF  FE9
04DF0:  MOVLW  06
04DF2:  ADDWFC 03,W
04DF4:  MOVWF  FEA
04DF6:  MOVFF  FEC,B37
04DFA:  MOVF   FED,F
04DFC:  MOVFF  FEF,B36
04E00:  MOVLB  A
04E02:  MOVF   x19,W
04E04:  INCF   x19,F
04E06:  MOVLB  B
04E08:  MOVWF  x39
04E0A:  CLRF   x4F
04E0C:  MOVWF  x4E
04E0E:  CLRF   x51
04E10:  MOVLW  09
04E12:  MOVWF  x50
04E14:  MOVLB  0
04E16:  CALL   0B2A
04E1A:  MOVFF  02,B39
04E1E:  MOVFF  01,B38
04E22:  MOVLW  08
04E24:  MOVLB  B
04E26:  ADDWF  01,W
04E28:  MOVWF  01
04E2A:  MOVLW  00
04E2C:  ADDWFC 02,W
04E2E:  MOVWF  03
04E30:  MOVF   01,W
04E32:  ADDLW  95
04E34:  MOVWF  FE9
04E36:  MOVLW  06
04E38:  ADDWFC 03,W
04E3A:  MOVWF  FEA
04E3C:  MOVFF  FEF,B38
04E40:  CLRF   x4F
04E42:  MOVFF  A19,B4E
04E46:  CLRF   x51
04E48:  MOVLW  09
04E4A:  MOVWF  x50
04E4C:  MOVLB  0
04E4E:  CALL   0B2A
04E52:  MOVFF  02,B3A
04E56:  MOVFF  01,B39
04E5A:  MOVLW  95
04E5C:  MOVLB  B
04E5E:  ADDWF  01,W
04E60:  MOVWF  FE9
04E62:  MOVLW  06
04E64:  ADDWFC 02,W
04E66:  MOVWF  FEA
04E68:  MOVFF  FEF,B3B
04E6C:  MOVFF  FEC,B3C
04E70:  MOVFF  FEC,B3D
04E74:  MOVFF  FEC,B3E
04E78:  CLRF   x4F
04E7A:  MOVFF  A19,B4E
04E7E:  CLRF   x51
04E80:  MOVLW  09
04E82:  MOVWF  x50
04E84:  MOVLB  0
04E86:  CALL   0B2A
04E8A:  MOVFF  01,B3F
04E8E:  MOVLW  04
04E90:  MOVLB  B
04E92:  ADDWF  01,W
04E94:  MOVWF  01
04E96:  MOVLW  00
04E98:  ADDWFC 02,W
04E9A:  MOVWF  03
04E9C:  MOVF   01,W
04E9E:  ADDLW  95
04EA0:  MOVWF  FE9
04EA2:  MOVLW  06
04EA4:  ADDWFC 03,W
04EA6:  MOVWF  FEA
04EA8:  MOVFF  FEC,B40
04EAC:  MOVF   FED,F
04EAE:  MOVFF  FEF,B3F
04EB2:  CLRF   x4F
04EB4:  MOVFF  A19,B4E
04EB8:  CLRF   x51
04EBA:  MOVLW  09
04EBC:  MOVWF  x50
04EBE:  MOVLB  0
04EC0:  CALL   0B2A
04EC4:  MOVFF  01,B41
04EC8:  MOVLW  06
04ECA:  MOVLB  B
04ECC:  ADDWF  01,W
04ECE:  MOVWF  01
04ED0:  MOVLW  00
04ED2:  ADDWFC 02,W
04ED4:  MOVWF  03
04ED6:  MOVF   01,W
04ED8:  ADDLW  95
04EDA:  MOVWF  FE9
04EDC:  MOVLW  06
04EDE:  ADDWFC 03,W
04EE0:  MOVWF  FEA
04EE2:  MOVFF  FEC,B42
04EE6:  MOVF   FED,F
04EE8:  MOVFF  FEF,B41
04EEC:  MOVLB  A
04EEE:  MOVF   x19,W
04EF0:  INCF   x19,F
04EF2:  MOVLB  B
04EF4:  MOVWF  x44
04EF6:  CLRF   x4F
04EF8:  MOVWF  x4E
04EFA:  CLRF   x51
04EFC:  MOVLW  09
04EFE:  MOVWF  x50
04F00:  MOVLB  0
04F02:  CALL   0B2A
04F06:  MOVFF  02,B44
04F0A:  MOVFF  01,B43
04F0E:  MOVLW  08
04F10:  MOVLB  B
04F12:  ADDWF  01,W
04F14:  MOVWF  01
04F16:  MOVLW  00
04F18:  ADDWFC 02,W
04F1A:  MOVWF  03
04F1C:  MOVF   01,W
04F1E:  ADDLW  95
04F20:  MOVWF  FE9
04F22:  MOVLW  06
04F24:  ADDWFC 03,W
04F26:  MOVWF  FEA
04F28:  MOVFF  FEF,B43
04F2C:  CLRF   x4F
04F2E:  MOVFF  A19,B4E
04F32:  CLRF   x51
04F34:  MOVLW  09
04F36:  MOVWF  x50
04F38:  MOVLB  0
04F3A:  CALL   0B2A
04F3E:  MOVFF  02,B45
04F42:  MOVFF  01,B44
04F46:  MOVLW  95
04F48:  MOVLB  B
04F4A:  ADDWF  01,W
04F4C:  MOVWF  FE9
04F4E:  MOVLW  06
04F50:  ADDWFC 02,W
04F52:  MOVWF  FEA
04F54:  MOVFF  FEF,B46
04F58:  MOVFF  FEC,B47
04F5C:  MOVFF  FEC,B48
04F60:  MOVFF  FEC,B49
04F64:  CLRF   x4F
04F66:  MOVFF  A19,B4E
04F6A:  CLRF   x51
04F6C:  MOVLW  09
04F6E:  MOVWF  x50
04F70:  MOVLB  0
04F72:  CALL   0B2A
04F76:  MOVFF  01,B4A
04F7A:  MOVLW  04
04F7C:  MOVLB  B
04F7E:  ADDWF  01,W
04F80:  MOVWF  01
04F82:  MOVLW  00
04F84:  ADDWFC 02,W
04F86:  MOVWF  03
04F88:  MOVF   01,W
04F8A:  ADDLW  95
04F8C:  MOVWF  FE9
04F8E:  MOVLW  06
04F90:  ADDWFC 03,W
04F92:  MOVWF  FEA
04F94:  MOVFF  FEC,B4B
04F98:  MOVF   FED,F
04F9A:  MOVFF  FEF,B4A
04F9E:  CLRF   x4F
04FA0:  MOVFF  A19,B4E
04FA4:  CLRF   x51
04FA6:  MOVLW  09
04FA8:  MOVWF  x50
04FAA:  MOVLB  0
04FAC:  CALL   0B2A
04FB0:  MOVFF  01,B4C
04FB4:  MOVLW  06
04FB6:  MOVLB  B
04FB8:  ADDWF  01,W
04FBA:  MOVWF  01
04FBC:  MOVLW  00
04FBE:  ADDWFC 02,W
04FC0:  MOVWF  03
04FC2:  MOVF   01,W
04FC4:  ADDLW  95
04FC6:  MOVWF  FE9
04FC8:  MOVLW  06
04FCA:  ADDWFC 03,W
04FCC:  MOVWF  FEA
04FCE:  MOVFF  FEC,B4D
04FD2:  MOVF   FED,F
04FD4:  MOVFF  FEF,B4C
04FD8:  CLRF   x4F
04FDA:  MOVFF  A19,B4E
04FDE:  CLRF   x51
04FE0:  MOVLW  09
04FE2:  MOVWF  x50
04FE4:  MOVLB  0
04FE6:  CALL   0B2A
04FEA:  MOVFF  01,B4E
04FEE:  MOVLW  08
04FF0:  MOVLB  B
04FF2:  ADDWF  01,W
04FF4:  MOVWF  01
04FF6:  MOVLW  00
04FF8:  ADDWFC 02,W
04FFA:  MOVWF  03
04FFC:  MOVF   01,W
04FFE:  ADDLW  95
05000:  MOVWF  FE9
05002:  MOVLW  06
05004:  ADDWFC 03,W
05006:  MOVWF  FEA
05008:  MOVFF  FEF,B4E
0500C:  MOVLW  8E
0500E:  MOVWF  FF6
05010:  MOVLW  08
05012:  MOVWF  FF7
05014:  MOVLW  36
05016:  MOVWF  x4F
05018:  MOVLB  0
0501A:  CALL   462E
0501E:  MOVFF  292,B4F
05022:  MOVLW  1B
05024:  MOVLB  B
05026:  MOVWF  x50
05028:  MOVLB  0
0502A:  CALL   465E
0502E:  MOVLW  C6
05030:  MOVWF  FF6
05032:  MOVLW  08
05034:  MOVWF  FF7
05036:  MOVLW  03
05038:  MOVLB  B
0503A:  MOVWF  x4F
0503C:  MOVLB  0
0503E:  CALL   462E
05042:  MOVLW  10
05044:  MOVWF  FE9
05046:  MOVFF  294,B50
0504A:  MOVFF  293,B4F
0504E:  CALL   47CA
05052:  MOVLW  CC
05054:  MOVWF  FF6
05056:  MOVLW  08
05058:  MOVWF  FF7
0505A:  MOVLW  03
0505C:  MOVLB  B
0505E:  MOVWF  x4F
05060:  MOVLB  0
05062:  CALL   462E
05066:  MOVFF  295,B4F
0506A:  MOVLW  1B
0506C:  MOVLB  B
0506E:  MOVWF  x50
05070:  MOVLB  0
05072:  CALL   465E
05076:  MOVLW  D1
05078:  MOVWF  FF6
0507A:  MOVLW  08
0507C:  MOVWF  FF7
0507E:  MOVLW  03
05080:  MOVLB  B
05082:  MOVWF  x4F
05084:  MOVLB  0
05086:  CALL   462E
0508A:  MOVLW  41
0508C:  MOVWF  FE9
0508E:  MOVFF  B1D,B52
05092:  MOVFF  B1C,B51
05096:  MOVFF  B1B,B50
0509A:  MOVFF  B1A,B4F
0509E:  CALL   4954
050A2:  MOVLW  24
050A4:  CLRWDT
050A6:  BTFSS  F9E.4
050A8:  GOTO   50A4
050AC:  MOVWF  FAD
050AE:  MOVLW  10
050B0:  MOVWF  FE9
050B2:  MOVFF  B1F,B50
050B6:  MOVFF  B1E,B4F
050BA:  CALL   47CA
050BE:  MOVLW  24
050C0:  CLRWDT
050C2:  BTFSS  F9E.4
050C4:  GOTO   50C0
050C8:  MOVWF  FAD
050CA:  MOVLW  10
050CC:  MOVWF  FE9
050CE:  MOVFF  B21,B50
050D2:  MOVFF  B20,B4F
050D6:  CALL   47CA
050DA:  MOVLW  24
050DC:  CLRWDT
050DE:  BTFSS  F9E.4
050E0:  GOTO   50DC
050E4:  MOVWF  FAD
050E6:  MOVFF  B22,B4F
050EA:  MOVLW  1B
050EC:  MOVLB  B
050EE:  MOVWF  x50
050F0:  MOVLB  0
050F2:  CALL   465E
050F6:  MOVLW  7C
050F8:  CLRWDT
050FA:  BTFSS  F9E.4
050FC:  GOTO   50F8
05100:  MOVWF  FAD
05102:  MOVLW  41
05104:  MOVWF  FE9
05106:  MOVFF  B28,B52
0510A:  MOVFF  B27,B51
0510E:  MOVFF  B26,B50
05112:  MOVFF  B25,B4F
05116:  CALL   4954
0511A:  MOVLW  24
0511C:  CLRWDT
0511E:  BTFSS  F9E.4
05120:  GOTO   511C
05124:  MOVWF  FAD
05126:  MOVLW  10
05128:  MOVWF  FE9
0512A:  MOVFF  B2A,B50
0512E:  MOVFF  B29,B4F
05132:  CALL   47CA
05136:  MOVLW  24
05138:  CLRWDT
0513A:  BTFSS  F9E.4
0513C:  GOTO   5138
05140:  MOVWF  FAD
05142:  MOVLW  10
05144:  MOVWF  FE9
05146:  MOVFF  B2C,B50
0514A:  MOVFF  B2B,B4F
0514E:  CALL   47CA
05152:  MOVLW  24
05154:  CLRWDT
05156:  BTFSS  F9E.4
05158:  GOTO   5154
0515C:  MOVWF  FAD
0515E:  MOVFF  B2D,B4F
05162:  MOVLW  1B
05164:  MOVLB  B
05166:  MOVWF  x50
05168:  MOVLB  0
0516A:  CALL   465E
0516E:  MOVLW  7C
05170:  CLRWDT
05172:  BTFSS  F9E.4
05174:  GOTO   5170
05178:  MOVWF  FAD
0517A:  MOVLW  41
0517C:  MOVWF  FE9
0517E:  MOVFF  B33,B52
05182:  MOVFF  B32,B51
05186:  MOVFF  B31,B50
0518A:  MOVFF  B30,B4F
0518E:  CALL   4954
05192:  MOVLW  24
05194:  CLRWDT
05196:  BTFSS  F9E.4
05198:  GOTO   5194
0519C:  MOVWF  FAD
0519E:  MOVLW  10
051A0:  MOVWF  FE9
051A2:  MOVFF  B35,B50
051A6:  MOVFF  B34,B4F
051AA:  CALL   47CA
051AE:  MOVLW  24
051B0:  CLRWDT
051B2:  BTFSS  F9E.4
051B4:  GOTO   51B0
051B8:  MOVWF  FAD
051BA:  MOVLW  10
051BC:  MOVWF  FE9
051BE:  MOVFF  B37,B50
051C2:  MOVFF  B36,B4F
051C6:  CALL   47CA
051CA:  MOVLW  24
051CC:  CLRWDT
051CE:  BTFSS  F9E.4
051D0:  GOTO   51CC
051D4:  MOVWF  FAD
051D6:  MOVFF  B38,B4F
051DA:  MOVLW  1B
051DC:  MOVLB  B
051DE:  MOVWF  x50
051E0:  MOVLB  0
051E2:  CALL   465E
051E6:  MOVLW  7C
051E8:  CLRWDT
051EA:  BTFSS  F9E.4
051EC:  GOTO   51E8
051F0:  MOVWF  FAD
051F2:  MOVLW  41
051F4:  MOVWF  FE9
051F6:  MOVFF  B3E,B52
051FA:  MOVFF  B3D,B51
051FE:  MOVFF  B3C,B50
05202:  MOVFF  B3B,B4F
05206:  CALL   4954
0520A:  MOVLW  24
0520C:  CLRWDT
0520E:  BTFSS  F9E.4
05210:  GOTO   520C
05214:  MOVWF  FAD
05216:  MOVLW  10
05218:  MOVWF  FE9
0521A:  MOVFF  B40,B50
0521E:  MOVFF  B3F,B4F
05222:  CALL   47CA
05226:  MOVLW  24
05228:  CLRWDT
0522A:  BTFSS  F9E.4
0522C:  GOTO   5228
05230:  MOVWF  FAD
05232:  MOVLW  10
05234:  MOVWF  FE9
05236:  MOVFF  B42,B50
0523A:  MOVFF  B41,B4F
0523E:  CALL   47CA
05242:  MOVLW  24
05244:  CLRWDT
05246:  BTFSS  F9E.4
05248:  GOTO   5244
0524C:  MOVWF  FAD
0524E:  MOVFF  B43,B4F
05252:  MOVLW  1B
05254:  MOVLB  B
05256:  MOVWF  x50
05258:  MOVLB  0
0525A:  CALL   465E
0525E:  MOVLW  7C
05260:  CLRWDT
05262:  BTFSS  F9E.4
05264:  GOTO   5260
05268:  MOVWF  FAD
0526A:  MOVLW  41
0526C:  MOVWF  FE9
0526E:  MOVFF  B49,B52
05272:  MOVFF  B48,B51
05276:  MOVFF  B47,B50
0527A:  MOVFF  B46,B4F
0527E:  CALL   4954
05282:  MOVLW  24
05284:  CLRWDT
05286:  BTFSS  F9E.4
05288:  GOTO   5284
0528C:  MOVWF  FAD
0528E:  MOVLW  10
05290:  MOVWF  FE9
05292:  MOVFF  B4B,B50
05296:  MOVFF  B4A,B4F
0529A:  CALL   47CA
0529E:  MOVLW  24
052A0:  CLRWDT
052A2:  BTFSS  F9E.4
052A4:  GOTO   52A0
052A8:  MOVWF  FAD
052AA:  MOVLW  10
052AC:  MOVWF  FE9
052AE:  MOVFF  B4D,B50
052B2:  MOVFF  B4C,B4F
052B6:  CALL   47CA
052BA:  MOVLW  24
052BC:  CLRWDT
052BE:  BTFSS  F9E.4
052C0:  GOTO   52BC
052C4:  MOVWF  FAD
052C6:  MOVFF  B4E,B4F
052CA:  MOVLW  1B
052CC:  MOVLB  B
052CE:  MOVWF  x50
052D0:  MOVLB  0
052D2:  CALL   465E
....................                                                                                                                                      
....................         } 
052D6:  GOTO   54B2
052DA:  MOVLB  6
....................         else 
....................         { 
....................             // Set No of messages to send. 
....................             g_stGPRSMsgHeader.m_ui8NoOfMessages = 1; 
052DC:  MOVLW  01
052DE:  MOVLB  2
052E0:  MOVWF  x92
....................             // Set web service URL. 
....................             fprintf(GSM_M66, "http://trackweigher.com/api/Test/GetStringGetMethod?a=%u&b=%Lu&c=%u&m=%Lu$%Lu$%Lu$%u", g_stGPRSMsgHeader.m_ui8NoOfMessages, g_stGPRSMsgHeader.m_ui16MachineID, g_stGPRSMsgHeader.m_ui8Variety, 
....................                                                                                                                      g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui8RejectionStatus); 
052E2:  MOVLB  B
052E4:  CLRF   x4F
052E6:  MOVFF  A19,B4E
052EA:  CLRF   x51
052EC:  MOVLW  09
052EE:  MOVWF  x50
052F0:  MOVLB  0
052F2:  CALL   0B2A
052F6:  MOVFF  02,B19
052FA:  MOVFF  01,B18
052FE:  MOVLW  95
05300:  MOVLB  B
05302:  ADDWF  01,W
05304:  MOVWF  FE9
05306:  MOVLW  06
05308:  ADDWFC 02,W
0530A:  MOVWF  FEA
0530C:  MOVFF  FEF,B1A
05310:  MOVFF  FEC,B1B
05314:  MOVFF  FEC,B1C
05318:  MOVFF  FEC,B1D
0531C:  CLRF   x4F
0531E:  MOVFF  A19,B4E
05322:  CLRF   x51
05324:  MOVLW  09
05326:  MOVWF  x50
05328:  MOVLB  0
0532A:  CALL   0B2A
0532E:  MOVFF  01,B1E
05332:  MOVLW  04
05334:  MOVLB  B
05336:  ADDWF  01,W
05338:  MOVWF  01
0533A:  MOVLW  00
0533C:  ADDWFC 02,W
0533E:  MOVWF  03
05340:  MOVF   01,W
05342:  ADDLW  95
05344:  MOVWF  FE9
05346:  MOVLW  06
05348:  ADDWFC 03,W
0534A:  MOVWF  FEA
0534C:  MOVFF  FEC,B1F
05350:  MOVF   FED,F
05352:  MOVFF  FEF,B1E
05356:  CLRF   x4F
05358:  MOVFF  A19,B4E
0535C:  CLRF   x51
0535E:  MOVLW  09
05360:  MOVWF  x50
05362:  MOVLB  0
05364:  CALL   0B2A
05368:  MOVFF  01,B20
0536C:  MOVLW  06
0536E:  MOVLB  B
05370:  ADDWF  01,W
05372:  MOVWF  01
05374:  MOVLW  00
05376:  ADDWFC 02,W
05378:  MOVWF  03
0537A:  MOVF   01,W
0537C:  ADDLW  95
0537E:  MOVWF  FE9
05380:  MOVLW  06
05382:  ADDWFC 03,W
05384:  MOVWF  FEA
05386:  MOVFF  FEC,B21
0538A:  MOVF   FED,F
0538C:  MOVFF  FEF,B20
05390:  CLRF   x4F
05392:  MOVFF  A19,B4E
05396:  CLRF   x51
05398:  MOVLW  09
0539A:  MOVWF  x50
0539C:  MOVLB  0
0539E:  CALL   0B2A
053A2:  MOVFF  02,B23
053A6:  MOVFF  01,B22
053AA:  MOVLW  08
053AC:  MOVLB  B
053AE:  ADDWF  01,W
053B0:  MOVWF  01
053B2:  MOVLW  00
053B4:  ADDWFC 02,W
053B6:  MOVWF  03
053B8:  MOVF   01,W
053BA:  ADDLW  95
053BC:  MOVWF  FE9
053BE:  MOVLW  06
053C0:  ADDWFC 03,W
053C2:  MOVWF  FEA
053C4:  MOVFF  FEF,B22
053C8:  MOVLW  20
053CA:  MOVWF  FF6
053CC:  MOVLW  09
053CE:  MOVWF  FF7
053D0:  MOVLW  36
053D2:  MOVWF  x4F
053D4:  MOVLB  0
053D6:  CALL   462E
053DA:  MOVFF  292,B4F
053DE:  MOVLW  1B
053E0:  MOVLB  B
053E2:  MOVWF  x50
053E4:  MOVLB  0
053E6:  CALL   465E
053EA:  MOVLW  58
053EC:  MOVWF  FF6
053EE:  MOVLW  09
053F0:  MOVWF  FF7
053F2:  MOVLW  03
053F4:  MOVLB  B
053F6:  MOVWF  x4F
053F8:  MOVLB  0
053FA:  CALL   462E
053FE:  MOVLW  10
05400:  MOVWF  FE9
05402:  MOVFF  294,B50
05406:  MOVFF  293,B4F
0540A:  CALL   47CA
0540E:  MOVLW  5E
05410:  MOVWF  FF6
05412:  MOVLW  09
05414:  MOVWF  FF7
05416:  MOVLW  03
05418:  MOVLB  B
0541A:  MOVWF  x4F
0541C:  MOVLB  0
0541E:  CALL   462E
05422:  MOVFF  295,B4F
05426:  MOVLW  1B
05428:  MOVLB  B
0542A:  MOVWF  x50
0542C:  MOVLB  0
0542E:  CALL   465E
05432:  MOVLW  63
05434:  MOVWF  FF6
05436:  MOVLW  09
05438:  MOVWF  FF7
0543A:  MOVLW  03
0543C:  MOVLB  B
0543E:  MOVWF  x4F
05440:  MOVLB  0
05442:  CALL   462E
05446:  MOVLW  41
05448:  MOVWF  FE9
0544A:  MOVFF  B1D,B52
0544E:  MOVFF  B1C,B51
05452:  MOVFF  B1B,B50
05456:  MOVFF  B1A,B4F
0545A:  CALL   4954
0545E:  MOVLW  24
05460:  CLRWDT
05462:  BTFSS  F9E.4
05464:  GOTO   5460
05468:  MOVWF  FAD
0546A:  MOVLW  10
0546C:  MOVWF  FE9
0546E:  MOVFF  B1F,B50
05472:  MOVFF  B1E,B4F
05476:  CALL   47CA
0547A:  MOVLW  24
0547C:  CLRWDT
0547E:  BTFSS  F9E.4
05480:  GOTO   547C
05484:  MOVWF  FAD
05486:  MOVLW  10
05488:  MOVWF  FE9
0548A:  MOVFF  B21,B50
0548E:  MOVFF  B20,B4F
05492:  CALL   47CA
05496:  MOVLW  24
05498:  CLRWDT
0549A:  BTFSS  F9E.4
0549C:  GOTO   5498
054A0:  MOVWF  FAD
054A2:  MOVFF  B22,B4F
054A6:  MOVLW  1B
054A8:  MOVLB  B
054AA:  MOVWF  x50
054AC:  MOVLB  0
054AE:  CALL   465E
....................         } 
....................         delay_ms(300); 
054B2:  MOVLW  02
054B4:  MOVLB  B
054B6:  MOVWF  x18
054B8:  MOVLW  96
054BA:  MOVWF  x34
054BC:  MOVLB  0
054BE:  CALL   0DB2
054C2:  MOVLB  B
054C4:  DECFSZ x18,F
054C6:  BRA    54B8
....................         // Check for "OK". 
....................         for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
054C8:  CLRF   x17
054CA:  CLRF   x16
054CC:  MOVF   x17,W
054CE:  MOVLB  6
054D0:  SUBWF  x89,W
054D2:  BTFSS  FD8.0
054D4:  GOTO   5584
054D8:  BTFSS  FD8.2
054DA:  GOTO   54F0
054DE:  MOVF   x88,W
054E0:  MOVLB  B
054E2:  SUBWF  x16,W
054E4:  BTFSS  FD8.0
054E6:  BRA    54EE
054E8:  MOVLB  6
054EA:  GOTO   5584
054EE:  MOVLB  6
....................         { 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
054F0:  MOVLW  94
054F2:  MOVLB  B
054F4:  ADDWF  x16,W
054F6:  MOVWF  FE9
054F8:  MOVLW  04
054FA:  ADDWFC x17,W
054FC:  MOVWF  FEA
054FE:  MOVF   FEF,W
05500:  SUBLW  0A
05502:  BTFSS  FD8.2
05504:  GOTO   5578
05508:  MOVLW  01
0550A:  SUBWF  x16,W
0550C:  MOVWF  x18
0550E:  MOVLW  00
05510:  SUBWFB x17,W
05512:  MOVWF  x19
05514:  MOVLW  94
05516:  ADDWF  x18,W
05518:  MOVWF  FE9
0551A:  MOVLW  04
0551C:  ADDWFC x19,W
0551E:  MOVWF  FEA
05520:  MOVF   FEF,W
05522:  SUBLW  0D
05524:  BTFSS  FD8.2
05526:  GOTO   5578
0552A:  MOVLW  02
0552C:  SUBWF  x16,W
0552E:  MOVWF  x1A
05530:  MOVLW  00
05532:  SUBWFB x17,W
05534:  MOVWF  x1B
05536:  MOVLW  94
05538:  ADDWF  x1A,W
0553A:  MOVWF  FE9
0553C:  MOVLW  04
0553E:  ADDWFC x1B,W
05540:  MOVWF  FEA
05542:  MOVF   FEF,W
05544:  SUBLW  4B
05546:  BTFSS  FD8.2
05548:  GOTO   5578
0554C:  MOVLW  03
0554E:  SUBWF  x16,W
05550:  MOVWF  x1C
05552:  MOVLW  00
05554:  SUBWFB x17,W
05556:  MOVWF  x1D
05558:  MOVLW  94
0555A:  ADDWF  x1C,W
0555C:  MOVWF  FE9
0555E:  MOVLW  04
05560:  ADDWFC x1D,W
05562:  MOVWF  FEA
05564:  MOVF   FEF,W
05566:  SUBLW  4F
05568:  BTFSS  FD8.2
0556A:  GOTO   5578
....................             { 
....................                 // Set flag denoting Set URL successfully. 
....................                 ui8IsSetURLOk = 0; 
0556E:  CLRF   x12
....................                 break; 
05570:  MOVLB  6
05572:  GOTO   5584
05576:  MOVLB  B
....................             } 
05578:  INCF   x16,F
0557A:  BTFSC  FD8.2
0557C:  INCF   x17,F
0557E:  GOTO   54CC
05582:  MOVLB  6
....................         }     
....................     } 
....................      
....................     // Check if queue front is at zero-th position..then increment front. 
....................     // This is after sending data of zero-th position. 
.................... //    if(g_stGPRSMsgSendQueue.m_i8Front == 0) 
.................... //    { 
.................... //        g_stGPRSMsgSendQueue.m_i8Front++; 
.................... //    } 
....................      
....................     return ui8IsSetURLOk; 
05584:  MOVLB  B
05586:  MOVFF  B12,01
0558A:  MOVLB  0
0558C:  GOTO   6710 (RETURN)
.................... } 
....................  
.................... void SendHTTPGetSessionRequest(void) 
.................... { 
....................     g_fIsTimedOut = 0; 
05590:  MOVLB  2
05592:  CLRF   x34
....................      
....................     // Reset Rx buffer. 
....................     ResetGSMM66RxBuffer(); 
05594:  MOVLB  0
05596:  CALL   1A5A
....................     // Set AT Command to start web service action. 
....................     fputs("AT+QHTTPGET=120\r", GSM_M66); 
0559A:  MOVLW  76
0559C:  MOVWF  FF6
0559E:  MOVLW  09
055A0:  MOVWF  FF7
055A2:  CALL   1A7A
055A6:  MOVLW  0D
055A8:  CLRWDT
055AA:  BTFSS  F9E.4
055AC:  GOTO   55A8
055B0:  MOVWF  FAD
055B2:  MOVLW  0A
055B4:  CLRWDT
055B6:  BTFSS  F9E.4
055B8:  GOTO   55B4
055BC:  MOVWF  FAD
055BE:  GOTO   6770 (RETURN)
....................     // Set timeout. 
....................     //SetTimeout(10); 
.................... } 
....................  
.................... unsigned int8 CheckHTTPGETRequestResponse(void) 
055C2:  MOVLW  01
055C4:  MOVLB  B
055C6:  MOVWF  x12
055C8:  CLRF   x13
055CA:  CLRF   x14
055CC:  CLRF   x15
055CE:  CLRF   x16
.................... { 
....................     unsigned int8 ui8IsOKFound = 1; 
....................     unsigned int8 ui8IsFirstCharSeqFound  = 0; 
....................     unsigned int8 ui8IsSecondCharSeqFound = 0; 
....................     unsigned int8 ui8CharSeqIndex         = 0; 
....................     unsigned int8 ui8CommaCount           = 0; 
....................      
....................     // Loop through entire receive buffer 
....................     for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
055D0:  CLRF   x18
055D2:  CLRF   x17
055D4:  MOVF   x18,W
055D6:  MOVLB  6
055D8:  SUBWF  x89,W
055DA:  BTFSS  FD8.0
055DC:  GOTO   5896
055E0:  BTFSS  FD8.2
055E2:  GOTO   55F8
055E6:  MOVF   x88,W
055E8:  MOVLB  B
055EA:  SUBWF  x17,W
055EC:  BTFSS  FD8.0
055EE:  BRA    55F6
055F0:  MOVLB  6
055F2:  GOTO   5896
055F6:  MOVLB  6
....................     { 
....................         // Check for first character sequence. 
....................         if(ui8IsFirstCharSeqFound == 0 && ui8IsSecondCharSeqFound == 0) 
055F8:  MOVLB  B
055FA:  MOVF   x13,F
055FC:  BTFSS  FD8.2
055FE:  GOTO   568E
05602:  MOVF   x14,F
05604:  BTFSS  FD8.2
05606:  GOTO   568E
....................         { 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
0560A:  MOVLW  94
0560C:  ADDWF  x17,W
0560E:  MOVWF  FE9
05610:  MOVLW  04
05612:  ADDWFC x18,W
05614:  MOVWF  FEA
05616:  MOVF   FEF,W
05618:  SUBLW  0A
0561A:  BTFSS  FD8.2
0561C:  GOTO   568A
05620:  MOVLW  01
05622:  SUBWF  x17,W
05624:  MOVWF  x19
05626:  MOVLW  00
05628:  SUBWFB x18,W
0562A:  MOVWF  x1A
0562C:  MOVLW  94
0562E:  ADDWF  x19,W
05630:  MOVWF  FE9
05632:  MOVLW  04
05634:  ADDWFC x1A,W
05636:  MOVWF  FEA
05638:  MOVF   FEF,W
0563A:  SUBLW  0D
0563C:  BTFSS  FD8.2
0563E:  GOTO   568A
05642:  MOVLW  02
05644:  SUBWF  x17,W
05646:  MOVWF  x1B
05648:  MOVLW  00
0564A:  SUBWFB x18,W
0564C:  MOVWF  x1C
0564E:  MOVLW  94
05650:  ADDWF  x1B,W
05652:  MOVWF  FE9
05654:  MOVLW  04
05656:  ADDWFC x1C,W
05658:  MOVWF  FEA
0565A:  MOVF   FEF,W
0565C:  SUBLW  4B
0565E:  BTFSS  FD8.2
05660:  GOTO   568A
05664:  MOVLW  03
05666:  SUBWF  x17,W
05668:  MOVWF  x1D
0566A:  MOVLW  00
0566C:  SUBWFB x18,W
0566E:  MOVWF  x1E
05670:  MOVLW  94
05672:  ADDWF  x1D,W
05674:  MOVWF  FE9
05676:  MOVLW  04
05678:  ADDWFC x1E,W
0567A:  MOVWF  FEA
0567C:  MOVF   FEF,W
0567E:  SUBLW  4F
05680:  BTFSS  FD8.2
05682:  GOTO   568A
....................             { 
....................                 // Set flag denoting that first character sequence is found. 
....................                 ui8IsFirstCharSeqFound = 1; 
05686:  MOVLW  01
05688:  MOVWF  x13
....................             } 
....................         } 
0568A:  GOTO   588A
....................  
....................         // Check for second character sequence. 
....................         else if(ui8IsFirstCharSeqFound == 1 && ui8IsSecondCharSeqFound == 0) 
0568E:  DECFSZ x13,W
05690:  GOTO   57EC
05694:  MOVF   x14,F
05696:  BTFSS  FD8.2
05698:  GOTO   57EC
....................         { 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ':' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'T' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'E' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'G' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'P' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'T' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 6)] == 'T' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 7)] == 'H' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 8)] == 'Q' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 9)] == '+' ) 
0569C:  MOVLW  94
0569E:  ADDWF  x17,W
056A0:  MOVWF  FE9
056A2:  MOVLW  04
056A4:  ADDWFC x18,W
056A6:  MOVWF  FEA
056A8:  MOVF   FEF,W
056AA:  SUBLW  3A
056AC:  BTFSS  FD8.2
056AE:  GOTO   57E8
056B2:  MOVLW  01
056B4:  SUBWF  x17,W
056B6:  MOVWF  x19
056B8:  MOVLW  00
056BA:  SUBWFB x18,W
056BC:  MOVWF  x1A
056BE:  MOVLW  94
056C0:  ADDWF  x19,W
056C2:  MOVWF  FE9
056C4:  MOVLW  04
056C6:  ADDWFC x1A,W
056C8:  MOVWF  FEA
056CA:  MOVF   FEF,W
056CC:  SUBLW  54
056CE:  BTFSS  FD8.2
056D0:  GOTO   57E8
056D4:  MOVLW  02
056D6:  SUBWF  x17,W
056D8:  MOVWF  x1B
056DA:  MOVLW  00
056DC:  SUBWFB x18,W
056DE:  MOVWF  x1C
056E0:  MOVLW  94
056E2:  ADDWF  x1B,W
056E4:  MOVWF  FE9
056E6:  MOVLW  04
056E8:  ADDWFC x1C,W
056EA:  MOVWF  FEA
056EC:  MOVF   FEF,W
056EE:  SUBLW  45
056F0:  BTFSS  FD8.2
056F2:  GOTO   57E8
056F6:  MOVLW  03
056F8:  SUBWF  x17,W
056FA:  MOVWF  x1D
056FC:  MOVLW  00
056FE:  SUBWFB x18,W
05700:  MOVWF  x1E
05702:  MOVLW  94
05704:  ADDWF  x1D,W
05706:  MOVWF  FE9
05708:  MOVLW  04
0570A:  ADDWFC x1E,W
0570C:  MOVWF  FEA
0570E:  MOVF   FEF,W
05710:  SUBLW  47
05712:  BTFSS  FD8.2
05714:  GOTO   57E8
05718:  MOVLW  04
0571A:  SUBWF  x17,W
0571C:  MOVWF  x1F
0571E:  MOVLW  00
05720:  SUBWFB x18,W
05722:  MOVWF  x20
05724:  MOVLW  94
05726:  ADDWF  x1F,W
05728:  MOVWF  FE9
0572A:  MOVLW  04
0572C:  ADDWFC x20,W
0572E:  MOVWF  FEA
05730:  MOVF   FEF,W
05732:  SUBLW  50
05734:  BTFSS  FD8.2
05736:  GOTO   57E8
0573A:  MOVLW  05
0573C:  SUBWF  x17,W
0573E:  MOVWF  x21
05740:  MOVLW  00
05742:  SUBWFB x18,W
05744:  MOVWF  x22
05746:  MOVLW  94
05748:  ADDWF  x21,W
0574A:  MOVWF  FE9
0574C:  MOVLW  04
0574E:  ADDWFC x22,W
05750:  MOVWF  FEA
05752:  MOVF   FEF,W
05754:  SUBLW  54
05756:  BTFSS  FD8.2
05758:  GOTO   57E8
0575C:  MOVLW  06
0575E:  SUBWF  x17,W
05760:  MOVWF  x23
05762:  MOVLW  00
05764:  SUBWFB x18,W
05766:  MOVWF  x24
05768:  MOVLW  94
0576A:  ADDWF  x23,W
0576C:  MOVWF  FE9
0576E:  MOVLW  04
05770:  ADDWFC x24,W
05772:  MOVWF  FEA
05774:  MOVF   FEF,W
05776:  SUBLW  54
05778:  BTFSS  FD8.2
0577A:  GOTO   57E8
0577E:  MOVLW  07
05780:  SUBWF  x17,W
05782:  MOVWF  x25
05784:  MOVLW  00
05786:  SUBWFB x18,W
05788:  MOVWF  x26
0578A:  MOVLW  94
0578C:  ADDWF  x25,W
0578E:  MOVWF  FE9
05790:  MOVLW  04
05792:  ADDWFC x26,W
05794:  MOVWF  FEA
05796:  MOVF   FEF,W
05798:  SUBLW  48
0579A:  BTFSS  FD8.2
0579C:  GOTO   57E8
057A0:  MOVLW  08
057A2:  SUBWF  x17,W
057A4:  MOVWF  x27
057A6:  MOVLW  00
057A8:  SUBWFB x18,W
057AA:  MOVWF  x28
057AC:  MOVLW  94
057AE:  ADDWF  x27,W
057B0:  MOVWF  FE9
057B2:  MOVLW  04
057B4:  ADDWFC x28,W
057B6:  MOVWF  FEA
057B8:  MOVF   FEF,W
057BA:  SUBLW  51
057BC:  BTFSS  FD8.2
057BE:  GOTO   57E8
057C2:  MOVLW  09
057C4:  SUBWF  x17,W
057C6:  MOVWF  x29
057C8:  MOVLW  00
057CA:  SUBWFB x18,W
057CC:  MOVWF  x2A
057CE:  MOVLW  94
057D0:  ADDWF  x29,W
057D2:  MOVWF  FE9
057D4:  MOVLW  04
057D6:  ADDWFC x2A,W
057D8:  MOVWF  FEA
057DA:  MOVF   FEF,W
057DC:  SUBLW  2B
057DE:  BTFSS  FD8.2
057E0:  GOTO   57E8
....................             { 
....................                 // Set flag denoting that second character sequence has found. 
....................                 ui8IsSecondCharSeqFound = 1; 
057E4:  MOVLW  01
057E6:  MOVWF  x14
....................             }  
....................  
....................         } 
057E8:  GOTO   588A
....................  
....................         // Check for third character sequence. 
....................         else if(ui8IsFirstCharSeqFound == 1 && ui8IsSecondCharSeqFound == 1) 
057EC:  DECFSZ x13,W
057EE:  GOTO   588A
057F2:  DECFSZ x14,W
057F4:  GOTO   588A
....................         { 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ',') 
057F8:  MOVLW  94
057FA:  ADDWF  x17,W
057FC:  MOVWF  FE9
057FE:  MOVLW  04
05800:  ADDWFC x18,W
05802:  MOVWF  FEA
05804:  MOVF   FEF,W
05806:  SUBLW  2C
05808:  BTFSS  FD8.2
0580A:  GOTO   588A
....................             { 
....................                 // Increase comma count 
....................                 ui8CommaCount++; 
0580E:  INCF   x16,F
....................                 // Check for comma count level 
....................                 if(ui8CommaCount == 2) 
05810:  MOVF   x16,W
05812:  SUBLW  02
05814:  BTFSS  FD8.2
05816:  GOTO   588A
....................                 { 
....................                     // Check for success message code. 
....................                     if(g_ui8M66RxBuffer[(ui16ByteCount - 1)] == '0' && 
....................                        g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '0' && 
....................                        g_ui8M66RxBuffer[(ui16ByteCount - 3)] == '2') 
0581A:  MOVLW  01
0581C:  SUBWF  x17,W
0581E:  MOVWF  x19
05820:  MOVLW  00
05822:  SUBWFB x18,W
05824:  MOVWF  x1A
05826:  MOVLW  94
05828:  ADDWF  x19,W
0582A:  MOVWF  FE9
0582C:  MOVLW  04
0582E:  ADDWFC x1A,W
05830:  MOVWF  FEA
05832:  MOVF   FEF,W
05834:  SUBLW  30
05836:  BTFSS  FD8.2
05838:  GOTO   588A
0583C:  MOVLW  02
0583E:  SUBWF  x17,W
05840:  MOVWF  x1B
05842:  MOVLW  00
05844:  SUBWFB x18,W
05846:  MOVWF  x1C
05848:  MOVLW  94
0584A:  ADDWF  x1B,W
0584C:  MOVWF  FE9
0584E:  MOVLW  04
05850:  ADDWFC x1C,W
05852:  MOVWF  FEA
05854:  MOVF   FEF,W
05856:  SUBLW  30
05858:  BTFSS  FD8.2
0585A:  GOTO   588A
0585E:  MOVLW  03
05860:  SUBWF  x17,W
05862:  MOVWF  x1D
05864:  MOVLW  00
05866:  SUBWFB x18,W
05868:  MOVWF  x1E
0586A:  MOVLW  94
0586C:  ADDWF  x1D,W
0586E:  MOVWF  FE9
05870:  MOVLW  04
05872:  ADDWFC x1E,W
05874:  MOVWF  FEA
05876:  MOVF   FEF,W
05878:  SUBLW  32
0587A:  BTFSS  FD8.2
0587C:  GOTO   588A
....................                     { 
....................                         // Set flag denoting that success message code found. 
....................                         ui8IsOKFound = 0; 
05880:  CLRF   x12
....................                         break; 
05882:  MOVLB  6
05884:  GOTO   5896
05888:  MOVLB  B
....................                     } 
....................                 } 
....................             }     
....................         } 
0588A:  INCF   x17,F
0588C:  BTFSC  FD8.2
0588E:  INCF   x18,F
05890:  GOTO   55D4
05894:  MOVLB  6
....................  
....................     } 
....................      
....................     return ui8IsOKFound; 
05896:  MOVLB  B
05898:  MOVFF  B12,01
0589C:  MOVLB  0
0589E:  GOTO   67A0 (RETURN)
.................... } 
....................  
.................... //unsigned int8 StartHTTPGETSession(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsOKFound = 1; 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Set AT Command to start web service action. 
.................... //    fputs("AT+QHTTPGET=120\r", GSM_M66); 
.................... //    // Set timeout. 
.................... //    SetTimeout(20); 
.................... //    // Wait for response. 
.................... //    while(g_fIsTimedOut == 0 && ui8IsOKFound == 1) 
.................... //    { 
.................... //        // Reset WDT 
.................... //        restart_wdt(); 
.................... //        // Loop through entire receive buffer 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... //            { 
.................... //                // Set flag denoting Set URL successfully. 
.................... //                ui8IsOKFound = 0; 
.................... //                break; 
.................... //            } 
.................... //        } 
.................... //    } 
.................... //     
.................... //    return ui8IsOKFound; 
.................... //} 
....................  
....................  
.................... // ############################################################# Above HTTP Application driver ########################################################## 
.................... #endif	/* VM_GSMM66_GPRS_CONFIG_H */ 
....................  
....................  
.................... #include "vmTimerConfig.h" 
.................... #ifndef _VM_TIMER_CONFIG_H_ 
.................... #define _VM_TIMER_CONFIG_H_ 
....................  
....................  
.................... //#include "vmCommon.h"   //TESTING 
.................... #include "../Common/viShiftRegister.h" 
.................... #include "../Common/vmModbusGlobal.h" 
.................... //#include "../Common/vmRS485Config.h" 
.................... #include "vmM1Common.h" 
.................... #include "../Common/vmIBCConfig.h" 
....................  
....................  
.................... #define T0_DIV_PRESCALE                     T0_DIV_8  
.................... #define TIMER_0_VALUE_LOAD_FOR_1MS          0xFD8F 
.................... #define ALL_TIMER_TEST_VAL_FOR_100_US       (0xFFFF - 0x003F + 1) 
.................... #define ALL_TIMER_TEST_VAL_FOR_70_US        (0xFFFF - 0x002C + 1) 
....................  
....................  
.................... #define FLAG_DI_STATE_CHANGED               11 
.................... #define FLAG_DI_STATE_NOT_CHANGED           12 
....................  
.................... #define ISR_TOTAL_BYTE_RECEIVE_TIME             9 //5 
.................... #define ISR_RECEIVED_ALL_BYTE                   21 
.................... #define ISR_PROCESSED_ALL_BYTE                  22 
.................... #define ISR_IS_READY                            40 
.................... #define ISR_IS_NOT_READY                        41 
....................  
.................... #define CHECK_FOR_AT_RESPONSE                   15 
.................... #define DO_NOT_CHECK_FOR_AT_RESPONSE            16 
.................... #define AT_RESPONSE_CHECK_INTRVL_TIMEOUT        60 
....................  
.................... #define MILLISECOND_TIMEOUT                     1000 
.................... #define SECOND_TIMEOUT                          60 
....................  
.................... #define SHOULD_SEND_DATA                        25 
.................... #define SHOULD_NOT_SEND_DATA                    26 
.................... #define DATA_SEND_INTERVAL_TIMEOUT              30 
....................  
.................... #define GPRS_CONNECTED                          1 
.................... #define GPRS_NOT_CONNECTED                      0 
....................  
.................... #define  GPRS_QUEUE_EMPTY_TIME_COUNT_START      80 
.................... #define  GPRS_QUEUE_EMPTY_TIME_COUNT_STOP       81 
.................... #define  GPRS_QUEUE_EMPTY_TIMEOUT               15 
....................  
.................... #define  SHOULD_CHECK_GPRS_CONNECTIVITY         55 
.................... #define  SHOULD_NOT_CHECK_GPRS_CONNECTIVITY     56 
....................  
.................... #define  REDAY_TO_RESTART_MCU                   33 
.................... #define  DO_NOT_RESTART_MCU                     34 
.................... #define  RESTART_MCU_INTERVAL_TIME              15  // In Minutes. Two Consecutive MCU restart will takes place at an interval of 15 minutes. 
....................  
.................... #define  GPRS_CONNECTION_QUERY_TIMEOUT          3  // In seconds. 
.................... #define  HTTP_URL_PARAMETER_SET_TIMEOUT         2 
.................... #define  HTTP_GET_SESSION_TIMEOUT               8 
.................... #define  DATA_RESEND_INTRVL_TIMEOUT             10 
....................  
.................... // ***************************************************************************** 
.................... // ***************** Below -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
.................... unsigned int16 g_ui16StackerEmptyDelayCount           = 0; 
.................... unsigned int8  g_fIsReadyToReceiveByte                = ISR_IS_NOT_READY; 
.................... unsigned int8  g_ui8ISRReceiveByteTimeCounter         = 0; 
.................... unsigned int8  g_fISRAllByteReceived                  = ISR_PROCESSED_ALL_BYTE; 
.................... unsigned int8  g_fDIChangeState                       = FLAG_DI_STATE_NOT_CHANGED; 
.................... unsigned int8  g_fShouldCheckForAtResponse            = CHECK_FOR_AT_RESPONSE; 
.................... unsigned int16 g_ui16MillisecondToSecondCounter       = 0; 
.................... unsigned int8  g_ui8SecondToMinuteCounter             = 0; 
.................... unsigned int8  g_ui8ATResponseCheckTimeInterval       = 0; 
.................... unsigned int16 g_ui16TimeOutMilliseconds              = 0; 
.................... unsigned int8  g_fShouldLookForTimeOut                = 0; 
.................... unsigned int16 g_ui16ShouldLookTimerCounter           = 0; 
.................... unsigned int8  g_fIsTimedOut                          = 0; 
.................... unsigned int8  g_fShouldSendData                      = SHOULD_NOT_SEND_DATA; 
.................... unsigned int16 g_ui16DataSendIntervalTime             = 0; 
.................... //unsigned int8  g_fIsGPRSConnected                     = 0; 
.................... unsigned int8  g_ui8GPRSQueueEmptyTimeCounter         = 0; 
.................... unsigned int8  g_fCheckGPRSConnectivity               = SHOULD_NOT_CHECK_GPRS_CONNECTIVITY; 
.................... unsigned int8  g_fGPRSQueueEmptyTimeStatus            = 0; 
.................... unsigned int8  g_fIsReadyToRestartMCU                 = DO_NOT_RESTART_MCU; 
.................... unsigned int8  g_ui8RestartMCUIntrvlTimeCounter       = 0; 
.................... unsigned int8  g_ui8RS485ByteCnt                      = 0; 
.................... unsigned int8  g_ui8RTSOnCountBefore                  = 0; 
.................... unsigned int8  g_ui8RTSOnCountAfter                   = 0; 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ***************** Above -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //**************** Below -> Timer Initialization Function ********************** 
.................... //****************************************************************************** 
....................  
.................... //Initialize 1MS Timer. 
.................... void Init1MSTimer(void) 
.................... { 
.................... 	//setup timer0 for 1MS time. 
.................... 	setup_timer_0( T0_INTERNAL | T0_DIV_PRESCALE ); 
.................... 	set_timer0(TIMER_0_VALUE_LOAD_FOR_1MS); 
....................  
.................... 	//Enable timer0 
.................... 	clear_interrupt( INT_TIMER0 ); 
.................... 	enable_interrupts( INT_TIMER0 ); 
.................... } 
....................  
.................... #INT_TIMER0 
.................... void timer0_isr(void) 
.................... {    
....................      
.................... 	// Increase millisecond counter at each millisecond. 
....................     g_ui16MillisecondToSecondCounter++;  //=========================================  1 
....................      
.................... ////    if (IBC_TIMER_0_CRITICAL_ON == g_ui8fTimer0State) 
.................... ////    { 
.................... ////        // Reset Timer0. 
.................... ////        set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS ); 
.................... ////        clear_interrupt( INT_TIMER0 ); 
.................... ////         
.................... ////        return; 
.................... ////    } 
....................      
....................      // Check if millisecond counter overflows 
....................     if(g_ui16MillisecondToSecondCounter >= MILLISECOND_TIMEOUT)  //==================== 2 
....................     { 
....................         // Reset counter. 
....................         g_ui16MillisecondToSecondCounter = 0; 
....................          
....................         // 1000MS i.e. 1second completed.. put stuff here that repeats after every second. 
....................          
....................         // Increase each second counter 
....................         g_ui8SecondToMinuteCounter++; 
....................          
....................         // If data should not send through GPRS then count data send interval time 
....................         if(SHOULD_NOT_SEND_DATA == g_fShouldSendData) 
....................         { 
....................             // Increase data send interval time. 
....................             g_ui16DataSendIntervalTime++; 
....................         } 
....................          
....................         // Increment counter to Sync with HMI Time to get proper timestamp. 
....................         g_ui16RegisterTime_Diff++; 
....................     }    
....................      
....................     // Check If There is data ready to send HMI through RS485 
....................     if (FLAG_RS485_DATA_READY == g_fRS485DataReady) // =================================== 4 
....................     { 
....................         // Raise RTS Pin On to hold the bus 
....................         output_bit(PIN_RS485_RTS, 1); 
....................         if (g_ui8RTSOnCountBefore++ >= DELAY_TIME_RTS_BEFORE) 
....................         { 
....................             g_ui8RTSOnCountBefore = 0; 
....................             g_ui8RS485ByteCnt = 0; 
....................             g_ui8fRS485DataSend = FLAG_RS485_DATA_SEND_ON; 
....................             g_fRS485DataReady = FLAG_RS485_DATA_NOT_READY; 
....................              
....................         } 
....................          
....................     } 
....................      
....................     // Check for RTS Flag 
....................     if (FLAG_RS485_DATA_SEND_DONE == g_ui8fRS485DataSend) // ================================ 5 
....................     { 
....................  
....................         if (g_ui8RTSOnCountAfter++ >= DELAY_TIME_RTS_AFTER) 
....................         { 
....................             // Release RTS Pin 
....................             output_bit(PIN_RS485_RTS,0); 
....................             g_ui8RTSOnCountAfter = 0; 
....................             g_ui8fRS485DataSend = FLAG_RS485_DATA_SEND_OFF; 
....................         } 
....................     } 
....................      
....................     // AR start 
....................     // Checking ISR received byte flag. 
....................     if(ISR_IS_READY == g_fIsReadyToReceiveByte) // =========================================== 
....................     { 
....................         // Increase the counter. 
....................         g_ui8ISRReceiveByteTimeCounter++; 
....................     } 
....................      
....................     if(ISR_TOTAL_BYTE_RECEIVE_TIME == g_ui8ISRReceiveByteTimeCounter) // ============================ 
....................     { 
....................         // Update all received byte flag. 
....................         g_fISRAllByteReceived = ISR_RECEIVED_ALL_BYTE; 
....................          
....................         // Update Is received byte flag.  
....................         g_fIsReadyToReceiveByte =  ISR_IS_NOT_READY; 
....................          
....................         // Reset Counter 
....................         g_ui8ISRReceiveByteTimeCounter = 0; 
....................     } 
....................     // AR end 
....................      
....................     if (IBC_TIMER_0_CRITICAL_ON == g_ui8fTimer0State) 
....................     { 
....................         // Reset Timer0. 
....................         set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS ); 
....................         clear_interrupt( INT_TIMER0 ); 
....................          
....................         return; 
....................     } 
....................      
....................     // ############################### Non Critical ############################### 
....................  
....................      
....................     // Check if second counter overflows 
....................     if(g_ui8SecondToMinuteCounter >= SECOND_TIMEOUT) 
....................     { 
....................         // Reset counter 
....................         g_ui8SecondToMinuteCounter = 0; 
....................          
....................         // 60Seconds i.e. 1 Minute completed.. put stuff here that repeats after every minute. 
....................          
....................         // Increase AT response check time interval counter..allows upto 60 minutes i.e. for 1 hour 
....................         g_ui8ATResponseCheckTimeInterval++; 
....................          
....................         // Check GPRS queue empty time status 
....................         if(GPRS_QUEUE_EMPTY_TIME_COUNT_START == g_fGPRSQueueEmptyTimeStatus) 
....................         { 
....................             // Increase time count 
....................             g_ui8GPRSQueueEmptyTimeCounter++; 
....................         } 
....................         else if(GPRS_QUEUE_EMPTY_TIME_COUNT_STOP == g_fGPRSQueueEmptyTimeStatus) 
....................         { 
....................             // when data available..reset time count 
....................             g_ui8GPRSQueueEmptyTimeCounter = 0; 
....................         } 
....................          
....................         // Check ready to restart MCU flag. 
....................         if(g_fIsReadyToRestartMCU >= DO_NOT_RESTART_MCU) 
....................         { 
....................             // Increment counter. 
....................             g_ui8RestartMCUIntrvlTimeCounter++; 
....................         } 
....................     } 
....................      
....................     // Check if AT response check interval time overflow. 
....................     if(AT_RESPONSE_CHECK_INTRVL_TIMEOUT == g_ui8ATResponseCheckTimeInterval) 
....................     { 
....................         // Reset counter 
....................         g_ui8ATResponseCheckTimeInterval = 0; 
....................          
....................         // Update AT response check flag. 
....................         g_fShouldCheckForAtResponse = CHECK_FOR_AT_RESPONSE; 
....................     } 
....................      
....................  
....................      
....................     // Check if timer should look for timeout 
....................     if(g_fShouldLookForTimeOut) 
....................     { 
....................         // Increase timer counter 
....................         g_ui16ShouldLookTimerCounter++; 
....................          
....................         // Check if timer counter reached timeout value 
....................         if(g_ui16ShouldLookTimerCounter >= g_ui16TimeOutMilliseconds) 
....................         { 
....................             // Set flag denoting that timer declares set time is timed out 
....................             g_fIsTimedOut = 1; 
....................              
....................             // Reset variables 
....................             g_fShouldLookForTimeOut      = 0; 
....................             g_ui16ShouldLookTimerCounter = 0; 
....................             g_ui16TimeOutMilliseconds    = 0; 
....................         } 
....................     } 
....................      
....................     // Check GPRS queue empty time count 
....................     if(GPRS_QUEUE_EMPTY_TIMEOUT == g_ui8GPRSQueueEmptyTimeCounter) 
....................     { 
....................         // Set flag that data is not available in GPRS queue for 15 minutes..check GPRS connection 
....................         g_fCheckGPRSConnectivity = SHOULD_CHECK_GPRS_CONNECTIVITY; 
....................          
....................         // Reset counter 
....................         g_ui8GPRSQueueEmptyTimeCounter = 0; 
....................     } 
....................      
....................     // Check if data send interval time reached timeout 
....................     if(DATA_SEND_INTERVAL_TIMEOUT == g_ui16DataSendIntervalTime) 
....................     { 
....................         // Update should send data flag 
....................         g_fShouldSendData = SHOULD_SEND_DATA; 
....................          
....................         // Reset variable 
....................         g_ui16DataSendIntervalTime = 0; 
....................     } 
....................      
....................     // Check restart MCU interval time counter. 
....................     if(g_ui8RestartMCUIntrvlTimeCounter >= RESTART_MCU_INTERVAL_TIME) 
....................     { 
....................         // Update flag status. 
....................         g_fIsReadyToRestartMCU = REDAY_TO_RESTART_MCU; 
....................          
....................         // Reset counter. 
....................         g_ui8RestartMCUIntrvlTimeCounter = 0; 
....................     } 
....................      
....................     // TESTING 
.................... 	//output_toggle(PIN_IN_EXT_DI_00); 
....................      
.................... 	// Reset Timer0. 
....................     set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS ); 
....................     clear_interrupt( INT_TIMER0 );	 
.................... } 
....................  
.................... //////// TESTING Start 
.................... //////void InitTIMER1(void) 
.................... //////{ 
.................... //////     // Setup Timer0 at 1 ms Time. 
.................... //////    setup_timer_1( T1_INTERNAL | T1_DIV_BY_8 ); 
.................... //////    set_timer0( ALL_TIMER_TEST_VAL_FOR_70_US ); 
.................... //////    // Enable Timer0. 
.................... //////    clear_interrupt( INT_TIMER1 ); 
.................... //////    enable_interrupts( INT_TIMER1 ); 
.................... //////} 
.................... ////// 
.................... //////void InitTIMER3(void) 
.................... //////{ 
.................... //////     // Setup Timer0 at 1 ms Time. 
.................... //////    setup_timer_3( T3_INTERNAL | T3_DIV_BY_8 ); 
.................... //////    set_timer0( ALL_TIMER_TEST_VAL_FOR_70_US ); 
.................... //////    // Enable Timer0. 
.................... //////    clear_interrupt( INT_TIMER3 ); 
.................... //////    enable_interrupts( INT_TIMER3 ); 
.................... //////} 
.................... ////// 
.................... //////// TESTING End. 
....................  
.................... //****************************************************************************** 
.................... //**************** Above -> Timer Initialization Function ********************** 
.................... //****************************************************************************** 
....................  
....................  
....................  
....................  
.................... void ExecuteALLDOs(void) 
.................... { 
.................... //    delay_us(10); 
.................... //    output_bit(PIN_OUT_DO_00, g_unDOState.m_stAllDOBits.m_ui1HWDOCn00); // Solenoid opeartion. 
.................... //    //output_bit(PIN_OUT_DO_01, g_unDOState.m_stAllDOBits.m_ui1HWDOCn01); // Shipper rejection RED LED. 
.................... //    //output_bit(PIN_OUT_DO_02, g_unDOState.m_stAllDOBits.m_ui1HWDOCn02); 
.................... //    output_bit(PIN_OUT_DO_03, g_unDOState.m_stAllDOBits.m_ui1HWDOCn03); // Ready To Feed. 
.................... //    //output_bit(PIN_OUT_DO_04, g_unDOState.m_stAllDOBits.m_ui1HWDOCn04); 
.................... //    //output_bit(PIN_OUT_DO_05, g_unDOState.m_stAllDOBits.m_ui1HWDOCn05); 
.................... //    //output_bit(PIN_OUT_DO_06, g_unDOState.m_stAllDOBits.m_ui1HWDOCn06); 
.................... //    //output_bit(PIN_OUT_DO_07, g_unDOState.m_stAllDOBits.m_ui1HWDOCn07);    
.................... } 
....................  
.................... //****************************************************************************** 
.................... //******************* Below -> 1MS Timer Implementation ************************ 
.................... //****************************************************************************** 
....................  
.................... ////////#INT_TIMER0 
.................... ////////void timer0_isr(void) 
.................... ////////{    
.................... ////////     
.................... ////////	// Increase millisecond counter at each millisecond. 
.................... ////////    g_ui16MillisecondToSecondCounter++;  //=========================================  1 
.................... ////////     
.................... ////////    // Check if millisecond counter overflows 
.................... ////////    if(g_ui16MillisecondToSecondCounter >= MILLISECOND_TIMEOUT)  //==================== 2 
.................... ////////    { 
.................... ////////        // Reset counter. 
.................... ////////        g_ui16MillisecondToSecondCounter = 0; 
.................... ////////         
.................... ////////        // 1000MS i.e. 1second completed.. put stuff here that repeats after every second. 
.................... ////////         
.................... ////////        // Increase each second counter 
.................... ////////        g_ui8SecondToMinuteCounter++; 
.................... ////////         
.................... ////////        // If data should not send through GPRS then count data send interval time 
.................... ////////        if(SHOULD_NOT_SEND_DATA == g_fShouldSendData) 
.................... ////////        { 
.................... ////////            // Increase data send interval time. 
.................... ////////            g_ui16DataSendIntervalTime++; 
.................... ////////        } 
.................... ////////         
.................... ////////        // Increment counter to Sync with HMI Time to get proper timestamp. 
.................... ////////        g_ui16RegisterTime_Diff++; 
.................... ////////    } 
.................... ////////     
.................... ////////    // Check if second counter overflows 
.................... ////////    if(SECOND_TIMEOUT == g_ui8SecondToMinuteCounter) // =============================== 3 
.................... ////////    { 
.................... ////////        // Reset counter 
.................... ////////        g_ui8SecondToMinuteCounter = 0; 
.................... ////////         
.................... ////////        // 60Seconds i.e. 1 Minute completed.. put stuff here that repeats after every minute. 
.................... ////////         
.................... ////////        // Increase AT response check time interval counter..allows upto 60 minutes i.e. for 1 hour 
.................... ////////        g_ui8ATResponseCheckTimeInterval++; 
.................... ////////         
.................... ////////        // Check GPRS queue empty time status 
.................... ////////        if(GPRS_QUEUE_EMPTY_TIME_COUNT_START == g_fGPRSQueueEmptyTimeStatus) 
.................... ////////        { 
.................... ////////            // Increase time count 
.................... ////////            g_ui8GPRSQueueEmptyTimeCounter++; 
.................... ////////        } 
.................... ////////        else if(GPRS_QUEUE_EMPTY_TIME_COUNT_STOP == g_fGPRSQueueEmptyTimeStatus) 
.................... ////////        { 
.................... ////////            // when data available..reset time count 
.................... ////////            g_ui8GPRSQueueEmptyTimeCounter = 0; 
.................... ////////        } 
.................... ////////         
.................... ////////        // Check ready to restart MCU flag. 
.................... ////////        if(DO_NOT_RESTART_MCU == g_fIsReadyToRestartMCU) 
.................... ////////        { 
.................... ////////            // Increment counter. 
.................... ////////            g_ui8RestartMCUIntrvlTimeCounter++; 
.................... ////////        } 
.................... ////////    } 
.................... ////////     
.................... ////////    // Check If There is data ready to send HMI through RS485 
.................... ////////    if (FLAG_RS485_DATA_READY == g_fRS485DataReady) // =================================== 4 
.................... ////////    { 
.................... ////////        // Raise RTS Pin On to hold the bus 
.................... ////////        output_bit(PIN_RS485_RTS, 1); 
.................... ////////        if (g_ui8RTSOnCountBefore++ >= DELAY_TIME_RTS_BEFORE) 
.................... ////////        { 
.................... ////////            g_ui8RTSOnCountBefore = 0; 
.................... ////////            g_ui8RS485ByteCnt = 0; 
.................... ////////            g_ui8fRS485DataSend = FLAG_RS485_DATA_SEND_ON; 
.................... ////////            g_fRS485DataReady = FLAG_RS485_DATA_NOT_READY; 
.................... ////////             
.................... ////////        } 
.................... ////////         
.................... ////////    } 
.................... ////////         
.................... //////// 
.................... //////// 
.................... ////////    // Check for RTS Flag 
.................... ////////    if (FLAG_RS485_DATA_SEND_DONE == g_ui8fRS485DataSend) // ================================ 5 
.................... ////////    { 
.................... //////// 
.................... ////////        if (g_ui8RTSOnCountAfter++ >= DELAY_TIME_RTS_AFTER) 
.................... ////////        { 
.................... ////////            // Release RTS Pin 
.................... ////////            output_bit(PIN_RS485_RTS,0); 
.................... ////////            g_ui8RTSOnCountAfter = 0; 
.................... ////////            g_ui8fRS485DataSend = FLAG_RS485_DATA_SEND_OFF; 
.................... ////////        } 
.................... ////////    } 
.................... ////////    // Check if AT response check interval time overflow. 
.................... ////////    if(AT_RESPONSE_CHECK_INTRVL_TIMEOUT == g_ui8ATResponseCheckTimeInterval) 
.................... ////////    { 
.................... ////////        // Reset counter 
.................... ////////        g_ui8ATResponseCheckTimeInterval = 0; 
.................... ////////         
.................... ////////        // Update AT response check flag. 
.................... ////////        g_fShouldCheckForAtResponse = CHECK_FOR_AT_RESPONSE; 
.................... ////////    } 
.................... ////////     
.................... ////////    // AR start 
.................... ////////    // Checking ISR received byte flag. 
.................... ////////    if(ISR_IS_READY == g_fIsReadyToReceiveByte) // =========================================== 
.................... ////////    { 
.................... ////////        // Increase the counter. 
.................... ////////        g_ui8ISRReceiveByteTimeCounter++; 
.................... ////////    } 
.................... ////////     
.................... ////////    if(ISR_TOTAL_BYTE_RECEIVE_TIME == g_ui8ISRReceiveByteTimeCounter) // ============================ 
.................... ////////    { 
.................... ////////        // Update all received byte flag. 
.................... ////////        g_fISRAllByteReceived = ISR_RECEIVED_ALL_BYTE; 
.................... ////////         
.................... ////////        // Update Is received byte flag.  
.................... ////////        g_fIsReadyToReceiveByte =  ISR_IS_NOT_READY; 
.................... ////////         
.................... ////////        // Reset Counter 
.................... ////////        g_ui8ISRReceiveByteTimeCounter = 0; 
.................... ////////    } 
.................... ////////    // AR end 
.................... ////////     
.................... ////////    // Check if timer should look for timeout 
.................... ////////    if(g_fShouldLookForTimeOut) 
.................... ////////    { 
.................... ////////        // Increase timer counter 
.................... ////////        g_ui16ShouldLookTimerCounter++; 
.................... ////////         
.................... ////////        // Check if timer counter reached timeout value 
.................... ////////        if(g_ui16ShouldLookTimerCounter >= g_ui16TimeOutMilliseconds) 
.................... ////////        { 
.................... ////////            // Set flag denoting that timer declares set time is timed out 
.................... ////////            g_fIsTimedOut = 1; 
.................... ////////             
.................... ////////            // Reset variables 
.................... ////////            g_fShouldLookForTimeOut      = 0; 
.................... ////////            g_ui16ShouldLookTimerCounter = 0; 
.................... ////////            g_ui16TimeOutMilliseconds    = 0; 
.................... ////////        } 
.................... ////////    } 
.................... ////////     
.................... ////////    // Check GPRS queue empty time count 
.................... ////////    if(GPRS_QUEUE_EMPTY_TIMEOUT == g_ui8GPRSQueueEmptyTimeCounter) 
.................... ////////    { 
.................... ////////        // Set flag that data is not available in GPRS queue for 15 minutes..check GPRS connection 
.................... ////////        g_fCheckGPRSConnectivity = SHOULD_CHECK_GPRS_CONNECTIVITY; 
.................... ////////         
.................... ////////        // Reset counter 
.................... ////////        g_ui8GPRSQueueEmptyTimeCounter = 0; 
.................... ////////    } 
.................... ////////     
.................... ////////    // Check if data send interval time reached timeout 
.................... ////////    if(DATA_SEND_INTERVAL_TIMEOUT == g_ui16DataSendIntervalTime) 
.................... ////////    { 
.................... ////////        // Update should send data flag 
.................... ////////        g_fShouldSendData = SHOULD_SEND_DATA; 
.................... ////////         
.................... ////////        // Reset variable 
.................... ////////        g_ui16DataSendIntervalTime = 0; 
.................... ////////    } 
.................... ////////     
.................... ////////    // Check restart MCU interval time counter. 
.................... ////////    if(g_ui8RestartMCUIntrvlTimeCounter >= RESTART_MCU_INTERVAL_TIME) 
.................... ////////    { 
.................... ////////        // Update flag status. 
.................... ////////        g_fIsReadyToRestartMCU = REDAY_TO_RESTART_MCU; 
.................... ////////         
.................... ////////        // Reset counter. 
.................... ////////        g_ui8RestartMCUIntrvlTimeCounter = 0; 
.................... ////////    } 
.................... ////////     
.................... ////////    // TESTING 
.................... ////////	//output_toggle(PIN_IN_EXT_DI_00); 
.................... ////////     
.................... ////////	// Reset Timer0. 
.................... ////////    set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS ); 
.................... ////////    clear_interrupt( INT_TIMER0 );	 
.................... ////////} 
....................  
.................... //////// TESTING Start 
.................... //////#INT_TIMER1 
.................... //////void timer_1_isr(void) 
.................... //////{ 
.................... //////    output_toggle(PIN_IN_EXT_DI_01); 
.................... //////     
.................... //////     // Reset Timer1. 
.................... //////    set_timer1( ALL_TIMER_TEST_VAL_FOR_70_US ); 
.................... //////    clear_interrupt( INT_TIMER1 ); 
.................... //////} 
.................... ////// 
.................... ////// 
.................... //////#INT_TIMER3 
.................... //////void timer_3_isr(void) 
.................... //////{ 
.................... //////    output_toggle(PIN_IN_EXT_DI_02); 
.................... //////     
.................... //////     // Reset Timer1. 
.................... //////    set_timer3( ALL_TIMER_TEST_VAL_FOR_70_US ); 
.................... //////    clear_interrupt( INT_TIMER3 ); 
.................... //////} 
.................... //////// TESTING End 
....................  
.................... //****************************************************************************** 
.................... //******************* Above -> 1MS Timer Implementation ************************ 
.................... //****************************************************************************** 
....................  
.................... void SetTimeout(unsigned int8 ui8TimedOutSeconds) 
.................... { 
....................     // Convert timeout seconds into milliseconds 
....................     g_ui16TimeOutMilliseconds = ui8TimedOutSeconds * 1000; 
....................      
....................     // Set flag denoting now timer should look for timeout value 
....................     g_fShouldLookForTimeOut = 1; 
.................... } 
....................  
....................  
.................... #endif /* _VM_TIMER_CONFIG_H_ */ 
....................  
....................  
.................... #define   SIZE_SMS_RESPONSE_BUFF                60 
.................... #define   GPRS_MODULE_HEALTH_OK                 44 
.................... #define   GPRS_MODULE_HEALTH_MODULE_IS_NOT_OK   45 
....................  
.................... // ***************************************************************************** 
.................... // ***************** Below -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
.................... unsigned int8  g_ui8M66SMSResponseDataBuffer[SIZE_SMS_RESPONSE_BUFF]      = {0}; 
.................... unsigned int8  g_ui8RcvPhoneNumber[13]                                    = {0}; 
.................... unsigned int8  g_ui8Recp1PhoneNumber[13]                                  = {'+','9','1','7','0','4','4','3','4','1','4','1','4'}; 
.................... unsigned int8  g_ui8Recp2PhoneNumber[13]                                  = {'+','9','1','8','9','8','1','7','8','3','6','0','9'}; 
.................... unsigned int8  g_ui8Recp3PhoneNumber[13]                                  = {'+','9','1','9','8','0','4','6','6','8','1','2','2'}; 
.................... unsigned int8  g_fIsGPRSConnected                                         = GPRS_NOT_CONNECTED; 
.................... unsigned int8  g_fIsSIM900ModuleOK                                        = GPRS_MODULE_HEALTH_MODULE_IS_NOT_OK; 
.................... // ***************************************************************************** 
.................... // ***************** Above -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
....................  
.................... void InitM66RxInterrupt(void) 
.................... { 
....................     // Enable SIM900 interrupt. 
....................     clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
*
00B0A:  BSF    F9D.5
00B0C:  GOTO   643A (RETURN)
.................... } 
....................  
....................  
....................  
.................... void Delay_Milli(unsigned int16 ui16DelayTime) 
.................... { 
....................     unsigned int16 ui16TimeCounter = 0; 
....................     while(ui16TimeCounter < ui16DelayTime) 
....................     { 
....................         delay_ms(1); 
....................         ui16TimeCounter++; 
....................     } 
.................... }    
....................  
.................... #INT_RDA 
.................... void GSMM66_Rx_ISR(void) 
.................... { 
....................      // Read the received byte from stream and store it in Rx buffer  
....................     g_ui8M66RxBuffer[g_ui16M66RxByteCount] = fgetc(GSM_M66); 
*
00988:  MOVLW  94
0098A:  MOVLB  6
0098C:  ADDWF  x88,W
0098E:  MOVWF  FE9
00990:  MOVLW  04
00992:  ADDWFC x89,W
00994:  MOVWF  FEA
00996:  CLRWDT
00998:  BTFSS  F9E.5
0099A:  GOTO   0996
0099E:  MOVFF  FAE,FEF
....................      
....................     // Increase receive byte count 
....................     g_ui16M66RxByteCount++; 
009A2:  INCF   x88,F
009A4:  BTFSC  FD8.2
009A6:  INCF   x89,F
....................      
....................     // Check if receive byte count reached receive buffer max size 
....................     if(SIZE_GSMM66_RX_BUFFER == g_ui16M66RxByteCount) 
009A8:  MOVF   x88,W
009AA:  SUBLW  F4
009AC:  BTFSS  FD8.2
009AE:  GOTO   09BC
009B2:  DECFSZ x89,W
009B4:  GOTO   09BC
....................     { 
....................         // Make it circular buffer 
....................         g_ui16M66RxByteCount = 0; 
009B8:  CLRF   x89
009BA:  CLRF   x88
....................   
....................     } 
....................      
....................     // Clear interrupt. 
....................     clear_interrupt(INT_RDA); 
009BC:  BCF    F9E.5
009BE:  MOVLB  0
009C0:  GOTO   00AC
.................... } 
....................  
.................... void SetM66BasicSMSConfiguration(void) 
.................... { 
.................... //    fputs("AT\r",GSM_M66); 
.................... //    //delay_ms(1000); 
.................... //    Delay_Milli(2000); 
....................      
....................     // Set GSM module Echo disable.  
....................     fputs("ATE0\r",GSM_M66); 
....................    delay_ms(1000); 
....................  
....................    // Set Message service type as GSM..Compatible with SMS AT Commands    
....................    fputs("AT+CSCS=\"GSM\"\r",GSM_M66); 
....................    delay_ms(1000); 
....................     
....................     // Set gsm modem preferred memory storage. 
....................     fputs("AT+CPMS=\"SM\"\r",GSM_M66); 
....................     delay_ms(1000); 
....................      
....................     // Set Incoming SMS Alert on. 
....................     fputs("AT+CNMI=2,2,0,0,0\r",GSM_M66); 
....................     delay_ms(1000); 
....................      
....................     // set the GSM modem in text mode. 
....................     fputs("AT+CMGF=1\r",GSM_M66); 
....................     delay_ms(1000); 
....................      
....................     ResetGSMM66RxBuffer(); 
.................... } 
....................  
.................... unsigned int8 SendAtCommand(void) 
*
01ACE:  MOVLB  B
01AD0:  CLRF   x12
01AD2:  CLRF   x13
.................... { 
....................     unsigned int8 ui8fIsOKFound = 0; 
....................     unsigned int8 ui8SendCount  = 0; 
....................     g_fIsTimedOut = 0; 
01AD4:  MOVLB  2
01AD6:  CLRF   x34
....................      
....................     while(ui8SendCount < 5) 
01AD8:  MOVLB  B
01ADA:  MOVF   x13,W
01ADC:  SUBLW  04
01ADE:  BTFSS  FD8.0
01AE0:  GOTO   1C02
....................     { 
.................... 	    // Reset Rx Buffer. 
.................... 	    ResetGSMM66RxBuffer(); 
01AE4:  MOVLB  0
01AE6:  CALL   1A5A
.................... 	    // Send AT Command. 
.................... 	    fputs("AT\r",GSM_M66); 
01AEA:  MOVLW  08
01AEC:  MOVWF  FF6
01AEE:  MOVLW  0A
01AF0:  MOVWF  FF7
01AF2:  CALL   1A7A
01AF6:  MOVLW  0D
01AF8:  CLRWDT
01AFA:  BTFSS  F9E.4
01AFC:  GOTO   1AF8
01B00:  MOVWF  FAD
01B02:  MOVLW  0A
01B04:  CLRWDT
01B06:  BTFSS  F9E.4
01B08:  GOTO   1B04
01B0C:  MOVWF  FAD
.................... 	    // Set Timeout.	 
.................... 	    SetTimeout(1); 
01B0E:  MOVLW  01
01B10:  MOVLB  B
01B12:  MOVWF  x1B
01B14:  MOVLB  0
01B16:  CALL   1AA6
.................... 	    // Check for 'OK' response. 
.................... 	     while(g_fIsTimedOut == 0 && ui8fIsOKFound == 0) 
01B1A:  MOVLB  2
01B1C:  MOVF   x34,F
01B1E:  BTFSS  FD8.2
01B20:  GOTO   1BFA
01B24:  MOVLB  B
01B26:  MOVF   x12,F
01B28:  BTFSC  FD8.2
01B2A:  BRA    1B32
01B2C:  MOVLB  2
01B2E:  GOTO   1BFA
.................... 	     { 
.................... 	     	for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
01B32:  CLRF   x15
01B34:  CLRF   x14
01B36:  MOVF   x15,W
01B38:  MOVLB  6
01B3A:  SUBWF  x89,W
01B3C:  BTFSS  FD8.0
01B3E:  GOTO   1BF2
01B42:  BTFSS  FD8.2
01B44:  GOTO   1B5A
01B48:  MOVF   x88,W
01B4A:  MOVLB  B
01B4C:  SUBWF  x14,W
01B4E:  BTFSS  FD8.0
01B50:  BRA    1B58
01B52:  MOVLB  6
01B54:  GOTO   1BF2
01B58:  MOVLB  6
.................... 	     	{ 
.................... 	     		// Check for "OK". 
.................... 	             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... 	                g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... 	                g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... 	                g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
01B5A:  MOVLW  94
01B5C:  MOVLB  B
01B5E:  ADDWF  x14,W
01B60:  MOVWF  FE9
01B62:  MOVLW  04
01B64:  ADDWFC x15,W
01B66:  MOVWF  FEA
01B68:  MOVF   FEF,W
01B6A:  SUBLW  0A
01B6C:  BTFSS  FD8.2
01B6E:  GOTO   1BE8
01B72:  MOVLW  01
01B74:  SUBWF  x14,W
01B76:  MOVWF  x16
01B78:  MOVLW  00
01B7A:  SUBWFB x15,W
01B7C:  MOVWF  x17
01B7E:  MOVLW  94
01B80:  ADDWF  x16,W
01B82:  MOVWF  FE9
01B84:  MOVLW  04
01B86:  ADDWFC x17,W
01B88:  MOVWF  FEA
01B8A:  MOVF   FEF,W
01B8C:  SUBLW  0D
01B8E:  BTFSS  FD8.2
01B90:  GOTO   1BE8
01B94:  MOVLW  02
01B96:  SUBWF  x14,W
01B98:  MOVWF  x18
01B9A:  MOVLW  00
01B9C:  SUBWFB x15,W
01B9E:  MOVWF  x19
01BA0:  MOVLW  94
01BA2:  ADDWF  x18,W
01BA4:  MOVWF  FE9
01BA6:  MOVLW  04
01BA8:  ADDWFC x19,W
01BAA:  MOVWF  FEA
01BAC:  MOVF   FEF,W
01BAE:  SUBLW  4B
01BB0:  BTFSS  FD8.2
01BB2:  GOTO   1BE8
01BB6:  MOVLW  03
01BB8:  SUBWF  x14,W
01BBA:  MOVWF  x1A
01BBC:  MOVLW  00
01BBE:  SUBWFB x15,W
01BC0:  MOVWF  x1B
01BC2:  MOVLW  94
01BC4:  ADDWF  x1A,W
01BC6:  MOVWF  FE9
01BC8:  MOVLW  04
01BCA:  ADDWFC x1B,W
01BCC:  MOVWF  FEA
01BCE:  MOVF   FEF,W
01BD0:  SUBLW  4F
01BD2:  BTFSS  FD8.2
01BD4:  GOTO   1BE8
.................... 	                { 
....................                         // Set flag denoting 'OK' is found. 
....................                         ui8fIsOKFound = 1; 
01BD8:  MOVLW  01
01BDA:  MOVWF  x12
....................                         ui8SendCount = 5; 
01BDC:  MOVLW  05
01BDE:  MOVWF  x13
....................                         break; 
01BE0:  MOVLB  6
01BE2:  GOTO   1BF2
01BE6:  MOVLB  B
.................... 	                } 
01BE8:  INCF   x14,F
01BEA:  BTFSC  FD8.2
01BEC:  INCF   x15,F
01BEE:  GOTO   1B36
.................... 	     	} 
01BF2:  MOVLB  0
01BF4:  GOTO   1B1A
01BF8:  MOVLB  2
.................... 	      
.................... 	     } 
.................... 	         
.................... 		ui8SendCount++; 
01BFA:  MOVLB  B
01BFC:  INCF   x13,F
01BFE:  GOTO   1ADA
.................... 	} 
.................... 	 
....................      
....................     return ui8fIsOKFound; 
01C02:  MOVFF  B12,01
01C06:  MOVLB  0
01C08:  GOTO   6520 (RETURN)
.................... } 
....................  
.................... void SendAllRecipients(unsigned int8 ui8DataLength) 
.................... { 
....................      
....................     unsigned int8 ui8IsOKFound = 0; 
....................     g_fIsTimedOut = 0; 
....................     unsigned int8 ui8LoopCount = 0; 
....................      
....................      
....................     // Check if recipient 1's phone number is valid. 
....................     if(g_ui8Recp1PhoneNumber[0] == '+') 
....................     { 
....................         // Set the GSM modem in text mode. 
....................         fputs("AT+CMGF=1\r",GSM_M66); 
....................         delay_ms(500); 
....................         // Reset M66 receive buffer 
....................         ResetGSMM66RxBuffer(); 
....................          
....................         // Prepare phone number at which SMS needs to send. 
....................         fprintf(GSM_M66, "AT+CMGS=\"%c%c%c%c%c%c%c%c%c%c%c%c%c\"\r", 
....................                                     g_ui8Recp1PhoneNumber[0], 
....................                                     g_ui8Recp1PhoneNumber[1], 
....................                                     g_ui8Recp1PhoneNumber[2], 
....................                                     g_ui8Recp1PhoneNumber[3], 
....................                                     g_ui8Recp1PhoneNumber[4], 
....................                                     g_ui8Recp1PhoneNumber[5], 
....................                                     g_ui8Recp1PhoneNumber[6], 
....................                                     g_ui8Recp1PhoneNumber[7], 
....................                                     g_ui8Recp1PhoneNumber[8], 
....................                                     g_ui8Recp1PhoneNumber[9], 
....................                                     g_ui8Recp1PhoneNumber[10], 
....................                                     g_ui8Recp1PhoneNumber[11], 
....................                                     g_ui8Recp1PhoneNumber[12]); 
....................          
....................         // Set timeout. 
....................         SetTimeout(2); 
....................         // wait for response. 
....................         while(0 == g_fIsTimedOut && ui8IsOKFound == 0) 
....................         { 
....................             // Loop through entire receive buffer response. 
....................             for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
....................             { 
....................                 // If 'prompt' received 
....................                 if(g_ui8M66RxBuffer[ui16ByteCount - 0] == '>') 
....................                 { 
....................                     // Set flag denoting response received. 
....................                     ui8IsOKFound = 1; 
....................                 } 
....................             } 
....................         } 
....................          
....................         // Check if response is received within time. 
....................         if(!g_fIsTimedOut) 
....................         { 
....................             // put data. 
....................             for(ui8LoopCount = 0; ui8LoopCount < ui8DataLength; ui8LoopCount++) 
....................             { 
....................                 fputc(g_ui8M66SMSResponseDataBuffer[ui8LoopCount], GSM_M66); 
....................             } 
....................              
....................             delay_ms(500); 
....................             fputc(0x1A,GSM_M66); // Ctrl-Z indicates end of SMS. 
....................             delay_ms(4000); 
....................             // Reset M66 receive buffer 
....................             ResetGSMM66RxBuffer(); 
....................         } 
....................     } 
....................      
....................     // Reset variables. 
....................     ui8IsOKFound = 0; 
....................     g_fIsTimedOut = 0; 
....................      
....................     // Check if recipient 2's phone number is valid. 
....................     if(g_ui8Recp2PhoneNumber[0] == '+') 
....................     { 
....................         // Reset M66 receive buffer 
....................         ResetGSMM66RxBuffer(); 
....................          
....................         // Prepare phone number at which SMS needs to send. 
....................         fprintf(GSM_M66, "AT+CMGS=\"%c%c%c%c%c%c%c%c%c%c%c%c%c\"\r", 
....................                                     g_ui8Recp2PhoneNumber[0], 
....................                                     g_ui8Recp2PhoneNumber[1], 
....................                                     g_ui8Recp2PhoneNumber[2], 
....................                                     g_ui8Recp2PhoneNumber[3], 
....................                                     g_ui8Recp2PhoneNumber[4], 
....................                                     g_ui8Recp2PhoneNumber[5], 
....................                                     g_ui8Recp2PhoneNumber[6], 
....................                                     g_ui8Recp2PhoneNumber[7], 
....................                                     g_ui8Recp2PhoneNumber[8], 
....................                                     g_ui8Recp2PhoneNumber[9], 
....................                                     g_ui8Recp2PhoneNumber[10], 
....................                                     g_ui8Recp2PhoneNumber[11], 
....................                                     g_ui8Recp2PhoneNumber[12]); 
....................          
....................         // Set timeout. 
....................         SetTimeout(2); 
....................         // wait for response. 
....................         while(0 == g_fIsTimedOut && ui8IsOKFound == 0) 
....................         { 
....................             // Loop through entire receive buffer response. 
....................             for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
....................             { 
....................                 // If 'prompt' received 
....................                 if(g_ui8M66RxBuffer[ui16ByteCount - 0] == '>') 
....................                 { 
....................                     // Set flag denoting response received. 
....................                     ui8IsOKFound = 1; 
....................                 } 
....................             } 
....................         } 
....................          
....................         // Check if response is received within time. 
....................         if(!g_fIsTimedOut) 
....................         { 
....................             // put data. 
....................             for(ui8LoopCount = 0; ui8LoopCount < ui8DataLength; ui8LoopCount++) 
....................             { 
....................                 fputc(g_ui8M66SMSResponseDataBuffer[ui8LoopCount], GSM_M66); 
....................             } 
....................              
....................             delay_ms(500); 
....................             fputc(0x1A,GSM_M66); // Ctrl-Z indicates end of SMS. 
....................             delay_ms(4000); 
....................             // Reset M66 receive buffer 
....................             ResetGSMM66RxBuffer(); 
....................         } 
....................     } 
....................      
....................     // Reset variables. 
....................     ui8IsOKFound = 0; 
....................     g_fIsTimedOut = 0; 
....................      
....................     // Check if recipient 3's phone number is valid. 
....................     if(g_ui8Recp3PhoneNumber[0] == '+') 
....................     { 
....................         // Reset M66 receive buffer 
....................         ResetGSMM66RxBuffer(); 
....................          
....................         // Prepare phone number at which SMS needs to send. 
....................         fprintf(GSM_M66, "AT+CMGS=\"%c%c%c%c%c%c%c%c%c%c%c%c%c\"\r", 
....................                                     g_ui8Recp3PhoneNumber[0], 
....................                                     g_ui8Recp3PhoneNumber[1], 
....................                                     g_ui8Recp3PhoneNumber[2], 
....................                                     g_ui8Recp3PhoneNumber[3], 
....................                                     g_ui8Recp3PhoneNumber[4], 
....................                                     g_ui8Recp3PhoneNumber[5], 
....................                                     g_ui8Recp3PhoneNumber[6], 
....................                                     g_ui8Recp3PhoneNumber[7], 
....................                                     g_ui8Recp3PhoneNumber[8], 
....................                                     g_ui8Recp3PhoneNumber[9], 
....................                                     g_ui8Recp3PhoneNumber[10], 
....................                                     g_ui8Recp3PhoneNumber[11], 
....................                                     g_ui8Recp3PhoneNumber[12]); 
....................          
....................         // Set timeout. 
....................         SetTimeout(2); 
....................         // wait for response. 
....................         while(0 == g_fIsTimedOut && ui8IsOKFound == 0) 
....................         { 
....................             // Loop through entire receive buffer response. 
....................             for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
....................             { 
....................                 // If 'prompt' received 
....................                 if(g_ui8M66RxBuffer[ui16ByteCount - 0] == '>') 
....................                 { 
....................                     // Set flag denoting response received. 
....................                     ui8IsOKFound = 1; 
....................                 } 
....................             } 
....................         } 
....................          
....................         // Check if response is received within time. 
....................         if(!g_fIsTimedOut) 
....................         { 
....................             // put data. 
....................             for(ui8LoopCount = 0; ui8LoopCount < ui8DataLength; ui8LoopCount++) 
....................             { 
....................                 fputc(g_ui8M66SMSResponseDataBuffer[ui8LoopCount], GSM_M66); 
....................             } 
....................              
....................             delay_ms(500); 
....................             fputc(0x1A,GSM_M66); // Ctrl-Z indicates end of SMS. 
....................             delay_ms(4000); 
....................             // Reset M66 receive buffer 
....................             ResetGSMM66RxBuffer(); 
....................         } 
....................     } 
....................      
....................     // Reset SMS response data buffer. 
....................     memset(g_ui8M66SMSResponseDataBuffer, 0 , SIZE_SMS_RESPONSE_BUFF); 
.................... } 
....................  
.................... void PopulateAndSendTestSMS(void) 
.................... { 
....................     // generate test SMS to send. 
....................     sprintf(g_ui8M66SMSResponseDataBuffer, "THIS IS A TEST MESSAGE FROM QUECTEL"); 
....................      
....................     // Send test message to all recipients. 
....................     SendAllRecipients(35); 
.................... } 
....................  
.................... unsigned int8 ConnectGPRS(void) 
*
03FBC:  MOVLB  B
03FBE:  CLRF   x12
.................... { 
....................     unsigned int8 ui8ReturnVal = 0; 
....................      
....................     do 
....................     { 
....................         // Reset Rx buffer. 
....................         ResetGSMM66RxBuffer(); 
03FC0:  MOVLB  0
03FC2:  CALL   1A5A
....................         // Define PDP context. 
....................         ui8ReturnVal = SetPDPContext(); 
03FC6:  GOTO   3A64
03FCA:  MOVFF  01,B12
....................          
....................        // Check return value. 
....................         if(ui8ReturnVal != 0) 
03FCE:  MOVLB  B
03FD0:  MOVF   x12,F
03FD2:  BTFSC  FD8.2
03FD4:  GOTO   3FDC
....................         { 
....................             break; 
03FD8:  GOTO   4014
....................         } 
....................          
....................         // Reset Rx buffer. 
....................         ResetGSMM66RxBuffer(); 
03FDC:  MOVLB  0
03FDE:  CALL   1A5A
....................         // Activate PDP context. 
....................         ui8ReturnVal = ActivatePDP(); 
03FE2:  GOTO   3B8A
03FE6:  MOVFF  01,B12
....................          
....................         // Check return value. 
....................         if(ui8ReturnVal != 0) 
03FEA:  MOVLB  B
03FEC:  MOVF   x12,F
03FEE:  BTFSC  FD8.2
03FF0:  GOTO   3FF8
....................         { 
....................             break; 
03FF4:  GOTO   4014
....................         } 
....................          
....................         // Reset Rx buffer. 
....................         ResetGSMM66RxBuffer(); 
03FF8:  MOVLB  0
03FFA:  CALL   1A5A
....................         // Show activated IP. 
....................         ui8ReturnVal = ShowActivatedAddress(); 
03FFE:  GOTO   3CB0
04002:  MOVFF  01,B12
....................          
....................         // Check return value. 
....................         if(ui8ReturnVal != 0) 
04006:  MOVLB  B
04008:  MOVF   x12,F
0400A:  BTFSC  FD8.2
0400C:  GOTO   4014
....................         { 
....................             break; 
04010:  GOTO   4014
....................         } 
....................   
....................     }while(0); 
....................      
....................     return ui8ReturnVal; 
04014:  MOVFF  B12,01
04018:  MOVLB  0
0401A:  GOTO   663E (RETURN)
.................... } 
....................  
.................... unsigned int8 SendData(void) 
.................... { 
....................     unsigned int8 ui8RetVal = 0; 
....................      
....................     do 
....................     { 
....................         // Reset Rx buffer. 
....................         ResetGSMM66RxBuffer(); 
....................         // Set web service URL. 
....................         ui8RetVal = SetHTTPURL(); 
....................          
....................         // Check return value. 
....................         if(ui8RetVal != 0) 
....................         { 
....................             break; 
....................         } 
....................          
....................         // Reset Rx buffer. 
....................         ResetGSMM66RxBuffer(); 
....................         // Start HTTP GET session. 
....................         ui8RetVal = StartHTTPGETSession(); 
....................          
....................         // Check return value. 
....................         if(ui8RetVal != 0) 
....................         { 
....................             break; 
....................         } 
....................                  
....................     }while(0); 
....................      
....................     return ui8RetVal; 
.................... } 
....................  
.................... #endif	/* VM_GSM_M66_CONFIG_H */ 
....................  
....................  
.................... #include "vmGSMM66_GPRSConfig.h" 
.................... /*  
....................  * File:   vmGSMM66_GPRSConfig.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on January 22, 2019, 6:50 PM 
....................  */ 
....................  
.................... #ifndef VM_GSMM66_GPRS_CONFIG_H 
.................... #define	VM_GSMM66_GPRS_CONFIG_H 
....................  
.................... #include "vmSIM900_GPRSConfig.h" 
.................... #include "viRS485Config.h" 
....................  
.................... // Stuff Machine ID and Variety type in GPRS Message header. 
.................... // Amta plant(Line 2) -> Machine ID - 2 and Marie Gold variety Type - 3. 
.................... // Delta Foods Machine ID - 4 
.................... // Super Snacks Machine ID - 5 
.................... #define  MACHINE_ID                2  // Delta 
....................      
.................... #define   SIZE_GSMM66_RX_BUFFER                 500 
.................... #define   SIZE_GPRS_DATA_NODE_QUEUE             100 
....................  
.................... #define   GPRS_DATA_SENDING_SEQUENCE_1          1 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_2          2 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_3          3 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_4          4 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_5          5 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_6          6 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_7          7 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_8          8 
....................  
....................  
.................... typedef struct _ST_GPRS_DATA_NODE 
.................... { 
....................     unsigned int32 m_ui32TimeStamp; 
....................     unsigned int16 m_ui16SequenceNo; 
....................     unsigned int16 m_ui16ItemWeight; 
....................     unsigned int8  m_ui8RejectionStatus; 
.................... } ST_GPRS_DATA_NODE; 
....................  
.................... typedef struct _ST_GPRS_MSG_SEND_QUEUE 
.................... { 
....................     ST_GPRS_DATA_NODE m_stArrGPRSDataNode[SIZE_GPRS_DATA_NODE_QUEUE]; 
....................     int8              m_i8Front; 
....................     int8              m_i8Rear; 
.................... } ST_GPRS_MSG_SEND_QUEUE; 
....................  
.................... typedef struct _ST_PROD_M_CURR_BOX_DATA 
.................... { 
....................     int16             m_i16BoxWeight; 
....................     unsigned int16    m_ui16SequenceNo; 
....................     unsigned int16    m_ui16RejectionStatus; 
....................     unsigned int32    m_ui32TimeStamp; 
.................... } ST_PROD_M_CURR_BOX_DATA; 
....................  
.................... // ***************************************************************************** 
.................... // ***************** Below -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
.................... unsigned int8       g_ui8M66RxBuffer[SIZE_GSMM66_RX_BUFFER]               = {0}; 
.................... unsigned int16      g_ui16M66RxByteCount                                  = 0; 
.................... unsigned int8       g_ui8URLInputByteLength                               = 0; 
.................... unsigned int8       g_ui8URLInputTime                                     = 0; 
.................... //unsigned int8       g_ui8DataToSend                                       = 0; 
.................... unsigned int16      g_ui16Itm1SequenceNumber                              = 1; 
.................... unsigned int16      g_ui16Itm2SequenceNumber                              = 2; 
.................... unsigned int16      g_ui16ItemWeight                                      = 1999; 
.................... unsigned int8       g_ui8DataQueueLen                                     = 0; 
.................... unsigned int8       g_fGPRSSequence                                       = 0; 
.................... unsigned int8       g_fGPRSFailureBit                                     = 0; 
....................  
.................... ST_GPRS_MSG_SEND_QUEUE   g_stGPRSMsgSendQueue; 
.................... ST_PROD_M_CURR_BOX_DATA  g_stProdModeCurrBoxData; 
.................... // ***************************************************************************** 
.................... // ***************** Above -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
.................... void ResetGSMM66RxBuffer(void) 
.................... { 
....................     // Reset whole buffer. 
....................     memset(g_ui8M66RxBuffer, 0, SIZE_GSMM66_RX_BUFFER); 
....................      
....................     // Reset byte count 
....................     g_ui16M66RxByteCount = 0; 
.................... } 
....................  
.................... unsigned int8 CountDataSize(unsigned int32 ui32Data) 
.................... { 
....................     unsigned int8 ui8DataLen = 0; 
....................      
....................     if(ui32Data <= 9) 
....................     { 
....................         ui8DataLen = 1; 
....................     } 
....................     else if(ui32Data <= 99) 
....................     { 
....................         ui8DataLen = 2; 
....................     } 
....................     else if(ui32Data <= 999) 
....................     { 
....................         ui8DataLen = 3; 
....................     } 
....................     else if(ui32Data <= 9999) 
....................     { 
....................         ui8DataLen = 4; 
....................     } 
....................     else if(ui32Data <= 99999) 
....................     { 
....................         ui8DataLen = 5; 
....................     } 
....................     else if(ui32Data <= 999999) 
....................     { 
....................         ui8DataLen = 6; 
....................     } 
....................     else if(ui32Data <= 9999999) 
....................     { 
....................         ui8DataLen = 7; 
....................     } 
....................     else if(ui32Data <= 99999999) 
....................     { 
....................         ui8DataLen = 8; 
....................     } 
....................     else if(ui32Data <= 999999999) 
....................     { 
....................         ui8DataLen = 9; 
....................     } 
....................     else if(ui32Data <= 9999999999) 
....................     { 
....................         ui8DataLen = 10; 
....................     } 
....................     else if(ui32Data <= 99999999999) 
....................     { 
....................         ui8DataLen = 11; 
....................     } 
....................     else if(ui32Data <= 999999999999) 
....................     { 
....................         ui8DataLen = 12; 
....................     } 
....................      
....................     return ui8DataLen; 
.................... } 
....................  
.................... void CheckURLInputByteLength(void) 
.................... { 
....................     unsigned int8 ui8DataByte = 0; 
....................      
....................     // Check remaining data in the GPRS queue is greater equals than five or not. 
....................     if(g_ui8DataQueueLen >= 5) 
....................     { 
....................         // Five accumulated data node has to send. 
....................         // Set number of messages to send is five. 
....................         g_stGPRSMsgHeader.m_ui8NoOfMessages = 5; 
....................          
....................         // Basic input byte has to send is 69 bytes. add up additional bytes per no of messages. 
....................         // Add data node separator "|" for input byte length. 
....................         g_ui8URLInputByteLength = g_ui8URLInputByteLength + (g_stGPRSMsgHeader.m_ui8NoOfMessages - 1); 
....................         // Add data separator "$" for each data node. 
....................         g_ui8URLInputByteLength = g_ui8URLInputByteLength + (g_stGPRSMsgHeader.m_ui8NoOfMessages * 3); 
....................         // Now loop through the data queue to count input byte length. 
....................         for(unsigned int8 ui8LoopCount = 0; ui8LoopCount < g_stGPRSMsgHeader.m_ui8NoOfMessages; ui8LoopCount++) 
....................         { 
....................             // Check for TimeStamp. 
....................             ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front + ui8LoopCount].m_ui32TimeStamp); 
....................             // Add up data byte. 
....................             g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
....................             // Check for Sequence number. 
....................             ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front + ui8LoopCount].m_ui16SequenceNo); 
....................             // Add up data byte. 
....................             g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
....................             // Check for Item weight. 
....................             ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front + ui8LoopCount].m_ui16ItemWeight); 
....................             // Add up data byte. 
....................             g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
....................             // Check for Rejection status. 
....................             ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front + ui8LoopCount].m_ui8RejectionStatus); 
....................             // Add up data byte. 
....................             g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
....................                  
....................         } 
....................     } 
....................     else 
....................     { 
....................         // Single data node has to send. 
....................         // Set number of messages to send is one. 
....................         g_stGPRSMsgHeader.m_ui8NoOfMessages = 1; 
....................          
....................         // Basic input byte has to send is 69 bytes. add up additional bytes per no of messages. 
....................         // No data node separator needed. Only data separator for each node will be counted. 
....................         // Add data separator "$" for each data node. 
....................         g_ui8URLInputByteLength = g_ui8URLInputByteLength + (g_stGPRSMsgHeader.m_ui8NoOfMessages * 3); 
....................          
....................         // Now count data size of each data for single data node. 
....................         // Check for TimeStamp. 
....................         ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp); 
....................         // Add up data byte. 
....................         g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
....................         // Check for Sequence number. 
....................         ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front ].m_ui16SequenceNo); 
....................         // Add up data byte. 
....................         g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
....................         // Check for Item weight. 
....................         ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight); 
....................         // Add up data byte. 
....................         g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
....................         // Check for Rejection status. 
....................         ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui8RejectionStatus); 
....................         // Add up data byte. 
....................         g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
....................          
....................     } 
.................... } 
....................  
.................... void StuffDummyTimeStamp(void) 
.................... { 
....................     unsigned int16 ui16DummyTimeStamp = 11111; 
....................     unsigned int8  ui8LoopCount       = 0; 
....................      
....................     for(ui8LoopCount = 0; ui8LoopCount < SIZE_GPRS_DATA_NODE_QUEUE; ui8LoopCount++) 
....................     { 
....................         // Stuff Data. 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui32TimeStamp = ui16DummyTimeStamp++; 
....................     } 
.................... } 
....................  
....................  
.................... void InitializeGPRSMsgQueue(void) 
.................... { 
....................     // Initialize front and rear of the queue 
....................     g_stGPRSMsgSendQueue.m_i8Front = -1; 
....................     g_stGPRSMsgSendQueue.m_i8Rear = -1; 
....................      
....................     // Initialize each queue element 
....................     for(unsigned int8 ui8LoopCount = 0; ui8LoopCount < SIZE_GPRS_DATA_NODE_QUEUE; ui8LoopCount++) 
....................     { 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui16ItemWeight = 0; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui16SequenceNo = 0; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui32TimeStamp  = 0; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui8RejectionStatus = 0; 
....................     } 
....................  
.................... } 
....................  
.................... unsigned int8 IsGPRSMsgQueueEmpty(void) 
.................... { 
....................     unsigned int8 ui8QueueStatus = 0; 
....................      
....................     if(g_stGPRSMsgSendQueue.m_i8Rear == -1) /* Queue at initial state; queue is empty */ 
....................     { 
....................         ui8QueueStatus = 1; 
....................     } 
....................     else if(g_stGPRSMsgSendQueue.m_i8Front == g_stGPRSMsgSendQueue.m_i8Rear) /* All data sent; queue is empty */ 
....................     { 
....................         // Update flag that last element present in the queue. 
....................         g_fIsLastElementInGPRSQueue = 1; 
....................          
....................         // Reset GPRS message queue 
....................         //InitializeGPRSMsgQueue(); 
....................          
....................         //ui8QueueStatus = 1; 
....................     } 
....................     else if(g_stGPRSMsgSendQueue.m_i8Front == g_stGPRSMsgSendQueue.m_i8Rear + 1) 
....................     { 
....................         // Reset GPRS message queue 
....................         InitializeGPRSMsgQueue(); 
....................         // Stuff dummy time stamp. 
....................         StuffDummyTimeStamp(); 
....................          
....................         // Update data availability status in queue. 
....................         ui8QueueStatus = 1; 
....................     } 
....................      
....................     return ui8QueueStatus; 
.................... } 
....................  
.................... void InsertInGPRSMsgQueue() 
.................... { 
....................     if ((g_stGPRSMsgSendQueue.m_i8Front == 0 && g_stGPRSMsgSendQueue.m_i8Rear == SIZE_GPRS_DATA_NODE_QUEUE - 1) ||  
....................             (g_stGPRSMsgSendQueue.m_i8Front == g_stGPRSMsgSendQueue.m_i8Rear + 1))  
....................     {  
....................         //printf("\nQueue is Full");  
....................         return;  
....................     } 
....................      
....................     else if (g_stGPRSMsgSendQueue.m_i8Rear == -1) /* Insert First Element */ 
....................     {  
....................         // Initialize queue front and rear. 
....................         g_stGPRSMsgSendQueue.m_i8Rear = 0; 
....................         g_stGPRSMsgSendQueue.m_i8Front = 0; 
....................          
....................         // Insert Data 
....................         //arr[g_stIBCDataSendQueue.m_i8Rear] = value; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16SequenceNo = g_stProdModeCurrBoxData.m_ui16SequenceNo; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16ItemWeight = g_stProdModeCurrBoxData.m_i16BoxWeight; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui8RejectionStatus = (unsigned int8)g_stProdModeCurrBoxData.m_ui16RejectionStatus; 
....................         //g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui32TimeStamp = g_stProdModeCurrBoxData.m_ui32TimeStamp; 
....................     }  
....................      
....................     else if (g_stGPRSMsgSendQueue.m_i8Rear == SIZE_GPRS_DATA_NODE_QUEUE - 1 && g_stGPRSMsgSendQueue.m_i8Front != 0) /* Rear reached at last position */ 
....................     {  
....................         // Make queue circular 
....................         g_stGPRSMsgSendQueue.m_i8Rear = 0;  
....................          
....................         // Insert data 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16SequenceNo = g_stProdModeCurrBoxData.m_ui16SequenceNo; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16ItemWeight = g_stProdModeCurrBoxData.m_i16BoxWeight; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui8RejectionStatus = (unsigned int8)g_stProdModeCurrBoxData.m_ui16RejectionStatus;  
....................         //g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui32TimeStamp = g_stProdModeCurrBoxData.m_ui32TimeStamp; 
....................     }  
....................      
....................     else 
....................     {  
....................         // Normal data insertion..not in boundary condition 
....................         g_stGPRSMsgSendQueue.m_i8Rear++;  
....................          
....................         // Insert data 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16SequenceNo = g_stProdModeCurrBoxData.m_ui16SequenceNo; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16ItemWeight = g_stProdModeCurrBoxData.m_i16BoxWeight; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui8RejectionStatus = (unsigned int8)g_stProdModeCurrBoxData.m_ui16RejectionStatus; 
....................         //g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui32TimeStamp = g_stProdModeCurrBoxData.m_ui32TimeStamp; 
....................     }  
.................... } 
....................  
.................... void InitializeGPRSMsgHeader(void) 
.................... { 
....................     // Stuff Machine ID and Variety type in GPRS Message header. 
....................     // Amta plant(Line 2) -> Machine ID - 2 and Marie Gold variety Type - 3. 
....................     // Delta Foods Machine ID - 4 
....................     // Super Snacks Machine ID - 5 
....................     g_stGPRSMsgHeader.m_ui16MachineID = MACHINE_ID;  // Delta 
....................     g_stGPRSMsgHeader.m_ui8Variety = 4; 
.................... } 
....................  
.................... void StuffGPRSMSgQueueDummy(void) 
.................... { 
....................     unsigned int8  ui8NoOfMessage     = 5; 
....................     unsigned int16 ui16MachineID      = 1; 
....................     unsigned int8  ui8Variety         = 6; 
....................      
....................     unsigned int32 ui32TimeStamp       = 4545; 
....................     unsigned int16 ui16SequenceNo      = 1; 
....................     int16          i16Itemweight       = 7000; 
....................     unsigned int16 ui16Rejectionstatus = 1; 
....................      
....................     // Stuff dummy message header 
....................     g_stGPRSMsgHeader.m_ui8NoOfMessages = ui8NoOfMessage; 
....................     g_stGPRSMsgHeader.m_ui16MachineID   = ui16MachineID; 
....................     g_stGPRSMsgHeader.m_ui8Variety      = ui8Variety; 
....................      
....................     for(unsigned int8 ui8LoopCount = 0; ui8LoopCount < SIZE_GPRS_DATA_NODE_QUEUE; ui8LoopCount++) 
....................     { 
....................         g_stGPRSMsgSendQueue.m_i8Rear++; 
....................          
....................         // Stuff data 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui32TimeStamp = ui32TimeStamp++; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16SequenceNo = ui16SequenceNo++; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16ItemWeight = i16Itemweight++; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui8RejectionStatus = ui16Rejectionstatus; 
....................     } 
....................      
....................     //g_stGPRSMsgSendQueue.m_i8Front = 0; 
.................... } 
....................  
....................  
....................  
.................... // ################################################################# Below GPRS Connection Driver ############################################################# 
....................  
.................... unsigned int8 SetPDPContext(void) 
.................... { 
....................     unsigned int8 ui8IsOKFound = 1; 
....................     g_fIsTimedOut = 0; 
....................      
....................     // Reset Rx buffer. 
....................     ResetGSMM66RxBuffer(); 
....................     // Set AT command for define PDP Context. 
....................     fputs("AT+CGDCONT=1,\"IP\",\"www\"\r", GSM_M66); 
....................     // Set timeout. 
....................     SetTimeout(2); 
....................     // Wait for response. 
....................     while(g_fIsTimedOut == 0 && ui8IsOKFound == 1) 
....................     { 
....................         // Loop through entire receive buffer. 
....................         for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
....................         { 
....................             // Check for "OK". 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................                { 
....................                    // Set flag denoting 'OK' is found. 
....................                    ui8IsOKFound = 0; 
....................                    break; 
....................                } 
....................         } 
....................     } 
....................      
....................     return ui8IsOKFound; 
.................... } 
....................  
.................... unsigned int8 ActivatePDP(void) 
.................... { 
....................     unsigned int8 ui8IsOKFound = 1; 
....................     g_fIsTimedOut = 0; 
....................      
....................     // Reset Rx buffer. 
....................     ResetGSMM66RxBuffer(); 
....................     // Set AT command to activate PDP context. 
....................     fputs("AT+CGACT=1,1\r", GSM_M66); 
....................     // Set timeout. 
....................     SetTimeout(2); 
....................     // Wait for response. 
....................     while(g_fIsTimedOut == 0 && ui8IsOKFound == 1) 
....................     { 
....................         // Loop through entire receive buffer. 
....................         for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
....................         { 
....................             // Check for "OK". 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................                { 
....................                    // Set flag denoting 'OK' is found. 
....................                    ui8IsOKFound = 0; 
....................                    break; 
....................                } 
....................         } 
....................     } 
....................      
....................     return ui8IsOKFound; 
.................... }  
....................  
.................... unsigned int8 ShowActivatedAddress(void) 
.................... { 
....................     unsigned int8 ui8IsResponseFound            = 1; 
....................     unsigned int8 ui8FirstCharSequenceFound     = 0; 
....................     unsigned int8 ui8FirstCharSeqIndex          = 0; 
....................     unsigned int8 ui8SecondCharSequenceFound    = 0; 
....................     unsigned int8 ui8DoubleQuoteCount           = 0; 
....................     
....................      
....................     // Reset Rx buffer. 
....................     ResetGSMM66RxBuffer(); 
....................     // Set AT command to Show activated PDP address. 
....................     fputs("AT+CGPADDR=1\r",GSM_M66); 
....................     delay_ms(2000); 
....................     // Set timeout. 
....................     SetTimeout(2); 
....................     // Reset timeout flag. 
....................      g_fIsTimedOut = 0; 
....................     // Wait for response. 
....................     while(g_fIsTimedOut == 0 && ui8IsResponseFound == 1) 
....................     { 
....................         // Reset WDT 
....................         //restart_wdt(); 
....................         // Reset variables. 
....................         ui8FirstCharSequenceFound  = 0; 
....................         ui8FirstCharSeqIndex       = 0; 
....................         ui8SecondCharSequenceFound = 0; 
....................          
....................         // Loop through entire receive buffer. 
....................         for(unsigned int16 ui16ByteCount = 0; ui16ByteCount <= g_ui16M66RxByteCount; ui16ByteCount++) 
....................         { 
....................             // Check for first character sequence. 
....................             if(ui8FirstCharSequenceFound == 0 && ui8SecondCharSequenceFound == 0) 
....................             { 
....................                 if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ':' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'R' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'D' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'D' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'A' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'P' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 6)] == 'G' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 7)] == 'C' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 8)] == '+') 
....................                 { 
....................                     // Set flag denoting first character sequence has found. 
....................                     ui8FirstCharSequenceFound = 1; 
....................                     // Copy the first character sequence index. 
....................                     ui8FirstCharSeqIndex = (ui16ByteCount - 0); 
....................                 } 
....................             } 
....................              
....................             // Check for second character sequence set. 
....................             else if(ui8FirstCharSequenceFound == 1 && ui8SecondCharSequenceFound == 0) 
....................             { 
....................                 if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '"') 
....................                 { 
....................                     // Increment double quote count. 
....................                     ui8DoubleQuoteCount++; 
....................                     // Check double quote count. 
....................                     if(2 == ui8DoubleQuoteCount) 
....................                     { 
....................                         // Reset double quote count. 
....................                         ui8DoubleQuoteCount = 0; 
....................                         // loop through to check second quote count. 
....................                         for(unsigned int8 ui8LoopCount = ui8FirstCharSeqIndex; ui8LoopCount < (ui16ByteCount - 0); ui8LoopCount++) 
....................                         { 
....................                             // Check for stop count. 
....................                             if(g_ui8M66RxBuffer[(ui8LoopCount - 0)] == '.') 
....................                             { 
....................                                 // Increase stop. 
....................                                 ui8DoubleQuoteCount++; 
....................                                 // Check limiting stop count. 
....................                                 if(3 == ui8DoubleQuoteCount) 
....................                                 { 
....................                                     // Set flag denoting second character sequence has found. 
....................                                     ui8SecondCharSequenceFound = 1; 
....................                                     break; 
....................                                 } 
....................                             }     
....................                         } 
....................                          
....................                          
....................                     } 
....................                 } 
....................             } 
....................              
....................             // Check for OK. 
....................             else if(ui8FirstCharSequenceFound == 1 && ui8SecondCharSequenceFound == 1) 
....................             { 
....................                 if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................                { 
....................                    // Set flag denoting 'OK' is found. 
....................                    ui8IsResponseFound = 0; 
....................                    break; 
....................                } 
....................             } 
....................         } 
....................          
....................     } 
....................      
....................     return ui8IsResponseFound; 
.................... } 
....................  
.................... void SendGPRSConnectionQuery(void) 
.................... { 
....................     g_fIsTimedOut = 0; 
....................      
....................      
....................     // Reset Rx buffer. 
....................     ResetGSMM66RxBuffer(); 
....................     // Check GPRS Connection. 
....................     fputs("AT+CGACT?\r", GSM_M66); 
....................     // Set timeout. 
....................     //SetTimeout(3); 
....................  
.................... } 
....................  
.................... //unsigned int8 CheckGPRSConnection(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsResponseFound = 5; 
.................... //    unsigned int8 ui8IsFirstCharSequenceFound = 0; 
.................... //    unsigned int8 ui8FirstCharSequenceIndex = 0; 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Check GPRS Connection. 
.................... //    fputs("AT+CGACT?\r", GSM_M66); 
.................... //    // Set timeout. 
.................... //    SetTimeout(2); 
.................... //    // Wait for response. 
.................... //    while(g_fIsTimedOut == 0 && ui8IsResponseFound == 5) 
.................... //    { 
.................... //        // Reset variables. 
.................... //        ui8IsFirstCharSequenceFound = 0; 
.................... //        ui8FirstCharSequenceIndex = 0; 
.................... //         
.................... //        // Loop through entire receive buffer. 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            // Check for first character sequence. 
.................... //            if(ui8IsFirstCharSequenceFound == 0) 
.................... //            { 
.................... //                if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ':'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'T'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount-  2)] == 'C'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'A'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'G'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'C'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 6)] == '+') 
.................... //                { 
.................... //                    // Set flag denoting first character sequence found. 
.................... //                    ui8IsFirstCharSequenceFound = 1; 
.................... //                    // Copy the index of the first character of the sequence. 
.................... //                    ui8FirstCharSequenceIndex = (ui16ByteCount - 0); 
.................... //                } 
.................... //            } 
.................... //            // Check for second character sequence. 
.................... //            else if(ui8IsFirstCharSequenceFound == 1) 
.................... //            { 
.................... //                if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '0'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 1)] == ','&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '1') 
.................... //                { 
.................... //                    // Set flag denoting particular response found. 
.................... //                    // and the response says GPRS not connected. 
.................... //                    ui8IsResponseFound = 0; 
.................... //                    break; 
.................... //                } 
.................... //                else if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '1'&& 
.................... //                        g_ui8M66RxBuffer[(ui16ByteCount - 1)] == ','&& 
.................... //                        g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '1') 
.................... //                { 
.................... //                    // Set flag denoting particular response found. 
.................... //                    // and the response says GPRS connected. 
.................... //                    ui8IsResponseFound = 1; 
.................... //                    break; 
.................... //                } 
.................... //            } 
.................... //        } 
.................... //    } 
.................... //     
.................... //    return ui8IsResponseFound; 
.................... //} 
....................  
.................... unsigned int8 CheckGPRSConnectionQueryResponse(void) 
.................... { 
....................     unsigned int8 ui8IsResponseFound = 5; 
....................     unsigned int8 ui8IsFirstCharSequenceFound = 0; 
....................     unsigned int8 ui8FirstCharSequenceIndex = 0; 
....................      
....................      
....................     // Loop through entire receive buffer. 
....................     for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
....................     { 
....................         // Check for first character sequence. 
....................         if(ui8IsFirstCharSequenceFound == 0) 
....................         { 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ':'&& 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'T'&& 
....................                g_ui8M66RxBuffer[(ui16ByteCount-  2)] == 'C'&& 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'A'&& 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'G'&& 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'C'&& 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 6)] == '+') 
....................             { 
....................                 // Set flag denoting first character sequence found. 
....................                 ui8IsFirstCharSequenceFound = 1; 
....................                 // Copy the index of the first character of the sequence. 
....................                 ui8FirstCharSequenceIndex = (ui16ByteCount - 0); 
....................             } 
....................         } 
....................         // Check for second character sequence. 
....................         else if(ui8IsFirstCharSequenceFound == 1) 
....................         { 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '0'&& 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 1)] == ','&& 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '1') 
....................             { 
....................                 // Set flag denoting particular response found. 
....................                 // and the response says GPRS not connected. 
....................                 ui8IsResponseFound = 0; 
....................                 break; 
....................             } 
....................             else if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '1'&& 
....................                     g_ui8M66RxBuffer[(ui16ByteCount - 1)] == ','&& 
....................                     g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '1') 
....................             { 
....................                 // Set flag denoting particular response found. 
....................                 // and the response says GPRS connected. 
....................                 ui8IsResponseFound = 1; 
....................                 break; 
....................             } 
....................         } 
....................     } 
....................      
....................     return ui8IsResponseFound; 
.................... } 
....................  
.................... // ########################################################## Above GPRS Connection Driver ############################################################### 
....................  
.................... // ########################################################## Below HTTP Application Driver ############################################################## 
....................  
.................... unsigned int8 SetHTTPURL(void) 
.................... { 
....................     unsigned int8 ui8IsSetURLOk = 1; 
....................     unsigned int8 ui8IsConnectionDone = 0; 
....................     g_ui8URLInputTime           = 60; 
....................     g_ui8URLInputByteLength     = 93; 
....................     g_fIsTimedOut               = 0; 
....................      
....................     // Reset Rx buffer. 
....................     ResetGSMM66RxBuffer(); 
....................     // Increment variables. 
....................     g_ui16Itm1SequenceNumber += 2; 
....................     g_ui16Itm2SequenceNumber += 2; 
....................     g_ui16ItemWeight++; 
....................     // Check URL input byte length. 
....................     CheckURLInputByteLength(); 
....................     // Set AT Commands to define web service URL. 
....................     fprintf(GSM_M66, "AT+QHTTPURL=%u,%u\r", g_ui8URLInputByteLength, g_ui8URLInputTime); 
....................     // Set timeout. 
....................     SetTimeout(2); 
....................     // Wait for response. 
....................     while(g_fIsTimedOut == 0 && ui8IsSetURLOk == 1) 
....................     { 
....................         // Loop through entire receive buffer. 
....................         for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
....................         { 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 'T' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'C' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'E' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'N' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'N' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'O' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 6)] == 'C') 
....................             { 
....................                 // Set flag denote connection is established. 
....................                 ui8IsConnectionDone = 1; 
....................                 break; 
....................             }        
....................         } 
....................          
....................         // set URL in buffer. 
....................         if(ui8IsConnectionDone) 
....................         { 
....................             // Set web service URL. 
....................             fprintf(GSM_M66, "http://mwm.itsinindia.com/api/Test/GetStringGetMethod?a=2&b=1&c=5&m=1000$%Lu$%Lu$1|1500$%Lu$%Lu$1", g_ui16Itm1SequenceNumber, g_ui16ItemWeight, g_ui16Itm2SequenceNumber, ++g_ui16ItemWeight); 
....................             delay_ms(300); 
....................             // Check for "OK". 
....................             for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
....................             { 
....................                 if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................                 { 
....................                     // Set flag denoting Set URL successfully. 
....................                     ui8IsSetURLOk = 0; 
....................                     break; 
....................                 } 
....................             }     
....................         } 
....................          
....................         
....................     } 
....................      
....................     return ui8IsSetURLOk; 
....................      
.................... } 
....................  
.................... void SetHTTPURLParameter(void) 
.................... { 
....................     g_ui8URLInputTime           = 60; 
....................     g_ui8URLInputByteLength     = 66; 
....................     g_fIsTimedOut               = 0; 
....................      
....................     // Reset Rx buffer. 
....................     ResetGSMM66RxBuffer(); 
....................      
.................... //    //Increase GPRS send msg queue front. 
.................... //    if(g_stGPRSMsgSendQueue.m_i8Front != 0) 
.................... //    { 
.................... //        g_stGPRSMsgSendQueue.m_i8Front++; 
.................... //    }   
....................      
....................     // Check remaining data length of queue. 
....................     // Count data length according to queue front and rear position. 
....................     if(g_stGPRSMsgSendQueue.m_i8Rear > g_stGPRSMsgSendQueue.m_i8Front) 
....................     { 
....................         g_ui8DataQueueLen = (g_stGPRSMsgSendQueue.m_i8Rear - g_stGPRSMsgSendQueue.m_i8Front + 1); 
....................     } 
....................     else if(g_stGPRSMsgSendQueue.m_i8Rear == g_stGPRSMsgSendQueue.m_i8Front) 
....................     { 
....................         g_ui8DataQueueLen = 1; 
....................     } 
....................     else 
....................     { 
....................         g_ui8DataQueueLen = ((SIZE_GPRS_DATA_NODE_QUEUE - g_stGPRSMsgSendQueue.m_i8Front) + (g_stGPRSMsgSendQueue.m_i8Rear + 1)); 
....................     } 
....................      
....................     // If, queue front is very near to queue size i.e. less than 5 data though data length is 
....................     // more than 5 then to properly circulate queue front we need to send data one by one at this situation until it reaches queue end. 
....................     if((SIZE_GPRS_DATA_NODE_QUEUE - g_stGPRSMsgSendQueue.m_i8Front) < 5) 
....................     { 
....................         g_ui8DataQueueLen = 1; 
....................     } 
....................      
....................     // Check URL input byte length. 
....................     CheckURLInputByteLength(); 
....................      
....................     // Set AT Commands to define web service URL. 
....................     fprintf(GSM_M66, "AT+QHTTPURL=%u,%u\r", g_ui8URLInputByteLength, g_ui8URLInputTime); 
....................     // Set timeout. 
....................     //SetTimeout(2); 
.................... } 
....................  
.................... unsigned int8 SetHTTPURLL(void) 
.................... { 
....................     unsigned int8 ui8IsSetURLOk = 1; 
....................     unsigned int8 ui8IsConnectionDone = 0; 
....................      
....................     // Loop through entire receive buffer. 
....................     for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
....................     { 
....................         if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 'T' && 
....................            g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'C' && 
....................            g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'E' && 
....................            g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'N' && 
....................            g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'N' && 
....................            g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'O' && 
....................            g_ui8M66RxBuffer[(ui16ByteCount - 6)] == 'C') 
....................         { 
....................             // Set flag denote connection is established. 
....................             ui8IsConnectionDone = 1; 
....................             break; 
....................         }        
....................     } 
....................      
....................     // set URL in buffer. 
....................     if(ui8IsConnectionDone) 
....................     { 
....................         if(g_ui8DataQueueLen > 5) 
....................         { 
....................             // Set No of messages to send. 
....................             g_stGPRSMsgHeader.m_ui8NoOfMessages = 5; 
....................             // Set web service URL. 
....................             fprintf(GSM_M66, "http://trackweigher.com/api/Test/GetStringGetMethod?a=%u&b=%Lu&c=%u&m=%Lu$%Lu$%Lu$%u|%Lu$%Lu$%Lu$%u|%Lu$%Lu$%Lu$%u|%Lu$%Lu$%Lu$%u|%Lu$%Lu$%Lu$%u", g_stGPRSMsgHeader.m_ui8NoOfMessages, g_stGPRSMsgHeader.m_ui16MachineID, g_stGPRSMsgHeader.m_ui8Variety, 
....................                                                                                                                                                                                    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front++].m_ui8RejectionStatus,  
....................                                                                                                                                                                                    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front++].m_ui8RejectionStatus, 
....................                                                                                                                                                                                    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front++].m_ui8RejectionStatus, 
....................                                                                                                                                                                                    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front++].m_ui8RejectionStatus, 
....................                                                                                                                                                                                    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui8RejectionStatus); 
....................                                                                                                                                      
....................         } 
....................         else 
....................         { 
....................             // Set No of messages to send. 
....................             g_stGPRSMsgHeader.m_ui8NoOfMessages = 1; 
....................             // Set web service URL. 
....................             fprintf(GSM_M66, "http://trackweigher.com/api/Test/GetStringGetMethod?a=%u&b=%Lu&c=%u&m=%Lu$%Lu$%Lu$%u", g_stGPRSMsgHeader.m_ui8NoOfMessages, g_stGPRSMsgHeader.m_ui16MachineID, g_stGPRSMsgHeader.m_ui8Variety, 
....................                                                                                                                      g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui8RejectionStatus); 
....................         } 
....................         delay_ms(300); 
....................         // Check for "OK". 
....................         for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
....................         { 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................             { 
....................                 // Set flag denoting Set URL successfully. 
....................                 ui8IsSetURLOk = 0; 
....................                 break; 
....................             } 
....................         }     
....................     } 
....................      
....................     // Check if queue front is at zero-th position..then increment front. 
....................     // This is after sending data of zero-th position. 
.................... //    if(g_stGPRSMsgSendQueue.m_i8Front == 0) 
.................... //    { 
.................... //        g_stGPRSMsgSendQueue.m_i8Front++; 
.................... //    } 
....................      
....................     return ui8IsSetURLOk; 
.................... } 
....................  
.................... void SendHTTPGetSessionRequest(void) 
.................... { 
....................     g_fIsTimedOut = 0; 
....................      
....................     // Reset Rx buffer. 
....................     ResetGSMM66RxBuffer(); 
....................     // Set AT Command to start web service action. 
....................     fputs("AT+QHTTPGET=120\r", GSM_M66); 
....................     // Set timeout. 
....................     //SetTimeout(10); 
.................... } 
....................  
.................... unsigned int8 CheckHTTPGETRequestResponse(void) 
.................... { 
....................     unsigned int8 ui8IsOKFound = 1; 
....................     unsigned int8 ui8IsFirstCharSeqFound  = 0; 
....................     unsigned int8 ui8IsSecondCharSeqFound = 0; 
....................     unsigned int8 ui8CharSeqIndex         = 0; 
....................     unsigned int8 ui8CommaCount           = 0; 
....................      
....................     // Loop through entire receive buffer 
....................     for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
....................     { 
....................         // Check for first character sequence. 
....................         if(ui8IsFirstCharSeqFound == 0 && ui8IsSecondCharSeqFound == 0) 
....................         { 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................             { 
....................                 // Set flag denoting that first character sequence is found. 
....................                 ui8IsFirstCharSeqFound = 1; 
....................             } 
....................         } 
....................  
....................         // Check for second character sequence. 
....................         else if(ui8IsFirstCharSeqFound == 1 && ui8IsSecondCharSeqFound == 0) 
....................         { 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ':' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'T' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'E' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'G' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'P' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'T' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 6)] == 'T' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 7)] == 'H' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 8)] == 'Q' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 9)] == '+' ) 
....................             { 
....................                 // Set flag denoting that second character sequence has found. 
....................                 ui8IsSecondCharSeqFound = 1; 
....................             }  
....................  
....................         } 
....................  
....................         // Check for third character sequence. 
....................         else if(ui8IsFirstCharSeqFound == 1 && ui8IsSecondCharSeqFound == 1) 
....................         { 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ',') 
....................             { 
....................                 // Increase comma count 
....................                 ui8CommaCount++; 
....................                 // Check for comma count level 
....................                 if(ui8CommaCount == 2) 
....................                 { 
....................                     // Check for success message code. 
....................                     if(g_ui8M66RxBuffer[(ui16ByteCount - 1)] == '0' && 
....................                        g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '0' && 
....................                        g_ui8M66RxBuffer[(ui16ByteCount - 3)] == '2') 
....................                     { 
....................                         // Set flag denoting that success message code found. 
....................                         ui8IsOKFound = 0; 
....................                         break; 
....................                     } 
....................                 } 
....................             }     
....................         } 
....................  
....................     } 
....................      
....................     return ui8IsOKFound; 
.................... } 
....................  
.................... //unsigned int8 StartHTTPGETSession(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsOKFound = 1; 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Set AT Command to start web service action. 
.................... //    fputs("AT+QHTTPGET=120\r", GSM_M66); 
.................... //    // Set timeout. 
.................... //    SetTimeout(20); 
.................... //    // Wait for response. 
.................... //    while(g_fIsTimedOut == 0 && ui8IsOKFound == 1) 
.................... //    { 
.................... //        // Reset WDT 
.................... //        restart_wdt(); 
.................... //        // Loop through entire receive buffer 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... //            { 
.................... //                // Set flag denoting Set URL successfully. 
.................... //                ui8IsOKFound = 0; 
.................... //                break; 
.................... //            } 
.................... //        } 
.................... //    } 
.................... //     
.................... //    return ui8IsOKFound; 
.................... //} 
....................  
....................  
.................... // ############################################################# Above HTTP Application driver ########################################################## 
.................... #endif	/* VM_GSMM66_GPRS_CONFIG_H */ 
....................  
....................  
.................... #include "../Common/vmIBCConfig.h" 
.................... #ifndef _VI_IBC_CONFIG_H_ 
.................... #define _VI_IBC_CONFIG_H_ 
....................  
.................... #include "vmSystemConfig.h" 
.................... #include "vmCRCConfig.h" 
.................... #include "vmDigitalIOConfig.h" 
.................... //#include "ctype.h" 
.................... #include "vmPINConfig.h" 
.................... #include "vmIBCGlobal.h" 
....................  
.................... #define IBC_MSG_BYTE_COUNT                       5 
.................... #define IBC_DATA_BITS_LENGTH                     10 
.................... #define IBC_DATA_BYTES_LENGTH                    10 
.................... #define IBC_BOARD_ID                             1 
....................  
.................... #define IBC_BAUD_RATE_9600                       20 
.................... #define IBC_BAUD_RATE_19200                      21 
....................  
.................... #define T1_DIV_PRESCALE                          T1_DIV_BY_8 
.................... #define T3_DIV_PRESCALE                          T3_DIV_BY_8 
....................  
.................... #define IBC_TX_1_BT_LOAD_VALUE_9600              (0xFFFF - 0x0041 + 1) 
.................... #define IBC_TX_1_BT_LOAD_VALUE_19200             (0xFFFF - 0x0021 + 1) 
....................  
.................... #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL_9600       (0xFFFF - 0x0062 + 1) // For 9600 
.................... #define IBC_RX_BIT_TIME_T1LOAD_VAL_9600           (0xFFFF - 0x0041 + 1) // For 9600 
....................  
.................... #ifdef M1_COMM_MODULE 
....................     #define IBC_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)  // 78us Instead of 104us we load 91.2 for per bit time. 
.................... #else 
....................     #define IBC_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)//   IBC_RX_BIT_TIME_T1LOAD_VAL_9600  // 104 us 
.................... #endif 
.................... //#define IBC_RX_1_BT_CUSTOMISED_VAL_9600           (0xFFFF - 0x0031 + 1)  // Instead of 104us we load 78 us for per bit time. 
.................... #define IBC_RX_BIT_TIME_1_2_T1LOAD_VAL_9600       (0xFFFF - 0x004E + 1) 
.................... #define IBC_RX_BIT_TIME_1_3_T1LOAD_VAL_9600       (0xFFFF - 0x0051 + 1) 
.................... #define IBC_RX_BIT_TIME_1_4_T1LOAD_VAL_9600       (0xFFFF - 0x005B + 1) 
....................  
....................  
.................... #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL_19200     (0xFFFF - 0x0031 + 1) // For 19200 
.................... #define IBC_RX_BIT_TIME_T1LOAD_VAL_19200         (0xFFFF - 0x0041 + 1) // For 19200 
....................  
.................... #define SIZE_IBC_SEND_BYTE_SEGMENT                15  //1+3+8+3, 1 Start Bit, 3 Sequence Bits, 8 bits of Data and 3 Stop Bits; Total 15bits in one segment/ custised byte 
....................  
.................... #define IBC_TIMER_0_CRITICAL_ON                   0 
.................... #define IBC_TIMER_0_CRITICAL_OFF                  1 
....................  
.................... //***************************************************************************** 
.................... // Below -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
.................... typedef struct _ST_INT_BOARD_ALL_BITS 
.................... { 
....................     unsigned int8 m_ui1IBCRcvbit_0: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_1: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_2: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_3: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_4: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_5: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_6: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_7: 1; 
.................... } ST_INT_BOARD_ALL_BITS; 
....................  
.................... //typedef union _UN_INT_BOARD_BYTE_TYPE 
.................... //{ 
.................... //    unsigned int8          m_ui8Byte; 
.................... //    ST_INT_BOARD_ALL_BITS  m_stByte; 
.................... //    char				   m_chData;	 
.................... //} UN_INT_BOARD_BYTE_TYPE; 
....................  
.................... typedef struct _ST_INT_BOARD_DATA 
.................... { 
....................     char 			m_boardData[IBC_DATA_BITS_LENGTH]; 
....................     unsigned int8  	m_boardID; 
.................... } ST_INT_BOARD_DATA; 
....................  
....................  
.................... //***************************************************************************** 
.................... // Above -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Interboard Communication  RX #  From M1_COMM ********************** 
.................... //***************************************************************************** 
....................  
.................... // Below -> Multiple Baud Rate Settings. 
....................  
.................... #ifdef IBC_BOUD_RATE_1000 
....................     #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL   (0xFFFF - 0x0EA6 + 1) 
....................     #define IBC_RX_BIT_TIME_T1LOAD_VAL       (0xFFFF - 0x09C4 + 1) 
.................... #endif 
....................  
.................... #ifdef IBC_BOUD_RATE_9600 
....................     #define IBC_RX_TIME_DELAY_1_5_BIT           156  
....................     #define IBC_RX_TIME_DELAY_1_BIT             104 
....................     #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL   (0xFFFF - 0x0062 + 1) 
....................     #define IBC_RX_BIT_TIME_T1LOAD_VAL       (0xFFFF - 0x0041 + 1) 
.................... #endif 
....................  
.................... #ifdef IBC_BOUD_RATE_19200 
....................     #define IBC_RX_TIME_DELAY_1_5_VAL           78  
....................     #define IBC_RX_TIME_DELAY_1_VAL             52 
....................     #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL   (0xFFFF - 0x0031 + 1) 
....................     #define IBC_RX_BIT_TIME_T1LOAD_VAL       (0xFFFF - 0x0021 + 1) 
.................... #endif 
....................  
.................... // Above -> Multiple Baud Rate Settings. 
....................  
.................... // Initialize IBC Data Set, Should be called from main()) 
.................... //void InitIBCDataSet() 
.................... //{ 
.................... //    g_unTempRxData1.m_uiByte = 0; 
.................... //} 
....................  
.................... typedef struct _ST_IBC_RCV_BYTE_NODE 
.................... { 
....................  
....................     unsigned int8 m_ui8SeqBit0 :1; 
....................     unsigned int8 m_ui8SeqBit1 :1; 
....................     unsigned int8 m_ui8SeqBit2 :1; 
....................     unsigned int8 m_ui8Padding :5; 
....................      
....................     unsigned int8 m_ui8DataBit0 :1; 
....................     unsigned int8 m_ui8DataBit1 :1; 
....................     unsigned int8 m_ui8DataBit2 :1; 
....................     unsigned int8 m_ui8DataBit3 :1; 
....................     unsigned int8 m_ui8DataBit4 :1; 
....................     unsigned int8 m_ui8DataBit5 :1; 
....................     unsigned int8 m_ui8DataBit6 :1; 
....................     unsigned int8 m_ui8DataBit7 :1; 
.................... } ST_IBC_RCV_BYTE_NODE; 
....................  
.................... typedef union _UN_IBC_RCV_BYTE_NODE 
.................... { 
....................     ST_IBC_RCV_BYTE_NODE m_stIBCNode; 
....................     unsigned int8        m_ui8Arr[2]; 
.................... } UN_IBC_RCV_BYTE_NODE; 
....................  
....................  
....................  
.................... typedef struct _ST_IBC_DATA_NODE 
.................... { 
....................     unsigned int8 g_ui8ArrIBCData[IBC_MSG_BYTE_COUNT]; 
.................... } ST_IBC_DATA_NODE; 
....................  
.................... #define SIZE_IBC_DATA_SEND_QUEUE 15 
....................  
.................... //typedef struct _ST_IBC_DATA_SEND_QUEUE 
.................... //{ 
.................... //    ST_IBC_DATA_NODE m_stArrIBCDataNode[SIZE_IBC_DATA_SEND_QUEUE]; 
.................... //    int8             m_i8Front; 
.................... //    int8             m_i8Rear; 
.................... //} ST_IBC_DATA_SEND_QUEUE; 
....................  
.................... typedef struct _ST_IBC_MSG_QUEUE 
.................... { 
....................     ST_IBC_DATA_NODE m_stArrIBCDataNode[SIZE_IBC_DATA_SEND_QUEUE]; 
....................     int8             m_i8Front; 
....................     int8             m_i8Rear; 
.................... } ST_IBC_MSG_QUEUE; 
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... //UN_INT_BOARD_BYTE_TYPE    g_unIBCRcvData; 
.................... unsigned int8             g_ui8IBCRcvBitCount = 0; 
.................... unsigned int8             g_ui8IBCTxBitCount  = 0; 
....................  
.................... // TESTING 
.................... unsigned int8             g_ui8IBCDataToSend = 0xA5; 
.................... unsigned int8             g_fIBCCommStatus   = 0; 
....................  
.................... ST_IBC_DATA_NODE          g_stIBCRcvData; 
.................... ST_IBC_DATA_NODE          g_stIBCSendData; 
.................... unsigned int8             g_ui8ArrSendSingleMSG[IBC_MSG_BYTE_COUNT*(SIZE_IBC_SEND_BYTE_SEGMENT)] = {0}; // 
.................... unsigned int8             g_fIBCDataReceived = 0; 
....................  
.................... //ST_IBC_DATA_SEND_QUEUE    g_stIBCDataSendQueue; 
.................... unsigned int8             g_fIBCSendBusy = 0; 
.................... UN_IBC_RCV_BYTE_NODE      g_unIBCRcvByteNode; 
....................  
.................... ST_IBC_MSG_QUEUE          g_stIBCSendQueue; 
.................... ST_IBC_MSG_QUEUE          g_stIBCRcvQueue; 
....................  
.................... unsigned int8             g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... ////////// 
.................... //////////void InitializeDataSendQueue() 
.................... //////////{ 
.................... //////////    int iLoopCount1 = 0; 
.................... //////////    int iLoopCount2 = 0; 
.................... //////////    g_stIBCDataSendQueue.m_i8Front = g_stIBCDataSendQueue.m_i8Rear = -1; 
.................... //////////     
.................... //////////    for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBC_DATA_SEND_QUEUE; iLoopCount1++) 
.................... //////////    { 
.................... //////////        for (iLoopCount2 = 0; iLoopCount2 < IBC_MSG_BYTE_COUNT; iLoopCount2++) 
.................... //////////        { 
.................... //////////           g_stIBCDataSendQueue.m_stArrIBCDataNode[iLoopCount1].g_ui8ArrIBCData[iLoopCount2] = 0; 
.................... //////////        } 
.................... //////////    } 
.................... //////////} 
.................... ////////// 
.................... //////////void CopySendData(int8 i8Location, ST_IBC_DATA_NODE* pstIBCData) 
.................... //////////{ 
.................... //////////    int8 i8LoopCount = 0; 
.................... //////////     
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        g_stIBCDataSendQueue.m_stArrIBCDataNode[i8Location].g_ui8ArrIBCData[i8LoopCount] = pstIBCData->g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////    } 
.................... //////////} 
.................... ////////// 
.................... //////////void CopyFromSendQueue(int8 i8Location, ST_IBC_DATA_NODE** ppstIBCData) 
.................... //////////{ 
.................... //////////    int8 i8LoopCount = 0; 
.................... //////////     
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        *ppstIBCData->g_ui8ArrIBCData[i8LoopCount] = g_stIBCDataSendQueue.m_stArrIBCDataNode[i8Location].g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////    } 
.................... //////////} 
.................... /* Function to create Circular queue */ 
.................... //////////void InsertSendQueue(ST_IBC_DATA_NODE* pstIBCData)  
.................... //////////{ 
.................... //////////    if (!pstIBCData) 
.................... //////////    { 
.................... //////////        return; 
.................... //////////    } 
.................... //////////     
.................... //////////    if ((g_stIBCDataSendQueue.m_i8Front == 0 && g_stIBCDataSendQueue.m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1) ||  
.................... //////////            (g_stIBCDataSendQueue.m_i8Front == g_stIBCDataSendQueue.m_i8Rear + 1))  
.................... //////////    {  
.................... //////////        //printf("\nQueue is Full");  
.................... //////////        return;  
.................... //////////    } 
.................... //////////   
.................... //////////    else if (g_stIBCDataSendQueue.m_i8Front == -1) /* Insert First Element */ 
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Front = g_stIBCDataSendQueue.m_i8Rear = 0; 
.................... //////////         
.................... //////////        // Insert Data 
.................... //////////        //arr[g_stIBCDataSendQueue.m_i8Rear] = value; 
.................... //////////        CopySendData(g_stIBCDataSendQueue.m_i8Rear, pstIBCData); 
.................... //////////    }  
.................... //////////   
.................... //////////    else if (g_stIBCDataSendQueue.m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1 && g_stIBCDataSendQueue.m_i8Front != 0)  
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Rear = 0;  
.................... //////////        CopySendData(g_stIBCDataSendQueue.m_i8Rear, pstIBCData);  
.................... //////////    }  
.................... //////////   
.................... //////////    else 
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Rear++;  
.................... //////////        CopySendData(g_stIBCDataSendQueue.m_i8Rear, pstIBCData); 
.................... //////////    }  
.................... //////////}  
....................  
.................... //////////void DeleteQueue(ST_IBC_DATA_NODE* pstIBCData)  
.................... //////////{  
.................... //////////    int8 i8LoopCount = 0; 
.................... ////////// 
.................... //////////    if (g_stIBCDataSendQueue.m_i8Front == -1) 
.................... //////////    {  
.................... //////////        //printf("\nQueue is Empty");  
.................... //////////        return;  
.................... //////////    }  
.................... //////////   
.................... //////////    //int data = arr[g_stIBCDataSendQueue.m_i8Front]; 
.................... //////////    //CopyFromSendQueue(g_stIBCDataSendQueue.m_i8Front, &pstIBCData); 
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        pstIBCData->g_ui8ArrIBCData[i8LoopCount] = g_stIBCDataSendQueue.m_stArrIBCDataNode[g_stIBCDataSendQueue.m_i8Front].g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////    } 
.................... //////////     
.................... //////////    //arr[g_stIBCDataSendQueue.m_i8Front] = -1;  
.................... //////////    if (g_stIBCDataSendQueue.m_i8Front == g_stIBCDataSendQueue.m_i8Rear)  
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Front = -1;  
.................... //////////        g_stIBCDataSendQueue.m_i8Rear = -1;  
.................... //////////    }  
.................... //////////    else if (g_stIBCDataSendQueue.m_i8Front == SIZE_IBC_DATA_SEND_QUEUE-1)  
.................... //////////        g_stIBCDataSendQueue.m_i8Front = 0;  
.................... //////////    else 
.................... //////////        g_stIBCDataSendQueue.m_i8Front++;  
.................... //////////   
.................... //////////    return; 
.................... //////////}  
.................... ////////// 
.................... //////////int8 IsMSGAvailableInIBCSendQueue() 
.................... //////////{ 
.................... //////////    if (g_stIBCDataSendQueue.m_i8Front == -1) 
.................... //////////    { 
.................... //////////        return 0; 
.................... //////////    } 
.................... //////////     
.................... //////////    return 1; 
.................... //////////} 
.................... ////////// 
.................... //////////void SendIBCMSG() 
.................... //////////{ 
.................... //////////    int8          i8LoopCount    = 0; 
.................... //////////    unsigned int8 ui8Sequence    = 0; 
.................... //////////    unsigned int8 ui8TempData    = 0; 
.................... //////////     
.................... //////////    // Initialize the Send Array 
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount] = 0; 
.................... //////////    } 
.................... ////////// 
.................... //////////    // Get Node from Queue 
.................... //////////    DeleteQueue(&g_stIBCSendData); 
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        // Step 1: First Stuff 1 Start Bit 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 0] = 0;   // Start Bit Always 0 
.................... //////////         
.................... //////////        // Step 2: Now Stuff 3 bit Message Byte Sequence Number 
.................... //////////         
.................... //////////        // Stuff the 1st Sequence Bit 
.................... //////////        ui8Sequence = i8LoopCount; 
.................... //////////        ui8Sequence = ui8Sequence << 7; 
.................... //////////        ui8Sequence = ui8Sequence >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 1] = ui8Sequence; 
.................... //////////         
.................... //////////        // Stuff the 2nd Sequence Bit  
.................... //////////        ui8Sequence = i8LoopCount; 
.................... //////////        ui8Sequence = ui8Sequence << 6; 
.................... //////////        ui8Sequence = ui8Sequence >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 2] = ui8Sequence; 
.................... //////////         
.................... //////////        // Stuff the 3rd Bit 
.................... //////////        ui8Sequence = i8LoopCount; 
.................... //////////        ui8Sequence = ui8Sequence << 5; 
.................... //////////        ui8Sequence = ui8Sequence >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 3] = ui8Sequence; 
.................... //////////         
.................... //////////        // Step 3: Now Stuff 8 bit Data 
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 7; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 4] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 6; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 5] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 5; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 6] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 4; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 7] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 3; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 8] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 2; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 9] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 1; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 10] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 11] = ui8TempData; 
.................... //////////         
.................... //////////        // Step 4: Stuff three Stop Bits 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 12] = 1;  // Stop bit is 1 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 13] = 1; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 14] = 1; 
.................... //////////    } 
.................... //////////     
.................... //////////    // So message stuffing is done now start the send timer 
.................... //////////    // Initialize send counter. 
.................... //////////    g_ui8IBCTxBitCount = 0; 
.................... //////////     
.................... //////////    // TESTING Start 
.................... ////////////    g_ui8ArrSendSingleMSG[0] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[1] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[2] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[3] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[4] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[5] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[6] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[7] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[8] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[9] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[10] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[11] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[12] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[13] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[14] = 1;     
.................... //////////    // TESTING End 
.................... //////////     
.................... //////////    // Start Timer3 that handle bit by bit sending. 
.................... //////////    // Set Timer3 as per Bit Time Value. 
.................... //////////    setup_timer_3(T3_INTERNAL | T3_DIV_PRESCALE); 
.................... //////////    set_timer3(IBC_TX_1_BT_LOAD_VALUE_9600); 
.................... //////////     
.................... //////////    clear_interrupt(INT_TIMER3); 
.................... //////////    enable_interrupts(INT_TIMER3); 
.................... //////////} 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving START /////////////// 
....................  
.................... void InitializeDataQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue) 
.................... { 
....................     int iLoopCount1 = 0; 
....................     int iLoopCount2 = 0; 
....................     pstIBCMSGQueue->m_i8Front = pstIBCMSGQueue->m_i8Rear = -1; 
....................      
....................     for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBC_DATA_SEND_QUEUE; iLoopCount1++) 
....................     { 
....................         for (iLoopCount2 = 0; iLoopCount2 < IBC_MSG_BYTE_COUNT; iLoopCount2++) 
....................         { 
....................            pstIBCMSGQueue->m_stArrIBCDataNode[iLoopCount1].g_ui8ArrIBCData[iLoopCount2] = 0; 
....................         } 
....................     } 
.................... } 
....................  
.................... void CopyIBCMsg(ST_IBC_DATA_NODE* pstIBCSource, ST_IBC_DATA_NODE* pstIBCDDest) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................      
....................     for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         pstIBCDDest->g_ui8ArrIBCData[i8LoopCount] = pstIBCSource->g_ui8ArrIBCData[i8LoopCount]; 
....................     } 
.................... } 
....................  
.................... /* Function to create Circular queue */ 
.................... void InsertIBCMsgQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue, ST_IBC_DATA_NODE* pstIBCData)  
.................... { 
....................     if (!pstIBCData) 
....................     { 
....................         return; 
....................     } 
....................      
....................     if ((pstIBCMSGQueue->m_i8Front == 0 && pstIBCMSGQueue->m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1) ||  
....................             (pstIBCMSGQueue->m_i8Rear == (pstIBCMSGQueue->m_i8Front-1)%(SIZE_IBC_DATA_SEND_QUEUE-1)))  
....................     {  
....................         //printf("\nQueue is Full");  
....................         return; 
....................     } 
....................    
....................     else if (pstIBCMSGQueue->m_i8Front == -1) /* Insert First Element */ 
....................     {  
....................         pstIBCMSGQueue->m_i8Front = pstIBCMSGQueue->m_i8Rear = 0; 
....................          
....................         // Insert Data 
....................         //arr[g_stIBCDataSendQueue.m_i8Rear] = value; 
....................         CopyIBCMsg(pstIBCData, &(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else if (pstIBCMSGQueue->m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1 && pstIBCMSGQueue->m_i8Front != 0)  
....................     {  
....................         pstIBCMSGQueue->m_i8Rear = 0;  
....................         CopyIBCMsg(pstIBCData, &(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else 
....................     {  
....................         pstIBCMSGQueue->m_i8Rear++;  
....................         CopyIBCMsg(pstIBCData, &(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Rear])); 
....................     }  
.................... }  
....................  
.................... void DeleteIBCMsgQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue, ST_IBC_DATA_NODE* pstIBCData)  
.................... { 
....................     if (pstIBCMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBCMsg(&(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Front]), pstIBCData); 
....................  
....................     if (pstIBCMSGQueue->m_i8Front == pstIBCMSGQueue->m_i8Rear)  
....................     {  
....................         pstIBCMSGQueue->m_i8Front = -1;  
....................         pstIBCMSGQueue->m_i8Rear = -1;  
....................     }  
....................     else if (pstIBCMSGQueue->m_i8Front == SIZE_IBC_DATA_SEND_QUEUE-1)  
....................         pstIBCMSGQueue->m_i8Front = 0;  
....................     else 
....................         pstIBCMSGQueue->m_i8Front++;  
....................    
....................     return; 
.................... } 
....................  
....................  
.................... int8 IsMSGInIBCQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue) 
.................... { 
....................     if (pstIBCMSGQueue->m_i8Front == -1) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................     return 1; 
.................... } 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving END ///////////////// 
.................... void SendIBCMSGFromQ() 
.................... { 
....................     int8          i8LoopCount    = 0; 
....................     unsigned int8 ui8Sequence    = 0; 
....................     unsigned int8 ui8TempData    = 0; 
....................  
....................     // Initialize the Send Array 
....................     for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount] = 0; 
....................     } 
....................  
....................     // Get Node from Queue 
....................     DeleteIBCMsgQueue(&g_stIBCSendQueue, &g_stIBCSendData); 
....................     for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         // Step 1: First Stuff 1 Start Bit 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 0] = 0;   // Start Bit Always 0 
....................          
....................         // Step 2: Now Stuff 3 bit Message Byte Sequence Number 
....................          
....................         // Stuff the 1st Sequence Bit 
....................         ui8Sequence = i8LoopCount; 
....................         ui8Sequence = ui8Sequence << 7; 
....................         ui8Sequence = ui8Sequence >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 1] = ui8Sequence; 
....................          
....................         // Stuff the 2nd Sequence Bit  
....................         ui8Sequence = i8LoopCount; 
....................         ui8Sequence = ui8Sequence << 6; 
....................         ui8Sequence = ui8Sequence >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 2] = ui8Sequence; 
....................          
....................         // Stuff the 3rd Bit 
....................         ui8Sequence = i8LoopCount; 
....................         ui8Sequence = ui8Sequence << 5; 
....................         ui8Sequence = ui8Sequence >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 3] = ui8Sequence; 
....................          
....................         // Step 3: Now Stuff 8 bit Data 
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 7; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 4] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 6; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 5] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 5; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 6] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 4; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 7] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 3; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 8] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 2; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 9] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 1; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 10] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 11] = ui8TempData; 
....................          
....................         // Step 4: Stuff three Stop Bits 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 12] = 1;  // Stop bit is 1 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 13] = 1; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 14] = 1; 
....................          
.................... ////////        // TESTING Start 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 0] = 0;   
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 1] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 2] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 3] = 1;  
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 4] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 5] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 6] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 7] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 8] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 9] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 10] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 11] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 12] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 13] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 14] = 1; 
.................... ////////        // TESTING End 
....................     } 
....................      
....................      
.................... ////    // TESTING Start 
.................... ////    g_ui8ArrSendSingleMSG[0] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[1] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[2] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[3] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[4] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[5] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[6] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[7] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[8] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[9] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[10] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[11] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[12] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[13] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[14] = 1;     
.................... ////    // TESTING End 
....................          
....................     // So message stuffing is done now start the send timer 
....................     // Initialize send counter. 
....................     g_ui8IBCTxBitCount = 0; 
....................      
....................     // Hold the IBC Send Lock 
....................     g_fIBCSendLockStatus = IBC_SEND_LOCK; 
....................     // Start Timer3 that handle bit by bit sending. 
....................     // Set Timer3 as per Bit Time Value. 
....................     setup_timer_3(T3_INTERNAL | T3_DIV_PRESCALE); 
....................     set_timer3(IBC_TX_1_BT_LOAD_VALUE_9600); 
....................      
....................     // Before Sending Data in IBC Run Timer0 in Time Critical. This we are doing 
....................     // just because we have seen the IBC Send Receive is affecting while Timer 0 
....................     // is executing, hence the IBC data send receive is not sampled at proper time 
....................     g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_ON; 
....................      
....................     clear_interrupt(INT_TIMER3); 
....................     enable_interrupts(INT_TIMER3); 
.................... } 
....................  
.................... void IBCProcessRcvMsg() 
.................... { 
....................     // I 
.................... } 
....................  
.................... #INT_TIMER3    // Used for IBC Send 
.................... void IBC_Tx_ISR(void) 
.................... { 
....................     // Send IBC bits 
....................     output_bit(PIN_IBC_XMIT, g_ui8ArrSendSingleMSG[g_ui8IBCTxBitCount++]); 
....................     // Reset Timer3 at 1Bit Time value. 
....................     set_timer3(IBC_TX_1_BT_LOAD_VALUE_9600); 
....................     clear_interrupt( INT_TIMER3 ); 
....................  
....................     // Check if IBC Sending completed 
....................     if ((IBC_MSG_BYTE_COUNT*SIZE_IBC_SEND_BYTE_SEGMENT) == g_ui8IBCTxBitCount) 
....................     { 
....................         // First release Timer0 Critical run lock 
....................         g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
....................          
....................         // Release Send Busy status 
....................         g_fIBCSendBusy     = 0; 
....................          
....................         // Send Stop bit forever 
....................         output_bit(PIN_IBC_XMIT, 1); 
....................  
....................         // Reset Tx counter 
....................         g_ui8IBCTxBitCount = 0; 
....................         // Reset IBC Send checking status flag. 
....................         //g_fIBCCommStatus = 0; 
....................         // Disable Timer 
....................         setup_timer_3 (T3_DISABLED); 
....................         disable_interrupts(INT_TIMER3); 
....................         // Clear Timer1 interrupt 
....................         clear_interrupt(INT_TIMER3); 
....................          
....................         // Release IBC Send Lock 
....................         g_fIBCSendLockStatus = IBC_SEND_UNLOCK; 
....................     } 
....................      
....................     // TESTING 
....................     //output_toggle(PIN_IN_EXT_DI_00); 
....................   
.................... } 
....................  
....................  
....................  
.................... /* 
....................     Timer1 is used to handle IBC Received bytes. 
....................  and Timer3 is used to handle IBC sent bytes. 
....................  */ 
.................... #ifdef M1_COMM_MODULE 
.................... #INT_EXT1  
.................... #else 
.................... #INT_EXT3 
.................... #endif 
.................... void IBC_Rx_ISR(void) 
.................... { 
....................    
....................     // Initialize Rx Bit Counter. 
....................    	g_ui8IBCRcvBitCount = 0; 
....................     g_unIBCRcvByteNode.m_ui8Arr[0] = 0; 
....................     g_unIBCRcvByteNode.m_ui8Arr[1] = 0; 
....................    	 
....................     // Setup Timer1 at 1.5 Bit Time.                   // Here we are using DIV_BY_8. 
....................     setup_timer_1( T1_INTERNAL | T1_DIV_PRESCALE ); // CPU Ext Clock is 20MHz, 20/4 => 5MHz is Peripheral Clock 
....................                                                 // => T1_DIV_BY_2 => 5/2 = 2.5MHz => (1/2.5)us = 0.4us 
....................                                                 // To Get 1Ms quanta = (1000us/0.4) = 2500 => 0x09C4 
....................                                                 // So, The timer will start counting from (0xFFFF - 0x09C4 + 1) 
....................                                                 // To Get 1.5Ms quanta = (1500us/0.4) = 3750 => 0x0EA6 
....................                                                 // So, The timer will start counting from (0xFFFF - 0x0EA6 + 1)  
....................      
.................... #ifdef M1_COMM_MODULE 
....................     set_timer1( IBC_RX_BIT_TIME_1_4_T1LOAD_VAL_9600);  
.................... #else 
....................     set_timer1( IBC_RX_BIT_TIME_1_5_T1LOAD_VAL_9600); 
.................... #endif 
....................      
....................     // Before Sending Data in IBC Run Timer0 in Time Critical. This we are doing 
....................     // just because we have seen the IBC Send Receive is affecting while Timer 0 
....................     // is executing, hence the IBC data send receive is not sampled at proper time 
....................     g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_ON; 
....................      
....................     clear_interrupt( INT_TIMER1 ); 
....................     enable_interrupts( INT_TIMER1 ); 
....................      
....................     // Clear and Disable External Interrupt 1  
.................... #ifdef M1_COMM_MODULE 
....................     clear_interrupt(INT_EXT1); 
....................     disable_interrupts(INT_EXT1);  
.................... #else 
....................     clear_interrupt(INT_EXT3); 
....................     disable_interrupts(INT_EXT3); 
.................... #endif 
....................      
....................     // TESTING Start 
.................... #ifdef M1_COMM_MODULE 
....................     //output_high(PIN_IN_EXT_DI_00); 
.................... #endif 
....................     // TESTING End 
.................... } 
....................  
.................... // TESTING Start 
.................... int8 g_i8RcvByteCount = 0; 
.................... // TESTING End 
....................  
.................... #INT_TIMER1           // This is for Receive                 
.................... void IBC_Rx_Sampling_ISR(void) 
.................... {  
.................... ////////    // TESTING Start 
.................... ////////#ifdef M1_COMM_MODULE 
.................... ////////    //output_toggle(PIN_IN_EXT_DI_00); 
.................... ////////#else 
.................... ////////    output_toggle(PIN_A5); 
.................... ////////#endif 
.................... ////////    // TESTING End 
....................      
....................     // Increment Rx Bit Counter for each received bit. 
....................    	g_ui8IBCRcvBitCount++; 
.................... 	 
....................     // Check Rx Bit Counter and read Bits 
....................     switch(g_ui8IBCRcvBitCount) 
....................     { 
....................         case 1: // Sequence Bit 0  
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8SeqBit0 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 2: // Sequence Bit 1 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8SeqBit1 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 3: // Sequence Bit 2 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8SeqBit2 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 4: // Data Bit Bit 0 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit0 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 5: // Bit 4 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit1 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 6: // Bit 5 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit2 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 7: // Bit 6 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit3 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 8: // Bit 7 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit4 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................          	set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................          	clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................              
....................              
....................         case 9: // Bit 8 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit5 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_1_BT_CUSTOMISED_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 10: // Bit 9 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit6 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_1_BT_CUSTOMISED_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 11: // Bit 10 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit7 = input(PIN_IBC_RCV); 
....................              
....................             // We have received all data so now we can release Timer0 Critical Run 
....................             g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
....................              
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_1_BT_CUSTOMISED_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................              
....................         case 12: // STOP Bit 
....................             // Check if the Stop Bit is High. 
....................             if(1 == input(PIN_IBC_RCV)) // Stop bit detected 
....................             { 
....................                 // Byte received successfully 
....................                 // Save received byte to the Message Array 1 
....................                 //g_arruiIBCRxMsg1[g_uiIBCRxByteCount1 - 1] = g_unTempRxData1.m_uiByte; 
....................             } 
....................             else 
....................             {  
....................                 // Handle error. 
....................                 // Framing error. 
....................                 // Set Flag tracking Framing Error. 
....................                 //g_uiIBCRxFramingErr1 = 1; 
....................                 //g_uiIBCSTXReceived1  = 0; 
....................             } 
....................             // Disable Timer1. 
....................             setup_timer_1 (T1_DISABLED); 
....................             disable_interrupts(INT_TIMER1);  
....................             // Clear Timer1 interrupt. 
....................             clear_interrupt(INT_TIMER1);  
....................   
....................              
....................             g_i8RcvByteCount++; 
....................             if (5 == g_i8RcvByteCount) 
....................             { 
....................                 g_i8RcvByteCount = 0; 
....................             } 
....................             // Now check the Byte Sequence 
....................             g_stIBCRcvData.g_ui8ArrIBCData[g_unIBCRcvByteNode.m_ui8Arr[0]] = g_unIBCRcvByteNode.m_ui8Arr[1]; 
....................              
....................             if ((IBC_MSG_BYTE_COUNT - 1) == g_unIBCRcvByteNode.m_ui8Arr[0]) 
....................             { 
....................                 // The complete 5 byte data has been received 
....................                 // Now we can process the data 
....................                 g_fIBCDataReceived = 1; 
....................                  
....................                 // Insert Message into IBC Receive Queue 
.................... ////////                InsertIBCMsgQueue(&g_stIBCRcvQueue, &g_stIBCRcvData);   
....................             } 
....................             // Reset Rx Bit Counter. 
....................             g_ui8IBCRcvBitCount = 0; 
....................              
....................             // Enable External Interrupt to detect next byte. 
.................... #ifdef M1_COMM_MODULE 
....................             ext_int_edge(1, H_TO_L);  
....................             clear_interrupt(INT_EXT1); 
....................             enable_interrupts(INT_EXT1); 
.................... #else 
....................             ext_int_edge(3, H_TO_L);  
....................             clear_interrupt(INT_EXT3); 
....................             enable_interrupts(INT_EXT3); 
.................... #endif 
....................             break; 
....................  
....................         default: 
....................             // Framing error. 
....................             // Set Flag tracking Framing Error. 
....................             //g_uiIBCRxFramingErr1 = 1; 
....................              
....................             // First release Timer0 Critical run lock 
....................             g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
....................              
....................             // Disable Timer1. 
....................             setup_timer_1 (T1_DISABLED); 
....................             disable_interrupts(INT_TIMER1);  
....................             // Clear Timer1 interrupt. 
....................             clear_interrupt(INT_TIMER1);  
....................              
....................             // Reset Rx Bit Counter 1. 
....................             g_ui8IBCRcvBitCount = 0; 
....................              
....................             // Enable External Interrupt 0 to detect next start bit. 
....................             ext_int_edge(1, H_TO_L);  
....................             clear_interrupt(INT_EXT1); 
....................             enable_interrupts(INT_EXT1); 
....................             break; 
....................     } 
....................      
.................... } 
....................  
....................  
....................  
.................... #endif /* _VI_IBC_CONFIG_H_ */ 
....................  
.................... #include "vmIBCProcessM1.h" 
.................... /*  
....................  * File:   vmIBCProcessM1.h 
....................  * Author: Mrinmoy 
....................  * 
....................  * Created on December 11, 2018, 3:11 PM 
....................  */ 
....................  
.................... #ifndef VM_IBC_PROCESS_M1_H 
.................... #define	VM_IBC_PROCESS_M1_H 
....................  
.................... #include "../Common/vmIBCConfig.h" 
.................... #ifndef _VI_IBC_CONFIG_H_ 
.................... #define _VI_IBC_CONFIG_H_ 
....................  
.................... #include "vmSystemConfig.h" 
.................... #include "vmCRCConfig.h" 
.................... #include "vmDigitalIOConfig.h" 
.................... //#include "ctype.h" 
.................... #include "vmPINConfig.h" 
.................... #include "vmIBCGlobal.h" 
....................  
.................... #define IBC_MSG_BYTE_COUNT                       5 
.................... #define IBC_DATA_BITS_LENGTH                     10 
.................... #define IBC_DATA_BYTES_LENGTH                    10 
.................... #define IBC_BOARD_ID                             1 
....................  
.................... #define IBC_BAUD_RATE_9600                       20 
.................... #define IBC_BAUD_RATE_19200                      21 
....................  
.................... #define T1_DIV_PRESCALE                          T1_DIV_BY_8 
.................... #define T3_DIV_PRESCALE                          T3_DIV_BY_8 
....................  
.................... #define IBC_TX_1_BT_LOAD_VALUE_9600              (0xFFFF - 0x0041 + 1) 
.................... #define IBC_TX_1_BT_LOAD_VALUE_19200             (0xFFFF - 0x0021 + 1) 
....................  
.................... #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL_9600       (0xFFFF - 0x0062 + 1) // For 9600 
.................... #define IBC_RX_BIT_TIME_T1LOAD_VAL_9600           (0xFFFF - 0x0041 + 1) // For 9600 
....................  
.................... #ifdef M1_COMM_MODULE 
....................     #define IBC_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)  // 78us Instead of 104us we load 91.2 for per bit time. 
.................... #else 
....................     #define IBC_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)//   IBC_RX_BIT_TIME_T1LOAD_VAL_9600  // 104 us 
.................... #endif 
.................... //#define IBC_RX_1_BT_CUSTOMISED_VAL_9600           (0xFFFF - 0x0031 + 1)  // Instead of 104us we load 78 us for per bit time. 
.................... #define IBC_RX_BIT_TIME_1_2_T1LOAD_VAL_9600       (0xFFFF - 0x004E + 1) 
.................... #define IBC_RX_BIT_TIME_1_3_T1LOAD_VAL_9600       (0xFFFF - 0x0051 + 1) 
.................... #define IBC_RX_BIT_TIME_1_4_T1LOAD_VAL_9600       (0xFFFF - 0x005B + 1) 
....................  
....................  
.................... #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL_19200     (0xFFFF - 0x0031 + 1) // For 19200 
.................... #define IBC_RX_BIT_TIME_T1LOAD_VAL_19200         (0xFFFF - 0x0041 + 1) // For 19200 
....................  
.................... #define SIZE_IBC_SEND_BYTE_SEGMENT                15  //1+3+8+3, 1 Start Bit, 3 Sequence Bits, 8 bits of Data and 3 Stop Bits; Total 15bits in one segment/ custised byte 
....................  
.................... #define IBC_TIMER_0_CRITICAL_ON                   0 
.................... #define IBC_TIMER_0_CRITICAL_OFF                  1 
....................  
.................... //***************************************************************************** 
.................... // Below -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
.................... typedef struct _ST_INT_BOARD_ALL_BITS 
.................... { 
....................     unsigned int8 m_ui1IBCRcvbit_0: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_1: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_2: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_3: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_4: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_5: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_6: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_7: 1; 
.................... } ST_INT_BOARD_ALL_BITS; 
....................  
.................... //typedef union _UN_INT_BOARD_BYTE_TYPE 
.................... //{ 
.................... //    unsigned int8          m_ui8Byte; 
.................... //    ST_INT_BOARD_ALL_BITS  m_stByte; 
.................... //    char				   m_chData;	 
.................... //} UN_INT_BOARD_BYTE_TYPE; 
....................  
.................... typedef struct _ST_INT_BOARD_DATA 
.................... { 
....................     char 			m_boardData[IBC_DATA_BITS_LENGTH]; 
....................     unsigned int8  	m_boardID; 
.................... } ST_INT_BOARD_DATA; 
....................  
....................  
.................... //***************************************************************************** 
.................... // Above -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Interboard Communication  RX #  From M1_COMM ********************** 
.................... //***************************************************************************** 
....................  
.................... // Below -> Multiple Baud Rate Settings. 
....................  
.................... #ifdef IBC_BOUD_RATE_1000 
....................     #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL   (0xFFFF - 0x0EA6 + 1) 
....................     #define IBC_RX_BIT_TIME_T1LOAD_VAL       (0xFFFF - 0x09C4 + 1) 
.................... #endif 
....................  
.................... #ifdef IBC_BOUD_RATE_9600 
....................     #define IBC_RX_TIME_DELAY_1_5_BIT           156  
....................     #define IBC_RX_TIME_DELAY_1_BIT             104 
....................     #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL   (0xFFFF - 0x0062 + 1) 
....................     #define IBC_RX_BIT_TIME_T1LOAD_VAL       (0xFFFF - 0x0041 + 1) 
.................... #endif 
....................  
.................... #ifdef IBC_BOUD_RATE_19200 
....................     #define IBC_RX_TIME_DELAY_1_5_VAL           78  
....................     #define IBC_RX_TIME_DELAY_1_VAL             52 
....................     #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL   (0xFFFF - 0x0031 + 1) 
....................     #define IBC_RX_BIT_TIME_T1LOAD_VAL       (0xFFFF - 0x0021 + 1) 
.................... #endif 
....................  
.................... // Above -> Multiple Baud Rate Settings. 
....................  
.................... // Initialize IBC Data Set, Should be called from main()) 
.................... //void InitIBCDataSet() 
.................... //{ 
.................... //    g_unTempRxData1.m_uiByte = 0; 
.................... //} 
....................  
.................... typedef struct _ST_IBC_RCV_BYTE_NODE 
.................... { 
....................  
....................     unsigned int8 m_ui8SeqBit0 :1; 
....................     unsigned int8 m_ui8SeqBit1 :1; 
....................     unsigned int8 m_ui8SeqBit2 :1; 
....................     unsigned int8 m_ui8Padding :5; 
....................      
....................     unsigned int8 m_ui8DataBit0 :1; 
....................     unsigned int8 m_ui8DataBit1 :1; 
....................     unsigned int8 m_ui8DataBit2 :1; 
....................     unsigned int8 m_ui8DataBit3 :1; 
....................     unsigned int8 m_ui8DataBit4 :1; 
....................     unsigned int8 m_ui8DataBit5 :1; 
....................     unsigned int8 m_ui8DataBit6 :1; 
....................     unsigned int8 m_ui8DataBit7 :1; 
.................... } ST_IBC_RCV_BYTE_NODE; 
....................  
.................... typedef union _UN_IBC_RCV_BYTE_NODE 
.................... { 
....................     ST_IBC_RCV_BYTE_NODE m_stIBCNode; 
....................     unsigned int8        m_ui8Arr[2]; 
.................... } UN_IBC_RCV_BYTE_NODE; 
....................  
....................  
....................  
.................... typedef struct _ST_IBC_DATA_NODE 
.................... { 
....................     unsigned int8 g_ui8ArrIBCData[IBC_MSG_BYTE_COUNT]; 
.................... } ST_IBC_DATA_NODE; 
....................  
.................... #define SIZE_IBC_DATA_SEND_QUEUE 15 
....................  
.................... //typedef struct _ST_IBC_DATA_SEND_QUEUE 
.................... //{ 
.................... //    ST_IBC_DATA_NODE m_stArrIBCDataNode[SIZE_IBC_DATA_SEND_QUEUE]; 
.................... //    int8             m_i8Front; 
.................... //    int8             m_i8Rear; 
.................... //} ST_IBC_DATA_SEND_QUEUE; 
....................  
.................... typedef struct _ST_IBC_MSG_QUEUE 
.................... { 
....................     ST_IBC_DATA_NODE m_stArrIBCDataNode[SIZE_IBC_DATA_SEND_QUEUE]; 
....................     int8             m_i8Front; 
....................     int8             m_i8Rear; 
.................... } ST_IBC_MSG_QUEUE; 
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... //UN_INT_BOARD_BYTE_TYPE    g_unIBCRcvData; 
.................... unsigned int8             g_ui8IBCRcvBitCount = 0; 
.................... unsigned int8             g_ui8IBCTxBitCount  = 0; 
....................  
.................... // TESTING 
.................... unsigned int8             g_ui8IBCDataToSend = 0xA5; 
.................... unsigned int8             g_fIBCCommStatus   = 0; 
....................  
.................... ST_IBC_DATA_NODE          g_stIBCRcvData; 
.................... ST_IBC_DATA_NODE          g_stIBCSendData; 
.................... unsigned int8             g_ui8ArrSendSingleMSG[IBC_MSG_BYTE_COUNT*(SIZE_IBC_SEND_BYTE_SEGMENT)] = {0}; // 
.................... unsigned int8             g_fIBCDataReceived = 0; 
....................  
.................... //ST_IBC_DATA_SEND_QUEUE    g_stIBCDataSendQueue; 
.................... unsigned int8             g_fIBCSendBusy = 0; 
.................... UN_IBC_RCV_BYTE_NODE      g_unIBCRcvByteNode; 
....................  
.................... ST_IBC_MSG_QUEUE          g_stIBCSendQueue; 
.................... ST_IBC_MSG_QUEUE          g_stIBCRcvQueue; 
....................  
.................... unsigned int8             g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... ////////// 
.................... //////////void InitializeDataSendQueue() 
.................... //////////{ 
.................... //////////    int iLoopCount1 = 0; 
.................... //////////    int iLoopCount2 = 0; 
.................... //////////    g_stIBCDataSendQueue.m_i8Front = g_stIBCDataSendQueue.m_i8Rear = -1; 
.................... //////////     
.................... //////////    for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBC_DATA_SEND_QUEUE; iLoopCount1++) 
.................... //////////    { 
.................... //////////        for (iLoopCount2 = 0; iLoopCount2 < IBC_MSG_BYTE_COUNT; iLoopCount2++) 
.................... //////////        { 
.................... //////////           g_stIBCDataSendQueue.m_stArrIBCDataNode[iLoopCount1].g_ui8ArrIBCData[iLoopCount2] = 0; 
.................... //////////        } 
.................... //////////    } 
.................... //////////} 
.................... ////////// 
.................... //////////void CopySendData(int8 i8Location, ST_IBC_DATA_NODE* pstIBCData) 
.................... //////////{ 
.................... //////////    int8 i8LoopCount = 0; 
.................... //////////     
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        g_stIBCDataSendQueue.m_stArrIBCDataNode[i8Location].g_ui8ArrIBCData[i8LoopCount] = pstIBCData->g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////    } 
.................... //////////} 
.................... ////////// 
.................... //////////void CopyFromSendQueue(int8 i8Location, ST_IBC_DATA_NODE** ppstIBCData) 
.................... //////////{ 
.................... //////////    int8 i8LoopCount = 0; 
.................... //////////     
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        *ppstIBCData->g_ui8ArrIBCData[i8LoopCount] = g_stIBCDataSendQueue.m_stArrIBCDataNode[i8Location].g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////    } 
.................... //////////} 
.................... /* Function to create Circular queue */ 
.................... //////////void InsertSendQueue(ST_IBC_DATA_NODE* pstIBCData)  
.................... //////////{ 
.................... //////////    if (!pstIBCData) 
.................... //////////    { 
.................... //////////        return; 
.................... //////////    } 
.................... //////////     
.................... //////////    if ((g_stIBCDataSendQueue.m_i8Front == 0 && g_stIBCDataSendQueue.m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1) ||  
.................... //////////            (g_stIBCDataSendQueue.m_i8Front == g_stIBCDataSendQueue.m_i8Rear + 1))  
.................... //////////    {  
.................... //////////        //printf("\nQueue is Full");  
.................... //////////        return;  
.................... //////////    } 
.................... //////////   
.................... //////////    else if (g_stIBCDataSendQueue.m_i8Front == -1) /* Insert First Element */ 
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Front = g_stIBCDataSendQueue.m_i8Rear = 0; 
.................... //////////         
.................... //////////        // Insert Data 
.................... //////////        //arr[g_stIBCDataSendQueue.m_i8Rear] = value; 
.................... //////////        CopySendData(g_stIBCDataSendQueue.m_i8Rear, pstIBCData); 
.................... //////////    }  
.................... //////////   
.................... //////////    else if (g_stIBCDataSendQueue.m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1 && g_stIBCDataSendQueue.m_i8Front != 0)  
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Rear = 0;  
.................... //////////        CopySendData(g_stIBCDataSendQueue.m_i8Rear, pstIBCData);  
.................... //////////    }  
.................... //////////   
.................... //////////    else 
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Rear++;  
.................... //////////        CopySendData(g_stIBCDataSendQueue.m_i8Rear, pstIBCData); 
.................... //////////    }  
.................... //////////}  
....................  
.................... //////////void DeleteQueue(ST_IBC_DATA_NODE* pstIBCData)  
.................... //////////{  
.................... //////////    int8 i8LoopCount = 0; 
.................... ////////// 
.................... //////////    if (g_stIBCDataSendQueue.m_i8Front == -1) 
.................... //////////    {  
.................... //////////        //printf("\nQueue is Empty");  
.................... //////////        return;  
.................... //////////    }  
.................... //////////   
.................... //////////    //int data = arr[g_stIBCDataSendQueue.m_i8Front]; 
.................... //////////    //CopyFromSendQueue(g_stIBCDataSendQueue.m_i8Front, &pstIBCData); 
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        pstIBCData->g_ui8ArrIBCData[i8LoopCount] = g_stIBCDataSendQueue.m_stArrIBCDataNode[g_stIBCDataSendQueue.m_i8Front].g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////    } 
.................... //////////     
.................... //////////    //arr[g_stIBCDataSendQueue.m_i8Front] = -1;  
.................... //////////    if (g_stIBCDataSendQueue.m_i8Front == g_stIBCDataSendQueue.m_i8Rear)  
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Front = -1;  
.................... //////////        g_stIBCDataSendQueue.m_i8Rear = -1;  
.................... //////////    }  
.................... //////////    else if (g_stIBCDataSendQueue.m_i8Front == SIZE_IBC_DATA_SEND_QUEUE-1)  
.................... //////////        g_stIBCDataSendQueue.m_i8Front = 0;  
.................... //////////    else 
.................... //////////        g_stIBCDataSendQueue.m_i8Front++;  
.................... //////////   
.................... //////////    return; 
.................... //////////}  
.................... ////////// 
.................... //////////int8 IsMSGAvailableInIBCSendQueue() 
.................... //////////{ 
.................... //////////    if (g_stIBCDataSendQueue.m_i8Front == -1) 
.................... //////////    { 
.................... //////////        return 0; 
.................... //////////    } 
.................... //////////     
.................... //////////    return 1; 
.................... //////////} 
.................... ////////// 
.................... //////////void SendIBCMSG() 
.................... //////////{ 
.................... //////////    int8          i8LoopCount    = 0; 
.................... //////////    unsigned int8 ui8Sequence    = 0; 
.................... //////////    unsigned int8 ui8TempData    = 0; 
.................... //////////     
.................... //////////    // Initialize the Send Array 
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount] = 0; 
.................... //////////    } 
.................... ////////// 
.................... //////////    // Get Node from Queue 
.................... //////////    DeleteQueue(&g_stIBCSendData); 
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        // Step 1: First Stuff 1 Start Bit 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 0] = 0;   // Start Bit Always 0 
.................... //////////         
.................... //////////        // Step 2: Now Stuff 3 bit Message Byte Sequence Number 
.................... //////////         
.................... //////////        // Stuff the 1st Sequence Bit 
.................... //////////        ui8Sequence = i8LoopCount; 
.................... //////////        ui8Sequence = ui8Sequence << 7; 
.................... //////////        ui8Sequence = ui8Sequence >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 1] = ui8Sequence; 
.................... //////////         
.................... //////////        // Stuff the 2nd Sequence Bit  
.................... //////////        ui8Sequence = i8LoopCount; 
.................... //////////        ui8Sequence = ui8Sequence << 6; 
.................... //////////        ui8Sequence = ui8Sequence >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 2] = ui8Sequence; 
.................... //////////         
.................... //////////        // Stuff the 3rd Bit 
.................... //////////        ui8Sequence = i8LoopCount; 
.................... //////////        ui8Sequence = ui8Sequence << 5; 
.................... //////////        ui8Sequence = ui8Sequence >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 3] = ui8Sequence; 
.................... //////////         
.................... //////////        // Step 3: Now Stuff 8 bit Data 
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 7; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 4] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 6; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 5] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 5; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 6] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 4; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 7] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 3; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 8] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 2; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 9] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 1; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 10] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 11] = ui8TempData; 
.................... //////////         
.................... //////////        // Step 4: Stuff three Stop Bits 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 12] = 1;  // Stop bit is 1 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 13] = 1; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 14] = 1; 
.................... //////////    } 
.................... //////////     
.................... //////////    // So message stuffing is done now start the send timer 
.................... //////////    // Initialize send counter. 
.................... //////////    g_ui8IBCTxBitCount = 0; 
.................... //////////     
.................... //////////    // TESTING Start 
.................... ////////////    g_ui8ArrSendSingleMSG[0] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[1] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[2] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[3] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[4] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[5] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[6] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[7] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[8] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[9] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[10] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[11] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[12] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[13] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[14] = 1;     
.................... //////////    // TESTING End 
.................... //////////     
.................... //////////    // Start Timer3 that handle bit by bit sending. 
.................... //////////    // Set Timer3 as per Bit Time Value. 
.................... //////////    setup_timer_3(T3_INTERNAL | T3_DIV_PRESCALE); 
.................... //////////    set_timer3(IBC_TX_1_BT_LOAD_VALUE_9600); 
.................... //////////     
.................... //////////    clear_interrupt(INT_TIMER3); 
.................... //////////    enable_interrupts(INT_TIMER3); 
.................... //////////} 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving START /////////////// 
....................  
.................... void InitializeDataQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue) 
.................... { 
....................     int iLoopCount1 = 0; 
....................     int iLoopCount2 = 0; 
....................     pstIBCMSGQueue->m_i8Front = pstIBCMSGQueue->m_i8Rear = -1; 
....................      
....................     for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBC_DATA_SEND_QUEUE; iLoopCount1++) 
....................     { 
....................         for (iLoopCount2 = 0; iLoopCount2 < IBC_MSG_BYTE_COUNT; iLoopCount2++) 
....................         { 
....................            pstIBCMSGQueue->m_stArrIBCDataNode[iLoopCount1].g_ui8ArrIBCData[iLoopCount2] = 0; 
....................         } 
....................     } 
.................... } 
....................  
.................... void CopyIBCMsg(ST_IBC_DATA_NODE* pstIBCSource, ST_IBC_DATA_NODE* pstIBCDDest) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................      
....................     for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         pstIBCDDest->g_ui8ArrIBCData[i8LoopCount] = pstIBCSource->g_ui8ArrIBCData[i8LoopCount]; 
....................     } 
.................... } 
....................  
.................... /* Function to create Circular queue */ 
.................... void InsertIBCMsgQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue, ST_IBC_DATA_NODE* pstIBCData)  
.................... { 
....................     if (!pstIBCData) 
....................     { 
....................         return; 
....................     } 
....................      
....................     if ((pstIBCMSGQueue->m_i8Front == 0 && pstIBCMSGQueue->m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1) ||  
....................             (pstIBCMSGQueue->m_i8Rear == (pstIBCMSGQueue->m_i8Front-1)%(SIZE_IBC_DATA_SEND_QUEUE-1)))  
....................     {  
....................         //printf("\nQueue is Full");  
....................         return; 
....................     } 
....................    
....................     else if (pstIBCMSGQueue->m_i8Front == -1) /* Insert First Element */ 
....................     {  
....................         pstIBCMSGQueue->m_i8Front = pstIBCMSGQueue->m_i8Rear = 0; 
....................          
....................         // Insert Data 
....................         //arr[g_stIBCDataSendQueue.m_i8Rear] = value; 
....................         CopyIBCMsg(pstIBCData, &(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else if (pstIBCMSGQueue->m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1 && pstIBCMSGQueue->m_i8Front != 0)  
....................     {  
....................         pstIBCMSGQueue->m_i8Rear = 0;  
....................         CopyIBCMsg(pstIBCData, &(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else 
....................     {  
....................         pstIBCMSGQueue->m_i8Rear++;  
....................         CopyIBCMsg(pstIBCData, &(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Rear])); 
....................     }  
.................... }  
....................  
.................... void DeleteIBCMsgQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue, ST_IBC_DATA_NODE* pstIBCData)  
.................... { 
....................     if (pstIBCMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBCMsg(&(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Front]), pstIBCData); 
....................  
....................     if (pstIBCMSGQueue->m_i8Front == pstIBCMSGQueue->m_i8Rear)  
....................     {  
....................         pstIBCMSGQueue->m_i8Front = -1;  
....................         pstIBCMSGQueue->m_i8Rear = -1;  
....................     }  
....................     else if (pstIBCMSGQueue->m_i8Front == SIZE_IBC_DATA_SEND_QUEUE-1)  
....................         pstIBCMSGQueue->m_i8Front = 0;  
....................     else 
....................         pstIBCMSGQueue->m_i8Front++;  
....................    
....................     return; 
.................... } 
....................  
....................  
.................... int8 IsMSGInIBCQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue) 
.................... { 
....................     if (pstIBCMSGQueue->m_i8Front == -1) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................     return 1; 
.................... } 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving END ///////////////// 
.................... void SendIBCMSGFromQ() 
.................... { 
....................     int8          i8LoopCount    = 0; 
....................     unsigned int8 ui8Sequence    = 0; 
....................     unsigned int8 ui8TempData    = 0; 
....................  
....................     // Initialize the Send Array 
....................     for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount] = 0; 
....................     } 
....................  
....................     // Get Node from Queue 
....................     DeleteIBCMsgQueue(&g_stIBCSendQueue, &g_stIBCSendData); 
....................     for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         // Step 1: First Stuff 1 Start Bit 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 0] = 0;   // Start Bit Always 0 
....................          
....................         // Step 2: Now Stuff 3 bit Message Byte Sequence Number 
....................          
....................         // Stuff the 1st Sequence Bit 
....................         ui8Sequence = i8LoopCount; 
....................         ui8Sequence = ui8Sequence << 7; 
....................         ui8Sequence = ui8Sequence >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 1] = ui8Sequence; 
....................          
....................         // Stuff the 2nd Sequence Bit  
....................         ui8Sequence = i8LoopCount; 
....................         ui8Sequence = ui8Sequence << 6; 
....................         ui8Sequence = ui8Sequence >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 2] = ui8Sequence; 
....................          
....................         // Stuff the 3rd Bit 
....................         ui8Sequence = i8LoopCount; 
....................         ui8Sequence = ui8Sequence << 5; 
....................         ui8Sequence = ui8Sequence >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 3] = ui8Sequence; 
....................          
....................         // Step 3: Now Stuff 8 bit Data 
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 7; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 4] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 6; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 5] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 5; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 6] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 4; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 7] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 3; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 8] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 2; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 9] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 1; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 10] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 11] = ui8TempData; 
....................          
....................         // Step 4: Stuff three Stop Bits 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 12] = 1;  // Stop bit is 1 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 13] = 1; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 14] = 1; 
....................          
.................... ////////        // TESTING Start 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 0] = 0;   
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 1] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 2] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 3] = 1;  
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 4] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 5] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 6] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 7] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 8] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 9] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 10] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 11] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 12] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 13] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 14] = 1; 
.................... ////////        // TESTING End 
....................     } 
....................      
....................      
.................... ////    // TESTING Start 
.................... ////    g_ui8ArrSendSingleMSG[0] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[1] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[2] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[3] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[4] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[5] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[6] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[7] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[8] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[9] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[10] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[11] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[12] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[13] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[14] = 1;     
.................... ////    // TESTING End 
....................          
....................     // So message stuffing is done now start the send timer 
....................     // Initialize send counter. 
....................     g_ui8IBCTxBitCount = 0; 
....................      
....................     // Hold the IBC Send Lock 
....................     g_fIBCSendLockStatus = IBC_SEND_LOCK; 
....................     // Start Timer3 that handle bit by bit sending. 
....................     // Set Timer3 as per Bit Time Value. 
....................     setup_timer_3(T3_INTERNAL | T3_DIV_PRESCALE); 
....................     set_timer3(IBC_TX_1_BT_LOAD_VALUE_9600); 
....................      
....................     // Before Sending Data in IBC Run Timer0 in Time Critical. This we are doing 
....................     // just because we have seen the IBC Send Receive is affecting while Timer 0 
....................     // is executing, hence the IBC data send receive is not sampled at proper time 
....................     g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_ON; 
....................      
....................     clear_interrupt(INT_TIMER3); 
....................     enable_interrupts(INT_TIMER3); 
.................... } 
....................  
.................... void IBCProcessRcvMsg() 
.................... { 
....................     // I 
.................... } 
....................  
.................... #INT_TIMER3    // Used for IBC Send 
.................... void IBC_Tx_ISR(void) 
.................... { 
....................     // Send IBC bits 
....................     output_bit(PIN_IBC_XMIT, g_ui8ArrSendSingleMSG[g_ui8IBCTxBitCount++]); 
....................     // Reset Timer3 at 1Bit Time value. 
....................     set_timer3(IBC_TX_1_BT_LOAD_VALUE_9600); 
....................     clear_interrupt( INT_TIMER3 ); 
....................  
....................     // Check if IBC Sending completed 
....................     if ((IBC_MSG_BYTE_COUNT*SIZE_IBC_SEND_BYTE_SEGMENT) == g_ui8IBCTxBitCount) 
....................     { 
....................         // First release Timer0 Critical run lock 
....................         g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
....................          
....................         // Release Send Busy status 
....................         g_fIBCSendBusy     = 0; 
....................          
....................         // Send Stop bit forever 
....................         output_bit(PIN_IBC_XMIT, 1); 
....................  
....................         // Reset Tx counter 
....................         g_ui8IBCTxBitCount = 0; 
....................         // Reset IBC Send checking status flag. 
....................         //g_fIBCCommStatus = 0; 
....................         // Disable Timer 
....................         setup_timer_3 (T3_DISABLED); 
....................         disable_interrupts(INT_TIMER3); 
....................         // Clear Timer1 interrupt 
....................         clear_interrupt(INT_TIMER3); 
....................          
....................         // Release IBC Send Lock 
....................         g_fIBCSendLockStatus = IBC_SEND_UNLOCK; 
....................     } 
....................      
....................     // TESTING 
....................     //output_toggle(PIN_IN_EXT_DI_00); 
....................   
.................... } 
....................  
....................  
....................  
.................... /* 
....................     Timer1 is used to handle IBC Received bytes. 
....................  and Timer3 is used to handle IBC sent bytes. 
....................  */ 
.................... #ifdef M1_COMM_MODULE 
.................... #INT_EXT1  
.................... #else 
.................... #INT_EXT3 
.................... #endif 
.................... void IBC_Rx_ISR(void) 
.................... { 
....................    
....................     // Initialize Rx Bit Counter. 
....................    	g_ui8IBCRcvBitCount = 0; 
....................     g_unIBCRcvByteNode.m_ui8Arr[0] = 0; 
....................     g_unIBCRcvByteNode.m_ui8Arr[1] = 0; 
....................    	 
....................     // Setup Timer1 at 1.5 Bit Time.                   // Here we are using DIV_BY_8. 
....................     setup_timer_1( T1_INTERNAL | T1_DIV_PRESCALE ); // CPU Ext Clock is 20MHz, 20/4 => 5MHz is Peripheral Clock 
....................                                                 // => T1_DIV_BY_2 => 5/2 = 2.5MHz => (1/2.5)us = 0.4us 
....................                                                 // To Get 1Ms quanta = (1000us/0.4) = 2500 => 0x09C4 
....................                                                 // So, The timer will start counting from (0xFFFF - 0x09C4 + 1) 
....................                                                 // To Get 1.5Ms quanta = (1500us/0.4) = 3750 => 0x0EA6 
....................                                                 // So, The timer will start counting from (0xFFFF - 0x0EA6 + 1)  
....................      
.................... #ifdef M1_COMM_MODULE 
....................     set_timer1( IBC_RX_BIT_TIME_1_4_T1LOAD_VAL_9600);  
.................... #else 
....................     set_timer1( IBC_RX_BIT_TIME_1_5_T1LOAD_VAL_9600); 
.................... #endif 
....................      
....................     // Before Sending Data in IBC Run Timer0 in Time Critical. This we are doing 
....................     // just because we have seen the IBC Send Receive is affecting while Timer 0 
....................     // is executing, hence the IBC data send receive is not sampled at proper time 
....................     g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_ON; 
....................      
....................     clear_interrupt( INT_TIMER1 ); 
....................     enable_interrupts( INT_TIMER1 ); 
....................      
....................     // Clear and Disable External Interrupt 1  
.................... #ifdef M1_COMM_MODULE 
....................     clear_interrupt(INT_EXT1); 
....................     disable_interrupts(INT_EXT1);  
.................... #else 
....................     clear_interrupt(INT_EXT3); 
....................     disable_interrupts(INT_EXT3); 
.................... #endif 
....................      
....................     // TESTING Start 
.................... #ifdef M1_COMM_MODULE 
....................     //output_high(PIN_IN_EXT_DI_00); 
.................... #endif 
....................     // TESTING End 
.................... } 
....................  
.................... // TESTING Start 
.................... int8 g_i8RcvByteCount = 0; 
.................... // TESTING End 
....................  
.................... #INT_TIMER1           // This is for Receive                 
.................... void IBC_Rx_Sampling_ISR(void) 
.................... {  
.................... ////////    // TESTING Start 
.................... ////////#ifdef M1_COMM_MODULE 
.................... ////////    //output_toggle(PIN_IN_EXT_DI_00); 
.................... ////////#else 
.................... ////////    output_toggle(PIN_A5); 
.................... ////////#endif 
.................... ////////    // TESTING End 
....................      
....................     // Increment Rx Bit Counter for each received bit. 
....................    	g_ui8IBCRcvBitCount++; 
.................... 	 
....................     // Check Rx Bit Counter and read Bits 
....................     switch(g_ui8IBCRcvBitCount) 
....................     { 
....................         case 1: // Sequence Bit 0  
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8SeqBit0 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 2: // Sequence Bit 1 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8SeqBit1 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 3: // Sequence Bit 2 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8SeqBit2 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 4: // Data Bit Bit 0 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit0 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 5: // Bit 4 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit1 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 6: // Bit 5 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit2 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 7: // Bit 6 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit3 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 8: // Bit 7 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit4 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................          	set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................          	clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................              
....................              
....................         case 9: // Bit 8 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit5 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_1_BT_CUSTOMISED_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 10: // Bit 9 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit6 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_1_BT_CUSTOMISED_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 11: // Bit 10 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit7 = input(PIN_IBC_RCV); 
....................              
....................             // We have received all data so now we can release Timer0 Critical Run 
....................             g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
....................              
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_1_BT_CUSTOMISED_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................              
....................         case 12: // STOP Bit 
....................             // Check if the Stop Bit is High. 
....................             if(1 == input(PIN_IBC_RCV)) // Stop bit detected 
....................             { 
....................                 // Byte received successfully 
....................                 // Save received byte to the Message Array 1 
....................                 //g_arruiIBCRxMsg1[g_uiIBCRxByteCount1 - 1] = g_unTempRxData1.m_uiByte; 
....................             } 
....................             else 
....................             {  
....................                 // Handle error. 
....................                 // Framing error. 
....................                 // Set Flag tracking Framing Error. 
....................                 //g_uiIBCRxFramingErr1 = 1; 
....................                 //g_uiIBCSTXReceived1  = 0; 
....................             } 
....................             // Disable Timer1. 
....................             setup_timer_1 (T1_DISABLED); 
....................             disable_interrupts(INT_TIMER1);  
....................             // Clear Timer1 interrupt. 
....................             clear_interrupt(INT_TIMER1);  
....................   
....................              
....................             g_i8RcvByteCount++; 
....................             if (5 == g_i8RcvByteCount) 
....................             { 
....................                 g_i8RcvByteCount = 0; 
....................             } 
....................             // Now check the Byte Sequence 
....................             g_stIBCRcvData.g_ui8ArrIBCData[g_unIBCRcvByteNode.m_ui8Arr[0]] = g_unIBCRcvByteNode.m_ui8Arr[1]; 
....................              
....................             if ((IBC_MSG_BYTE_COUNT - 1) == g_unIBCRcvByteNode.m_ui8Arr[0]) 
....................             { 
....................                 // The complete 5 byte data has been received 
....................                 // Now we can process the data 
....................                 g_fIBCDataReceived = 1; 
....................                  
....................                 // Insert Message into IBC Receive Queue 
.................... ////////                InsertIBCMsgQueue(&g_stIBCRcvQueue, &g_stIBCRcvData);   
....................             } 
....................             // Reset Rx Bit Counter. 
....................             g_ui8IBCRcvBitCount = 0; 
....................              
....................             // Enable External Interrupt to detect next byte. 
.................... #ifdef M1_COMM_MODULE 
....................             ext_int_edge(1, H_TO_L);  
....................             clear_interrupt(INT_EXT1); 
....................             enable_interrupts(INT_EXT1); 
.................... #else 
....................             ext_int_edge(3, H_TO_L);  
....................             clear_interrupt(INT_EXT3); 
....................             enable_interrupts(INT_EXT3); 
.................... #endif 
....................             break; 
....................  
....................         default: 
....................             // Framing error. 
....................             // Set Flag tracking Framing Error. 
....................             //g_uiIBCRxFramingErr1 = 1; 
....................              
....................             // First release Timer0 Critical run lock 
....................             g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
....................              
....................             // Disable Timer1. 
....................             setup_timer_1 (T1_DISABLED); 
....................             disable_interrupts(INT_TIMER1);  
....................             // Clear Timer1 interrupt. 
....................             clear_interrupt(INT_TIMER1);  
....................              
....................             // Reset Rx Bit Counter 1. 
....................             g_ui8IBCRcvBitCount = 0; 
....................              
....................             // Enable External Interrupt 0 to detect next start bit. 
....................             ext_int_edge(1, H_TO_L);  
....................             clear_interrupt(INT_EXT1); 
....................             enable_interrupts(INT_EXT1); 
....................             break; 
....................     } 
....................      
.................... } 
....................  
....................  
....................  
.................... #endif /* _VI_IBC_CONFIG_H_ */ 
....................  
.................... #include "vmCalibrationConfig.h" 
.................... /*  
....................  * File:   vmCalibrationConfig.h 
....................  * Author: Mrinmoy 
....................  * 
....................  * Created on December 10, 2018, 7:32 PM 
....................  */ 
....................  
.................... #ifndef VM_CALIBRATION_CONFIG_H 
.................... #define	VM_CALIBRATION_CONFIG_H 
....................  
.................... #include "../Common/vmIBCConfig.h" 
.................... #ifndef _VI_IBC_CONFIG_H_ 
.................... #define _VI_IBC_CONFIG_H_ 
....................  
.................... #include "vmSystemConfig.h" 
.................... #include "vmCRCConfig.h" 
.................... #include "vmDigitalIOConfig.h" 
.................... //#include "ctype.h" 
.................... #include "vmPINConfig.h" 
.................... #include "vmIBCGlobal.h" 
....................  
.................... #define IBC_MSG_BYTE_COUNT                       5 
.................... #define IBC_DATA_BITS_LENGTH                     10 
.................... #define IBC_DATA_BYTES_LENGTH                    10 
.................... #define IBC_BOARD_ID                             1 
....................  
.................... #define IBC_BAUD_RATE_9600                       20 
.................... #define IBC_BAUD_RATE_19200                      21 
....................  
.................... #define T1_DIV_PRESCALE                          T1_DIV_BY_8 
.................... #define T3_DIV_PRESCALE                          T3_DIV_BY_8 
....................  
.................... #define IBC_TX_1_BT_LOAD_VALUE_9600              (0xFFFF - 0x0041 + 1) 
.................... #define IBC_TX_1_BT_LOAD_VALUE_19200             (0xFFFF - 0x0021 + 1) 
....................  
.................... #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL_9600       (0xFFFF - 0x0062 + 1) // For 9600 
.................... #define IBC_RX_BIT_TIME_T1LOAD_VAL_9600           (0xFFFF - 0x0041 + 1) // For 9600 
....................  
.................... #ifdef M1_COMM_MODULE 
....................     #define IBC_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)  // 78us Instead of 104us we load 91.2 for per bit time. 
.................... #else 
....................     #define IBC_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)//   IBC_RX_BIT_TIME_T1LOAD_VAL_9600  // 104 us 
.................... #endif 
.................... //#define IBC_RX_1_BT_CUSTOMISED_VAL_9600           (0xFFFF - 0x0031 + 1)  // Instead of 104us we load 78 us for per bit time. 
.................... #define IBC_RX_BIT_TIME_1_2_T1LOAD_VAL_9600       (0xFFFF - 0x004E + 1) 
.................... #define IBC_RX_BIT_TIME_1_3_T1LOAD_VAL_9600       (0xFFFF - 0x0051 + 1) 
.................... #define IBC_RX_BIT_TIME_1_4_T1LOAD_VAL_9600       (0xFFFF - 0x005B + 1) 
....................  
....................  
.................... #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL_19200     (0xFFFF - 0x0031 + 1) // For 19200 
.................... #define IBC_RX_BIT_TIME_T1LOAD_VAL_19200         (0xFFFF - 0x0041 + 1) // For 19200 
....................  
.................... #define SIZE_IBC_SEND_BYTE_SEGMENT                15  //1+3+8+3, 1 Start Bit, 3 Sequence Bits, 8 bits of Data and 3 Stop Bits; Total 15bits in one segment/ custised byte 
....................  
.................... #define IBC_TIMER_0_CRITICAL_ON                   0 
.................... #define IBC_TIMER_0_CRITICAL_OFF                  1 
....................  
.................... //***************************************************************************** 
.................... // Below -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
.................... typedef struct _ST_INT_BOARD_ALL_BITS 
.................... { 
....................     unsigned int8 m_ui1IBCRcvbit_0: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_1: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_2: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_3: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_4: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_5: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_6: 1; 
....................     unsigned int8 m_ui1IBCRcvbit_7: 1; 
.................... } ST_INT_BOARD_ALL_BITS; 
....................  
.................... //typedef union _UN_INT_BOARD_BYTE_TYPE 
.................... //{ 
.................... //    unsigned int8          m_ui8Byte; 
.................... //    ST_INT_BOARD_ALL_BITS  m_stByte; 
.................... //    char				   m_chData;	 
.................... //} UN_INT_BOARD_BYTE_TYPE; 
....................  
.................... typedef struct _ST_INT_BOARD_DATA 
.................... { 
....................     char 			m_boardData[IBC_DATA_BITS_LENGTH]; 
....................     unsigned int8  	m_boardID; 
.................... } ST_INT_BOARD_DATA; 
....................  
....................  
.................... //***************************************************************************** 
.................... // Above -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Interboard Communication  RX #  From M1_COMM ********************** 
.................... //***************************************************************************** 
....................  
.................... // Below -> Multiple Baud Rate Settings. 
....................  
.................... #ifdef IBC_BOUD_RATE_1000 
....................     #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL   (0xFFFF - 0x0EA6 + 1) 
....................     #define IBC_RX_BIT_TIME_T1LOAD_VAL       (0xFFFF - 0x09C4 + 1) 
.................... #endif 
....................  
.................... #ifdef IBC_BOUD_RATE_9600 
....................     #define IBC_RX_TIME_DELAY_1_5_BIT           156  
....................     #define IBC_RX_TIME_DELAY_1_BIT             104 
....................     #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL   (0xFFFF - 0x0062 + 1) 
....................     #define IBC_RX_BIT_TIME_T1LOAD_VAL       (0xFFFF - 0x0041 + 1) 
.................... #endif 
....................  
.................... #ifdef IBC_BOUD_RATE_19200 
....................     #define IBC_RX_TIME_DELAY_1_5_VAL           78  
....................     #define IBC_RX_TIME_DELAY_1_VAL             52 
....................     #define IBC_RX_BIT_TIME_1_5_T1LOAD_VAL   (0xFFFF - 0x0031 + 1) 
....................     #define IBC_RX_BIT_TIME_T1LOAD_VAL       (0xFFFF - 0x0021 + 1) 
.................... #endif 
....................  
.................... // Above -> Multiple Baud Rate Settings. 
....................  
.................... // Initialize IBC Data Set, Should be called from main()) 
.................... //void InitIBCDataSet() 
.................... //{ 
.................... //    g_unTempRxData1.m_uiByte = 0; 
.................... //} 
....................  
.................... typedef struct _ST_IBC_RCV_BYTE_NODE 
.................... { 
....................  
....................     unsigned int8 m_ui8SeqBit0 :1; 
....................     unsigned int8 m_ui8SeqBit1 :1; 
....................     unsigned int8 m_ui8SeqBit2 :1; 
....................     unsigned int8 m_ui8Padding :5; 
....................      
....................     unsigned int8 m_ui8DataBit0 :1; 
....................     unsigned int8 m_ui8DataBit1 :1; 
....................     unsigned int8 m_ui8DataBit2 :1; 
....................     unsigned int8 m_ui8DataBit3 :1; 
....................     unsigned int8 m_ui8DataBit4 :1; 
....................     unsigned int8 m_ui8DataBit5 :1; 
....................     unsigned int8 m_ui8DataBit6 :1; 
....................     unsigned int8 m_ui8DataBit7 :1; 
.................... } ST_IBC_RCV_BYTE_NODE; 
....................  
.................... typedef union _UN_IBC_RCV_BYTE_NODE 
.................... { 
....................     ST_IBC_RCV_BYTE_NODE m_stIBCNode; 
....................     unsigned int8        m_ui8Arr[2]; 
.................... } UN_IBC_RCV_BYTE_NODE; 
....................  
....................  
....................  
.................... typedef struct _ST_IBC_DATA_NODE 
.................... { 
....................     unsigned int8 g_ui8ArrIBCData[IBC_MSG_BYTE_COUNT]; 
.................... } ST_IBC_DATA_NODE; 
....................  
.................... #define SIZE_IBC_DATA_SEND_QUEUE 15 
....................  
.................... //typedef struct _ST_IBC_DATA_SEND_QUEUE 
.................... //{ 
.................... //    ST_IBC_DATA_NODE m_stArrIBCDataNode[SIZE_IBC_DATA_SEND_QUEUE]; 
.................... //    int8             m_i8Front; 
.................... //    int8             m_i8Rear; 
.................... //} ST_IBC_DATA_SEND_QUEUE; 
....................  
.................... typedef struct _ST_IBC_MSG_QUEUE 
.................... { 
....................     ST_IBC_DATA_NODE m_stArrIBCDataNode[SIZE_IBC_DATA_SEND_QUEUE]; 
....................     int8             m_i8Front; 
....................     int8             m_i8Rear; 
.................... } ST_IBC_MSG_QUEUE; 
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... //UN_INT_BOARD_BYTE_TYPE    g_unIBCRcvData; 
.................... unsigned int8             g_ui8IBCRcvBitCount = 0; 
.................... unsigned int8             g_ui8IBCTxBitCount  = 0; 
....................  
.................... // TESTING 
.................... unsigned int8             g_ui8IBCDataToSend = 0xA5; 
.................... unsigned int8             g_fIBCCommStatus   = 0; 
....................  
.................... ST_IBC_DATA_NODE          g_stIBCRcvData; 
.................... ST_IBC_DATA_NODE          g_stIBCSendData; 
.................... unsigned int8             g_ui8ArrSendSingleMSG[IBC_MSG_BYTE_COUNT*(SIZE_IBC_SEND_BYTE_SEGMENT)] = {0}; // 
.................... unsigned int8             g_fIBCDataReceived = 0; 
....................  
.................... //ST_IBC_DATA_SEND_QUEUE    g_stIBCDataSendQueue; 
.................... unsigned int8             g_fIBCSendBusy = 0; 
.................... UN_IBC_RCV_BYTE_NODE      g_unIBCRcvByteNode; 
....................  
.................... ST_IBC_MSG_QUEUE          g_stIBCSendQueue; 
.................... ST_IBC_MSG_QUEUE          g_stIBCRcvQueue; 
....................  
.................... unsigned int8             g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... ////////// 
.................... //////////void InitializeDataSendQueue() 
.................... //////////{ 
.................... //////////    int iLoopCount1 = 0; 
.................... //////////    int iLoopCount2 = 0; 
.................... //////////    g_stIBCDataSendQueue.m_i8Front = g_stIBCDataSendQueue.m_i8Rear = -1; 
.................... //////////     
.................... //////////    for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBC_DATA_SEND_QUEUE; iLoopCount1++) 
.................... //////////    { 
.................... //////////        for (iLoopCount2 = 0; iLoopCount2 < IBC_MSG_BYTE_COUNT; iLoopCount2++) 
.................... //////////        { 
.................... //////////           g_stIBCDataSendQueue.m_stArrIBCDataNode[iLoopCount1].g_ui8ArrIBCData[iLoopCount2] = 0; 
.................... //////////        } 
.................... //////////    } 
.................... //////////} 
.................... ////////// 
.................... //////////void CopySendData(int8 i8Location, ST_IBC_DATA_NODE* pstIBCData) 
.................... //////////{ 
.................... //////////    int8 i8LoopCount = 0; 
.................... //////////     
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        g_stIBCDataSendQueue.m_stArrIBCDataNode[i8Location].g_ui8ArrIBCData[i8LoopCount] = pstIBCData->g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////    } 
.................... //////////} 
.................... ////////// 
.................... //////////void CopyFromSendQueue(int8 i8Location, ST_IBC_DATA_NODE** ppstIBCData) 
.................... //////////{ 
.................... //////////    int8 i8LoopCount = 0; 
.................... //////////     
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        *ppstIBCData->g_ui8ArrIBCData[i8LoopCount] = g_stIBCDataSendQueue.m_stArrIBCDataNode[i8Location].g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////    } 
.................... //////////} 
.................... /* Function to create Circular queue */ 
.................... //////////void InsertSendQueue(ST_IBC_DATA_NODE* pstIBCData)  
.................... //////////{ 
.................... //////////    if (!pstIBCData) 
.................... //////////    { 
.................... //////////        return; 
.................... //////////    } 
.................... //////////     
.................... //////////    if ((g_stIBCDataSendQueue.m_i8Front == 0 && g_stIBCDataSendQueue.m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1) ||  
.................... //////////            (g_stIBCDataSendQueue.m_i8Front == g_stIBCDataSendQueue.m_i8Rear + 1))  
.................... //////////    {  
.................... //////////        //printf("\nQueue is Full");  
.................... //////////        return;  
.................... //////////    } 
.................... //////////   
.................... //////////    else if (g_stIBCDataSendQueue.m_i8Front == -1) /* Insert First Element */ 
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Front = g_stIBCDataSendQueue.m_i8Rear = 0; 
.................... //////////         
.................... //////////        // Insert Data 
.................... //////////        //arr[g_stIBCDataSendQueue.m_i8Rear] = value; 
.................... //////////        CopySendData(g_stIBCDataSendQueue.m_i8Rear, pstIBCData); 
.................... //////////    }  
.................... //////////   
.................... //////////    else if (g_stIBCDataSendQueue.m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1 && g_stIBCDataSendQueue.m_i8Front != 0)  
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Rear = 0;  
.................... //////////        CopySendData(g_stIBCDataSendQueue.m_i8Rear, pstIBCData);  
.................... //////////    }  
.................... //////////   
.................... //////////    else 
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Rear++;  
.................... //////////        CopySendData(g_stIBCDataSendQueue.m_i8Rear, pstIBCData); 
.................... //////////    }  
.................... //////////}  
....................  
.................... //////////void DeleteQueue(ST_IBC_DATA_NODE* pstIBCData)  
.................... //////////{  
.................... //////////    int8 i8LoopCount = 0; 
.................... ////////// 
.................... //////////    if (g_stIBCDataSendQueue.m_i8Front == -1) 
.................... //////////    {  
.................... //////////        //printf("\nQueue is Empty");  
.................... //////////        return;  
.................... //////////    }  
.................... //////////   
.................... //////////    //int data = arr[g_stIBCDataSendQueue.m_i8Front]; 
.................... //////////    //CopyFromSendQueue(g_stIBCDataSendQueue.m_i8Front, &pstIBCData); 
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        pstIBCData->g_ui8ArrIBCData[i8LoopCount] = g_stIBCDataSendQueue.m_stArrIBCDataNode[g_stIBCDataSendQueue.m_i8Front].g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////    } 
.................... //////////     
.................... //////////    //arr[g_stIBCDataSendQueue.m_i8Front] = -1;  
.................... //////////    if (g_stIBCDataSendQueue.m_i8Front == g_stIBCDataSendQueue.m_i8Rear)  
.................... //////////    {  
.................... //////////        g_stIBCDataSendQueue.m_i8Front = -1;  
.................... //////////        g_stIBCDataSendQueue.m_i8Rear = -1;  
.................... //////////    }  
.................... //////////    else if (g_stIBCDataSendQueue.m_i8Front == SIZE_IBC_DATA_SEND_QUEUE-1)  
.................... //////////        g_stIBCDataSendQueue.m_i8Front = 0;  
.................... //////////    else 
.................... //////////        g_stIBCDataSendQueue.m_i8Front++;  
.................... //////////   
.................... //////////    return; 
.................... //////////}  
.................... ////////// 
.................... //////////int8 IsMSGAvailableInIBCSendQueue() 
.................... //////////{ 
.................... //////////    if (g_stIBCDataSendQueue.m_i8Front == -1) 
.................... //////////    { 
.................... //////////        return 0; 
.................... //////////    } 
.................... //////////     
.................... //////////    return 1; 
.................... //////////} 
.................... ////////// 
.................... //////////void SendIBCMSG() 
.................... //////////{ 
.................... //////////    int8          i8LoopCount    = 0; 
.................... //////////    unsigned int8 ui8Sequence    = 0; 
.................... //////////    unsigned int8 ui8TempData    = 0; 
.................... //////////     
.................... //////////    // Initialize the Send Array 
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount] = 0; 
.................... //////////    } 
.................... ////////// 
.................... //////////    // Get Node from Queue 
.................... //////////    DeleteQueue(&g_stIBCSendData); 
.................... //////////    for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
.................... //////////    { 
.................... //////////        // Step 1: First Stuff 1 Start Bit 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 0] = 0;   // Start Bit Always 0 
.................... //////////         
.................... //////////        // Step 2: Now Stuff 3 bit Message Byte Sequence Number 
.................... //////////         
.................... //////////        // Stuff the 1st Sequence Bit 
.................... //////////        ui8Sequence = i8LoopCount; 
.................... //////////        ui8Sequence = ui8Sequence << 7; 
.................... //////////        ui8Sequence = ui8Sequence >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 1] = ui8Sequence; 
.................... //////////         
.................... //////////        // Stuff the 2nd Sequence Bit  
.................... //////////        ui8Sequence = i8LoopCount; 
.................... //////////        ui8Sequence = ui8Sequence << 6; 
.................... //////////        ui8Sequence = ui8Sequence >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 2] = ui8Sequence; 
.................... //////////         
.................... //////////        // Stuff the 3rd Bit 
.................... //////////        ui8Sequence = i8LoopCount; 
.................... //////////        ui8Sequence = ui8Sequence << 5; 
.................... //////////        ui8Sequence = ui8Sequence >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 3] = ui8Sequence; 
.................... //////////         
.................... //////////        // Step 3: Now Stuff 8 bit Data 
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 7; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 4] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 6; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 5] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 5; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 6] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 4; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 7] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 3; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 8] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 2; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 9] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData << 1; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 10] = ui8TempData; 
.................... //////////         
.................... //////////        ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
.................... //////////        ui8TempData = ui8TempData >> 7; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 11] = ui8TempData; 
.................... //////////         
.................... //////////        // Step 4: Stuff three Stop Bits 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 12] = 1;  // Stop bit is 1 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 13] = 1; 
.................... //////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 14] = 1; 
.................... //////////    } 
.................... //////////     
.................... //////////    // So message stuffing is done now start the send timer 
.................... //////////    // Initialize send counter. 
.................... //////////    g_ui8IBCTxBitCount = 0; 
.................... //////////     
.................... //////////    // TESTING Start 
.................... ////////////    g_ui8ArrSendSingleMSG[0] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[1] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[2] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[3] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[4] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[5] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[6] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[7] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[8] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[9] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[10] = 0; 
.................... ////////////    g_ui8ArrSendSingleMSG[11] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[12] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[13] = 1; 
.................... ////////////    g_ui8ArrSendSingleMSG[14] = 1;     
.................... //////////    // TESTING End 
.................... //////////     
.................... //////////    // Start Timer3 that handle bit by bit sending. 
.................... //////////    // Set Timer3 as per Bit Time Value. 
.................... //////////    setup_timer_3(T3_INTERNAL | T3_DIV_PRESCALE); 
.................... //////////    set_timer3(IBC_TX_1_BT_LOAD_VALUE_9600); 
.................... //////////     
.................... //////////    clear_interrupt(INT_TIMER3); 
.................... //////////    enable_interrupts(INT_TIMER3); 
.................... //////////} 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving START /////////////// 
....................  
.................... void InitializeDataQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue) 
.................... { 
....................     int iLoopCount1 = 0; 
....................     int iLoopCount2 = 0; 
....................     pstIBCMSGQueue->m_i8Front = pstIBCMSGQueue->m_i8Rear = -1; 
....................      
....................     for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBC_DATA_SEND_QUEUE; iLoopCount1++) 
....................     { 
....................         for (iLoopCount2 = 0; iLoopCount2 < IBC_MSG_BYTE_COUNT; iLoopCount2++) 
....................         { 
....................            pstIBCMSGQueue->m_stArrIBCDataNode[iLoopCount1].g_ui8ArrIBCData[iLoopCount2] = 0; 
....................         } 
....................     } 
.................... } 
....................  
.................... void CopyIBCMsg(ST_IBC_DATA_NODE* pstIBCSource, ST_IBC_DATA_NODE* pstIBCDDest) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................      
....................     for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         pstIBCDDest->g_ui8ArrIBCData[i8LoopCount] = pstIBCSource->g_ui8ArrIBCData[i8LoopCount]; 
....................     } 
.................... } 
....................  
.................... /* Function to create Circular queue */ 
.................... void InsertIBCMsgQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue, ST_IBC_DATA_NODE* pstIBCData)  
.................... { 
....................     if (!pstIBCData) 
....................     { 
....................         return; 
....................     } 
....................      
....................     if ((pstIBCMSGQueue->m_i8Front == 0 && pstIBCMSGQueue->m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1) ||  
....................             (pstIBCMSGQueue->m_i8Rear == (pstIBCMSGQueue->m_i8Front-1)%(SIZE_IBC_DATA_SEND_QUEUE-1)))  
....................     {  
....................         //printf("\nQueue is Full");  
....................         return; 
....................     } 
....................    
....................     else if (pstIBCMSGQueue->m_i8Front == -1) /* Insert First Element */ 
....................     {  
....................         pstIBCMSGQueue->m_i8Front = pstIBCMSGQueue->m_i8Rear = 0; 
....................          
....................         // Insert Data 
....................         //arr[g_stIBCDataSendQueue.m_i8Rear] = value; 
....................         CopyIBCMsg(pstIBCData, &(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else if (pstIBCMSGQueue->m_i8Rear == SIZE_IBC_DATA_SEND_QUEUE-1 && pstIBCMSGQueue->m_i8Front != 0)  
....................     {  
....................         pstIBCMSGQueue->m_i8Rear = 0;  
....................         CopyIBCMsg(pstIBCData, &(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else 
....................     {  
....................         pstIBCMSGQueue->m_i8Rear++;  
....................         CopyIBCMsg(pstIBCData, &(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Rear])); 
....................     }  
.................... }  
....................  
.................... void DeleteIBCMsgQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue, ST_IBC_DATA_NODE* pstIBCData)  
.................... { 
....................     if (pstIBCMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBCMsg(&(pstIBCMSGQueue->m_stArrIBCDataNode[pstIBCMSGQueue->m_i8Front]), pstIBCData); 
....................  
....................     if (pstIBCMSGQueue->m_i8Front == pstIBCMSGQueue->m_i8Rear)  
....................     {  
....................         pstIBCMSGQueue->m_i8Front = -1;  
....................         pstIBCMSGQueue->m_i8Rear = -1;  
....................     }  
....................     else if (pstIBCMSGQueue->m_i8Front == SIZE_IBC_DATA_SEND_QUEUE-1)  
....................         pstIBCMSGQueue->m_i8Front = 0;  
....................     else 
....................         pstIBCMSGQueue->m_i8Front++;  
....................    
....................     return; 
.................... } 
....................  
....................  
.................... int8 IsMSGInIBCQueue(ST_IBC_MSG_QUEUE *pstIBCMSGQueue) 
.................... { 
....................     if (pstIBCMSGQueue->m_i8Front == -1) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................     return 1; 
.................... } 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving END ///////////////// 
.................... void SendIBCMSGFromQ() 
.................... { 
....................     int8          i8LoopCount    = 0; 
....................     unsigned int8 ui8Sequence    = 0; 
....................     unsigned int8 ui8TempData    = 0; 
....................  
....................     // Initialize the Send Array 
....................     for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount] = 0; 
....................     } 
....................  
....................     // Get Node from Queue 
....................     DeleteIBCMsgQueue(&g_stIBCSendQueue, &g_stIBCSendData); 
....................     for (i8LoopCount = 0; i8LoopCount < IBC_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         // Step 1: First Stuff 1 Start Bit 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 0] = 0;   // Start Bit Always 0 
....................          
....................         // Step 2: Now Stuff 3 bit Message Byte Sequence Number 
....................          
....................         // Stuff the 1st Sequence Bit 
....................         ui8Sequence = i8LoopCount; 
....................         ui8Sequence = ui8Sequence << 7; 
....................         ui8Sequence = ui8Sequence >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 1] = ui8Sequence; 
....................          
....................         // Stuff the 2nd Sequence Bit  
....................         ui8Sequence = i8LoopCount; 
....................         ui8Sequence = ui8Sequence << 6; 
....................         ui8Sequence = ui8Sequence >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 2] = ui8Sequence; 
....................          
....................         // Stuff the 3rd Bit 
....................         ui8Sequence = i8LoopCount; 
....................         ui8Sequence = ui8Sequence << 5; 
....................         ui8Sequence = ui8Sequence >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 3] = ui8Sequence; 
....................          
....................         // Step 3: Now Stuff 8 bit Data 
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 7; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 4] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 6; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 5] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 5; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 6] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 4; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 7] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 3; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 8] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 2; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 9] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData << 1; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 10] = ui8TempData; 
....................          
....................         ui8TempData = g_stIBCSendData.g_ui8ArrIBCData[i8LoopCount]; 
....................         ui8TempData = ui8TempData >> 7; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 11] = ui8TempData; 
....................          
....................         // Step 4: Stuff three Stop Bits 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 12] = 1;  // Stop bit is 1 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 13] = 1; 
....................         g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 14] = 1; 
....................          
.................... ////////        // TESTING Start 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 0] = 0;   
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 1] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 2] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 3] = 1;  
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 4] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 5] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 6] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 7] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 8] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 9] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 10] = 0; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 11] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 12] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 13] = 1; 
.................... ////////        g_ui8ArrSendSingleMSG[(SIZE_IBC_SEND_BYTE_SEGMENT*i8LoopCount) + 14] = 1; 
.................... ////////        // TESTING End 
....................     } 
....................      
....................      
.................... ////    // TESTING Start 
.................... ////    g_ui8ArrSendSingleMSG[0] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[1] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[2] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[3] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[4] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[5] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[6] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[7] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[8] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[9] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[10] = 0; 
.................... ////    g_ui8ArrSendSingleMSG[11] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[12] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[13] = 1; 
.................... ////    g_ui8ArrSendSingleMSG[14] = 1;     
.................... ////    // TESTING End 
....................          
....................     // So message stuffing is done now start the send timer 
....................     // Initialize send counter. 
....................     g_ui8IBCTxBitCount = 0; 
....................      
....................     // Hold the IBC Send Lock 
....................     g_fIBCSendLockStatus = IBC_SEND_LOCK; 
....................     // Start Timer3 that handle bit by bit sending. 
....................     // Set Timer3 as per Bit Time Value. 
....................     setup_timer_3(T3_INTERNAL | T3_DIV_PRESCALE); 
....................     set_timer3(IBC_TX_1_BT_LOAD_VALUE_9600); 
....................      
....................     // Before Sending Data in IBC Run Timer0 in Time Critical. This we are doing 
....................     // just because we have seen the IBC Send Receive is affecting while Timer 0 
....................     // is executing, hence the IBC data send receive is not sampled at proper time 
....................     g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_ON; 
....................      
....................     clear_interrupt(INT_TIMER3); 
....................     enable_interrupts(INT_TIMER3); 
.................... } 
....................  
.................... void IBCProcessRcvMsg() 
.................... { 
....................     // I 
.................... } 
....................  
.................... #INT_TIMER3    // Used for IBC Send 
.................... void IBC_Tx_ISR(void) 
.................... { 
....................     // Send IBC bits 
....................     output_bit(PIN_IBC_XMIT, g_ui8ArrSendSingleMSG[g_ui8IBCTxBitCount++]); 
....................     // Reset Timer3 at 1Bit Time value. 
....................     set_timer3(IBC_TX_1_BT_LOAD_VALUE_9600); 
....................     clear_interrupt( INT_TIMER3 ); 
....................  
....................     // Check if IBC Sending completed 
....................     if ((IBC_MSG_BYTE_COUNT*SIZE_IBC_SEND_BYTE_SEGMENT) == g_ui8IBCTxBitCount) 
....................     { 
....................         // First release Timer0 Critical run lock 
....................         g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
....................          
....................         // Release Send Busy status 
....................         g_fIBCSendBusy     = 0; 
....................          
....................         // Send Stop bit forever 
....................         output_bit(PIN_IBC_XMIT, 1); 
....................  
....................         // Reset Tx counter 
....................         g_ui8IBCTxBitCount = 0; 
....................         // Reset IBC Send checking status flag. 
....................         //g_fIBCCommStatus = 0; 
....................         // Disable Timer 
....................         setup_timer_3 (T3_DISABLED); 
....................         disable_interrupts(INT_TIMER3); 
....................         // Clear Timer1 interrupt 
....................         clear_interrupt(INT_TIMER3); 
....................          
....................         // Release IBC Send Lock 
....................         g_fIBCSendLockStatus = IBC_SEND_UNLOCK; 
....................     } 
....................      
....................     // TESTING 
....................     //output_toggle(PIN_IN_EXT_DI_00); 
....................   
.................... } 
....................  
....................  
....................  
.................... /* 
....................     Timer1 is used to handle IBC Received bytes. 
....................  and Timer3 is used to handle IBC sent bytes. 
....................  */ 
.................... #ifdef M1_COMM_MODULE 
.................... #INT_EXT1  
.................... #else 
.................... #INT_EXT3 
.................... #endif 
.................... void IBC_Rx_ISR(void) 
.................... { 
....................    
....................     // Initialize Rx Bit Counter. 
....................    	g_ui8IBCRcvBitCount = 0; 
....................     g_unIBCRcvByteNode.m_ui8Arr[0] = 0; 
....................     g_unIBCRcvByteNode.m_ui8Arr[1] = 0; 
....................    	 
....................     // Setup Timer1 at 1.5 Bit Time.                   // Here we are using DIV_BY_8. 
....................     setup_timer_1( T1_INTERNAL | T1_DIV_PRESCALE ); // CPU Ext Clock is 20MHz, 20/4 => 5MHz is Peripheral Clock 
....................                                                 // => T1_DIV_BY_2 => 5/2 = 2.5MHz => (1/2.5)us = 0.4us 
....................                                                 // To Get 1Ms quanta = (1000us/0.4) = 2500 => 0x09C4 
....................                                                 // So, The timer will start counting from (0xFFFF - 0x09C4 + 1) 
....................                                                 // To Get 1.5Ms quanta = (1500us/0.4) = 3750 => 0x0EA6 
....................                                                 // So, The timer will start counting from (0xFFFF - 0x0EA6 + 1)  
....................      
.................... #ifdef M1_COMM_MODULE 
....................     set_timer1( IBC_RX_BIT_TIME_1_4_T1LOAD_VAL_9600);  
.................... #else 
....................     set_timer1( IBC_RX_BIT_TIME_1_5_T1LOAD_VAL_9600); 
.................... #endif 
....................      
....................     // Before Sending Data in IBC Run Timer0 in Time Critical. This we are doing 
....................     // just because we have seen the IBC Send Receive is affecting while Timer 0 
....................     // is executing, hence the IBC data send receive is not sampled at proper time 
....................     g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_ON; 
....................      
....................     clear_interrupt( INT_TIMER1 ); 
....................     enable_interrupts( INT_TIMER1 ); 
....................      
....................     // Clear and Disable External Interrupt 1  
.................... #ifdef M1_COMM_MODULE 
....................     clear_interrupt(INT_EXT1); 
....................     disable_interrupts(INT_EXT1);  
.................... #else 
....................     clear_interrupt(INT_EXT3); 
....................     disable_interrupts(INT_EXT3); 
.................... #endif 
....................      
....................     // TESTING Start 
.................... #ifdef M1_COMM_MODULE 
....................     //output_high(PIN_IN_EXT_DI_00); 
.................... #endif 
....................     // TESTING End 
.................... } 
....................  
.................... // TESTING Start 
.................... int8 g_i8RcvByteCount = 0; 
.................... // TESTING End 
....................  
.................... #INT_TIMER1           // This is for Receive                 
.................... void IBC_Rx_Sampling_ISR(void) 
.................... {  
.................... ////////    // TESTING Start 
.................... ////////#ifdef M1_COMM_MODULE 
.................... ////////    //output_toggle(PIN_IN_EXT_DI_00); 
.................... ////////#else 
.................... ////////    output_toggle(PIN_A5); 
.................... ////////#endif 
.................... ////////    // TESTING End 
....................      
....................     // Increment Rx Bit Counter for each received bit. 
....................    	g_ui8IBCRcvBitCount++; 
.................... 	 
....................     // Check Rx Bit Counter and read Bits 
....................     switch(g_ui8IBCRcvBitCount) 
....................     { 
....................         case 1: // Sequence Bit 0  
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8SeqBit0 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 2: // Sequence Bit 1 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8SeqBit1 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 3: // Sequence Bit 2 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8SeqBit2 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 4: // Data Bit Bit 0 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit0 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 5: // Bit 4 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit1 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 6: // Bit 5 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit2 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 7: // Bit 6 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit3 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 8: // Bit 7 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit4 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................          	set_timer1(IBC_RX_BIT_TIME_T1LOAD_VAL_9600); 
....................          	clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................              
....................              
....................         case 9: // Bit 8 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit5 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_1_BT_CUSTOMISED_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 10: // Bit 9 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit6 = input(PIN_IBC_RCV); 
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_1_BT_CUSTOMISED_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................         case 11: // Bit 10 
....................             g_unIBCRcvByteNode.m_stIBCNode.m_ui8DataBit7 = input(PIN_IBC_RCV); 
....................              
....................             // We have received all data so now we can release Timer0 Critical Run 
....................             g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
....................              
....................             // Setup Timer1 at 1 Bit Time. 
....................             set_timer1(IBC_RX_1_BT_CUSTOMISED_VAL_9600); 
....................             clear_interrupt( INT_TIMER1 ); 
....................             break; 
....................              
....................         case 12: // STOP Bit 
....................             // Check if the Stop Bit is High. 
....................             if(1 == input(PIN_IBC_RCV)) // Stop bit detected 
....................             { 
....................                 // Byte received successfully 
....................                 // Save received byte to the Message Array 1 
....................                 //g_arruiIBCRxMsg1[g_uiIBCRxByteCount1 - 1] = g_unTempRxData1.m_uiByte; 
....................             } 
....................             else 
....................             {  
....................                 // Handle error. 
....................                 // Framing error. 
....................                 // Set Flag tracking Framing Error. 
....................                 //g_uiIBCRxFramingErr1 = 1; 
....................                 //g_uiIBCSTXReceived1  = 0; 
....................             } 
....................             // Disable Timer1. 
....................             setup_timer_1 (T1_DISABLED); 
....................             disable_interrupts(INT_TIMER1);  
....................             // Clear Timer1 interrupt. 
....................             clear_interrupt(INT_TIMER1);  
....................   
....................              
....................             g_i8RcvByteCount++; 
....................             if (5 == g_i8RcvByteCount) 
....................             { 
....................                 g_i8RcvByteCount = 0; 
....................             } 
....................             // Now check the Byte Sequence 
....................             g_stIBCRcvData.g_ui8ArrIBCData[g_unIBCRcvByteNode.m_ui8Arr[0]] = g_unIBCRcvByteNode.m_ui8Arr[1]; 
....................              
....................             if ((IBC_MSG_BYTE_COUNT - 1) == g_unIBCRcvByteNode.m_ui8Arr[0]) 
....................             { 
....................                 // The complete 5 byte data has been received 
....................                 // Now we can process the data 
....................                 g_fIBCDataReceived = 1; 
....................                  
....................                 // Insert Message into IBC Receive Queue 
.................... ////////                InsertIBCMsgQueue(&g_stIBCRcvQueue, &g_stIBCRcvData);   
....................             } 
....................             // Reset Rx Bit Counter. 
....................             g_ui8IBCRcvBitCount = 0; 
....................              
....................             // Enable External Interrupt to detect next byte. 
.................... #ifdef M1_COMM_MODULE 
....................             ext_int_edge(1, H_TO_L);  
....................             clear_interrupt(INT_EXT1); 
....................             enable_interrupts(INT_EXT1); 
.................... #else 
....................             ext_int_edge(3, H_TO_L);  
....................             clear_interrupt(INT_EXT3); 
....................             enable_interrupts(INT_EXT3); 
.................... #endif 
....................             break; 
....................  
....................         default: 
....................             // Framing error. 
....................             // Set Flag tracking Framing Error. 
....................             //g_uiIBCRxFramingErr1 = 1; 
....................              
....................             // First release Timer0 Critical run lock 
....................             g_ui8fTimer0State   = IBC_TIMER_0_CRITICAL_OFF; 
....................              
....................             // Disable Timer1. 
....................             setup_timer_1 (T1_DISABLED); 
....................             disable_interrupts(INT_TIMER1);  
....................             // Clear Timer1 interrupt. 
....................             clear_interrupt(INT_TIMER1);  
....................              
....................             // Reset Rx Bit Counter 1. 
....................             g_ui8IBCRcvBitCount = 0; 
....................              
....................             // Enable External Interrupt 0 to detect next start bit. 
....................             ext_int_edge(1, H_TO_L);  
....................             clear_interrupt(INT_EXT1); 
....................             enable_interrupts(INT_EXT1); 
....................             break; 
....................     } 
....................      
.................... } 
....................  
....................  
....................  
.................... #endif /* _VI_IBC_CONFIG_H_ */ 
....................  
.................... #include "vmIBCProcessM1.h" 
.................... /*  
....................  * File:   vmIBCProcessM1.h 
....................  * Author: Mrinmoy 
....................  * 
....................  * Created on December 11, 2018, 3:11 PM 
....................  */ 
....................  
.................... #ifndef VM_IBC_PROCESS_M1_H 
.................... #define	VM_IBC_PROCESS_M1_H 
....................  
.................... #include "../Common/vmIBCConfig.h" 
.................... #include "vmCalibrationConfig.h" 
.................... #include "vmSIM900_GPRSConfig.h" 
.................... #include "viModbusGlobal.h" 
.................... #include "vmGSMM66_GPRSConfig.h" 
....................  
.................... //#define IBC_CMD_SET_CALIB_POINT             1 
.................... //#define IBC_CMD_GET_CALIB_POINT             2 
.................... //#define IBC_CMD_RESET_CALIB_POINT           3 
.................... //#define IBC_CMD_TARE_REQUEST                4 
.................... //#define IBC_CMD_PRE_PROD_AVG_WEIGHT         5 
.................... //#define IBC_CMD_PRE_PROD_TOLERANCE          6 
.................... //#define IBC_CMD_START_PROD                  7 
.................... //#define IBC_CMD_PROD_WEIGH_DATA              
....................  
.................... unsigned int16 g_ui16PrevItemCount = 0; 
....................  
.................... void StuffCalibTable(void) 
.................... { 
....................     unsigned int8 ui8Index = (g_i16CalibPoint / 1000); 
....................      
....................     if((g_i16CalibPoint % 1000) == 0 && g_i16CalibPoint <= 10000) 
....................     { 
....................         g_stCalibTable[ui8Index].m_i16CalibPoint = g_i16CalibPoint; 
....................         g_stCalibTable[ui8Index].m_ui32CalibValue = g_i32CalibValue; 
....................         
....................         switch(ui8Index) 
....................         { 
....................             case 0: 
....................                 g_ui16Register0_2 = (unsigned int16)((g_i32CalibValue >> 16) & 0x0000FFFF); 
....................                 g_ui16Register0_1 = (unsigned int16)(g_i32CalibValue & 0x0000FFFF); 
....................                 break; 
....................             case 1: 
....................                 g_ui16Register1000_2 = (unsigned int16)((g_i32CalibValue >> 16) & 0x0000FFFF); 
....................                 g_ui16Register1000_1 = (unsigned int16)(g_i32CalibValue & 0x0000FFFF); 
....................                 break; 
....................             case 2: 
....................                 g_ui16Register2000_2 = (unsigned int16)((g_i32CalibValue >> 16) & 0x0000FFFF); 
....................                 g_ui16Register2000_1 = (unsigned int16)(g_i32CalibValue & 0x0000FFFF); 
....................                 break; 
....................             case 3: 
....................                 g_ui16Register3000_2 = (unsigned int16)((g_i32CalibValue >> 16) & 0x0000FFFF); 
....................                 g_ui16Register3000_1 = (unsigned int16)(g_i32CalibValue & 0x0000FFFF); 
....................                 break; 
....................             case 4: 
....................                 g_ui16Register4000_2 = (unsigned int16)((g_i32CalibValue >> 16) & 0x0000FFFF); 
....................                 g_ui16Register4000_1 = (unsigned int16)(g_i32CalibValue & 0x0000FFFF); 
....................                 break; 
....................             case 5: 
....................                 g_ui16Register5000_2 = (unsigned int16)((g_i32CalibValue >> 16) & 0x0000FFFF); 
....................                 g_ui16Register5000_1 = (unsigned int16)(g_i32CalibValue & 0x0000FFFF); 
....................                 break; 
....................             case 6: 
....................                 g_ui16Register6000_2 = (unsigned int16)((g_i32CalibValue >> 16) & 0x0000FFFF); 
....................                 g_ui16Register6000_1 = (unsigned int16)(g_i32CalibValue & 0x0000FFFF); 
....................                 break; 
....................             case 7: 
....................                 g_ui16Register7000_2 = (unsigned int16)((g_i32CalibValue >> 16) & 0x0000FFFF); 
....................                 g_ui16Register7000_1 = (unsigned int16)(g_i32CalibValue & 0x0000FFFF); 
....................                 break; 
....................             case 8: 
....................                 g_ui16Register8000_2 = (unsigned int16)((g_i32CalibValue >> 16) & 0x0000FFFF); 
....................                 g_ui16Register8000_1 = (unsigned int16)(g_i32CalibValue & 0x0000FFFF); 
....................                 break; 
....................             case 9: 
....................                 g_ui16Register9000_2 = (unsigned int16)((g_i32CalibValue >> 16) & 0x0000FFFF); 
....................                 g_ui16Register9000_1 = (unsigned int16)(g_i32CalibValue & 0x0000FFFF); 
....................                 break; 
....................             case 10: 
....................                 g_ui16Register10000_2 = (unsigned int16)((g_i32CalibValue >> 16) & 0x0000FFFF); 
....................                 g_ui16Register10000_1 = (unsigned int16)(g_i32CalibValue & 0x0000FFFF); 
....................                 break;    
....................         } 
....................          
....................     }    
....................         
.................... } 
....................  
....................  // TESTING  
....................     unsigned int8 ui8Counter = 0; 
....................  
.................... // IBC Received message process proc 
.................... void ProcessIBCMsg() 
.................... {    
....................     ST_IBC_DATA_NODE stIBCRcvNode; 
....................     unsigned int8  ui8LoopCount = 0; 
....................     unsigned int16 ui16ItemCount = 0; 
....................     unsigned int16 ui16TempCurrPassStatus = 50;; 
....................  
....................     // Get Node from IBC Receive Message Queue 
....................     DeleteIBCMsgQueue(&g_stIBCRcvQueue, &stIBCRcvNode); 
....................      
....................     // Valid message present in IBC receive buffer 
....................     // So go for process the data 
....................     switch(stIBCRcvNode.g_ui8ArrIBCData[0]) 
....................     { 
....................         case IBC_CMD_RESET_CALIB_POINT_TARE: 
....................             // Store receive data. 
....................             for(ui8LoopCount = 1; ui8LoopCount < IBC_MSG_BYTE_COUNT; ui8LoopCount++) 
....................             { 
....................                 g_unIBCResetCalibTare.m_ui8Arr[ui8LoopCount - 1] = stIBCRcvNode.g_ui8ArrIBCData[ui8LoopCount]; 
....................             } 
....................              
....................             // Retrieve and store the dynamic ADC tare value. 
....................             g_ui32TareADCValueForCalibration = g_unIBCResetCalibTare.m_stIBCResetCalibTare.m_ui32CalibADCForTare; 
....................      
....................             break; 
....................         case IBC_CMD_GET_CALIB_POINT: 
....................             break; 
....................         case IBC_CMD_RESET_CALIB_POINT:             
....................             break; 
....................         case IBC_CMD_PROD_TARE_DATA: 
....................             { 
....................                 for(ui8LoopCount = 1; ui8LoopCount < IBC_MSG_BYTE_COUNT; ui8LoopCount++) 
....................                 { 
....................                     g_unIBCProdModeTrData.m_ui8Arr[ui8LoopCount-1] = stIBCRcvNode.g_ui8ArrIBCData[ui8LoopCount]; 
....................                 } 
....................                 g_ui16RunningTareValue = (unsigned int16)(g_unIBCProdModeTrData.m_stTareData.m_i16TareData); 
....................             } 
....................              
....................             break; 
....................         case IBC_CMD_PRE_PROD_AVG_WEIGHT: 
....................             break; 
....................         case IBC_CMD_PRE_PROD_TOLERANCE: 
....................             break; 
....................         case IBC_CMD_START_PROD: 
....................             break; 
....................         case IBC_CMD_PROD_AVG_WT_DATA: 
....................             { 
....................                 for(ui8LoopCount = 1; ui8LoopCount < IBC_MSG_BYTE_COUNT; ui8LoopCount++) 
....................                 { 
....................                     g_unIBCProdModeAvg.m_ui8Arr[ui8LoopCount-1] = stIBCRcvNode.g_ui8ArrIBCData[ui8LoopCount]; 
....................                 } 
....................                  
....................                 g_ui16RunningAvgWt = g_unIBCProdModeAvg.m_stAvgData.m_i16CurAvg; 
....................             } 
....................             break; 
....................              
....................         case IBC_CMD_PROD_WEIGH_DATA: 
....................             { 
....................                 // Copy individual Box data. 
....................                 for(ui8LoopCount = 1; ui8LoopCount < IBC_MSG_BYTE_COUNT; ui8LoopCount++) 
....................                 { 
....................                     g_unIBCProdModeWtData.m_ui8Arr[ui8LoopCount - 1] = stIBCRcvNode.g_ui8ArrIBCData[ui8LoopCount]; 
....................                     //g_unIBCProdModeWtData.m_ui8Arr[ui8LoopCount] = g_stIBCRcvData.g_ui8ArrIBCData[ui8LoopCount + 1]; 
....................                 } 
....................  
....................                 // Segregate Box count, Rejection status and weight of single box and store in RAM. 
....................                 // HMI data display variables. 
....................                 g_ui16CBBCount = g_unIBCProdModeWtData.m_stWeighingData.m_ui16BoxCount >> 1; 
....................                 //g_ui16CBBCount = g_unIBCProdModeWtData.m_stWeighingData.m_ui16BoxCount >> 2; 
....................                 // Store the CBB count temporarily. 
....................                 ui16ItemCount = g_ui16CBBCount; 
....................                  
....................                 g_stProdModeCurrBoxData.m_i16BoxWeight = g_unIBCProdModeWtData.m_stWeighingData.m_i16BoxWeight; 
....................                 // Insert current box data to variables for Display in HMI 
....................                 g_ui16CurrentWt = g_stProdModeCurrBoxData.m_i16BoxWeight; 
....................                  
....................                 // Update current Box pass status. 
....................                 g_ui16CurrentPassStatus = g_unIBCProdModeWtData.m_stWeighingData.m_ui16BoxCount << 15; 
....................                 g_ui16CurrentPassStatus = g_ui16CurrentPassStatus >> 15; 
....................          
....................                 //TODO => IBC Error adjustment Start. 
....................                 // Just to Cleaning first two erroneous bits due to IBC Sampling Problem. 
....................                 g_ui16CBBCount = g_ui16CBBCount << 2; 
....................                 g_ui16CBBCount = g_ui16CBBCount >> 2; 
....................                 //TODO IBC Error adjustment End 
....................                  
....................                 if(ui16ItemCount > 0 && g_ui16PrevItemCount != ui16ItemCount) 
....................                 { 
....................                     // Update production mode current box data. 
....................                     g_stProdModeCurrBoxData.m_ui16SequenceNo = g_ui16CBBCount; 
....................                     g_stProdModeCurrBoxData.m_i16BoxWeight = g_ui16CurrentWt; 
....................                     g_stProdModeCurrBoxData.m_ui16RejectionStatus = g_ui16CurrentPassStatus;  // TODO 
....................                     //g_stProdModeCurrBoxData.m_ui32TimeStamp = GetRTC(); 
....................                     // Insert current box data in GPRS send Message queue. 
....................                     InsertInGPRSMsgQueue(); 
....................  
....................                     // update previous item count for next box reference. 
....................                     g_ui16PrevItemCount = ui16ItemCount; 
....................                 } 
....................                 // Arijita 
....................                 // Current box weight to avg array 
....................                 if(g_ui16CBBCount > 0)  
....................                 { 
....................                      //g_ui16RunningAvgWt = ProcessWeightData(g_ui16CurrentWt); 
....................                 } 
....................                 else 
....................                 { 
....................                     // TESTING 
....................                     int8 i8NewData = 0; 
....................                     i8NewData++; 
....................                     i8NewData = 100; 
....................                 } 
....................             } 
....................             break; 
....................         case IBC_CMD_PROD_INTMD_DATA: 
....................             { 
....................                 // Copy individual Box data. 
....................                 for(ui8LoopCount = 1; ui8LoopCount < IBC_MSG_BYTE_COUNT; ui8LoopCount++) 
....................                 { 
....................                     g_unIBCProdModeWtData.m_ui8Arr[ui8LoopCount - 1] = stIBCRcvNode.g_ui8ArrIBCData[ui8LoopCount]; 
....................                     //g_unIBCProdModeWtData.m_ui8Arr[ui8LoopCount] = g_stIBCRcvData.g_ui8ArrIBCData[ui8LoopCount + 1]; 
....................                 } 
....................  
....................                 g_stProdModeCurrBoxData.m_i16BoxWeight = g_unIBCProdModeWtData.m_stWeighingData.m_i16BoxWeight; 
....................  
....................                 // Insert current box data to variables for Display in HMI 
....................                 g_ui16CurrentWt = g_stProdModeCurrBoxData.m_i16BoxWeight; 
....................  
....................                  
....................             } 
....................             break;             
....................         case IBC_CMD_RESET_CALIB_POINT_WEIGHT: 
....................             // Store receive data. 
....................             for(ui8LoopCount = 1; ui8LoopCount < IBC_MSG_BYTE_COUNT; ui8LoopCount++) 
....................             { 
....................                 g_unIBCResetCalibWeight.m_ui8Arr[ui8LoopCount - 1] = stIBCRcvNode.g_ui8ArrIBCData[ui8LoopCount]; 
....................             } 
....................              
....................             // Retrieve and store the dynamic ADC tare value. 
....................             g_ui32gWeightADCValueForCalibration = g_unIBCResetCalibWeight.m_stIBCResetCalibWeight.m_ui32CalibADCForWeight; 
....................             break; 
....................         default : 
....................             break; 
....................     } 
.................... }    
....................  
....................  
....................  
.................... #endif	/* VM_IBC_PROCESS_M1_H */ 
....................  
....................  
....................  
.................... #define SIZE_CALIB_TABLE              11   // Only for the values 0, 1000, 2000, 3000, 4000, 
....................                                             // 5000, 6000, 7000, 8000, 9000 and 10000 
....................  
.................... typedef struct _ST_CALIB_NODE 
.................... { 
....................     int16          m_i16CalibPoint; 
....................     unsigned int32 m_ui32CalibValue; 
.................... } ST_CALIB_NODE; 
....................  
.................... // Parse Union for Calib Point 
.................... typedef union _UN_CALIB_POINT 
.................... { 
....................     unsigned int16 m_ui16CalibPoint; 
....................     unsigned int8  m_ui8Arr[2]; 
.................... } UN_CALIB_POINT; 
....................  
.................... // Parse Union for Calib Value 
.................... typedef union _UN_RCV_CALIB_VALUE 
.................... { 
....................     unsigned int32 m_ui32Value; 
....................     unsigned int8  m_ui8Arr[4]; 
.................... } UN_RCV_CALIB_VALUE; 
....................  
....................  
....................  
.................... // ***************************************************************************** 
.................... // ***************** Below -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
.................... ST_CALIB_NODE g_stCalibTable[SIZE_CALIB_TABLE]; 
.................... UN_CALIB_POINT g_unCalibPoint; 
.................... UN_RCV_CALIB_VALUE g_unCalibValue[SIZE_CALIB_TABLE]; 
.................... int16 g_i16CalibPoint = 0; 
.................... int32 g_i32CalibValue = 0; 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ***************** Above -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
.................... // Segregate merged calib table and prepare proper calib table. 
.................... void PrepareCalibNode(void) 
.................... {                                            //################# Data Receive Format ############################ 
....................     unsigned int16 ui16TempCalibPoint = 0;  // Calib Point while in int16 is stored in byte array as  |b1|a1| 
....................                                             // Calib Value while in int32 is stored in byte array as  |d2|c2|b2|a2| 
....................                                             // In EEPROM it should be like |a1|b1+c2|a2|b2| 
....................     unsigned int32 ui32TempCalibValue = 0; 
....................     unsigned int8 ui8TempData0        = 0; 
....................     unsigned int8 ui8TempData1        = 0; 
....................     unsigned int8 ui8TempData2        = 0; 
....................     unsigned int8 ui8TempData3        = 0; 
....................     unsigned int8 ui8Temp             = 0; 
....................      
....................      
....................     // Assign received 4 bytes in temp data. 
....................     ui8TempData0 = g_stIBCRcvData.g_ui8ArrIBCData[1]; 
....................     ui8TempData1 = g_stIBCRcvData.g_ui8ArrIBCData[2]; 
....................     ui8TempData2 = g_stIBCRcvData.g_ui8ArrIBCData[3]; 
....................     ui8TempData3 = g_stIBCRcvData.g_ui8ArrIBCData[4]; 
....................  
....................     // Set the Calibration Point 
....................     ui16TempCalibPoint = ui8TempData1; 
....................     ui16TempCalibPoint = ui16TempCalibPoint >> 2; 
....................     g_i16CalibPoint = ui16TempCalibPoint; 
....................     g_i16CalibPoint = g_i16CalibPoint << 8; 
....................     g_i16CalibPoint = g_i16CalibPoint | ui8TempData0; 
....................  
....................     // Set the Calibration Value 
....................     ui8Temp = ui8TempData1; 
....................     ui8Temp = ui8Temp << 6; 
....................     ui8Temp = ui8Temp >> 6; 
....................     g_i32CalibValue = ui8Temp; 
....................     g_i32CalibValue = g_i32CalibValue << 16; 
....................  
....................     ui32TempCalibValue = ui8TempData3; 
....................     ui32TempCalibValue = ui32TempCalibValue << 8; 
....................     g_i32CalibValue = g_i32CalibValue | ui32TempCalibValue; 
....................  
....................     ui32TempCalibValue = ui8TempData2; 
....................     g_i32CalibValue = g_i32CalibValue | ui32TempCalibValue; 
....................  
....................          
....................      
.................... } 
....................  
....................  
.................... #endif	/* VM_CALIBRATION_CONFIG_H */ 
....................  
....................  
.................... #include "vmSIM900_GPRSConfig.h" 
.................... /*  
....................  * File:   vmSIM900_GPRSConfig.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on December 12, 2018, 4:05 PM 
....................  */ 
....................  
.................... #ifndef VM_SIM900_GPRS_CONFIG_H 
.................... #define	VM_SIM900_GPRS_CONFIG_H 
....................  
.................... #include "vmTimerConfig.h" 
.................... //#include "vmCalibrationConfig.h" 
.................... #include "viRS485Config.h" 
....................  
.................... #define   SIM900_RX_BUFF_SIZE                   500 
....................  
....................  
.................... #define   IN_MOTION_MACHINE_ID                  1 
.................... #define   GPRS_RQSTTYPE_SEND_2_SERVER           1 
....................  
.................... #define  GPRS_CONNECTION_FAILS                  30 
.................... #define  GPRS_HTTP_ENABLE_FAILS                 31 
.................... #define  GPRS_SET_BEARER_ID_FAILS               32 
.................... #define  GPRS_SET_WEB_SERVICE_URL_FAILS         33 
.................... #define  GPRS_START_HTTP_GET_SESSION_FAILS      34 
.................... #define  VYOMEC_250_LOO118_MACHINE_ID           1 
....................  
....................  
.................... //typedef struct _ST_GPRS_DATA_NODE 
.................... //{ 
.................... //    unsigned int32 m_ui32TimeStamp; 
.................... //    unsigned int16 m_ui16SequenceNo; 
.................... //    unsigned int16 m_ui16ItemWeight; 
.................... //    unsigned int8  m_ui8RejectionStatus; 
.................... //} ST_GPRS_DATA_NODE; 
.................... // 
.................... //typedef struct _ST_GPRS_MSG_SEND_QUEUE 
.................... //{ 
.................... //    ST_GPRS_DATA_NODE m_stArrGPRSDataNode[SIZE_GPRS_DATA_NODE_QUEUE]; 
.................... //    int8              m_i8Front; 
.................... //    int8              m_i8Rear; 
.................... //} ST_GPRS_MSG_SEND_QUEUE; 
....................  
.................... //typedef struct _ST_PROD_M_CURR_BOX_DATA 
.................... //{ 
.................... //    int16             m_i16BoxWeight; 
.................... //    unsigned int16    m_ui16SequenceNo; 
.................... //    unsigned int16    m_ui16RejectionStatus; 
.................... //    unsigned int32    m_ui32TimeStamp; 
.................... //} ST_PROD_M_CURR_BOX_DATA; 
....................  
.................... // ***************************************************************************** 
.................... // ***************** Below -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
.................... unsigned int8      g_ui8SIM900RxBuffer[SIM900_RX_BUFF_SIZE] = {0}; 
.................... unsigned int16     g_ui16SIM900RxByteCount                  = 0; 
.................... //unsigned int16     g_ui16HTTPData                           = 0; 
.................... //unsigned int8      g_ui8GPRSRqstType                        = GPRS_RQSTTYPE_SEND_2_SERVER; 
.................... unsigned int8      g_fIsLastElementInGPRSQueue              = 0; 
.................... //unsigned int8      g_fGPRSSequence                          = 0; 
.................... //unsigned int8      g_fGPRSFailureBit                        = 0; 
.................... //unsigned int8      g_ui8DataQueueLen                        = 0; 
....................  
....................  
.................... //ST_GPRS_DATA_NODE  g_stGPRSDataNode; 
.................... //ST_GPRS_MSG_SEND_QUEUE   g_stGPRSMsgSendQueue; 
.................... //ST_PROD_M_CURR_BOX_DATA  g_stProdModeCurrBoxData; 
....................  
.................... // ***************************************************************************** 
.................... // ***************** Above -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
.................... void Delay_milisecond_(unsigned int16 ui16DelayTime) 
.................... { 
.................... 	unsigned int16 ui16Counter = 0; 
.................... 	while(ui16Counter < ui16DelayTime) 
.................... 	{ 
.................... 		// Reset WDT 
....................    		restart_wdt(); 
....................      
.................... 		delay_ms(1); 
.................... 		ui16Counter++; 
.................... 	} 
.................... } 
....................  
.................... void ResetSIM900RxBuffer(void) 
.................... { 
....................     // Reset Rx Byte count. 
....................     g_ui16SIM900RxByteCount = 0; 
....................     // Flush all data in SIM900 Rx buffer 
....................     memset(g_ui8SIM900RxBuffer, 0, SIM900_RX_BUFF_SIZE); 
.................... } 
....................  
....................  
....................  
.................... //void StuffGPRSMSgQueueDummy(void) 
.................... //{ 
.................... //    unsigned int8  ui8NoOfMessage     = 2; 
.................... //    unsigned int16 ui16MachineID      = 1; 
.................... //    unsigned int8  ui8Variety         = 6; 
.................... //     
.................... //    unsigned int32 ui32TimeStamp       = 454545; 
.................... //    unsigned int16 ui16SequenceNo      = 1; 
.................... //    int16          i16Itemweight       = 7000; 
.................... //    unsigned int16 ui16Rejectionstatus = 1; 
.................... //     
.................... //    // Stuff dummy message header 
.................... //    g_stGPRSMsgHeader.m_ui8NoOfMessages = ui8NoOfMessage; 
.................... //    g_stGPRSMsgHeader.m_ui16MachineID   = ui16MachineID; 
.................... //    g_stGPRSMsgHeader.m_ui8Variety      = ui8Variety; 
.................... //     
.................... //    for(unsigned int8 ui8LoopCount = 0; ui8LoopCount <= 30; ui8LoopCount++) 
.................... //    { 
.................... //        g_stGPRSMsgSendQueue.m_i8Rear++; 
.................... //         
.................... //        // Stuff data 
.................... //        g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui32TimeStamp = ui32TimeStamp++; 
.................... //        g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16SequenceNo = ui16SequenceNo++; 
.................... //        g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16ItemWeight = i16Itemweight++; 
.................... //        g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui8RejectionStatus = ui16Rejectionstatus; 
.................... //    } 
.................... //     
.................... //    g_stGPRSMsgSendQueue.m_i8Front = 0; 
.................... //} 
....................  
.................... //void StuffDummyTimeStamp(void) 
.................... //{ 
.................... //    unsigned int32 ui32TimeStamp       = 8080; 
.................... //    int8           i8TempRear          = 0; 
.................... //     
.................... //    i8TempRear = g_stGPRSMsgSendQueue.m_i8Rear; 
.................... //    for(unsigned int8 ui8LoopCount = 0; ui8LoopCount < SIZE_GPRS_DATA_NODE_QUEUE; ui8LoopCount++) 
.................... //    { 
.................... //        i8TempRear++; 
.................... //         
.................... //        // Stuff data 
.................... //        g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[i8TempRear].m_ui32TimeStamp = ui32TimeStamp++; 
.................... //         
.................... //    } 
.................... //     
.................... //} 
....................  
.................... void StuffDummyHeader(void) 
.................... { 
....................     unsigned int16 ui16MachineID      = VYOMEC_250_LOO118_MACHINE_ID; 
....................     unsigned int8  ui8Variety         = 6; 
....................      
....................     // Stuff dummy message header 
....................     //g_stGPRSMsgHeader.m_ui8NoOfMessages = ui8NoOfMessage; 
....................     g_stGPRSMsgHeader.m_ui16MachineID   = ui16MachineID; 
....................     g_stGPRSMsgHeader.m_ui8Variety      = ui8Variety; 
....................      
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... // ############################################################# GPRS Connection Driver ################################################################## 
....................  
.................... unsigned int8 SetConnectionType(void) 
.................... { 
.................... 	unsigned int8 ui8fIsOKfound = 1; 
.................... 	g_fIsTimedOut = 0; 
.................... 	 
.................... 	// Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
.................... 	// Set connection type to GPRS. 
.................... 	//fputs("AT+SAPBR=3,1,\"CONTYPE\",\"GPRS\"\r", SIM900); 
.................... 	// Set timeout. 
.................... 	SetTimeout(5); 
.................... 	// Wait for response. 
.................... 	while(ui8fIsOKfound == 1 && g_fIsTimedOut == 0) 
.................... 	{ 
.................... 		// Restart WDT. 
....................         restart_wdt(); 
....................         for(unsigned int16 ui16ByteCount = 0;  ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................         { 
....................         	// Check for "OK". 
....................             if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................             { 
....................                 // Mark flag denoting "OK" was found. 
....................                 ui8fIsOKfound = 0; 
....................                 break; 
....................             } 
....................         } 
....................          
.................... 	} 
.................... 	 
.................... 	return ui8fIsOKfound; 
.................... } 
....................  
.................... unsigned int8 SetAPN(void) 
.................... { 
.................... 	unsigned int8 ui8fIsOKfound = 1; 
.................... 	g_fIsTimedOut = 0; 
.................... 	 
.................... 	// Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
.................... 	// Set APN. 
....................     //fputs("AT+SAPBR=3,1,\"APN\",\"www\"\r",SIM900); 
....................     // Set timeout. 
.................... 	SetTimeout(5); 
.................... 	// Wait for response. 
.................... 	while(ui8fIsOKfound == 1 && g_fIsTimedOut == 0) 
.................... 	{ 
.................... 		// Restart WDT. 
....................         restart_wdt(); 
....................         for(unsigned int16 ui16ByteCount = 0;  ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................         { 
....................         	// Check for "OK". 
....................             if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................             { 
....................                 // Mark flag denoting "OK" was found. 
....................                 ui8fIsOKfound = 0; 
....................                 break; 
....................             } 
....................         } 
.................... 	} 
.................... 	 
.................... 	return ui8fIsOKfound; 
.................... 	 
.................... } 
....................  
.................... unsigned int8 EnableGPRS(void) 
.................... { 
.................... 	unsigned int8 ui8fIsOKfound = 1; 
.................... 	g_fIsTimedOut = 0; 
.................... 	 
.................... 	// Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
.................... 	// Enable GPRS. 
....................     //fputs("AT+SAPBR=1,1\r", SIM900); 
....................     // Set timeout. 
.................... 	SetTimeout(5); 
.................... 	// Wait for response. 
.................... 	while(ui8fIsOKfound == 1 && g_fIsTimedOut == 0) 
.................... 	{ 
.................... 		// Restart WDT. 
....................         restart_wdt(); 
....................         for(unsigned int16 ui16ByteCount = 0;  ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................         { 
....................         	// Check for "OK". 
....................             if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................             { 
....................                 // Mark flag denoting "OK" was found. 
....................                 ui8fIsOKfound = 0; 
....................                 break; 
....................             } 
....................         } 
....................         
.................... 	} 
.................... 	 
.................... 	return ui8fIsOKfound; 
.................... } 
....................  
.................... unsigned int8 CheckGPRSConnection(void) 
.................... { 
.................... 	unsigned int8 ui8fIsOKFound = 1; 
....................     unsigned int8 ui8fIsFirstCharFound = 0; 
....................     unsigned int8 ui8FirstCharIndex = 0; 
....................     unsigned int8 ui8fIsSecondCharFound = 0; 
....................     unsigned int8 ui8StopCount = 0; 
....................     g_fIsTimedOut = 0; 
....................      
....................     // Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
....................     // Check GPRS Connection. 
....................     //fputs("AT+SAPBR=2,1\r",SIM900);    
....................     // Set timeout. 
....................     SetTimeout(5); 
....................     // Wait for response. 
....................     while(ui8fIsOKFound == 1 && g_fIsTimedOut == 0) 
....................     { 
....................     	// Restart WDT. 
....................         restart_wdt(); 
....................         // Reset variables. 
....................         ui8fIsFirstCharFound = 0; 
....................         ui8FirstCharIndex = 0; 
....................         ui8fIsSecondCharFound = 0; 
....................         ui8StopCount = 0; 
....................          
....................         // Loop Thorugh entire receive buffer. 
....................         for(unsigned int16 ui16ByteCount = 0;  ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................         { 
....................         	// Check for first character sequence. 
....................         	if(ui8fIsFirstCharFound == 0 && ui8fIsSecondCharFound == 0) 
....................         	{ 
....................                 // To check bearer after connect GPRS 
....................         		if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == '"' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == ',' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == '1' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == ',' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 4)] == '1' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 5)] == 0x20 && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 6)] == ':') 
....................                  { 
....................                  	// Set flag denoting first charcter sequence found. 
....................                  	ui8fIsFirstCharFound = 1; 
....................                  	// Copy the first character sequence index. 
....................                  	ui8FirstCharIndex = ui16ByteCount; 
....................                  } 
....................                  
....................         	} 
....................         	// Check for second character sequence. 
....................         	else if(ui8fIsFirstCharFound == 1 && ui8fIsSecondCharFound == 0)  // First character already found.  
....................         	{ 
....................         		if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == '"') 
....................         		{ 
....................         			// Loop from first character to second character to check if IP was received. 
....................                     for(unsigned int8 ui8LoopCount = ui8FirstCharIndex; ui8LoopCount <= ui16ByteCount; ui8LoopCount++) 
....................                     { 
....................                         // Check how many . is received.....should be 3. 
....................                         if(g_ui8SIM900RxBuffer[ui8LoopCount] == '.') 
....................                         { 
....................                             ui8StopCount++; 
....................                             // Check if all 3 stops have been received. 
....................                             if(ui8StopCount == 3) 
....................                             { 
....................                                 ui8fIsSecondCharFound = 1; 
....................                             } 
....................                         } 
....................                     } 
....................         		} 
....................         	} 
....................         	// First and second character both found........check for "OK". 
....................         	else if(ui8fIsFirstCharFound == 1 && ui8fIsSecondCharFound == 1) 
....................         	{ 
....................         		// Check for "OK". 
....................                 if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................                 { 
....................                     // Mark flag denoting "OK" was found. 
....................                     ui8fIsOKFound = 0; 
....................                 } 
....................         	} 
....................         } 
....................     } 
....................  
.................... 	return ui8fIsOKFound; 
.................... } 
....................  
.................... void SendCheckGPRSConnectionQuery(void) 
.................... { 
....................     g_fIsTimedOut = 0; 
....................      
....................     // Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
....................     // Check GPRS Connection. 
....................     //fputs("AT+SAPBR=2,1\r",SIM900);    
....................     // Set timeout. 
....................     SetTimeout(3); 
.................... } 
....................  
.................... unsigned int8 GPRSConnectionCheckQueryResponse() 
.................... { 
....................     unsigned int8 ui8fIsOKFound = 1; 
....................     unsigned int8 ui8fIsFirstCharFound = 0; 
....................     unsigned int8 ui8FirstCharIndex = 0; 
....................     unsigned int8 ui8fIsSecondCharFound = 0; 
....................     unsigned int8 ui8StopCount = 0; 
....................      
....................      
....................     // Loop through entire SIM900 Rx buffer 
....................     for(unsigned int16 ui16ByteCount = 0;  ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................     { 
....................         // Check for first character sequence. 
....................         if(ui8fIsFirstCharFound == 0 && ui8fIsSecondCharFound == 0) 
....................         { 
....................             // To check bearer after connect GPRS 
....................             if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == '"' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == ',' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == '1' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == ',' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 4)] == '1' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 5)] == 0x20 && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 6)] == ':') 
....................              { 
....................                 // Set flag denoting first charcter sequence found. 
....................                 ui8fIsFirstCharFound = 1; 
....................                 // Copy the first character sequence index. 
....................                 ui8FirstCharIndex = ui16ByteCount; 
....................              } 
....................  
....................         } 
....................         // Check for second character sequence. 
....................         else if(ui8fIsFirstCharFound == 1 && ui8fIsSecondCharFound == 0)  // First character already found.  
....................         { 
....................             if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == '"') 
....................             { 
....................                 // Loop from first character to second character to check if IP was received. 
....................                 for(unsigned int8 ui8LoopCount = ui8FirstCharIndex; ui8LoopCount <= ui16ByteCount; ui8LoopCount++) 
....................                 { 
....................                     // Check how many . is received.....should be 3. 
....................                     if(g_ui8SIM900RxBuffer[ui8LoopCount] == '.') 
....................                     { 
....................                         ui8StopCount++; 
....................                         // Check if all 3 stops have been received. 
....................                         if(ui8StopCount == 3) 
....................                         { 
....................                             ui8fIsSecondCharFound = 1; 
....................                         } 
....................                     } 
....................                 } 
....................             } 
....................         } 
....................         // First and second character both found........check for "OK". 
....................         else if(ui8fIsFirstCharFound == 1 && ui8fIsSecondCharFound == 1) 
....................         { 
....................             // Check for "OK". 
....................             if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................             { 
....................                 // Mark flag denoting "OK" was found. 
....................                 ui8fIsOKFound = 0; 
....................             } 
....................         } 
....................     }     
....................      
....................     return ui8fIsOKFound; 
.................... } 
....................  
.................... unsigned int8 DisconnectGPRS(void) 
.................... { 
.................... 	unsigned int8 ui8fIsOKFound = 2; 
.................... 	g_fIsTimedOut = 0; 
.................... 	 
.................... 	// Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
.................... 	// Disconnect GPRS. 
....................     //fputs("AT+SAPBR=0,1\r",SIM900); 
....................     Delay_milisecond_(5000);  
....................     // Set timeout. 
....................     SetTimeout(15); 
....................     // Wait for Response. 
....................     while(g_fIsTimedOut == 0 && ui8fIsOKFound == 2) 
....................     { 
....................     	// Restart WDT. 
....................         restart_wdt(); 
....................         // Loop through entire SIM900 Rx buffer. 
....................         for(unsigned int16 ui16ByteCount = 0;  ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................         { 
....................         	// Check for "OK". 
....................             if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................             { 
....................                 // Mark flag denoting "OK" was found. 
....................                 ui8fIsOKFound = 3; 
....................                 break; 
....................             } 
....................         } 
....................     }   
....................      
.................... 	return ui8fIsOKFound; 	 
.................... } 
....................  
.................... unsigned int8 CheckGPRSDisconnection(void) 
.................... { 
.................... 	unsigned int8 ui8fIsOKFound = 1; 
....................     unsigned int8 ui8fIsFirstCharFound = 0; 
....................     unsigned int8 ui8FirstCharIndex = 0; 
....................     unsigned int8 ui8fIsSecondCharFound = 0; 
....................     unsigned int8 ui8StopCount = 0; 
....................     g_fIsTimedOut = 0; 
....................      
....................     // Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
....................     // Check GPRS Connection. 
....................     //fputs("AT+SAPBR=2,1\r",SIM900);    
....................     // Set timeout. 
....................     SetTimeout(15); 
....................     // Wait for response. 
....................     while(ui8fIsOKFound == 1 && g_fIsTimedOut == 0) 
....................     { 
....................     	// Restart WDT. 
....................         restart_wdt(); 
....................         // Reset variables. 
....................         ui8fIsFirstCharFound = 0; 
....................         ui8FirstCharIndex = 0; 
....................         ui8fIsSecondCharFound = 0; 
....................         ui8StopCount = 0; 
....................          
....................         // Loop Thorugh entire receive buffer. 
....................         for(unsigned int16 ui16ByteCount = 0;  ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................         { 
....................         	// Check for first character sequence. 
....................         	if(ui8fIsFirstCharFound == 0 && ui8fIsSecondCharFound == 0) 
....................         	{ 
....................                 // To check bearer after connect GPRS 
....................         		if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == '"' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == ',' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == '3' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == ',' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 4)] == '1' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 5)] == 0x20 && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 6)] == ':') 
....................                  { 
....................                  	// Set flag denoting first charcter sequence found. 
....................                  	ui8fIsFirstCharFound = 1; 
....................                  	// Copy the first character sequence index. 
....................                  	ui8FirstCharIndex = ui16ByteCount; 
....................                  } 
....................                  
....................         	} 
....................         	// Check for second character sequence. 
....................         	else if(ui8fIsFirstCharFound == 1 && ui8fIsSecondCharFound == 0)  // First character already found.  
....................         	{ 
....................         		if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == '"') 
....................         		{ 
....................         			// Loop from first character to second character to check if IP was received. 
....................                     for(unsigned int8 ui8LoopCount = ui8FirstCharIndex; ui8LoopCount <= ui16ByteCount; ui8LoopCount++) 
....................                     { 
....................                         // Check how many . is received.....should be 3. 
....................                         if(g_ui8SIM900RxBuffer[ui8LoopCount] == '.') 
....................                         { 
....................                             ui8StopCount++; 
....................                             // Check if all 3 stops have been received. 
....................                             if(ui8StopCount == 3) 
....................                             { 
....................                                 ui8fIsSecondCharFound = 1; 
....................                             } 
....................                         } 
....................                     } 
....................         		} 
....................         	} 
....................         	// First and second character both found........check for "OK". 
....................         	else if(ui8fIsFirstCharFound == 1 && ui8fIsSecondCharFound == 1) 
....................         	{ 
....................         		// Check for "OK". 
....................                 if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................                 { 
....................                     // Mark flag denoting "OK" was found. 
....................                     ui8fIsOKFound = 0; 
....................                 } 
....................         	} 
....................         } 
....................     } 
....................  
.................... 	return ui8fIsOKFound; 
.................... } 
....................  
.................... // ############################################ End of GPRS Connection Driver ############################################################ 
....................  
....................  
.................... // ############################################# HTTP Application Driver #################################################################### 
....................  
.................... unsigned int8 EnableHttpMode(void) 
.................... { 
.................... 	unsigned int8 ui8fIsOKFound = 1; 
.................... 	g_fIsTimedOut = 0; 
....................  
.................... 	// Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
....................     // Enable HTTP Mode. 
....................     //fputs("AT+HTTPINIT\r",SIM900); 
....................     // Set timeout. 
....................     SetTimeout(5); 
....................     // Wait for response. 
....................     while(g_fIsTimedOut == 0 && ui8fIsOKFound == 1) 
....................     { 
....................         // Restart WDT. 
....................         restart_wdt(); 
....................         // Loop through the entire SIM900 Rx buffer. 
....................         for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................         { 
....................             // Check for "OK". 
....................             if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................             { 
....................                 // Mark flag denoting "OK" was found. 
....................                 ui8fIsOKFound = 0; 
....................                 break; 
....................             } 
....................         } 
....................     } 
....................     
....................     return ui8fIsOKFound; 
....................  
.................... }  
....................  
.................... void SendEnableHTTPModeRequest(void) 
.................... { 
....................     g_fIsTimedOut = 0; 
....................  
.................... 	// Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
....................     // Enable HTTP Mode. 
....................     //fputs("AT+HTTPINIT\r",SIM900); 
....................     // Set timeout. 
....................     SetTimeout(2); 
.................... } 
....................  
.................... unsigned int8 CheckEnableHTTPModeReqResponse(void) 
.................... { 
....................     unsigned int8 ui8fIsOKFound = 1; 
....................      
....................     for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................     { 
....................         // Check for "OK". 
....................         if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................            g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................            g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................            g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................         { 
....................             // Mark flag denoting "OK" was found. 
....................             ui8fIsOKFound = 0; 
....................             break; 
....................         } 
....................     } 
....................      
....................     return ui8fIsOKFound; 
.................... } 
....................  
.................... unsigned int8 EnableSecureHttpMode(void) 
.................... { 
.................... 	unsigned int8 ui8fIsOKFound = 1; 
.................... 	g_fIsTimedOut = 0; 
.................... 	 
.................... 	// Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
.................... 	// Enable HTTPS Mode. 
.................... 	//fputs("AT+HTTPSSL=1\r",SIM900); 
.................... 	// Set timeout. 
....................     SetTimeout(5); 
....................     // Wait for response. 
....................     while(g_fIsTimedOut == 0 && ui8fIsOKFound == 1) 
....................     {    
.................... 		  // Restart WDT. 
.................... 	       restart_wdt(); 
.................... 	       // Loop through the entire SIM900 Rx buffer. 
.................... 	       for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
.................... 	       {   
.................... 		  		// Check for "OK". 
.................... 		  		if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... 		     	   g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... 		     	   g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... 		     	   g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... 		  		{ 
.................... 		      		// Mark flag denoting "OK" was found. 
.................... 		      		ui8fIsOKFound = 0; 
.................... 		      		break; 
.................... 		  		} 
.................... 	   	  } 
.................... 	}	   
.................... 	 
.................... 	return ui8fIsOKFound; 
.................... } 
....................  
.................... unsigned int8 SetHTTPBearerProfileID(void) 
.................... { 
.................... 	unsigned int8 ui8fIsOKFound = 1; 
.................... 	g_fIsTimedOut = 0; 
....................  
.................... 	// Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
....................     // Set HTTP Bearer Profile ID. 
....................     ///fputs("AT+HTTPPARA=\"CID\",1\r",SIM900); 
....................     // Set timeout. 
....................     SetTimeout(5); 
....................     // Wait for response. 
....................     while(g_fIsTimedOut == 0 && ui8fIsOKFound == 1) 
....................     { 
....................         // Restart WDT. 
....................         restart_wdt(); 
....................         // Loop through the entire SIM900 Rx buffer. 
....................         for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................         { 
....................             // Check for "OK". 
....................             if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................             { 
....................                 // Mark flag denoting "OK" was found. 
....................                 ui8fIsOKFound = 0; 
....................                 break; 
....................             } 
....................         } 
....................     } 
....................      
....................     return ui8fIsOKFound; 
.................... } 
....................  
.................... void SendSetHTTPBearerProfileIDRequest(void) 
.................... { 
....................     g_fIsTimedOut = 0; 
....................      
....................     // Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
....................     // Set HTTP Bearer Profile ID. 
....................     //fputs("AT+HTTPPARA=\"CID\",1\r",SIM900); 
....................     // Set timeout. 
....................     SetTimeout(2); 
.................... } 
....................  
.................... unsigned int8 SetHTTPBearerProfileIDReqResponse(void) 
.................... { 
....................     unsigned int8 ui8fIsOKFound = 1; 
....................      
....................     // Loop through entire SIM900 Rx buffer 
....................     for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................     { 
....................         // Check for "OK". 
....................         if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................            g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................            g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................            g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................         { 
....................             // Mark flag denoting "OK" was found. 
....................             ui8fIsOKFound = 0; 
....................             break; 
....................         } 
....................     } 
....................      
....................     return ui8fIsOKFound; 
....................     ; 
.................... } 
....................  
.................... //unsigned int8 SetWebServiceURL(void) 
.................... //{ 
.................... //    unsigned int8 ui8fIsOKFound   = 1; 
.................... //    unsigned int8 ui8DataQueueLen = 0; 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //     
.................... //    //Increase GPRS send msg queue front. 
.................... //    if(g_stGPRSMsgSendQueue.m_i8Front != 0) 
.................... //    { 
.................... //        g_stGPRSMsgSendQueue.m_i8Front++; 
.................... //    }     
.................... //     
.................... //    // Check remaining data length of queue 
.................... //    ui8DataQueueLen = (g_stGPRSMsgSendQueue.m_i8Rear - g_stGPRSMsgSendQueue.m_i8Front + 1); 
.................... //     
.................... //    if(ui8DataQueueLen >= 3) 
.................... //    {    
.................... //        // Set number of message to send in message header 
.................... //        g_stGPRSMsgHeader.m_ui8NoOfMessages = 3; 
.................... //        // Set Web Service URL. 
.................... //        //unsigned int16 ui16StopID = 4; 
.................... //        fprintf (SIM900, "AT+HTTPPARA=\"URL\",\"http://www.trackweights.com/api/GetCtlrData.php?a=%u&b=%Lu&c=%u&m=%Lu$%Lu$%Lu$%u|%Lu$%Lu$%Lu$%u|%Lu$%Lu$%Lu$%u\"\r", g_stGPRSMsgHeader.m_ui8NoOfMessages, g_stGPRSMsgHeader.m_ui16MachineID, g_stGPRSMsgHeader.m_ui8Variety,  
.................... //                                                                                                                                                                     g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front++].m_ui8RejectionStatus, 
.................... //                                                                                                                                                                     g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front++].m_ui8RejectionStatus 
.................... //                                                                                                                                                                     g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui8RejectionStatus); 
.................... //        //fprintf (SIM900, "AT+HTTPPARA=\"URL\",\"http://www.vyomainnovus.com/ServiceSet.php?%Lu\"\r", g_ui16HTTPData++); 
.................... //        //fputs("AT+HTTPPARA=\"URL\",\"http://www.vyomainnovus.com/BusStandService.php?id=81\"\r",SIM900); 
.................... //    }  
.................... //    else  
.................... //    { 
.................... //        // Set number of message to send in message header. 
.................... //        g_stGPRSMsgHeader.m_ui8NoOfMessages = 1; 
.................... //        // Set Web Service URL. 
.................... //        fprintf (SIM900, "AT+HTTPPARA=\"URL\",\"http://www.trackweights.com/api/GetCtlrData.php?a=%u&b=%Lu&c=%u&m=%Lu$%Lu$%Lu$%u\"\r", g_stGPRSMsgHeader.m_ui8NoOfMessages, g_stGPRSMsgHeader.m_ui16MachineID, g_stGPRSMsgHeader.m_ui8Variety,  
.................... //                                                                                                                                       g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui8RejectionStatus); 
.................... //    }     
.................... //    // Set timeout. 
.................... //    SetTimeout(5); 
.................... //    // Wait for response. 
.................... //    while(g_fIsTimedOut == 0 && ui8fIsOKFound == 1) 
.................... //    { 
.................... //        // Restart WDT. 
.................... //        restart_wdt(); 
.................... //        // Loop through the entire SIM900 Rx buffer. 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            // Check for "OK". 
.................... //            if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... //               g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... //               g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... //               g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... //            { 
.................... //                // Mark flag denoting "OK" was found. 
.................... //                ui8fIsOKFound = 0; 
.................... //            }                
.................... //        } 
.................... //    } 
.................... //    
.................... //    return ui8fIsOKFound; 
.................... //} 
.................... // 
.................... //void SendSetWebServiceURLrequest(void) 
.................... //{ 
.................... //    //unsigned int8 ui8DataQueueLen = 0; 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //    //Increase GPRS send msg queue front. 
.................... //    g_stGPRSMsgSendQueue.m_i8Front++; 
.................... //     
.................... //     // Check remaining data length of queue 
.................... //    g_ui8DataQueueLen = (g_stGPRSMsgSendQueue.m_i8Rear - g_stGPRSMsgSendQueue.m_i8Front + 1); 
.................... //     
.................... //     
.................... //     if(g_ui8DataQueueLen >= 5) 
.................... //    {    
.................... //        // Set number of message to send in message header 
.................... //\ 
.................... //         g_stGPRSMsgHeader.m_ui8NoOfMessages = 5; 
.................... //        // Set Web Service URL. 
.................... //        //unsigned int16 ui16StopID = 4; 
.................... //        fprintf (SIM900, "AT+HTTPPARA=\"URL\",\"http://www.trackweights.com/api/GetCtlrData.php?a=%u&b=%Lu&c=%u&m=%Lu$%Lu$%Lu$%u|%Lu$%Lu$%Lu$%u|%Lu$%Lu$%Lu$%u|%Lu$%Lu$%Lu$%u|%Lu$%Lu$%Lu$%u\"\r", g_stGPRSMsgHeader.m_ui8NoOfMessages, g_stGPRSMsgHeader.m_ui16MachineID, g_stGPRSMsgHeader.m_ui8Variety,  
.................... //                                                                                                                                                                                                   g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front++].m_ui8RejectionStatus, 
.................... //                                                                                                                                                                                                   g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front++].m_ui8RejectionStatus, 
.................... //                                                                                                                                                                                                   g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front++].m_ui8RejectionStatus, 
.................... //                                                                                                                                                                                                   g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front++].m_ui8RejectionStatus, 
.................... //                                                                                                                                                                                                   g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui8RejectionStatus); 
.................... //        //fprintf (SIM900, "AT+HTTPPARA=\"URL\",\"http://www.vyomainnovus.com/ServiceSet.php?%Lu\"\r", g_ui16HTTPData++); 
.................... //        //fputs("AT+HTTPPARA=\"URL\",\"http://www.vyomainnovus.com/BusStandService.php?id=81\"\r",SIM900); 
.................... //    }  
.................... //    else  
.................... //    { 
.................... //        // Set number of message to send in message header. 
.................... //        g_stGPRSMsgHeader.m_ui8NoOfMessages = 1; 
.................... //        // Set Web Service URL. 
.................... //        fprintf (SIM900, "AT+HTTPPARA=\"URL\",\"http://www.trackweights.com/api/GetCtlrData.php?a=%u&b=%Lu&c=%u&m=%Lu$%Lu$%Lu$%u\"\r", g_stGPRSMsgHeader.m_ui8NoOfMessages, g_stGPRSMsgHeader.m_ui16MachineID, g_stGPRSMsgHeader.m_ui8Variety,  
.................... //                                                                                                                                       g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui8RejectionStatus); 
.................... //         
.................... //         
.................... //    }     
.................... //    // Set timeout. 
.................... //    SetTimeout(2); 
.................... //} 
....................  
.................... unsigned int8 SetWebServiceURLReqresponse(void) 
.................... { 
....................     unsigned int8 ui8fIsOKFound   = 1; 
....................      
....................     // Loop through entire SIM900 Rx buffer 
....................     for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................     { 
....................         // Check for "OK". 
....................         if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................            g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................            g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................            g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................         { 
....................             // Mark flag denoting "OK" was found. 
....................             ui8fIsOKFound = 0; 
....................         }    
....................     } 
....................      
....................     return ui8fIsOKFound; 
.................... } 
....................  
.................... unsigned int8 GetWebServiceURL(void) 
.................... { 
.................... 	unsigned int8 ui8fIsOKFound = 1; 
.................... 	g_fIsTimedOut = 0; 
.................... 	 
.................... 	// Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
.................... 	// Set the URL to Read data. 
.................... 	//fputs("AT+HTTPPARA=\"URL\",\"http://www.vyomainnovus.com/Service.php\"\r", SIM900); 
.................... 	// Set Timeout. 
.................... 	SetTimeout(15); 
.................... 	// Wait for Response. 
.................... 	while(g_fIsTimedOut == 0 && ui8fIsOKFound == 1) 
.................... 	{ 
.................... 		// Restart WDT. 
....................         restart_wdt(); 
....................         // Loop through the entire SIM900 Rx buffer. 
....................         for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................         { 
....................         	// Check for "OK". 
....................             if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................             { 
....................                 // Mark flag denoting "OK" was found. 
....................                 ui8fIsOKFound = 0; 
....................                 break; 
....................             } 
....................         } 
.................... 	} 
.................... 	 
.................... 	return ui8fIsOKFound; 
.................... }  
....................  
....................  
.................... unsigned int8 StartHTTPGETSession(void) 
.................... { 
.................... 	unsigned int8 ui8fIsOKFound 	 = 1; 
....................     unsigned int8 ui8IsColonFound 	 = 0; 
....................     unsigned int8 ui8CommaCount 	 = 0; 
....................     unsigned int8 ui8IsCommaFound 	 = 0; 
....................     unsigned int8 ui8FirstCommaIndex = 0;  
....................      
....................      
....................     // Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
.................... 	// Set Web Service Action. 
....................     //fputs("AT+HTTPACTION=0\r",SIM900); 
....................     // Wait for 10 seconds to properly hit the URL. 
....................     Delay_milisecond_(5000);  /* This will take sometimes more time */ 
....................     // Set timeout. 
....................     SetTimeout(10); 
....................     // Reset variable. 
....................     g_fIsTimedOut = 0; 
....................     // Wait for response. 
....................     while(g_fIsTimedOut == 0 && ui8fIsOKFound == 1) 
....................     { 
....................     	// Restart WDT. 
....................         restart_wdt(); 
....................         // Reset variables. 
....................         ui8IsColonFound = 0; 
....................         ui8CommaCount = 0; 
....................         ui8IsCommaFound = 0; 
....................         ui8FirstCommaIndex = 0; 
....................          
....................         // Loop through the entire SIM900 Rx buffer. 
....................         for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................         { 
....................         	// Looking for First character sequence..i.e ':' 
....................         	if(ui8IsColonFound == 0 && ui8IsCommaFound == 0) 
....................         	{ 
....................         		if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == ':' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 'N' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'O' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'I' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 4)] == 'T' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 5)] == 'C' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 6)] == 'A' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 7)] == 'P' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 8)] == 'T' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 9)] == 'T' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 10)] == 'H' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 11)] == '+' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 12)] == 0x0A && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 13)] == 0x0D && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 14)] == 0x0A && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 15)] == 0x0D && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 16)] == 'K' && 
....................                    g_ui8SIM900RxBuffer[(ui16ByteCount - 17)] == 'O') 
....................                 { 
....................                     // Mark flag denoting colon is found. 
....................                     ui8IsColonFound = 1; 
....................                 } 
....................         	} 
....................         	// Looking for second character sequence..i.e ',' 
....................         	else if (ui8IsColonFound == 1 && ui8IsCommaFound == 0) // First character sequence found. 
....................         	{ 
.................... 	        	// Look for comma..',' 
....................         		if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == ',') 
....................         		{ 
.................... 	        		if(!ui8FirstCommaIndex) 
.................... 	        		{ 
.................... 	        			// Copy the index of the first comma. 
.................... 	        			ui8FirstCommaIndex = ui16ByteCount; 
.................... 	        		} 
....................         			// Comma found...increment counter. 
....................                     ui8CommaCount++; 
....................                     // Check if 2 comma were received. 
....................                     if(ui8CommaCount == 2) 
....................                     { 
....................                     	// Mark flag denoting second comma found. 
....................                     	ui8IsCommaFound = 1; 
....................                     } 
....................         		} 
....................         	} 
....................         	// Both First and second character sequence found..check the received data. 
....................         	else if(ui8IsColonFound == 1 && ui8IsCommaFound == 1) 
....................         	{ 
....................         		if(g_ui8SIM900RxBuffer[(ui8FirstCommaIndex - 1)] == '0') 
....................         		{ 
....................         			if(g_ui8SIM900RxBuffer[(ui8FirstCommaIndex + 1)] == '2' && 
....................         			   g_ui8SIM900RxBuffer[(ui8FirstCommaIndex + 2)] == '0' && 
....................         			   g_ui8SIM900RxBuffer[(ui8FirstCommaIndex + 3)] == '0') 
....................         			{ 
....................         				// Mark flag denoting all received data is ok...send data successfully. 
....................         				ui8fIsOKFound = 0; 
....................         				break; 
....................         			} 
....................         		} 
....................         	} 
....................         } 
....................      
....................     } 
....................      
....................     return ui8fIsOKFound; 
.................... } 
....................  
.................... void SendStartHTTPGetSessionRequest(void) 
.................... { 
....................     g_fIsTimedOut = 0; 
....................      
....................     // Reset Rx Buffer. 
.................... 	ResetSIM900RxBuffer(); 
.................... 	// Set Web Service Action. 
....................     //fputs("AT+HTTPACTION=0\r",SIM900); 
....................     // Set timeout. 
....................     SetTimeout(20); 
....................      
.................... } 
....................  
.................... unsigned int8 StartHTTPGetSessionReqResponse(void) 
.................... { 
....................     unsigned int8 ui8fIsOKFound 	 = 1; 
....................     unsigned int8 ui8IsColonFound 	 = 0; 
....................     unsigned int8 ui8CommaCount 	 = 0; 
....................     unsigned int8 ui8IsCommaFound 	 = 0; 
....................     unsigned int8 ui8FirstCommaIndex = 0;  
....................      
....................      
....................     // Loop through the entire SIM900 Rx buffer. 
....................     for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16SIM900RxByteCount; ui16ByteCount++) 
....................     { 
....................     // Looking for First character sequence..i.e ':' 
....................         if(ui8IsColonFound == 0 && ui8IsCommaFound == 0) 
....................         { 
....................             if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == ':' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 1)] == 'N' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 2)] == 'O' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 3)] == 'I' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 4)] == 'T' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 5)] == 'C' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 6)] == 'A' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 7)] == 'P' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 8)] == 'T' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 9)] == 'T' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 10)] == 'H' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 11)] == '+' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 12)] == 0x0A && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 13)] == 0x0D && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 14)] == 0x0A && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 15)] == 0x0D && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 16)] == 'K' && 
....................                g_ui8SIM900RxBuffer[(ui16ByteCount - 17)] == 'O') 
....................             { 
....................                 // Mark flag denoting colon is found. 
....................                 ui8IsColonFound = 1; 
....................             } 
....................         } 
....................         // Looking for second character sequence..i.e ',' 
....................         else if (ui8IsColonFound == 1 && ui8IsCommaFound == 0) // First character sequence found. 
....................         { 
....................             // Look for comma..',' 
....................             if(g_ui8SIM900RxBuffer[(ui16ByteCount - 0)] == ',') 
....................             { 
....................                 if(!ui8FirstCommaIndex) 
....................                 { 
....................                     // Copy the index of the first comma. 
....................                     ui8FirstCommaIndex = ui16ByteCount; 
....................                 } 
....................                 // Comma found...increment counter. 
....................                 ui8CommaCount++; 
....................                 // Check if 2 comma were received. 
....................                 if(ui8CommaCount == 2) 
....................                 { 
....................                     // Mark flag denoting second comma found. 
....................                     ui8IsCommaFound = 1; 
....................                 } 
....................             } 
....................         } 
....................         // Both First and second character sequence found..check the received data. 
....................         else if(ui8IsColonFound == 1 && ui8IsCommaFound == 1) 
....................         { 
....................             if(g_ui8SIM900RxBuffer[(ui8FirstCommaIndex - 1)] == '0') 
....................             { 
....................                 if(g_ui8SIM900RxBuffer[(ui8FirstCommaIndex + 1)] == '2' && 
....................                    g_ui8SIM900RxBuffer[(ui8FirstCommaIndex + 2)] == '0' && 
....................                    g_ui8SIM900RxBuffer[(ui8FirstCommaIndex + 3)] == '0') 
....................                 { 
....................                     // Mark flag denoting all received data is ok...send data successfully. 
....................                     ui8fIsOKFound = 0; 
....................                     break; 
....................                 } 
....................             } 
....................         } 
....................     } 
....................      
....................     return ui8fIsOKFound; 
.................... } 
....................  
.................... void TerminateHttpSession(void) 
.................... { 
....................     // Set command to terminate HTTP Session. 
....................     //fputs("AT+HTTPTERM\r",SIM900); 
....................     delay_ms(3000); 
.................... } 
....................  
.................... void TermHTTPSession(void) 
.................... { 
....................     // Set command to terminate HTTP Session. 
....................     //fputs("AT+HTTPTERM\r",SIM900); 
....................      
....................     // Set timeout 
....................     //SetTimeout(3); 
.................... } 
....................  
.................... // ########################################################## End of HTTP Application Driver ############################################################# 
....................  
.................... #endif	/* VM_SIM900_GPRS_CONFIG_H */ 
....................  
....................  
.................... #include "viModbusGlobal.h" 
.................... #ifndef _VI_MODBUS_GOBAL_H_ 
.................... #define _VI_MODBUS_GOBAL_H_ 
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE 64   
.................... #define MODBUS_REG_BUFFER_SIZE 10    
....................   
.................... #define MODBUS_REG_OUTPUT_0  	0  
.................... #define MODBUS_REG_OUTPUT_1		1 
.................... #define MODBUS_REG_OUTPUT_2		2 
.................... #define MODBUS_REG_OUTPUT_3		4 
.................... #define MODBUS_REG_OUTPUT_4		8 
.................... #define MODBUS_REG_OUTPUT_5		16 
.................... #define MODBUS_REG_OUTPUT_6		32 
.................... #define MODBUS_REG_OUTPUT_7		64 
.................... #define MODBUS_REG_OUTPUT_8		128 
.................... #define MODBUS_REG_OUTPUT_9		256 
.................... #define MODBUS_REG_OUTPUT_10	512 
.................... #define MODBUS_REG_OUTPUT_11	1024 
.................... #define MODBUS_REG_OUTPUT_12	2048 
.................... #define MODBUS_REG_OUTPUT_13	4096 
.................... #define MODBUS_REG_OUTPUT_14	8192 
.................... #define MODBUS_REG_OUTPUT_15	16384 
.................... #define MODBUS_REG_OUTPUT_16	32768 
....................  
....................  
.................... enum function { 
.................... 	RS485_FUNCTION_READ_COILS                 = 1, 
.................... 	RS485_FUNCTION_READ_DISCRETE_INPUT        = 2, 
.................... 	RS485_FUNCTION_READ_HOLDING_REGISTERS     = 3, 
.................... 	RS485_FUNCTION_READ_INPUT_REGISTERS       = 4, 
.................... 	RS485_FUNCTION_WRITE_SINGLE_COIL          = 5, 
.................... 	RS485_FUNCTION_WRITE_SINGLE_REGISTER      = 6, 
.................... 	RS485_FUNCTION_READ_MULTIPLE_REGISTERS    = 15, 
.................... 	RS485_FUNCTION_WRITE_MULTIPLE_REGISTERS   = 16		 
.................... }; 
....................  
.................... enum exception { 
.................... 	RS485_ILLEGAL_FUNCTION        = 1,	 
.................... 	RS485_ILLEGAL_DATA_ADDRESS    = 2, 
.................... 	RS485_ILLEGAL_DATA_VALUE      = 3, 
.................... 	RS485_SLAVE_DEVICE_FAILED     = 4, 
.................... 	RS485_ACKNOWLAGE              = 5, 
.................... 	RS485_SLAVE_DEVICE_BUSY       = 6, 
.................... 	RS485_NEG_ACKNOWLAGE          = 7, 
.................... 	RS485_MEMORY_PARITY_ERROR     = 8, 
.................... 	RS485_GETWAY_PATH             = 10, 
.................... 	RS485_GETWAY_DEVICE           = 11	 
.................... }; 
....................  
.................... typedef struct 
.................... {  
....................    unsigned int8    ui8Slaveid;  
....................    unsigned int16   u16Address; 
....................    unsigned int16   u16LenData;                       //number of bytes in the message received  
....................    function         func;                           //the function of the message received  
....................    exception        error;                         //error recieved, if any  
....................    unsigned int16   ui16RegisterData; 
.................... //   unsigned int8    ui8Data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received  
....................    BOOLEAN          bDataProcessed; 
....................    unsigned int8    ui8NoRegDataBytes; 
....................    unsigned int16   ui16RegisterDataArr[MODBUS_REG_BUFFER_SIZE]; 
....................    unsigned int32   u32RegData; 
.................... } Modbus_Rx;  
....................  
.................... Modbus_Rx g_ModbusRx; 
....................  
.................... unsigned int16 g_ui16RegisterForCount; 
.................... unsigned int16 g_ui16RegisterForCounter1_1; 
.................... unsigned int16 g_ui16RegisterForCounter1_2; 
.................... unsigned int16 g_ui16RegisterForCounter2_1; 
.................... unsigned int16 g_ui16RegisterForCounter2_2; 
.................... unsigned int16 g_ui16RegisterForCounter3_1; 
.................... unsigned int16 g_ui16RegisterForCounter3_2; 
....................  
.................... unsigned int16 g_ui16Register0_1; 
.................... unsigned int16 g_ui16Register0_2; 
.................... unsigned int16 g_ui16Register1000_1; 
.................... unsigned int16 g_ui16Register1000_2; 
.................... unsigned int16 g_ui16Register2000_1; 
.................... unsigned int16 g_ui16Register2000_2; 
.................... unsigned int16 g_ui16Register3000_1; 
.................... unsigned int16 g_ui16Register3000_2; 
.................... unsigned int16 g_ui16Register4000_1; 
.................... unsigned int16 g_ui16Register4000_2; 
.................... unsigned int16 g_ui16Register5000_1; 
.................... unsigned int16 g_ui16Register5000_2; 
.................... unsigned int16 g_ui16Register6000_1; 
.................... unsigned int16 g_ui16Register6000_2; 
.................... unsigned int16 g_ui16Register7000_1; 
.................... unsigned int16 g_ui16Register7000_2; 
.................... unsigned int16 g_ui16Register8000_1; 
.................... unsigned int16 g_ui16Register8000_2; 
.................... unsigned int16 g_ui16Register9000_1; 
.................... unsigned int16 g_ui16Register9000_2; 
.................... unsigned int16 g_ui16Register10000_1; 
.................... unsigned int16 g_ui16Register10000_2; 
....................  
.................... unsigned int16 g_ui16RegisterAvgWeight; 
.................... unsigned int16 g_ui16RegisterTolPv; 
.................... unsigned int16 g_ui16RegisterTolNv; 
.................... unsigned int16 g_ui16RegisterCurrProductIndex; 
....................  
.................... #endif /* _VI_MODBUS_GOBAL_H_ */ 
....................  
....................  
.................... #include "vmGSMM66_GPRSConfig.h" 
.................... /*  
....................  * File:   vmGSMM66_GPRSConfig.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on January 22, 2019, 6:50 PM 
....................  */ 
....................  
.................... #ifndef VM_GSMM66_GPRS_CONFIG_H 
.................... #define	VM_GSMM66_GPRS_CONFIG_H 
....................  
.................... #include "vmSIM900_GPRSConfig.h" 
.................... #include "viRS485Config.h" 
....................  
.................... // Stuff Machine ID and Variety type in GPRS Message header. 
.................... // Amta plant(Line 2) -> Machine ID - 2 and Marie Gold variety Type - 3. 
.................... // Delta Foods Machine ID - 4 
.................... // Super Snacks Machine ID - 5 
.................... #define  MACHINE_ID                2  // Delta 
....................      
.................... #define   SIZE_GSMM66_RX_BUFFER                 500 
.................... #define   SIZE_GPRS_DATA_NODE_QUEUE             100 
....................  
.................... #define   GPRS_DATA_SENDING_SEQUENCE_1          1 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_2          2 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_3          3 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_4          4 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_5          5 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_6          6 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_7          7 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_8          8 
....................  
....................  
.................... typedef struct _ST_GPRS_DATA_NODE 
.................... { 
....................     unsigned int32 m_ui32TimeStamp; 
....................     unsigned int16 m_ui16SequenceNo; 
....................     unsigned int16 m_ui16ItemWeight; 
....................     unsigned int8  m_ui8RejectionStatus; 
.................... } ST_GPRS_DATA_NODE; 
....................  
.................... typedef struct _ST_GPRS_MSG_SEND_QUEUE 
.................... { 
....................     ST_GPRS_DATA_NODE m_stArrGPRSDataNode[SIZE_GPRS_DATA_NODE_QUEUE]; 
....................     int8              m_i8Front; 
....................     int8              m_i8Rear; 
.................... } ST_GPRS_MSG_SEND_QUEUE; 
....................  
.................... typedef struct _ST_PROD_M_CURR_BOX_DATA 
.................... { 
....................     int16             m_i16BoxWeight; 
....................     unsigned int16    m_ui16SequenceNo; 
....................     unsigned int16    m_ui16RejectionStatus; 
....................     unsigned int32    m_ui32TimeStamp; 
.................... } ST_PROD_M_CURR_BOX_DATA; 
....................  
.................... // ***************************************************************************** 
.................... // ***************** Below -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
.................... unsigned int8       g_ui8M66RxBuffer[SIZE_GSMM66_RX_BUFFER]               = {0}; 
.................... unsigned int16      g_ui16M66RxByteCount                                  = 0; 
.................... unsigned int8       g_ui8URLInputByteLength                               = 0; 
.................... unsigned int8       g_ui8URLInputTime                                     = 0; 
.................... //unsigned int8       g_ui8DataToSend                                       = 0; 
.................... unsigned int16      g_ui16Itm1SequenceNumber                              = 1; 
.................... unsigned int16      g_ui16Itm2SequenceNumber                              = 2; 
.................... unsigned int16      g_ui16ItemWeight                                      = 1999; 
.................... unsigned int8       g_ui8DataQueueLen                                     = 0; 
.................... unsigned int8       g_fGPRSSequence                                       = 0; 
.................... unsigned int8       g_fGPRSFailureBit                                     = 0; 
....................  
.................... ST_GPRS_MSG_SEND_QUEUE   g_stGPRSMsgSendQueue; 
.................... ST_PROD_M_CURR_BOX_DATA  g_stProdModeCurrBoxData; 
.................... // ***************************************************************************** 
.................... // ***************** Above -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
.................... void ResetGSMM66RxBuffer(void) 
.................... { 
....................     // Reset whole buffer. 
....................     memset(g_ui8M66RxBuffer, 0, SIZE_GSMM66_RX_BUFFER); 
....................      
....................     // Reset byte count 
....................     g_ui16M66RxByteCount = 0; 
.................... } 
....................  
.................... unsigned int8 CountDataSize(unsigned int32 ui32Data) 
.................... { 
....................     unsigned int8 ui8DataLen = 0; 
....................      
....................     if(ui32Data <= 9) 
....................     { 
....................         ui8DataLen = 1; 
....................     } 
....................     else if(ui32Data <= 99) 
....................     { 
....................         ui8DataLen = 2; 
....................     } 
....................     else if(ui32Data <= 999) 
....................     { 
....................         ui8DataLen = 3; 
....................     } 
....................     else if(ui32Data <= 9999) 
....................     { 
....................         ui8DataLen = 4; 
....................     } 
....................     else if(ui32Data <= 99999) 
....................     { 
....................         ui8DataLen = 5; 
....................     } 
....................     else if(ui32Data <= 999999) 
....................     { 
....................         ui8DataLen = 6; 
....................     } 
....................     else if(ui32Data <= 9999999) 
....................     { 
....................         ui8DataLen = 7; 
....................     } 
....................     else if(ui32Data <= 99999999) 
....................     { 
....................         ui8DataLen = 8; 
....................     } 
....................     else if(ui32Data <= 999999999) 
....................     { 
....................         ui8DataLen = 9; 
....................     } 
....................     else if(ui32Data <= 9999999999) 
....................     { 
....................         ui8DataLen = 10; 
....................     } 
....................     else if(ui32Data <= 99999999999) 
....................     { 
....................         ui8DataLen = 11; 
....................     } 
....................     else if(ui32Data <= 999999999999) 
....................     { 
....................         ui8DataLen = 12; 
....................     } 
....................      
....................     return ui8DataLen; 
.................... } 
....................  
.................... void CheckURLInputByteLength(void) 
.................... { 
....................     unsigned int8 ui8DataByte = 0; 
....................      
....................     // Check remaining data in the GPRS queue is greater equals than five or not. 
....................     if(g_ui8DataQueueLen >= 5) 
....................     { 
....................         // Five accumulated data node has to send. 
....................         // Set number of messages to send is five. 
....................         g_stGPRSMsgHeader.m_ui8NoOfMessages = 5; 
....................          
....................         // Basic input byte has to send is 69 bytes. add up additional bytes per no of messages. 
....................         // Add data node separator "|" for input byte length. 
....................         g_ui8URLInputByteLength = g_ui8URLInputByteLength + (g_stGPRSMsgHeader.m_ui8NoOfMessages - 1); 
....................         // Add data separator "$" for each data node. 
....................         g_ui8URLInputByteLength = g_ui8URLInputByteLength + (g_stGPRSMsgHeader.m_ui8NoOfMessages * 3); 
....................         // Now loop through the data queue to count input byte length. 
....................         for(unsigned int8 ui8LoopCount = 0; ui8LoopCount < g_stGPRSMsgHeader.m_ui8NoOfMessages; ui8LoopCount++) 
....................         { 
....................             // Check for TimeStamp. 
....................             ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front + ui8LoopCount].m_ui32TimeStamp); 
....................             // Add up data byte. 
....................             g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
....................             // Check for Sequence number. 
....................             ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front + ui8LoopCount].m_ui16SequenceNo); 
....................             // Add up data byte. 
....................             g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
....................             // Check for Item weight. 
....................             ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front + ui8LoopCount].m_ui16ItemWeight); 
....................             // Add up data byte. 
....................             g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
....................             // Check for Rejection status. 
....................             ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front + ui8LoopCount].m_ui8RejectionStatus); 
....................             // Add up data byte. 
....................             g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
....................                  
....................         } 
....................     } 
....................     else 
....................     { 
....................         // Single data node has to send. 
....................         // Set number of messages to send is one. 
....................         g_stGPRSMsgHeader.m_ui8NoOfMessages = 1; 
....................          
....................         // Basic input byte has to send is 69 bytes. add up additional bytes per no of messages. 
....................         // No data node separator needed. Only data separator for each node will be counted. 
....................         // Add data separator "$" for each data node. 
....................         g_ui8URLInputByteLength = g_ui8URLInputByteLength + (g_stGPRSMsgHeader.m_ui8NoOfMessages * 3); 
....................          
....................         // Now count data size of each data for single data node. 
....................         // Check for TimeStamp. 
....................         ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp); 
....................         // Add up data byte. 
....................         g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
....................         // Check for Sequence number. 
....................         ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front ].m_ui16SequenceNo); 
....................         // Add up data byte. 
....................         g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
....................         // Check for Item weight. 
....................         ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight); 
....................         // Add up data byte. 
....................         g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
....................         // Check for Rejection status. 
....................         ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui8RejectionStatus); 
....................         // Add up data byte. 
....................         g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
....................          
....................     } 
.................... } 
....................  
.................... void StuffDummyTimeStamp(void) 
.................... { 
....................     unsigned int16 ui16DummyTimeStamp = 11111; 
....................     unsigned int8  ui8LoopCount       = 0; 
....................      
....................     for(ui8LoopCount = 0; ui8LoopCount < SIZE_GPRS_DATA_NODE_QUEUE; ui8LoopCount++) 
....................     { 
....................         // Stuff Data. 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui32TimeStamp = ui16DummyTimeStamp++; 
....................     } 
.................... } 
....................  
....................  
.................... void InitializeGPRSMsgQueue(void) 
.................... { 
....................     // Initialize front and rear of the queue 
....................     g_stGPRSMsgSendQueue.m_i8Front = -1; 
....................     g_stGPRSMsgSendQueue.m_i8Rear = -1; 
....................      
....................     // Initialize each queue element 
....................     for(unsigned int8 ui8LoopCount = 0; ui8LoopCount < SIZE_GPRS_DATA_NODE_QUEUE; ui8LoopCount++) 
....................     { 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui16ItemWeight = 0; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui16SequenceNo = 0; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui32TimeStamp  = 0; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui8RejectionStatus = 0; 
....................     } 
....................  
.................... } 
....................  
.................... unsigned int8 IsGPRSMsgQueueEmpty(void) 
.................... { 
....................     unsigned int8 ui8QueueStatus = 0; 
....................      
....................     if(g_stGPRSMsgSendQueue.m_i8Rear == -1) /* Queue at initial state; queue is empty */ 
....................     { 
....................         ui8QueueStatus = 1; 
....................     } 
....................     else if(g_stGPRSMsgSendQueue.m_i8Front == g_stGPRSMsgSendQueue.m_i8Rear) /* All data sent; queue is empty */ 
....................     { 
....................         // Update flag that last element present in the queue. 
....................         g_fIsLastElementInGPRSQueue = 1; 
....................          
....................         // Reset GPRS message queue 
....................         //InitializeGPRSMsgQueue(); 
....................          
....................         //ui8QueueStatus = 1; 
....................     } 
....................     else if(g_stGPRSMsgSendQueue.m_i8Front == g_stGPRSMsgSendQueue.m_i8Rear + 1) 
....................     { 
....................         // Reset GPRS message queue 
....................         InitializeGPRSMsgQueue(); 
....................         // Stuff dummy time stamp. 
....................         StuffDummyTimeStamp(); 
....................          
....................         // Update data availability status in queue. 
....................         ui8QueueStatus = 1; 
....................     } 
....................      
....................     return ui8QueueStatus; 
.................... } 
....................  
.................... void InsertInGPRSMsgQueue() 
.................... { 
....................     if ((g_stGPRSMsgSendQueue.m_i8Front == 0 && g_stGPRSMsgSendQueue.m_i8Rear == SIZE_GPRS_DATA_NODE_QUEUE - 1) ||  
....................             (g_stGPRSMsgSendQueue.m_i8Front == g_stGPRSMsgSendQueue.m_i8Rear + 1))  
....................     {  
....................         //printf("\nQueue is Full");  
....................         return;  
....................     } 
....................      
....................     else if (g_stGPRSMsgSendQueue.m_i8Rear == -1) /* Insert First Element */ 
....................     {  
....................         // Initialize queue front and rear. 
....................         g_stGPRSMsgSendQueue.m_i8Rear = 0; 
....................         g_stGPRSMsgSendQueue.m_i8Front = 0; 
....................          
....................         // Insert Data 
....................         //arr[g_stIBCDataSendQueue.m_i8Rear] = value; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16SequenceNo = g_stProdModeCurrBoxData.m_ui16SequenceNo; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16ItemWeight = g_stProdModeCurrBoxData.m_i16BoxWeight; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui8RejectionStatus = (unsigned int8)g_stProdModeCurrBoxData.m_ui16RejectionStatus; 
....................         //g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui32TimeStamp = g_stProdModeCurrBoxData.m_ui32TimeStamp; 
....................     }  
....................      
....................     else if (g_stGPRSMsgSendQueue.m_i8Rear == SIZE_GPRS_DATA_NODE_QUEUE - 1 && g_stGPRSMsgSendQueue.m_i8Front != 0) /* Rear reached at last position */ 
....................     {  
....................         // Make queue circular 
....................         g_stGPRSMsgSendQueue.m_i8Rear = 0;  
....................          
....................         // Insert data 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16SequenceNo = g_stProdModeCurrBoxData.m_ui16SequenceNo; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16ItemWeight = g_stProdModeCurrBoxData.m_i16BoxWeight; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui8RejectionStatus = (unsigned int8)g_stProdModeCurrBoxData.m_ui16RejectionStatus;  
....................         //g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui32TimeStamp = g_stProdModeCurrBoxData.m_ui32TimeStamp; 
....................     }  
....................      
....................     else 
....................     {  
....................         // Normal data insertion..not in boundary condition 
....................         g_stGPRSMsgSendQueue.m_i8Rear++;  
....................          
....................         // Insert data 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16SequenceNo = g_stProdModeCurrBoxData.m_ui16SequenceNo; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16ItemWeight = g_stProdModeCurrBoxData.m_i16BoxWeight; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui8RejectionStatus = (unsigned int8)g_stProdModeCurrBoxData.m_ui16RejectionStatus; 
....................         //g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui32TimeStamp = g_stProdModeCurrBoxData.m_ui32TimeStamp; 
....................     }  
.................... } 
....................  
.................... void InitializeGPRSMsgHeader(void) 
.................... { 
....................     // Stuff Machine ID and Variety type in GPRS Message header. 
....................     // Amta plant(Line 2) -> Machine ID - 2 and Marie Gold variety Type - 3. 
....................     // Delta Foods Machine ID - 4 
....................     // Super Snacks Machine ID - 5 
....................     g_stGPRSMsgHeader.m_ui16MachineID = MACHINE_ID;  // Delta 
....................     g_stGPRSMsgHeader.m_ui8Variety = 4; 
.................... } 
....................  
.................... void StuffGPRSMSgQueueDummy(void) 
.................... { 
....................     unsigned int8  ui8NoOfMessage     = 5; 
....................     unsigned int16 ui16MachineID      = 1; 
....................     unsigned int8  ui8Variety         = 6; 
....................      
....................     unsigned int32 ui32TimeStamp       = 4545; 
....................     unsigned int16 ui16SequenceNo      = 1; 
....................     int16          i16Itemweight       = 7000; 
....................     unsigned int16 ui16Rejectionstatus = 1; 
....................      
....................     // Stuff dummy message header 
....................     g_stGPRSMsgHeader.m_ui8NoOfMessages = ui8NoOfMessage; 
....................     g_stGPRSMsgHeader.m_ui16MachineID   = ui16MachineID; 
....................     g_stGPRSMsgHeader.m_ui8Variety      = ui8Variety; 
....................      
....................     for(unsigned int8 ui8LoopCount = 0; ui8LoopCount < SIZE_GPRS_DATA_NODE_QUEUE; ui8LoopCount++) 
....................     { 
....................         g_stGPRSMsgSendQueue.m_i8Rear++; 
....................          
....................         // Stuff data 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui32TimeStamp = ui32TimeStamp++; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16SequenceNo = ui16SequenceNo++; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16ItemWeight = i16Itemweight++; 
....................         g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui8RejectionStatus = ui16Rejectionstatus; 
....................     } 
....................      
....................     //g_stGPRSMsgSendQueue.m_i8Front = 0; 
.................... } 
....................  
....................  
....................  
.................... // ################################################################# Below GPRS Connection Driver ############################################################# 
....................  
.................... unsigned int8 SetPDPContext(void) 
.................... { 
....................     unsigned int8 ui8IsOKFound = 1; 
....................     g_fIsTimedOut = 0; 
....................      
....................     // Reset Rx buffer. 
....................     ResetGSMM66RxBuffer(); 
....................     // Set AT command for define PDP Context. 
....................     fputs("AT+CGDCONT=1,\"IP\",\"www\"\r", GSM_M66); 
....................     // Set timeout. 
....................     SetTimeout(2); 
....................     // Wait for response. 
....................     while(g_fIsTimedOut == 0 && ui8IsOKFound == 1) 
....................     { 
....................         // Loop through entire receive buffer. 
....................         for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
....................         { 
....................             // Check for "OK". 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................                { 
....................                    // Set flag denoting 'OK' is found. 
....................                    ui8IsOKFound = 0; 
....................                    break; 
....................                } 
....................         } 
....................     } 
....................      
....................     return ui8IsOKFound; 
.................... } 
....................  
.................... unsigned int8 ActivatePDP(void) 
.................... { 
....................     unsigned int8 ui8IsOKFound = 1; 
....................     g_fIsTimedOut = 0; 
....................      
....................     // Reset Rx buffer. 
....................     ResetGSMM66RxBuffer(); 
....................     // Set AT command to activate PDP context. 
....................     fputs("AT+CGACT=1,1\r", GSM_M66); 
....................     // Set timeout. 
....................     SetTimeout(2); 
....................     // Wait for response. 
....................     while(g_fIsTimedOut == 0 && ui8IsOKFound == 1) 
....................     { 
....................         // Loop through entire receive buffer. 
....................         for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
....................         { 
....................             // Check for "OK". 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................                { 
....................                    // Set flag denoting 'OK' is found. 
....................                    ui8IsOKFound = 0; 
....................                    break; 
....................                } 
....................         } 
....................     } 
....................      
....................     return ui8IsOKFound; 
.................... }  
....................  
.................... unsigned int8 ShowActivatedAddress(void) 
.................... { 
....................     unsigned int8 ui8IsResponseFound            = 1; 
....................     unsigned int8 ui8FirstCharSequenceFound     = 0; 
....................     unsigned int8 ui8FirstCharSeqIndex          = 0; 
....................     unsigned int8 ui8SecondCharSequenceFound    = 0; 
....................     unsigned int8 ui8DoubleQuoteCount           = 0; 
....................     
....................      
....................     // Reset Rx buffer. 
....................     ResetGSMM66RxBuffer(); 
....................     // Set AT command to Show activated PDP address. 
....................     fputs("AT+CGPADDR=1\r",GSM_M66); 
....................     delay_ms(2000); 
....................     // Set timeout. 
....................     SetTimeout(2); 
....................     // Reset timeout flag. 
....................      g_fIsTimedOut = 0; 
....................     // Wait for response. 
....................     while(g_fIsTimedOut == 0 && ui8IsResponseFound == 1) 
....................     { 
....................         // Reset WDT 
....................         //restart_wdt(); 
....................         // Reset variables. 
....................         ui8FirstCharSequenceFound  = 0; 
....................         ui8FirstCharSeqIndex       = 0; 
....................         ui8SecondCharSequenceFound = 0; 
....................          
....................         // Loop through entire receive buffer. 
....................         for(unsigned int16 ui16ByteCount = 0; ui16ByteCount <= g_ui16M66RxByteCount; ui16ByteCount++) 
....................         { 
....................             // Check for first character sequence. 
....................             if(ui8FirstCharSequenceFound == 0 && ui8SecondCharSequenceFound == 0) 
....................             { 
....................                 if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ':' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'R' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'D' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'D' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'A' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'P' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 6)] == 'G' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 7)] == 'C' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 8)] == '+') 
....................                 { 
....................                     // Set flag denoting first character sequence has found. 
....................                     ui8FirstCharSequenceFound = 1; 
....................                     // Copy the first character sequence index. 
....................                     ui8FirstCharSeqIndex = (ui16ByteCount - 0); 
....................                 } 
....................             } 
....................              
....................             // Check for second character sequence set. 
....................             else if(ui8FirstCharSequenceFound == 1 && ui8SecondCharSequenceFound == 0) 
....................             { 
....................                 if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '"') 
....................                 { 
....................                     // Increment double quote count. 
....................                     ui8DoubleQuoteCount++; 
....................                     // Check double quote count. 
....................                     if(2 == ui8DoubleQuoteCount) 
....................                     { 
....................                         // Reset double quote count. 
....................                         ui8DoubleQuoteCount = 0; 
....................                         // loop through to check second quote count. 
....................                         for(unsigned int8 ui8LoopCount = ui8FirstCharSeqIndex; ui8LoopCount < (ui16ByteCount - 0); ui8LoopCount++) 
....................                         { 
....................                             // Check for stop count. 
....................                             if(g_ui8M66RxBuffer[(ui8LoopCount - 0)] == '.') 
....................                             { 
....................                                 // Increase stop. 
....................                                 ui8DoubleQuoteCount++; 
....................                                 // Check limiting stop count. 
....................                                 if(3 == ui8DoubleQuoteCount) 
....................                                 { 
....................                                     // Set flag denoting second character sequence has found. 
....................                                     ui8SecondCharSequenceFound = 1; 
....................                                     break; 
....................                                 } 
....................                             }     
....................                         } 
....................                          
....................                          
....................                     } 
....................                 } 
....................             } 
....................              
....................             // Check for OK. 
....................             else if(ui8FirstCharSequenceFound == 1 && ui8SecondCharSequenceFound == 1) 
....................             { 
....................                 if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................                { 
....................                    // Set flag denoting 'OK' is found. 
....................                    ui8IsResponseFound = 0; 
....................                    break; 
....................                } 
....................             } 
....................         } 
....................          
....................     } 
....................      
....................     return ui8IsResponseFound; 
.................... } 
....................  
.................... void SendGPRSConnectionQuery(void) 
.................... { 
....................     g_fIsTimedOut = 0; 
....................      
....................      
....................     // Reset Rx buffer. 
....................     ResetGSMM66RxBuffer(); 
....................     // Check GPRS Connection. 
....................     fputs("AT+CGACT?\r", GSM_M66); 
....................     // Set timeout. 
....................     //SetTimeout(3); 
....................  
.................... } 
....................  
.................... //unsigned int8 CheckGPRSConnection(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsResponseFound = 5; 
.................... //    unsigned int8 ui8IsFirstCharSequenceFound = 0; 
.................... //    unsigned int8 ui8FirstCharSequenceIndex = 0; 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Check GPRS Connection. 
.................... //    fputs("AT+CGACT?\r", GSM_M66); 
.................... //    // Set timeout. 
.................... //    SetTimeout(2); 
.................... //    // Wait for response. 
.................... //    while(g_fIsTimedOut == 0 && ui8IsResponseFound == 5) 
.................... //    { 
.................... //        // Reset variables. 
.................... //        ui8IsFirstCharSequenceFound = 0; 
.................... //        ui8FirstCharSequenceIndex = 0; 
.................... //         
.................... //        // Loop through entire receive buffer. 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            // Check for first character sequence. 
.................... //            if(ui8IsFirstCharSequenceFound == 0) 
.................... //            { 
.................... //                if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ':'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'T'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount-  2)] == 'C'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'A'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'G'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'C'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 6)] == '+') 
.................... //                { 
.................... //                    // Set flag denoting first character sequence found. 
.................... //                    ui8IsFirstCharSequenceFound = 1; 
.................... //                    // Copy the index of the first character of the sequence. 
.................... //                    ui8FirstCharSequenceIndex = (ui16ByteCount - 0); 
.................... //                } 
.................... //            } 
.................... //            // Check for second character sequence. 
.................... //            else if(ui8IsFirstCharSequenceFound == 1) 
.................... //            { 
.................... //                if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '0'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 1)] == ','&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '1') 
.................... //                { 
.................... //                    // Set flag denoting particular response found. 
.................... //                    // and the response says GPRS not connected. 
.................... //                    ui8IsResponseFound = 0; 
.................... //                    break; 
.................... //                } 
.................... //                else if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '1'&& 
.................... //                        g_ui8M66RxBuffer[(ui16ByteCount - 1)] == ','&& 
.................... //                        g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '1') 
.................... //                { 
.................... //                    // Set flag denoting particular response found. 
.................... //                    // and the response says GPRS connected. 
.................... //                    ui8IsResponseFound = 1; 
.................... //                    break; 
.................... //                } 
.................... //            } 
.................... //        } 
.................... //    } 
.................... //     
.................... //    return ui8IsResponseFound; 
.................... //} 
....................  
.................... unsigned int8 CheckGPRSConnectionQueryResponse(void) 
.................... { 
....................     unsigned int8 ui8IsResponseFound = 5; 
....................     unsigned int8 ui8IsFirstCharSequenceFound = 0; 
....................     unsigned int8 ui8FirstCharSequenceIndex = 0; 
....................      
....................      
....................     // Loop through entire receive buffer. 
....................     for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
....................     { 
....................         // Check for first character sequence. 
....................         if(ui8IsFirstCharSequenceFound == 0) 
....................         { 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ':'&& 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'T'&& 
....................                g_ui8M66RxBuffer[(ui16ByteCount-  2)] == 'C'&& 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'A'&& 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'G'&& 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'C'&& 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 6)] == '+') 
....................             { 
....................                 // Set flag denoting first character sequence found. 
....................                 ui8IsFirstCharSequenceFound = 1; 
....................                 // Copy the index of the first character of the sequence. 
....................                 ui8FirstCharSequenceIndex = (ui16ByteCount - 0); 
....................             } 
....................         } 
....................         // Check for second character sequence. 
....................         else if(ui8IsFirstCharSequenceFound == 1) 
....................         { 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '0'&& 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 1)] == ','&& 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '1') 
....................             { 
....................                 // Set flag denoting particular response found. 
....................                 // and the response says GPRS not connected. 
....................                 ui8IsResponseFound = 0; 
....................                 break; 
....................             } 
....................             else if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '1'&& 
....................                     g_ui8M66RxBuffer[(ui16ByteCount - 1)] == ','&& 
....................                     g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '1') 
....................             { 
....................                 // Set flag denoting particular response found. 
....................                 // and the response says GPRS connected. 
....................                 ui8IsResponseFound = 1; 
....................                 break; 
....................             } 
....................         } 
....................     } 
....................      
....................     return ui8IsResponseFound; 
.................... } 
....................  
.................... // ########################################################## Above GPRS Connection Driver ############################################################### 
....................  
.................... // ########################################################## Below HTTP Application Driver ############################################################## 
....................  
.................... unsigned int8 SetHTTPURL(void) 
.................... { 
....................     unsigned int8 ui8IsSetURLOk = 1; 
....................     unsigned int8 ui8IsConnectionDone = 0; 
....................     g_ui8URLInputTime           = 60; 
....................     g_ui8URLInputByteLength     = 93; 
....................     g_fIsTimedOut               = 0; 
....................      
....................     // Reset Rx buffer. 
....................     ResetGSMM66RxBuffer(); 
....................     // Increment variables. 
....................     g_ui16Itm1SequenceNumber += 2; 
....................     g_ui16Itm2SequenceNumber += 2; 
....................     g_ui16ItemWeight++; 
....................     // Check URL input byte length. 
....................     CheckURLInputByteLength(); 
....................     // Set AT Commands to define web service URL. 
....................     fprintf(GSM_M66, "AT+QHTTPURL=%u,%u\r", g_ui8URLInputByteLength, g_ui8URLInputTime); 
....................     // Set timeout. 
....................     SetTimeout(2); 
....................     // Wait for response. 
....................     while(g_fIsTimedOut == 0 && ui8IsSetURLOk == 1) 
....................     { 
....................         // Loop through entire receive buffer. 
....................         for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
....................         { 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 'T' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'C' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'E' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'N' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'N' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'O' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 6)] == 'C') 
....................             { 
....................                 // Set flag denote connection is established. 
....................                 ui8IsConnectionDone = 1; 
....................                 break; 
....................             }        
....................         } 
....................          
....................         // set URL in buffer. 
....................         if(ui8IsConnectionDone) 
....................         { 
....................             // Set web service URL. 
....................             fprintf(GSM_M66, "http://mwm.itsinindia.com/api/Test/GetStringGetMethod?a=2&b=1&c=5&m=1000$%Lu$%Lu$1|1500$%Lu$%Lu$1", g_ui16Itm1SequenceNumber, g_ui16ItemWeight, g_ui16Itm2SequenceNumber, ++g_ui16ItemWeight); 
....................             delay_ms(300); 
....................             // Check for "OK". 
....................             for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
....................             { 
....................                 if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                    g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................                 { 
....................                     // Set flag denoting Set URL successfully. 
....................                     ui8IsSetURLOk = 0; 
....................                     break; 
....................                 } 
....................             }     
....................         } 
....................          
....................         
....................     } 
....................      
....................     return ui8IsSetURLOk; 
....................      
.................... } 
....................  
.................... void SetHTTPURLParameter(void) 
.................... { 
....................     g_ui8URLInputTime           = 60; 
....................     g_ui8URLInputByteLength     = 66; 
....................     g_fIsTimedOut               = 0; 
....................      
....................     // Reset Rx buffer. 
....................     ResetGSMM66RxBuffer(); 
....................      
.................... //    //Increase GPRS send msg queue front. 
.................... //    if(g_stGPRSMsgSendQueue.m_i8Front != 0) 
.................... //    { 
.................... //        g_stGPRSMsgSendQueue.m_i8Front++; 
.................... //    }   
....................      
....................     // Check remaining data length of queue. 
....................     // Count data length according to queue front and rear position. 
....................     if(g_stGPRSMsgSendQueue.m_i8Rear > g_stGPRSMsgSendQueue.m_i8Front) 
....................     { 
....................         g_ui8DataQueueLen = (g_stGPRSMsgSendQueue.m_i8Rear - g_stGPRSMsgSendQueue.m_i8Front + 1); 
....................     } 
....................     else if(g_stGPRSMsgSendQueue.m_i8Rear == g_stGPRSMsgSendQueue.m_i8Front) 
....................     { 
....................         g_ui8DataQueueLen = 1; 
....................     } 
....................     else 
....................     { 
....................         g_ui8DataQueueLen = ((SIZE_GPRS_DATA_NODE_QUEUE - g_stGPRSMsgSendQueue.m_i8Front) + (g_stGPRSMsgSendQueue.m_i8Rear + 1)); 
....................     } 
....................      
....................     // If, queue front is very near to queue size i.e. less than 5 data though data length is 
....................     // more than 5 then to properly circulate queue front we need to send data one by one at this situation until it reaches queue end. 
....................     if((SIZE_GPRS_DATA_NODE_QUEUE - g_stGPRSMsgSendQueue.m_i8Front) < 5) 
....................     { 
....................         g_ui8DataQueueLen = 1; 
....................     } 
....................      
....................     // Check URL input byte length. 
....................     CheckURLInputByteLength(); 
....................      
....................     // Set AT Commands to define web service URL. 
....................     fprintf(GSM_M66, "AT+QHTTPURL=%u,%u\r", g_ui8URLInputByteLength, g_ui8URLInputTime); 
....................     // Set timeout. 
....................     //SetTimeout(2); 
.................... } 
....................  
.................... unsigned int8 SetHTTPURLL(void) 
.................... { 
....................     unsigned int8 ui8IsSetURLOk = 1; 
....................     unsigned int8 ui8IsConnectionDone = 0; 
....................      
....................     // Loop through entire receive buffer. 
....................     for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
....................     { 
....................         if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 'T' && 
....................            g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'C' && 
....................            g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'E' && 
....................            g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'N' && 
....................            g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'N' && 
....................            g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'O' && 
....................            g_ui8M66RxBuffer[(ui16ByteCount - 6)] == 'C') 
....................         { 
....................             // Set flag denote connection is established. 
....................             ui8IsConnectionDone = 1; 
....................             break; 
....................         }        
....................     } 
....................      
....................     // set URL in buffer. 
....................     if(ui8IsConnectionDone) 
....................     { 
....................         if(g_ui8DataQueueLen > 5) 
....................         { 
....................             // Set No of messages to send. 
....................             g_stGPRSMsgHeader.m_ui8NoOfMessages = 5; 
....................             // Set web service URL. 
....................             fprintf(GSM_M66, "http://trackweigher.com/api/Test/GetStringGetMethod?a=%u&b=%Lu&c=%u&m=%Lu$%Lu$%Lu$%u|%Lu$%Lu$%Lu$%u|%Lu$%Lu$%Lu$%u|%Lu$%Lu$%Lu$%u|%Lu$%Lu$%Lu$%u", g_stGPRSMsgHeader.m_ui8NoOfMessages, g_stGPRSMsgHeader.m_ui16MachineID, g_stGPRSMsgHeader.m_ui8Variety, 
....................                                                                                                                                                                                    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front++].m_ui8RejectionStatus,  
....................                                                                                                                                                                                    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front++].m_ui8RejectionStatus, 
....................                                                                                                                                                                                    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front++].m_ui8RejectionStatus, 
....................                                                                                                                                                                                    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front++].m_ui8RejectionStatus, 
....................                                                                                                                                                                                    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui8RejectionStatus); 
....................                                                                                                                                      
....................         } 
....................         else 
....................         { 
....................             // Set No of messages to send. 
....................             g_stGPRSMsgHeader.m_ui8NoOfMessages = 1; 
....................             // Set web service URL. 
....................             fprintf(GSM_M66, "http://trackweigher.com/api/Test/GetStringGetMethod?a=%u&b=%Lu&c=%u&m=%Lu$%Lu$%Lu$%u", g_stGPRSMsgHeader.m_ui8NoOfMessages, g_stGPRSMsgHeader.m_ui16MachineID, g_stGPRSMsgHeader.m_ui8Variety, 
....................                                                                                                                      g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui8RejectionStatus); 
....................         } 
....................         delay_ms(300); 
....................         // Check for "OK". 
....................         for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
....................         { 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................             { 
....................                 // Set flag denoting Set URL successfully. 
....................                 ui8IsSetURLOk = 0; 
....................                 break; 
....................             } 
....................         }     
....................     } 
....................      
....................     // Check if queue front is at zero-th position..then increment front. 
....................     // This is after sending data of zero-th position. 
.................... //    if(g_stGPRSMsgSendQueue.m_i8Front == 0) 
.................... //    { 
.................... //        g_stGPRSMsgSendQueue.m_i8Front++; 
.................... //    } 
....................      
....................     return ui8IsSetURLOk; 
.................... } 
....................  
.................... void SendHTTPGetSessionRequest(void) 
.................... { 
....................     g_fIsTimedOut = 0; 
....................      
....................     // Reset Rx buffer. 
....................     ResetGSMM66RxBuffer(); 
....................     // Set AT Command to start web service action. 
....................     fputs("AT+QHTTPGET=120\r", GSM_M66); 
....................     // Set timeout. 
....................     //SetTimeout(10); 
.................... } 
....................  
.................... unsigned int8 CheckHTTPGETRequestResponse(void) 
.................... { 
....................     unsigned int8 ui8IsOKFound = 1; 
....................     unsigned int8 ui8IsFirstCharSeqFound  = 0; 
....................     unsigned int8 ui8IsSecondCharSeqFound = 0; 
....................     unsigned int8 ui8CharSeqIndex         = 0; 
....................     unsigned int8 ui8CommaCount           = 0; 
....................      
....................     // Loop through entire receive buffer 
....................     for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
....................     { 
....................         // Check for first character sequence. 
....................         if(ui8IsFirstCharSeqFound == 0 && ui8IsSecondCharSeqFound == 0) 
....................         { 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
....................             { 
....................                 // Set flag denoting that first character sequence is found. 
....................                 ui8IsFirstCharSeqFound = 1; 
....................             } 
....................         } 
....................  
....................         // Check for second character sequence. 
....................         else if(ui8IsFirstCharSeqFound == 1 && ui8IsSecondCharSeqFound == 0) 
....................         { 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ':' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'T' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'E' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'G' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'P' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'T' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 6)] == 'T' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 7)] == 'H' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 8)] == 'Q' && 
....................                g_ui8M66RxBuffer[(ui16ByteCount - 9)] == '+' ) 
....................             { 
....................                 // Set flag denoting that second character sequence has found. 
....................                 ui8IsSecondCharSeqFound = 1; 
....................             }  
....................  
....................         } 
....................  
....................         // Check for third character sequence. 
....................         else if(ui8IsFirstCharSeqFound == 1 && ui8IsSecondCharSeqFound == 1) 
....................         { 
....................             if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ',') 
....................             { 
....................                 // Increase comma count 
....................                 ui8CommaCount++; 
....................                 // Check for comma count level 
....................                 if(ui8CommaCount == 2) 
....................                 { 
....................                     // Check for success message code. 
....................                     if(g_ui8M66RxBuffer[(ui16ByteCount - 1)] == '0' && 
....................                        g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '0' && 
....................                        g_ui8M66RxBuffer[(ui16ByteCount - 3)] == '2') 
....................                     { 
....................                         // Set flag denoting that success message code found. 
....................                         ui8IsOKFound = 0; 
....................                         break; 
....................                     } 
....................                 } 
....................             }     
....................         } 
....................  
....................     } 
....................      
....................     return ui8IsOKFound; 
.................... } 
....................  
.................... //unsigned int8 StartHTTPGETSession(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsOKFound = 1; 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Set AT Command to start web service action. 
.................... //    fputs("AT+QHTTPGET=120\r", GSM_M66); 
.................... //    // Set timeout. 
.................... //    SetTimeout(20); 
.................... //    // Wait for response. 
.................... //    while(g_fIsTimedOut == 0 && ui8IsOKFound == 1) 
.................... //    { 
.................... //        // Reset WDT 
.................... //        restart_wdt(); 
.................... //        // Loop through entire receive buffer 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... //            { 
.................... //                // Set flag denoting Set URL successfully. 
.................... //                ui8IsOKFound = 0; 
.................... //                break; 
.................... //            } 
.................... //        } 
.................... //    } 
.................... //     
.................... //    return ui8IsOKFound; 
.................... //} 
....................  
....................  
.................... // ############################################################# Above HTTP Application driver ########################################################## 
.................... #endif	/* VM_GSMM66_GPRS_CONFIG_H */ 
....................  
....................  
....................  
.................... //#define IBC_CMD_SET_CALIB_POINT             1 
.................... //#define IBC_CMD_GET_CALIB_POINT             2 
.................... //#define IBC_CMD_RESET_CALIB_POINT           3 
.................... //#define IBC_CMD_TARE_REQUEST                4 
.................... //#define IBC_CMD_PRE_PROD_AVG_WEIGHT         5 
.................... //#define IBC_CMD_PRE_PROD_TOLERANCE          6 
.................... //#define IBC_CMD_START_PROD                  7 
.................... //#define IBC_CMD_PROD_WEIGH_DATA              
....................  
.................... unsigned int16 g_ui16PrevItemCount = 0; 
....................  
.................... void StuffCalibTable(void) 
.................... { 
....................     unsigned int8 ui8Index = (g_i16CalibPoint / 1000); 
....................      
....................     if((g_i16CalibPoint % 1000) == 0 && g_i16CalibPoint <= 10000) 
....................     { 
....................         g_stCalibTable[ui8Index].m_i16CalibPoint = g_i16CalibPoint; 
....................         g_stCalibTable[ui8Index].m_ui32CalibValue = g_i32CalibValue; 
....................         
....................         switch(ui8Index) 
....................         { 
....................             case 0: 
....................                 g_ui16Register0_2 = (unsigned int16)((g_i32CalibValue >> 16) & 0x0000FFFF); 
....................                 g_ui16Register0_1 = (unsigned int16)(g_i32CalibValue & 0x0000FFFF); 
....................                 break; 
....................             case 1: 
....................                 g_ui16Register1000_2 = (unsigned int16)((g_i32CalibValue >> 16) & 0x0000FFFF); 
....................                 g_ui16Register1000_1 = (unsigned int16)(g_i32CalibValue & 0x0000FFFF); 
....................                 break; 
....................             case 2: 
....................                 g_ui16Register2000_2 = (unsigned int16)((g_i32CalibValue >> 16) & 0x0000FFFF); 
....................                 g_ui16Register2000_1 = (unsigned int16)(g_i32CalibValue & 0x0000FFFF); 
....................                 break; 
....................             case 3: 
....................                 g_ui16Register3000_2 = (unsigned int16)((g_i32CalibValue >> 16) & 0x0000FFFF); 
....................                 g_ui16Register3000_1 = (unsigned int16)(g_i32CalibValue & 0x0000FFFF); 
....................                 break; 
....................             case 4: 
....................                 g_ui16Register4000_2 = (unsigned int16)((g_i32CalibValue >> 16) & 0x0000FFFF); 
....................                 g_ui16Register4000_1 = (unsigned int16)(g_i32CalibValue & 0x0000FFFF); 
....................                 break; 
....................             case 5: 
....................                 g_ui16Register5000_2 = (unsigned int16)((g_i32CalibValue >> 16) & 0x0000FFFF); 
....................                 g_ui16Register5000_1 = (unsigned int16)(g_i32CalibValue & 0x0000FFFF); 
....................                 break; 
....................             case 6: 
....................                 g_ui16Register6000_2 = (unsigned int16)((g_i32CalibValue >> 16) & 0x0000FFFF); 
....................                 g_ui16Register6000_1 = (unsigned int16)(g_i32CalibValue & 0x0000FFFF); 
....................                 break; 
....................             case 7: 
....................                 g_ui16Register7000_2 = (unsigned int16)((g_i32CalibValue >> 16) & 0x0000FFFF); 
....................                 g_ui16Register7000_1 = (unsigned int16)(g_i32CalibValue & 0x0000FFFF); 
....................                 break; 
....................             case 8: 
....................                 g_ui16Register8000_2 = (unsigned int16)((g_i32CalibValue >> 16) & 0x0000FFFF); 
....................                 g_ui16Register8000_1 = (unsigned int16)(g_i32CalibValue & 0x0000FFFF); 
....................                 break; 
....................             case 9: 
....................                 g_ui16Register9000_2 = (unsigned int16)((g_i32CalibValue >> 16) & 0x0000FFFF); 
....................                 g_ui16Register9000_1 = (unsigned int16)(g_i32CalibValue & 0x0000FFFF); 
....................                 break; 
....................             case 10: 
....................                 g_ui16Register10000_2 = (unsigned int16)((g_i32CalibValue >> 16) & 0x0000FFFF); 
....................                 g_ui16Register10000_1 = (unsigned int16)(g_i32CalibValue & 0x0000FFFF); 
....................                 break;    
....................         } 
....................          
....................     }    
....................         
.................... } 
....................  
....................  // TESTING  
....................     unsigned int8 ui8Counter = 0; 
....................  
.................... // IBC Received message process proc 
.................... void ProcessIBCMsg() 
*
016EC:  MOVLB  B
016EE:  CLRF   x17
016F0:  CLRF   x19
016F2:  CLRF   x18
016F4:  CLRF   x1B
016F6:  MOVLW  32
016F8:  MOVWF  x1A
.................... {    
....................     ST_IBC_DATA_NODE stIBCRcvNode; 
....................     unsigned int8  ui8LoopCount = 0; 
....................     unsigned int16 ui16ItemCount = 0; 
....................     unsigned int16 ui16TempCurrPassStatus = 50;; 
....................  
....................     // Get Node from IBC Receive Message Queue 
....................     DeleteIBCMsgQueue(&g_stIBCRcvQueue, &stIBCRcvNode); 
016FA:  MOVLW  01
016FC:  MOVWF  x1E
016FE:  MOVLW  D5
01700:  MOVWF  x1D
01702:  MOVLW  0B
01704:  MOVWF  x20
01706:  MOVLW  12
01708:  MOVWF  x1F
0170A:  MOVLB  0
0170C:  CALL   1084
....................      
....................     // Valid message present in IBC receive buffer 
....................     // So go for process the data 
....................     switch(stIBCRcvNode.g_ui8ArrIBCData[0]) 
01710:  MOVLB  B
01712:  MOVF   x12,W
01714:  XORLW  67
01716:  MOVLB  0
01718:  BTFSC  FD8.2
0171A:  GOTO   1772
0171E:  XORLW  01
01720:  BTFSC  FD8.2
01722:  GOTO   17CC
01726:  XORLW  0E
01728:  BTFSC  FD8.2
0172A:  GOTO   17D2
0172E:  XORLW  1E
01730:  BTFSC  FD8.2
01732:  GOTO   17D8
01736:  XORLW  1A
01738:  BTFSC  FD8.2
0173A:  GOTO   182A
0173E:  XORLW  01
01740:  BTFSC  FD8.2
01742:  GOTO   1830
01746:  XORLW  1C
01748:  BTFSC  FD8.2
0174A:  GOTO   1836
0174E:  XORLW  06
01750:  BTFSC  FD8.2
01752:  GOTO   183C
01756:  XORLW  05
01758:  BTFSC  FD8.2
0175A:  GOTO   188E
0175E:  XORLW  08
01760:  BTFSC  FD8.2
01762:  GOTO   1998
01766:  XORLW  13
01768:  BTFSC  FD8.2
0176A:  GOTO   19F2
0176E:  GOTO   1A4E
....................     { 
....................         case IBC_CMD_RESET_CALIB_POINT_TARE: 
....................             // Store receive data. 
....................             for(ui8LoopCount = 1; ui8LoopCount < IBC_MSG_BYTE_COUNT; ui8LoopCount++) 
01772:  MOVLW  01
01774:  MOVLB  B
01776:  MOVWF  x17
01778:  MOVF   x17,W
0177A:  SUBLW  04
0177C:  BTFSS  FD8.0
0177E:  GOTO   17B8
....................             { 
....................                 g_unIBCResetCalibTare.m_ui8Arr[ui8LoopCount - 1] = stIBCRcvNode.g_ui8ArrIBCData[ui8LoopCount]; 
01782:  MOVLW  01
01784:  SUBWF  x17,W
01786:  CLRF   03
01788:  ADDLW  D7
0178A:  MOVWF  01
0178C:  MOVLW  00
0178E:  ADDWFC 03,F
01790:  MOVFF  03,B1E
01794:  CLRF   03
01796:  MOVF   x17,W
01798:  ADDLW  12
0179A:  MOVWF  FE9
0179C:  MOVLW  0B
0179E:  ADDWFC 03,W
017A0:  MOVWF  FEA
017A2:  MOVFF  FEF,B1F
017A6:  MOVFF  B1E,FEA
017AA:  MOVFF  01,FE9
017AE:  MOVFF  B1F,FEF
017B2:  INCF   x17,F
017B4:  GOTO   1778
....................             } 
....................              
....................             // Retrieve and store the dynamic ADC tare value. 
....................             g_ui32TareADCValueForCalibration = g_unIBCResetCalibTare.m_stIBCResetCalibTare.m_ui32CalibADCForTare; 
017B8:  MOVFF  DA,70
017BC:  MOVFF  D9,6F
017C0:  MOVFF  D8,6E
017C4:  MOVFF  D7,6D
....................      
....................             break; 
017C8:  GOTO   1A54
....................         case IBC_CMD_GET_CALIB_POINT: 
....................             break; 
017CC:  MOVLB  B
017CE:  GOTO   1A54
....................         case IBC_CMD_RESET_CALIB_POINT:             
....................             break; 
017D2:  MOVLB  B
017D4:  GOTO   1A54
....................         case IBC_CMD_PROD_TARE_DATA: 
....................             { 
....................                 for(ui8LoopCount = 1; ui8LoopCount < IBC_MSG_BYTE_COUNT; ui8LoopCount++) 
017D8:  MOVLW  01
017DA:  MOVLB  B
017DC:  MOVWF  x17
017DE:  MOVF   x17,W
017E0:  SUBLW  04
017E2:  BTFSS  FD8.0
017E4:  GOTO   181E
....................                 { 
....................                     g_unIBCProdModeTrData.m_ui8Arr[ui8LoopCount-1] = stIBCRcvNode.g_ui8ArrIBCData[ui8LoopCount]; 
017E8:  MOVLW  01
017EA:  SUBWF  x17,W
017EC:  CLRF   03
017EE:  ADDLW  BB
017F0:  MOVWF  01
017F2:  MOVLW  00
017F4:  ADDWFC 03,F
017F6:  MOVFF  03,B1E
017FA:  CLRF   03
017FC:  MOVF   x17,W
017FE:  ADDLW  12
01800:  MOVWF  FE9
01802:  MOVLW  0B
01804:  ADDWFC 03,W
01806:  MOVWF  FEA
01808:  MOVFF  FEF,B1F
0180C:  MOVFF  B1E,FEA
01810:  MOVFF  01,FE9
01814:  MOVFF  B1F,FEF
01818:  INCF   x17,F
0181A:  GOTO   17DE
....................                 } 
....................                 g_ui16RunningTareValue = (unsigned int16)(g_unIBCProdModeTrData.m_stTareData.m_i16TareData); 
0181E:  MOVFF  BE,8A
01822:  MOVFF  BD,89
....................             } 
....................              
....................             break; 
01826:  GOTO   1A54
....................         case IBC_CMD_PRE_PROD_AVG_WEIGHT: 
....................             break; 
0182A:  MOVLB  B
0182C:  GOTO   1A54
....................         case IBC_CMD_PRE_PROD_TOLERANCE: 
....................             break; 
01830:  MOVLB  B
01832:  GOTO   1A54
....................         case IBC_CMD_START_PROD: 
....................             break; 
01836:  MOVLB  B
01838:  GOTO   1A54
....................         case IBC_CMD_PROD_AVG_WT_DATA: 
....................             { 
....................                 for(ui8LoopCount = 1; ui8LoopCount < IBC_MSG_BYTE_COUNT; ui8LoopCount++) 
0183C:  MOVLW  01
0183E:  MOVLB  B
01840:  MOVWF  x17
01842:  MOVF   x17,W
01844:  SUBLW  04
01846:  BTFSS  FD8.0
01848:  GOTO   1882
....................                 { 
....................                     g_unIBCProdModeAvg.m_ui8Arr[ui8LoopCount-1] = stIBCRcvNode.g_ui8ArrIBCData[ui8LoopCount]; 
0184C:  MOVLW  01
0184E:  SUBWF  x17,W
01850:  CLRF   03
01852:  ADDLW  CF
01854:  MOVWF  01
01856:  MOVLW  00
01858:  ADDWFC 03,F
0185A:  MOVFF  03,B1E
0185E:  CLRF   03
01860:  MOVF   x17,W
01862:  ADDLW  12
01864:  MOVWF  FE9
01866:  MOVLW  0B
01868:  ADDWFC 03,W
0186A:  MOVWF  FEA
0186C:  MOVFF  FEF,B1F
01870:  MOVFF  B1E,FEA
01874:  MOVFF  01,FE9
01878:  MOVFF  B1F,FEF
0187C:  INCF   x17,F
0187E:  GOTO   1842
....................                 } 
....................                  
....................                 g_ui16RunningAvgWt = g_unIBCProdModeAvg.m_stAvgData.m_i16CurAvg; 
01882:  MOVFF  D0,88
01886:  MOVFF  CF,87
....................             } 
....................             break; 
0188A:  GOTO   1A54
....................              
....................         case IBC_CMD_PROD_WEIGH_DATA: 
....................             { 
....................                 // Copy individual Box data. 
....................                 for(ui8LoopCount = 1; ui8LoopCount < IBC_MSG_BYTE_COUNT; ui8LoopCount++) 
0188E:  MOVLW  01
01890:  MOVLB  B
01892:  MOVWF  x17
01894:  MOVF   x17,W
01896:  SUBLW  04
01898:  BTFSS  FD8.0
0189A:  GOTO   18D4
....................                 { 
....................                     g_unIBCProdModeWtData.m_ui8Arr[ui8LoopCount - 1] = stIBCRcvNode.g_ui8ArrIBCData[ui8LoopCount]; 
0189E:  MOVLW  01
018A0:  SUBWF  x17,W
018A2:  CLRF   03
018A4:  ADDLW  B7
018A6:  MOVWF  01
018A8:  MOVLW  00
018AA:  ADDWFC 03,F
018AC:  MOVFF  03,B1E
018B0:  CLRF   03
018B2:  MOVF   x17,W
018B4:  ADDLW  12
018B6:  MOVWF  FE9
018B8:  MOVLW  0B
018BA:  ADDWFC 03,W
018BC:  MOVWF  FEA
018BE:  MOVFF  FEF,B1F
018C2:  MOVFF  B1E,FEA
018C6:  MOVFF  01,FE9
018CA:  MOVFF  B1F,FEF
018CE:  INCF   x17,F
018D0:  GOTO   1894
....................                     //g_unIBCProdModeWtData.m_ui8Arr[ui8LoopCount] = g_stIBCRcvData.g_ui8ArrIBCData[ui8LoopCount + 1]; 
....................                 } 
....................  
....................                 // Segregate Box count, Rejection status and weight of single box and store in RAM. 
....................                 // HMI data display variables. 
....................                 g_ui16CBBCount = g_unIBCProdModeWtData.m_stWeighingData.m_ui16BoxCount >> 1; 
018D4:  BCF    FD8.0
018D6:  MOVLB  0
018D8:  RRCF   xB8,W
018DA:  MOVWF  x80
018DC:  RRCF   xB7,W
018DE:  MOVWF  x7F
....................                 //g_ui16CBBCount = g_unIBCProdModeWtData.m_stWeighingData.m_ui16BoxCount >> 2; 
....................                 // Store the CBB count temporarily. 
....................                 ui16ItemCount = g_ui16CBBCount; 
018E0:  MOVFF  80,B19
018E4:  MOVFF  7F,B18
....................                  
....................                 g_stProdModeCurrBoxData.m_i16BoxWeight = g_unIBCProdModeWtData.m_stWeighingData.m_i16BoxWeight; 
018E8:  MOVFF  BA,A1C
018EC:  MOVFF  B9,A1B
....................                 // Insert current box data to variables for Display in HMI 
....................                 g_ui16CurrentWt = g_stProdModeCurrBoxData.m_i16BoxWeight; 
018F0:  MOVFF  A1C,84
018F4:  MOVFF  A1B,83
....................                  
....................                 // Update current Box pass status. 
....................                 g_ui16CurrentPassStatus = g_unIBCProdModeWtData.m_stWeighingData.m_ui16BoxCount << 15; 
018F8:  CLRF   x85
018FA:  CLRF   x86
018FC:  BTFSC  xB7.0
018FE:  BSF    x86.7
....................                 g_ui16CurrentPassStatus = g_ui16CurrentPassStatus >> 15; 
01900:  RLCF   x86,W
01902:  CLRF   x85
01904:  CLRF   x86
01906:  BTFSC  FD8.0
01908:  BSF    x85.0
....................          
....................                 //TODO => IBC Error adjustment Start. 
....................                 // Just to Cleaning first two erroneous bits due to IBC Sampling Problem. 
....................                 g_ui16CBBCount = g_ui16CBBCount << 2; 
0190A:  RLCF   x7F,F
0190C:  RLCF   x80,F
0190E:  RLCF   x7F,F
01910:  RLCF   x80,F
01912:  MOVLW  FC
01914:  ANDWF  x7F,F
....................                 g_ui16CBBCount = g_ui16CBBCount >> 2; 
01916:  RRCF   x80,F
01918:  RRCF   x7F,F
0191A:  RRCF   x80,F
0191C:  RRCF   x7F,F
0191E:  MOVLW  3F
01920:  ANDWF  x80,F
....................                 //TODO IBC Error adjustment End 
....................                  
....................                 if(ui16ItemCount > 0 && g_ui16PrevItemCount != ui16ItemCount) 
01922:  MOVLB  B
01924:  MOVF   x18,F
01926:  BTFSS  FD8.2
01928:  GOTO   1934
0192C:  MOVF   x19,F
0192E:  BTFSC  FD8.2
01930:  GOTO   1970
01934:  MOVF   x18,W
01936:  SUBWF  x0D,W
01938:  BTFSS  FD8.2
0193A:  GOTO   1948
0193E:  MOVF   x19,W
01940:  SUBWF  x0E,W
01942:  BTFSC  FD8.2
01944:  GOTO   1970
....................                 { 
....................                     // Update production mode current box data. 
....................                     g_stProdModeCurrBoxData.m_ui16SequenceNo = g_ui16CBBCount; 
01948:  MOVFF  80,A1E
0194C:  MOVFF  7F,A1D
....................                     g_stProdModeCurrBoxData.m_i16BoxWeight = g_ui16CurrentWt; 
01950:  MOVFF  84,A1C
01954:  MOVFF  83,A1B
....................                     g_stProdModeCurrBoxData.m_ui16RejectionStatus = g_ui16CurrentPassStatus;  // TODO 
01958:  MOVFF  86,A20
0195C:  MOVFF  85,A1F
....................                     //g_stProdModeCurrBoxData.m_ui32TimeStamp = GetRTC(); 
....................                     // Insert current box data in GPRS send Message queue. 
....................                     InsertInGPRSMsgQueue(); 
01960:  MOVLB  0
01962:  GOTO   148E
....................  
....................                     // update previous item count for next box reference. 
....................                     g_ui16PrevItemCount = ui16ItemCount; 
01966:  MOVFF  B19,B0E
0196A:  MOVFF  B18,B0D
0196E:  MOVLB  B
....................                 } 
....................                 // Arijita 
....................                 // Current box weight to avg array 
....................                 if(g_ui16CBBCount > 0)  
01970:  MOVLB  0
01972:  MOVF   x7F,F
01974:  BTFSS  FD8.2
01976:  GOTO   1982
0197A:  MOVF   x80,F
0197C:  BTFSC  FD8.2
0197E:  GOTO   1986
....................                 { 
....................                      //g_ui16RunningAvgWt = ProcessWeightData(g_ui16CurrentWt); 
....................                 } 
01982:  GOTO   1992
....................                 else 
....................                 { 
....................                     // TESTING 
....................                     int8 i8NewData = 0; 
01986:  MOVLB  B
01988:  CLRF   x1C
....................                     i8NewData++; 
0198A:  INCF   x1C,F
....................                     i8NewData = 100; 
0198C:  MOVLW  64
0198E:  MOVWF  x1C
01990:  MOVLB  0
....................                 } 
....................             } 
....................             break; 
01992:  MOVLB  B
01994:  GOTO   1A54
....................         case IBC_CMD_PROD_INTMD_DATA: 
....................             { 
....................                 // Copy individual Box data. 
....................                 for(ui8LoopCount = 1; ui8LoopCount < IBC_MSG_BYTE_COUNT; ui8LoopCount++) 
01998:  MOVLW  01
0199A:  MOVLB  B
0199C:  MOVWF  x17
0199E:  MOVF   x17,W
019A0:  SUBLW  04
019A2:  BTFSS  FD8.0
019A4:  GOTO   19DE
....................                 { 
....................                     g_unIBCProdModeWtData.m_ui8Arr[ui8LoopCount - 1] = stIBCRcvNode.g_ui8ArrIBCData[ui8LoopCount]; 
019A8:  MOVLW  01
019AA:  SUBWF  x17,W
019AC:  CLRF   03
019AE:  ADDLW  B7
019B0:  MOVWF  01
019B2:  MOVLW  00
019B4:  ADDWFC 03,F
019B6:  MOVFF  03,B1E
019BA:  CLRF   03
019BC:  MOVF   x17,W
019BE:  ADDLW  12
019C0:  MOVWF  FE9
019C2:  MOVLW  0B
019C4:  ADDWFC 03,W
019C6:  MOVWF  FEA
019C8:  MOVFF  FEF,B1F
019CC:  MOVFF  B1E,FEA
019D0:  MOVFF  01,FE9
019D4:  MOVFF  B1F,FEF
019D8:  INCF   x17,F
019DA:  GOTO   199E
....................                     //g_unIBCProdModeWtData.m_ui8Arr[ui8LoopCount] = g_stIBCRcvData.g_ui8ArrIBCData[ui8LoopCount + 1]; 
....................                 } 
....................  
....................                 g_stProdModeCurrBoxData.m_i16BoxWeight = g_unIBCProdModeWtData.m_stWeighingData.m_i16BoxWeight; 
019DE:  MOVFF  BA,A1C
019E2:  MOVFF  B9,A1B
....................  
....................                 // Insert current box data to variables for Display in HMI 
....................                 g_ui16CurrentWt = g_stProdModeCurrBoxData.m_i16BoxWeight; 
019E6:  MOVFF  A1C,84
019EA:  MOVFF  A1B,83
....................  
....................                  
....................             } 
....................             break;             
019EE:  GOTO   1A54
....................         case IBC_CMD_RESET_CALIB_POINT_WEIGHT: 
....................             // Store receive data. 
....................             for(ui8LoopCount = 1; ui8LoopCount < IBC_MSG_BYTE_COUNT; ui8LoopCount++) 
019F2:  MOVLW  01
019F4:  MOVLB  B
019F6:  MOVWF  x17
019F8:  MOVF   x17,W
019FA:  SUBLW  04
019FC:  BTFSS  FD8.0
019FE:  GOTO   1A38
....................             { 
....................                 g_unIBCResetCalibWeight.m_ui8Arr[ui8LoopCount - 1] = stIBCRcvNode.g_ui8ArrIBCData[ui8LoopCount]; 
01A02:  MOVLW  01
01A04:  SUBWF  x17,W
01A06:  CLRF   03
01A08:  ADDLW  DB
01A0A:  MOVWF  01
01A0C:  MOVLW  00
01A0E:  ADDWFC 03,F
01A10:  MOVFF  03,B1E
01A14:  CLRF   03
01A16:  MOVF   x17,W
01A18:  ADDLW  12
01A1A:  MOVWF  FE9
01A1C:  MOVLW  0B
01A1E:  ADDWFC 03,W
01A20:  MOVWF  FEA
01A22:  MOVFF  FEF,B1F
01A26:  MOVFF  B1E,FEA
01A2A:  MOVFF  01,FE9
01A2E:  MOVFF  B1F,FEF
01A32:  INCF   x17,F
01A34:  GOTO   19F8
....................             } 
....................              
....................             // Retrieve and store the dynamic ADC tare value. 
....................             g_ui32gWeightADCValueForCalibration = g_unIBCResetCalibWeight.m_stIBCResetCalibWeight.m_ui32CalibADCForWeight; 
01A38:  MOVFF  DE,74
01A3C:  MOVFF  DD,73
01A40:  MOVFF  DC,72
01A44:  MOVFF  DB,71
....................             break; 
01A48:  GOTO   1A54
01A4C:  MOVLB  0
....................         default : 
....................             break; 
01A4E:  MOVLB  B
01A50:  GOTO   1A54
....................     } 
01A54:  MOVLB  0
01A56:  GOTO   650A (RETURN)
.................... }    
....................  
....................  
....................  
.................... #endif	/* VM_IBC_PROCESS_M1_H */ 
....................  
....................  
.................... #include "../Common/vmTime.h" 
.................... #ifndef _VM_TIME_CONFIG_H_ 
.................... #define _VM_TIME_CONFIG_H_ 
....................  
.................... //#include "18F46K80.h" 
.................... #include "vmModbusGlobal.h" 
.................... #include <time.h> 
.................... #include <time.c> 
.................... //#include "vmHMIBoardModbusSetup.h" 
....................  
.................... #define SYSTEM_BASE_DATE 		1900 
.................... #define SYSTEM_HH_TO_SS 		3600 
.................... #define SYSTEM_MM_TO_SS 		60 
....................  
....................  
.................... unsigned int32 GetRTC(void) 
.................... { 
....................     struct_tm lDate;     
....................  
....................     unsigned int16 ui16SSDiff = 0; 
....................     unsigned int16 ui16MMDiff = 0; 
....................     unsigned int16 ui16HHDiff = g_ui16RegisterTime_Diff / SYSTEM_HH_TO_SS; 
....................     ui16SSDiff = g_ui16RegisterTime_Diff % SYSTEM_HH_TO_SS; 
....................     ui16MMDiff = ui16SSDiff / SYSTEM_MM_TO_SS; 
....................     ui16SSDiff = ui16SSDiff % SYSTEM_MM_TO_SS; 
....................      
....................     lDate.tm_sec = (unsigned int8) g_ui16RegisterTime_ss + ui16SSDiff;   
....................     lDate.tm_min = (unsigned int8)g_ui16RegisterTime_mm + ui16MMDiff;   
....................     lDate.tm_hour = (unsigned int8)g_ui16RegisterTime_HH + ui16HHDiff;   
....................     lDate.tm_mday = (unsigned int8) g_ui16RegisterDateDD;   
....................     lDate.tm_mon = (Month) g_ui16RegisterDateMM;   
....................     lDate.tm_year = (unsigned int16) g_ui16RegisterDateYY - SYSTEM_BASE_DATE;   
....................  
....................     time_t lTimeEpoch = mktime(&lDate); 
....................     return lTimeEpoch; 
.................... //lTimeEpoch 
.................... } 
....................  
.................... #endif /* _VM_TIME_CONFIG_H_ */ 
....................  
....................  
.................... //#include "viShiftRegister.h" 
....................  
....................  
.................... void Initialize(void) 
.................... { 
....................      
....................     // Set RS485 Transmit Inactive. 
....................     output_bit(PIN_RS485_RTS,0); 
*
00D2A:  BCF    F8C.4
00D2C:  BCF    F95.4
....................  
....................     // Initialize external interrupt for InterBoard Communication. 
....................     ext_int_edge(1, H_TO_L);  
00D2E:  BCF    FF1.5
....................     clear_interrupt(INT_EXT1); 
00D30:  BCF    FF0.0
....................     enable_interrupts(INT_EXT1); 
00D32:  BSF    FF0.3
....................      
....................     // Enable 1MS main timer. 
....................     clear_interrupt(INT_TIMER0); 
00D34:  BCF    FF2.2
....................     enable_interrupts(INT_TIMER0); 
00D36:  BSF    FF2.5
....................      
....................     // Enable timer interrupts for InterBoard Communication(IBC). 
....................     // TIMER1 => used for IBC receive; TIMER3=> used for IBC transmit. 
....................     clear_interrupt(INT_TIMER1); 
00D38:  BCF    F9E.0
....................     enable_interrupts(INT_TIMER1); 
00D3A:  BSF    F9D.0
....................     clear_interrupt(INT_TIMER3); 
00D3C:  BCF    FA1.1
....................     enable_interrupts(INT_TIMER3); 
00D3E:  BSF    FA0.1
....................      
....................     // Enable Global Interrupts. 
....................     enable_interrupts(GLOBAL); 
00D40:  MOVLW  C0
00D42:  IORWF  FF2,F
....................      
....................  
.................... //    Initialize for GPRS message queue. 
....................     InitializeGPRSMsgQueue(); 
00D44:  CALL   0B4C
....................     InitializeGPRSMsgHeader(); 
00D48:  GOTO   0C3A
....................     StuffDummyTimeStamp(); 
00D4C:  CALL   0C4C
....................      
....................     
....................     // Initialize the sending queue to M0 
....................     //InitializeDataSendQueue(); 
....................     InitializeDataQueue(&g_stIBCRcvQueue); 
00D50:  MOVLW  01
00D52:  MOVLB  B
00D54:  MOVWF  x13
00D56:  MOVLW  D5
00D58:  MOVWF  x12
00D5A:  MOVLB  0
00D5C:  CALL   0CA4
....................     InitializeDataQueue(&g_stIBCSendQueue); 
00D60:  MOVLW  01
00D62:  MOVLB  B
00D64:  MOVWF  x13
00D66:  MOVLW  88
00D68:  MOVWF  x12
00D6A:  MOVLB  0
00D6C:  CALL   0CA4
....................      
....................     // Initialize global variables for RS485 communication.     
....................     g_ui16CBBCount =  0; 
00D70:  CLRF   x80
00D72:  CLRF   x7F
....................     g_ui16CBBCountPrev = 0; 
00D74:  CLRF   x82
00D76:  CLRF   x81
....................     g_ui16CurrentWt = 0; 
00D78:  CLRF   x84
00D7A:  CLRF   x83
....................     g_ui16CurrentPassStatus = 0; 
00D7C:  CLRF   x86
00D7E:  CLRF   x85
....................     g_ui16RunningAvgWt = 0; 
00D80:  CLRF   x88
00D82:  CLRF   x87
....................     g_ui16RunningTareValue = 0; 
00D84:  CLRF   x8A
00D86:  CLRF   x89
....................     g_ui16ServerStatus = 0; 
00D88:  CLRF   x8C
00D8A:  CLRF   x8B
....................     g_ui16CurrentMode = 0; 
00D8C:  CLRF   xA6
00D8E:  CLRF   xA5
....................      
....................     // initialize variables for set point 
....................     g_ui16gAvgWtForCalibration = 0; 
00D90:  CLRF   x76
00D92:  CLRF   x75
....................     //g_ui16CounterForAvgCalibrationWt = 0; 
....................  
....................     // use for production type 
....................     g_fAutoCalibrationMode = 0; 
00D94:  CLRF   xA7
....................  
....................     // use for sample count for auto calibration 
....................     g_ui16AutoCalibrationSampleCount = 10; 
00D96:  CLRF   xA9
00D98:  MOVLW  0A
00D9A:  MOVWF  xA8
....................  
....................     // TESTING End 
....................     g_unIBCRcvByteNode.m_ui8Arr[0] = 0; 
00D9C:  MOVLB  1
00D9E:  CLRF   x86
....................     g_unIBCRcvByteNode.m_ui8Arr[1] = 0; 
00DA0:  CLRF   x87
....................      
....................     g_stIBCRcvData.g_ui8ArrIBCData[0] = 0; 
00DA2:  CLRF   x2F
....................     g_stIBCRcvData.g_ui8ArrIBCData[1] = 0; 
00DA4:  CLRF   x30
....................     g_stIBCRcvData.g_ui8ArrIBCData[2] = 0; 
00DA6:  CLRF   x31
....................     g_stIBCRcvData.g_ui8ArrIBCData[3] = 0; 
00DA8:  CLRF   x32
....................     g_stIBCRcvData.g_ui8ArrIBCData[4] = 0; 
00DAA:  CLRF   x33
00DAC:  MOVLB  0
00DAE:  GOTO   6442 (RETURN)
....................      
....................      
.................... }	 
....................  
.................... void main() 
*
058A2:  CLRF   FF8
058A4:  BCF    FF1.2
058A6:  BCF    F9F.0
058A8:  BCF    FA2.1
058AA:  BCF    FF0.6
058AC:  BCF    F9F.5
058AE:  BCF    FA5.5
058B0:  BSF    FD0.7
058B2:  BSF    07.7
058B4:  BSF    FA7.3
058B6:  MOVLW  08
058B8:  MOVWF  FAF
058BA:  MOVLW  02
058BC:  MOVWF  F7D
058BE:  MOVLW  A6
058C0:  MOVWF  FAC
058C2:  MOVLW  90
058C4:  MOVWF  FAB
058C6:  BSF    FB9.3
058C8:  MOVLW  08
058CA:  MOVWF  F7B
058CC:  MOVLW  02
058CE:  MOVWF  F7C
058D0:  MOVLW  A6
058D2:  MOVWF  FBA
058D4:  MOVLW  90
058D6:  MOVWF  FA6
058D8:  CLRF   xB6
058DA:  MOVLB  1
058DC:  CLRF   x28
058DE:  CLRF   x29
058E0:  MOVLW  03
058E2:  MOVWF  x2A
058E4:  CLRF   x2B
058E6:  CLRF   x2C
058E8:  MOVLW  A5
058EA:  MOVWF  x2D
058EC:  CLRF   x2E
058EE:  CLRF   x84
058F0:  CLRF   x85
058F2:  MOVLW  01
058F4:  MOVLB  2
058F6:  MOVWF  x22
058F8:  CLRF   x23
058FA:  CLRF   x25
058FC:  CLRF   x24
058FE:  MOVLW  29
05900:  MOVWF  x26
05902:  CLRF   x27
05904:  MOVLW  16
05906:  MOVWF  x28
05908:  MOVLW  0C
0590A:  MOVWF  x29
0590C:  MOVLW  0F
0590E:  MOVWF  x2A
05910:  CLRF   x2C
05912:  CLRF   x2B
05914:  CLRF   x2D
05916:  CLRF   x2E
05918:  CLRF   x30
0591A:  CLRF   x2F
0591C:  CLRF   x31
0591E:  CLRF   x33
05920:  CLRF   x32
05922:  CLRF   x34
05924:  MOVLW  1A
05926:  MOVWF  x35
05928:  CLRF   x37
0592A:  CLRF   x36
0592C:  CLRF   x38
0592E:  MOVLW  38
05930:  MOVWF  x39
05932:  CLRF   x3A
05934:  MOVLW  22
05936:  MOVWF  x3B
05938:  CLRF   x3C
0593A:  CLRF   x3D
0593C:  CLRF   x3E
0593E:  CLRF   x3F
05940:  CLRF   x43
05942:  CLRF   x42
05944:  CLRF   x82
05946:  CLRF   x96
05948:  CLRF   x97
0594A:  MOVLW  08
0594C:  MOVWF  x98
0594E:  CLRF   x99
05950:  CLRF   x9A
05952:  CLRF   x9B
05954:  CLRF   x9C
05956:  MOVLB  4
05958:  CLRF   x92
0595A:  CLRF   x91
0595C:  CLRF   x93
0595E:  MOVLB  6
05960:  CLRF   x89
05962:  CLRF   x88
05964:  CLRF   x8A
05966:  CLRF   x8B
05968:  CLRF   x8D
0596A:  MOVLW  01
0596C:  MOVWF  x8C
0596E:  CLRF   x8F
05970:  MOVLW  02
05972:  MOVWF  x8E
05974:  MOVLW  07
05976:  MOVWF  x91
05978:  MOVLW  CF
0597A:  MOVWF  x90
0597C:  CLRF   x92
0597E:  CLRF   x93
05980:  CLRF   x94
05982:  MOVLB  A
05984:  CLRF   x95
05986:  MOVLW  2D
05988:  MOVWF  x96
0598A:  MOVLB  B
0598C:  CLRF   x08
0598E:  CLRF   x07
05990:  CLRF   x0C
05992:  CLRF   x0B
05994:  CLRF   x0A
05996:  CLRF   x09
05998:  CLRF   x0E
0599A:  CLRF   x0D
0599C:  CLRF   x0F
0599E:  MOVLB  F
059A0:  MOVF   x5C,W
059A2:  ANDLW  80
059A4:  MOVWF  x5C
059A6:  MOVLW  00
059A8:  MOVWF  x5D
059AA:  BCF    FC1.3
059AC:  BCF    FC1.4
059AE:  BCF    FC1.5
059B0:  MOVLB  1
059B2:  CLRF   x88
059B4:  MOVLB  F
059B6:  CLRF   x5E
059B8:  CLRF   x5F
059BA:  MOVLW  0B
059BC:  MOVLB  2
059BE:  MOVWF  x41
059C0:  MOVLW  6A
059C2:  MOVWF  x40
059C4:  MOVLW  02
059C6:  MOVLB  B
059C8:  MOVWF  x6B
059CA:  MOVLW  D2
059CC:  MOVWF  x6A
059CE:  CLRF   x6D
059D0:  CLRF   x6C
059D2:  MOVLB  0
059D4:  CLRF   xE2
059D6:  CLRF   xE3
059D8:  CLRF   xE4
059DA:  CLRF   xE5
059DC:  CLRF   xE6
059DE:  CLRF   xE7
059E0:  CLRF   xE8
059E2:  CLRF   xE9
059E4:  CLRF   xEA
059E6:  CLRF   xEB
059E8:  CLRF   xEC
059EA:  CLRF   xED
059EC:  CLRF   xEE
059EE:  CLRF   xEF
059F0:  CLRF   xF0
059F2:  CLRF   xF1
059F4:  CLRF   xF2
059F6:  CLRF   xF3
059F8:  CLRF   xF4
059FA:  CLRF   xF5
059FC:  CLRF   xF6
059FE:  CLRF   xF7
05A00:  CLRF   xF8
05A02:  CLRF   xF9
05A04:  CLRF   xFA
05A06:  CLRF   xFB
05A08:  CLRF   xFC
05A0A:  CLRF   xFD
05A0C:  CLRF   xFE
05A0E:  CLRF   xFF
05A10:  MOVLB  1
05A12:  CLRF   x00
05A14:  CLRF   x01
05A16:  CLRF   x02
05A18:  CLRF   x03
05A1A:  CLRF   x04
05A1C:  CLRF   x05
05A1E:  CLRF   x06
05A20:  CLRF   x07
05A22:  CLRF   x08
05A24:  CLRF   x09
05A26:  CLRF   x0A
05A28:  CLRF   x0B
05A2A:  CLRF   x0C
05A2C:  CLRF   x0D
05A2E:  CLRF   x0E
05A30:  CLRF   x0F
05A32:  CLRF   x10
05A34:  CLRF   x11
05A36:  CLRF   x12
05A38:  CLRF   x13
05A3A:  CLRF   x14
05A3C:  CLRF   x15
05A3E:  CLRF   x16
05A40:  CLRF   x17
05A42:  CLRF   x18
05A44:  CLRF   x19
05A46:  CLRF   x1A
05A48:  CLRF   x1B
05A4A:  CLRF   x1C
05A4C:  CLRF   x1D
05A4E:  CLRF   x1E
05A50:  CLRF   x1F
05A52:  CLRF   x20
05A54:  CLRF   x21
05A56:  CLRF   x22
05A58:  CLRF   x23
05A5A:  CLRF   x24
05A5C:  CLRF   x25
05A5E:  CLRF   x26
05A60:  CLRF   x27
05A62:  CLRF   x39
05A64:  CLRF   x3A
05A66:  CLRF   x3B
05A68:  CLRF   x3C
05A6A:  CLRF   x3D
05A6C:  CLRF   x3E
05A6E:  CLRF   x3F
05A70:  CLRF   x40
05A72:  CLRF   x41
05A74:  CLRF   x42
05A76:  CLRF   x43
05A78:  CLRF   x44
05A7A:  CLRF   x45
05A7C:  CLRF   x46
05A7E:  CLRF   x47
05A80:  CLRF   x48
05A82:  CLRF   x49
05A84:  CLRF   x4A
05A86:  CLRF   x4B
05A88:  CLRF   x4C
05A8A:  CLRF   x4D
05A8C:  CLRF   x4E
05A8E:  CLRF   x4F
05A90:  CLRF   x50
05A92:  CLRF   x51
05A94:  CLRF   x52
05A96:  CLRF   x53
05A98:  CLRF   x54
05A9A:  CLRF   x55
05A9C:  CLRF   x56
05A9E:  CLRF   x57
05AA0:  CLRF   x58
05AA2:  CLRF   x59
05AA4:  CLRF   x5A
05AA6:  CLRF   x5B
05AA8:  CLRF   x5C
05AAA:  CLRF   x5D
05AAC:  CLRF   x5E
05AAE:  CLRF   x5F
05AB0:  CLRF   x60
05AB2:  CLRF   x61
05AB4:  CLRF   x62
05AB6:  CLRF   x63
05AB8:  CLRF   x64
05ABA:  CLRF   x65
05ABC:  CLRF   x66
05ABE:  CLRF   x67
05AC0:  CLRF   x68
05AC2:  CLRF   x69
05AC4:  CLRF   x6A
05AC6:  CLRF   x6B
05AC8:  CLRF   x6C
05ACA:  CLRF   x6D
05ACC:  CLRF   x6E
05ACE:  CLRF   x6F
05AD0:  CLRF   x70
05AD2:  CLRF   x71
05AD4:  CLRF   x72
05AD6:  CLRF   x73
05AD8:  CLRF   x74
05ADA:  CLRF   x75
05ADC:  CLRF   x76
05ADE:  CLRF   x77
05AE0:  CLRF   x78
05AE2:  CLRF   x79
05AE4:  CLRF   x7A
05AE6:  CLRF   x7B
05AE8:  CLRF   x7C
05AEA:  CLRF   x7D
05AEC:  CLRF   x7E
05AEE:  CLRF   x7F
05AF0:  CLRF   x80
05AF2:  CLRF   x81
05AF4:  CLRF   x82
05AF6:  CLRF   x83
05AF8:  MOVLB  2
05AFA:  CLRF   x83
05AFC:  CLRF   x84
05AFE:  CLRF   x85
05B00:  CLRF   x86
05B02:  CLRF   x87
05B04:  CLRF   x88
05B06:  CLRF   x89
05B08:  CLRF   x8A
05B0A:  CLRF   x8B
05B0C:  CLRF   x8C
05B0E:  CLRF   x8D
05B10:  CLRF   x8E
05B12:  CLRF   x8F
05B14:  CLRF   x90
05B16:  CLRF   x91
05B18:  CLRF   x9D
05B1A:  CLRF   x9E
05B1C:  CLRF   x9F
05B1E:  CLRF   xA0
05B20:  CLRF   xA1
05B22:  CLRF   xA2
05B24:  CLRF   xA3
05B26:  CLRF   xA4
05B28:  CLRF   xA5
05B2A:  CLRF   xA6
05B2C:  CLRF   xA7
05B2E:  CLRF   xA8
05B30:  CLRF   xA9
05B32:  CLRF   xAA
05B34:  CLRF   xAB
05B36:  CLRF   xAC
05B38:  CLRF   xAD
05B3A:  CLRF   xAE
05B3C:  CLRF   xAF
05B3E:  CLRF   xB0
05B40:  CLRF   xB1
05B42:  CLRF   xB2
05B44:  CLRF   xB3
05B46:  CLRF   xB4
05B48:  CLRF   xB5
05B4A:  CLRF   xB6
05B4C:  CLRF   xB7
05B4E:  CLRF   xB8
05B50:  CLRF   xB9
05B52:  CLRF   xBA
05B54:  CLRF   xBB
05B56:  CLRF   xBC
05B58:  CLRF   xBD
05B5A:  CLRF   xBE
05B5C:  CLRF   xBF
05B5E:  CLRF   xC0
05B60:  CLRF   xC1
05B62:  CLRF   xC2
05B64:  CLRF   xC3
05B66:  CLRF   xC4
05B68:  CLRF   xC5
05B6A:  CLRF   xC6
05B6C:  CLRF   xC7
05B6E:  CLRF   xC8
05B70:  CLRF   xC9
05B72:  CLRF   xCA
05B74:  CLRF   xCB
05B76:  CLRF   xCC
05B78:  CLRF   xCD
05B7A:  CLRF   xCE
05B7C:  CLRF   xCF
05B7E:  CLRF   xD0
05B80:  CLRF   xD1
05B82:  CLRF   xD2
05B84:  CLRF   xD3
05B86:  CLRF   xD4
05B88:  CLRF   xD5
05B8A:  CLRF   xD6
05B8C:  CLRF   xD7
05B8E:  CLRF   xD8
05B90:  CLRF   xD9
05B92:  CLRF   xDA
05B94:  CLRF   xDB
05B96:  CLRF   xDC
05B98:  CLRF   xDD
05B9A:  CLRF   xDE
05B9C:  CLRF   xDF
05B9E:  CLRF   xE0
05BA0:  CLRF   xE1
05BA2:  CLRF   xE2
05BA4:  CLRF   xE3
05BA6:  CLRF   xE4
05BA8:  CLRF   xE5
05BAA:  CLRF   xE6
05BAC:  CLRF   xE7
05BAE:  CLRF   xE8
05BB0:  CLRF   xE9
05BB2:  CLRF   xEA
05BB4:  CLRF   xEB
05BB6:  CLRF   xEC
05BB8:  CLRF   xED
05BBA:  CLRF   xEE
05BBC:  CLRF   xEF
05BBE:  CLRF   xF0
05BC0:  CLRF   xF1
05BC2:  CLRF   xF2
05BC4:  CLRF   xF3
05BC6:  CLRF   xF4
05BC8:  CLRF   xF5
05BCA:  CLRF   xF6
05BCC:  CLRF   xF7
05BCE:  CLRF   xF8
05BD0:  CLRF   xF9
05BD2:  CLRF   xFA
05BD4:  CLRF   xFB
05BD6:  CLRF   xFC
05BD8:  CLRF   xFD
05BDA:  CLRF   xFE
05BDC:  CLRF   xFF
05BDE:  MOVLB  3
05BE0:  CLRF   x00
05BE2:  CLRF   x01
05BE4:  CLRF   x02
05BE6:  CLRF   x03
05BE8:  CLRF   x04
05BEA:  CLRF   x05
05BEC:  CLRF   x06
05BEE:  CLRF   x07
05BF0:  CLRF   x08
05BF2:  CLRF   x09
05BF4:  CLRF   x0A
05BF6:  CLRF   x0B
05BF8:  CLRF   x0C
05BFA:  CLRF   x0D
05BFC:  CLRF   x0E
05BFE:  CLRF   x0F
05C00:  CLRF   x10
05C02:  CLRF   x11
05C04:  CLRF   x12
05C06:  CLRF   x13
05C08:  CLRF   x14
05C0A:  CLRF   x15
05C0C:  CLRF   x16
05C0E:  CLRF   x17
05C10:  CLRF   x18
05C12:  CLRF   x19
05C14:  CLRF   x1A
05C16:  CLRF   x1B
05C18:  CLRF   x1C
05C1A:  CLRF   x1D
05C1C:  CLRF   x1E
05C1E:  CLRF   x1F
05C20:  CLRF   x20
05C22:  CLRF   x21
05C24:  CLRF   x22
05C26:  CLRF   x23
05C28:  CLRF   x24
05C2A:  CLRF   x25
05C2C:  CLRF   x26
05C2E:  CLRF   x27
05C30:  CLRF   x28
05C32:  CLRF   x29
05C34:  CLRF   x2A
05C36:  CLRF   x2B
05C38:  CLRF   x2C
05C3A:  CLRF   x2D
05C3C:  CLRF   x2E
05C3E:  CLRF   x2F
05C40:  CLRF   x30
05C42:  CLRF   x31
05C44:  CLRF   x32
05C46:  CLRF   x33
05C48:  CLRF   x34
05C4A:  CLRF   x35
05C4C:  CLRF   x36
05C4E:  CLRF   x37
05C50:  CLRF   x38
05C52:  CLRF   x39
05C54:  CLRF   x3A
05C56:  CLRF   x3B
05C58:  CLRF   x3C
05C5A:  CLRF   x3D
05C5C:  CLRF   x3E
05C5E:  CLRF   x3F
05C60:  CLRF   x40
05C62:  CLRF   x41
05C64:  CLRF   x42
05C66:  CLRF   x43
05C68:  CLRF   x44
05C6A:  CLRF   x45
05C6C:  CLRF   x46
05C6E:  CLRF   x47
05C70:  CLRF   x48
05C72:  CLRF   x49
05C74:  CLRF   x4A
05C76:  CLRF   x4B
05C78:  CLRF   x4C
05C7A:  CLRF   x4D
05C7C:  CLRF   x4E
05C7E:  CLRF   x4F
05C80:  CLRF   x50
05C82:  CLRF   x51
05C84:  CLRF   x52
05C86:  CLRF   x53
05C88:  CLRF   x54
05C8A:  CLRF   x55
05C8C:  CLRF   x56
05C8E:  CLRF   x57
05C90:  CLRF   x58
05C92:  CLRF   x59
05C94:  CLRF   x5A
05C96:  CLRF   x5B
05C98:  CLRF   x5C
05C9A:  CLRF   x5D
05C9C:  CLRF   x5E
05C9E:  CLRF   x5F
05CA0:  CLRF   x60
05CA2:  CLRF   x61
05CA4:  CLRF   x62
05CA6:  CLRF   x63
05CA8:  CLRF   x64
05CAA:  CLRF   x65
05CAC:  CLRF   x66
05CAE:  CLRF   x67
05CB0:  CLRF   x68
05CB2:  CLRF   x69
05CB4:  CLRF   x6A
05CB6:  CLRF   x6B
05CB8:  CLRF   x6C
05CBA:  CLRF   x6D
05CBC:  CLRF   x6E
05CBE:  CLRF   x6F
05CC0:  CLRF   x70
05CC2:  CLRF   x71
05CC4:  CLRF   x72
05CC6:  CLRF   x73
05CC8:  CLRF   x74
05CCA:  CLRF   x75
05CCC:  CLRF   x76
05CCE:  CLRF   x77
05CD0:  CLRF   x78
05CD2:  CLRF   x79
05CD4:  CLRF   x7A
05CD6:  CLRF   x7B
05CD8:  CLRF   x7C
05CDA:  CLRF   x7D
05CDC:  CLRF   x7E
05CDE:  CLRF   x7F
05CE0:  CLRF   x80
05CE2:  CLRF   x81
05CE4:  CLRF   x82
05CE6:  CLRF   x83
05CE8:  CLRF   x84
05CEA:  CLRF   x85
05CEC:  CLRF   x86
05CEE:  CLRF   x87
05CF0:  CLRF   x88
05CF2:  CLRF   x89
05CF4:  CLRF   x8A
05CF6:  CLRF   x8B
05CF8:  CLRF   x8C
05CFA:  CLRF   x8D
05CFC:  CLRF   x8E
05CFE:  CLRF   x8F
05D00:  CLRF   x90
05D02:  CLRF   x91
05D04:  CLRF   x92
05D06:  CLRF   x93
05D08:  CLRF   x94
05D0A:  CLRF   x95
05D0C:  CLRF   x96
05D0E:  CLRF   x97
05D10:  CLRF   x98
05D12:  CLRF   x99
05D14:  CLRF   x9A
05D16:  CLRF   x9B
05D18:  CLRF   x9C
05D1A:  CLRF   x9D
05D1C:  CLRF   x9E
05D1E:  CLRF   x9F
05D20:  CLRF   xA0
05D22:  CLRF   xA1
05D24:  CLRF   xA2
05D26:  CLRF   xA3
05D28:  CLRF   xA4
05D2A:  CLRF   xA5
05D2C:  CLRF   xA6
05D2E:  CLRF   xA7
05D30:  CLRF   xA8
05D32:  CLRF   xA9
05D34:  CLRF   xAA
05D36:  CLRF   xAB
05D38:  CLRF   xAC
05D3A:  CLRF   xAD
05D3C:  CLRF   xAE
05D3E:  CLRF   xAF
05D40:  CLRF   xB0
05D42:  CLRF   xB1
05D44:  CLRF   xB2
05D46:  CLRF   xB3
05D48:  CLRF   xB4
05D4A:  CLRF   xB5
05D4C:  CLRF   xB6
05D4E:  CLRF   xB7
05D50:  CLRF   xB8
05D52:  CLRF   xB9
05D54:  CLRF   xBA
05D56:  CLRF   xBB
05D58:  CLRF   xBC
05D5A:  CLRF   xBD
05D5C:  CLRF   xBE
05D5E:  CLRF   xBF
05D60:  CLRF   xC0
05D62:  CLRF   xC1
05D64:  CLRF   xC2
05D66:  CLRF   xC3
05D68:  CLRF   xC4
05D6A:  CLRF   xC5
05D6C:  CLRF   xC6
05D6E:  CLRF   xC7
05D70:  CLRF   xC8
05D72:  CLRF   xC9
05D74:  CLRF   xCA
05D76:  CLRF   xCB
05D78:  CLRF   xCC
05D7A:  CLRF   xCD
05D7C:  CLRF   xCE
05D7E:  CLRF   xCF
05D80:  CLRF   xD0
05D82:  CLRF   xD1
05D84:  CLRF   xD2
05D86:  CLRF   xD3
05D88:  CLRF   xD4
05D8A:  CLRF   xD5
05D8C:  CLRF   xD6
05D8E:  CLRF   xD7
05D90:  CLRF   xD8
05D92:  CLRF   xD9
05D94:  CLRF   xDA
05D96:  CLRF   xDB
05D98:  CLRF   xDC
05D9A:  CLRF   xDD
05D9C:  CLRF   xDE
05D9E:  CLRF   xDF
05DA0:  CLRF   xE0
05DA2:  CLRF   xE1
05DA4:  CLRF   xE2
05DA6:  CLRF   xE3
05DA8:  CLRF   xE4
05DAA:  CLRF   xE5
05DAC:  CLRF   xE6
05DAE:  CLRF   xE7
05DB0:  CLRF   xE8
05DB2:  CLRF   xE9
05DB4:  CLRF   xEA
05DB6:  CLRF   xEB
05DB8:  CLRF   xEC
05DBA:  CLRF   xED
05DBC:  CLRF   xEE
05DBE:  CLRF   xEF
05DC0:  CLRF   xF0
05DC2:  CLRF   xF1
05DC4:  CLRF   xF2
05DC6:  CLRF   xF3
05DC8:  CLRF   xF4
05DCA:  CLRF   xF5
05DCC:  CLRF   xF6
05DCE:  CLRF   xF7
05DD0:  CLRF   xF8
05DD2:  CLRF   xF9
05DD4:  CLRF   xFA
05DD6:  CLRF   xFB
05DD8:  CLRF   xFC
05DDA:  CLRF   xFD
05DDC:  CLRF   xFE
05DDE:  CLRF   xFF
05DE0:  MOVLB  4
05DE2:  CLRF   x00
05DE4:  CLRF   x01
05DE6:  CLRF   x02
05DE8:  CLRF   x03
05DEA:  CLRF   x04
05DEC:  CLRF   x05
05DEE:  CLRF   x06
05DF0:  CLRF   x07
05DF2:  CLRF   x08
05DF4:  CLRF   x09
05DF6:  CLRF   x0A
05DF8:  CLRF   x0B
05DFA:  CLRF   x0C
05DFC:  CLRF   x0D
05DFE:  CLRF   x0E
05E00:  CLRF   x0F
05E02:  CLRF   x10
05E04:  CLRF   x11
05E06:  CLRF   x12
05E08:  CLRF   x13
05E0A:  CLRF   x14
05E0C:  CLRF   x15
05E0E:  CLRF   x16
05E10:  CLRF   x17
05E12:  CLRF   x18
05E14:  CLRF   x19
05E16:  CLRF   x1A
05E18:  CLRF   x1B
05E1A:  CLRF   x1C
05E1C:  CLRF   x1D
05E1E:  CLRF   x1E
05E20:  CLRF   x1F
05E22:  CLRF   x20
05E24:  CLRF   x21
05E26:  CLRF   x22
05E28:  CLRF   x23
05E2A:  CLRF   x24
05E2C:  CLRF   x25
05E2E:  CLRF   x26
05E30:  CLRF   x27
05E32:  CLRF   x28
05E34:  CLRF   x29
05E36:  CLRF   x2A
05E38:  CLRF   x2B
05E3A:  CLRF   x2C
05E3C:  CLRF   x2D
05E3E:  CLRF   x2E
05E40:  CLRF   x2F
05E42:  CLRF   x30
05E44:  CLRF   x31
05E46:  CLRF   x32
05E48:  CLRF   x33
05E4A:  CLRF   x34
05E4C:  CLRF   x35
05E4E:  CLRF   x36
05E50:  CLRF   x37
05E52:  CLRF   x38
05E54:  CLRF   x39
05E56:  CLRF   x3A
05E58:  CLRF   x3B
05E5A:  CLRF   x3C
05E5C:  CLRF   x3D
05E5E:  CLRF   x3E
05E60:  CLRF   x3F
05E62:  CLRF   x40
05E64:  CLRF   x41
05E66:  CLRF   x42
05E68:  CLRF   x43
05E6A:  CLRF   x44
05E6C:  CLRF   x45
05E6E:  CLRF   x46
05E70:  CLRF   x47
05E72:  CLRF   x48
05E74:  CLRF   x49
05E76:  CLRF   x4A
05E78:  CLRF   x4B
05E7A:  CLRF   x4C
05E7C:  CLRF   x4D
05E7E:  CLRF   x4E
05E80:  CLRF   x4F
05E82:  CLRF   x50
05E84:  CLRF   x51
05E86:  CLRF   x52
05E88:  CLRF   x53
05E8A:  CLRF   x54
05E8C:  CLRF   x55
05E8E:  CLRF   x56
05E90:  CLRF   x57
05E92:  CLRF   x58
05E94:  CLRF   x59
05E96:  CLRF   x5A
05E98:  CLRF   x5B
05E9A:  CLRF   x5C
05E9C:  CLRF   x5D
05E9E:  CLRF   x5E
05EA0:  CLRF   x5F
05EA2:  CLRF   x60
05EA4:  CLRF   x61
05EA6:  CLRF   x62
05EA8:  CLRF   x63
05EAA:  CLRF   x64
05EAC:  CLRF   x65
05EAE:  CLRF   x66
05EB0:  CLRF   x67
05EB2:  CLRF   x68
05EB4:  CLRF   x69
05EB6:  CLRF   x6A
05EB8:  CLRF   x6B
05EBA:  CLRF   x6C
05EBC:  CLRF   x6D
05EBE:  CLRF   x6E
05EC0:  CLRF   x6F
05EC2:  CLRF   x70
05EC4:  CLRF   x71
05EC6:  CLRF   x72
05EC8:  CLRF   x73
05ECA:  CLRF   x74
05ECC:  CLRF   x75
05ECE:  CLRF   x76
05ED0:  CLRF   x77
05ED2:  CLRF   x78
05ED4:  CLRF   x79
05ED6:  CLRF   x7A
05ED8:  CLRF   x7B
05EDA:  CLRF   x7C
05EDC:  CLRF   x7D
05EDE:  CLRF   x7E
05EE0:  CLRF   x7F
05EE2:  CLRF   x80
05EE4:  CLRF   x81
05EE6:  CLRF   x82
05EE8:  CLRF   x83
05EEA:  CLRF   x84
05EEC:  CLRF   x85
05EEE:  CLRF   x86
05EF0:  CLRF   x87
05EF2:  CLRF   x88
05EF4:  CLRF   x89
05EF6:  CLRF   x8A
05EF8:  CLRF   x8B
05EFA:  CLRF   x8C
05EFC:  CLRF   x8D
05EFE:  CLRF   x8E
05F00:  CLRF   x8F
05F02:  CLRF   x90
05F04:  CLRF   x94
05F06:  CLRF   x95
05F08:  CLRF   x96
05F0A:  CLRF   x97
05F0C:  CLRF   x98
05F0E:  CLRF   x99
05F10:  CLRF   x9A
05F12:  CLRF   x9B
05F14:  CLRF   x9C
05F16:  CLRF   x9D
05F18:  CLRF   x9E
05F1A:  CLRF   x9F
05F1C:  CLRF   xA0
05F1E:  CLRF   xA1
05F20:  CLRF   xA2
05F22:  CLRF   xA3
05F24:  CLRF   xA4
05F26:  CLRF   xA5
05F28:  CLRF   xA6
05F2A:  CLRF   xA7
05F2C:  CLRF   xA8
05F2E:  CLRF   xA9
05F30:  CLRF   xAA
05F32:  CLRF   xAB
05F34:  CLRF   xAC
05F36:  CLRF   xAD
05F38:  CLRF   xAE
05F3A:  CLRF   xAF
05F3C:  CLRF   xB0
05F3E:  CLRF   xB1
05F40:  CLRF   xB2
05F42:  CLRF   xB3
05F44:  CLRF   xB4
05F46:  CLRF   xB5
05F48:  CLRF   xB6
05F4A:  CLRF   xB7
05F4C:  CLRF   xB8
05F4E:  CLRF   xB9
05F50:  CLRF   xBA
05F52:  CLRF   xBB
05F54:  CLRF   xBC
05F56:  CLRF   xBD
05F58:  CLRF   xBE
05F5A:  CLRF   xBF
05F5C:  CLRF   xC0
05F5E:  CLRF   xC1
05F60:  CLRF   xC2
05F62:  CLRF   xC3
05F64:  CLRF   xC4
05F66:  CLRF   xC5
05F68:  CLRF   xC6
05F6A:  CLRF   xC7
05F6C:  CLRF   xC8
05F6E:  CLRF   xC9
05F70:  CLRF   xCA
05F72:  CLRF   xCB
05F74:  CLRF   xCC
05F76:  CLRF   xCD
05F78:  CLRF   xCE
05F7A:  CLRF   xCF
05F7C:  CLRF   xD0
05F7E:  CLRF   xD1
05F80:  CLRF   xD2
05F82:  CLRF   xD3
05F84:  CLRF   xD4
05F86:  CLRF   xD5
05F88:  CLRF   xD6
05F8A:  CLRF   xD7
05F8C:  CLRF   xD8
05F8E:  CLRF   xD9
05F90:  CLRF   xDA
05F92:  CLRF   xDB
05F94:  CLRF   xDC
05F96:  CLRF   xDD
05F98:  CLRF   xDE
05F9A:  CLRF   xDF
05F9C:  CLRF   xE0
05F9E:  CLRF   xE1
05FA0:  CLRF   xE2
05FA2:  CLRF   xE3
05FA4:  CLRF   xE4
05FA6:  CLRF   xE5
05FA8:  CLRF   xE6
05FAA:  CLRF   xE7
05FAC:  CLRF   xE8
05FAE:  CLRF   xE9
05FB0:  CLRF   xEA
05FB2:  CLRF   xEB
05FB4:  CLRF   xEC
05FB6:  CLRF   xED
05FB8:  CLRF   xEE
05FBA:  CLRF   xEF
05FBC:  CLRF   xF0
05FBE:  CLRF   xF1
05FC0:  CLRF   xF2
05FC2:  CLRF   xF3
05FC4:  CLRF   xF4
05FC6:  CLRF   xF5
05FC8:  CLRF   xF6
05FCA:  CLRF   xF7
05FCC:  CLRF   xF8
05FCE:  CLRF   xF9
05FD0:  CLRF   xFA
05FD2:  CLRF   xFB
05FD4:  CLRF   xFC
05FD6:  CLRF   xFD
05FD8:  CLRF   xFE
05FDA:  CLRF   xFF
05FDC:  MOVLB  5
05FDE:  CLRF   x00
05FE0:  CLRF   x01
05FE2:  CLRF   x02
05FE4:  CLRF   x03
05FE6:  CLRF   x04
05FE8:  CLRF   x05
05FEA:  CLRF   x06
05FEC:  CLRF   x07
05FEE:  CLRF   x08
05FF0:  CLRF   x09
05FF2:  CLRF   x0A
05FF4:  CLRF   x0B
05FF6:  CLRF   x0C
05FF8:  CLRF   x0D
05FFA:  CLRF   x0E
05FFC:  CLRF   x0F
05FFE:  CLRF   x10
06000:  CLRF   x11
06002:  CLRF   x12
06004:  CLRF   x13
06006:  CLRF   x14
06008:  CLRF   x15
0600A:  CLRF   x16
0600C:  CLRF   x17
0600E:  CLRF   x18
06010:  CLRF   x19
06012:  CLRF   x1A
06014:  CLRF   x1B
06016:  CLRF   x1C
06018:  CLRF   x1D
0601A:  CLRF   x1E
0601C:  CLRF   x1F
0601E:  CLRF   x20
06020:  CLRF   x21
06022:  CLRF   x22
06024:  CLRF   x23
06026:  CLRF   x24
06028:  CLRF   x25
0602A:  CLRF   x26
0602C:  CLRF   x27
0602E:  CLRF   x28
06030:  CLRF   x29
06032:  CLRF   x2A
06034:  CLRF   x2B
06036:  CLRF   x2C
06038:  CLRF   x2D
0603A:  CLRF   x2E
0603C:  CLRF   x2F
0603E:  CLRF   x30
06040:  CLRF   x31
06042:  CLRF   x32
06044:  CLRF   x33
06046:  CLRF   x34
06048:  CLRF   x35
0604A:  CLRF   x36
0604C:  CLRF   x37
0604E:  CLRF   x38
06050:  CLRF   x39
06052:  CLRF   x3A
06054:  CLRF   x3B
06056:  CLRF   x3C
06058:  CLRF   x3D
0605A:  CLRF   x3E
0605C:  CLRF   x3F
0605E:  CLRF   x40
06060:  CLRF   x41
06062:  CLRF   x42
06064:  CLRF   x43
06066:  CLRF   x44
06068:  CLRF   x45
0606A:  CLRF   x46
0606C:  CLRF   x47
0606E:  CLRF   x48
06070:  CLRF   x49
06072:  CLRF   x4A
06074:  CLRF   x4B
06076:  CLRF   x4C
06078:  CLRF   x4D
0607A:  CLRF   x4E
0607C:  CLRF   x4F
0607E:  CLRF   x50
06080:  CLRF   x51
06082:  CLRF   x52
06084:  CLRF   x53
06086:  CLRF   x54
06088:  CLRF   x55
0608A:  CLRF   x56
0608C:  CLRF   x57
0608E:  CLRF   x58
06090:  CLRF   x59
06092:  CLRF   x5A
06094:  CLRF   x5B
06096:  CLRF   x5C
06098:  CLRF   x5D
0609A:  CLRF   x5E
0609C:  CLRF   x5F
0609E:  CLRF   x60
060A0:  CLRF   x61
060A2:  CLRF   x62
060A4:  CLRF   x63
060A6:  CLRF   x64
060A8:  CLRF   x65
060AA:  CLRF   x66
060AC:  CLRF   x67
060AE:  CLRF   x68
060B0:  CLRF   x69
060B2:  CLRF   x6A
060B4:  CLRF   x6B
060B6:  CLRF   x6C
060B8:  CLRF   x6D
060BA:  CLRF   x6E
060BC:  CLRF   x6F
060BE:  CLRF   x70
060C0:  CLRF   x71
060C2:  CLRF   x72
060C4:  CLRF   x73
060C6:  CLRF   x74
060C8:  CLRF   x75
060CA:  CLRF   x76
060CC:  CLRF   x77
060CE:  CLRF   x78
060D0:  CLRF   x79
060D2:  CLRF   x7A
060D4:  CLRF   x7B
060D6:  CLRF   x7C
060D8:  CLRF   x7D
060DA:  CLRF   x7E
060DC:  CLRF   x7F
060DE:  CLRF   x80
060E0:  CLRF   x81
060E2:  CLRF   x82
060E4:  CLRF   x83
060E6:  CLRF   x84
060E8:  CLRF   x85
060EA:  CLRF   x86
060EC:  CLRF   x87
060EE:  CLRF   x88
060F0:  CLRF   x89
060F2:  CLRF   x8A
060F4:  CLRF   x8B
060F6:  CLRF   x8C
060F8:  CLRF   x8D
060FA:  CLRF   x8E
060FC:  CLRF   x8F
060FE:  CLRF   x90
06100:  CLRF   x91
06102:  CLRF   x92
06104:  CLRF   x93
06106:  CLRF   x94
06108:  CLRF   x95
0610A:  CLRF   x96
0610C:  CLRF   x97
0610E:  CLRF   x98
06110:  CLRF   x99
06112:  CLRF   x9A
06114:  CLRF   x9B
06116:  CLRF   x9C
06118:  CLRF   x9D
0611A:  CLRF   x9E
0611C:  CLRF   x9F
0611E:  CLRF   xA0
06120:  CLRF   xA1
06122:  CLRF   xA2
06124:  CLRF   xA3
06126:  CLRF   xA4
06128:  CLRF   xA5
0612A:  CLRF   xA6
0612C:  CLRF   xA7
0612E:  CLRF   xA8
06130:  CLRF   xA9
06132:  CLRF   xAA
06134:  CLRF   xAB
06136:  CLRF   xAC
06138:  CLRF   xAD
0613A:  CLRF   xAE
0613C:  CLRF   xAF
0613E:  CLRF   xB0
06140:  CLRF   xB1
06142:  CLRF   xB2
06144:  CLRF   xB3
06146:  CLRF   xB4
06148:  CLRF   xB5
0614A:  CLRF   xB6
0614C:  CLRF   xB7
0614E:  CLRF   xB8
06150:  CLRF   xB9
06152:  CLRF   xBA
06154:  CLRF   xBB
06156:  CLRF   xBC
06158:  CLRF   xBD
0615A:  CLRF   xBE
0615C:  CLRF   xBF
0615E:  CLRF   xC0
06160:  CLRF   xC1
06162:  CLRF   xC2
06164:  CLRF   xC3
06166:  CLRF   xC4
06168:  CLRF   xC5
0616A:  CLRF   xC6
0616C:  CLRF   xC7
0616E:  CLRF   xC8
06170:  CLRF   xC9
06172:  CLRF   xCA
06174:  CLRF   xCB
06176:  CLRF   xCC
06178:  CLRF   xCD
0617A:  CLRF   xCE
0617C:  CLRF   xCF
0617E:  CLRF   xD0
06180:  CLRF   xD1
06182:  CLRF   xD2
06184:  CLRF   xD3
06186:  CLRF   xD4
06188:  CLRF   xD5
0618A:  CLRF   xD6
0618C:  CLRF   xD7
0618E:  CLRF   xD8
06190:  CLRF   xD9
06192:  CLRF   xDA
06194:  CLRF   xDB
06196:  CLRF   xDC
06198:  CLRF   xDD
0619A:  CLRF   xDE
0619C:  CLRF   xDF
0619E:  CLRF   xE0
061A0:  CLRF   xE1
061A2:  CLRF   xE2
061A4:  CLRF   xE3
061A6:  CLRF   xE4
061A8:  CLRF   xE5
061AA:  CLRF   xE6
061AC:  CLRF   xE7
061AE:  CLRF   xE8
061B0:  CLRF   xE9
061B2:  CLRF   xEA
061B4:  CLRF   xEB
061B6:  CLRF   xEC
061B8:  CLRF   xED
061BA:  CLRF   xEE
061BC:  CLRF   xEF
061BE:  CLRF   xF0
061C0:  CLRF   xF1
061C2:  CLRF   xF2
061C4:  CLRF   xF3
061C6:  CLRF   xF4
061C8:  CLRF   xF5
061CA:  CLRF   xF6
061CC:  CLRF   xF7
061CE:  CLRF   xF8
061D0:  CLRF   xF9
061D2:  CLRF   xFA
061D4:  CLRF   xFB
061D6:  CLRF   xFC
061D8:  CLRF   xFD
061DA:  CLRF   xFE
061DC:  CLRF   xFF
061DE:  MOVLB  6
061E0:  CLRF   x00
061E2:  CLRF   x01
061E4:  CLRF   x02
061E6:  CLRF   x03
061E8:  CLRF   x04
061EA:  CLRF   x05
061EC:  CLRF   x06
061EE:  CLRF   x07
061F0:  CLRF   x08
061F2:  CLRF   x09
061F4:  CLRF   x0A
061F6:  CLRF   x0B
061F8:  CLRF   x0C
061FA:  CLRF   x0D
061FC:  CLRF   x0E
061FE:  CLRF   x0F
06200:  CLRF   x10
06202:  CLRF   x11
06204:  CLRF   x12
06206:  CLRF   x13
06208:  CLRF   x14
0620A:  CLRF   x15
0620C:  CLRF   x16
0620E:  CLRF   x17
06210:  CLRF   x18
06212:  CLRF   x19
06214:  CLRF   x1A
06216:  CLRF   x1B
06218:  CLRF   x1C
0621A:  CLRF   x1D
0621C:  CLRF   x1E
0621E:  CLRF   x1F
06220:  CLRF   x20
06222:  CLRF   x21
06224:  CLRF   x22
06226:  CLRF   x23
06228:  CLRF   x24
0622A:  CLRF   x25
0622C:  CLRF   x26
0622E:  CLRF   x27
06230:  CLRF   x28
06232:  CLRF   x29
06234:  CLRF   x2A
06236:  CLRF   x2B
06238:  CLRF   x2C
0623A:  CLRF   x2D
0623C:  CLRF   x2E
0623E:  CLRF   x2F
06240:  CLRF   x30
06242:  CLRF   x31
06244:  CLRF   x32
06246:  CLRF   x33
06248:  CLRF   x34
0624A:  CLRF   x35
0624C:  CLRF   x36
0624E:  CLRF   x37
06250:  CLRF   x38
06252:  CLRF   x39
06254:  CLRF   x3A
06256:  CLRF   x3B
06258:  CLRF   x3C
0625A:  CLRF   x3D
0625C:  CLRF   x3E
0625E:  CLRF   x3F
06260:  CLRF   x40
06262:  CLRF   x41
06264:  CLRF   x42
06266:  CLRF   x43
06268:  CLRF   x44
0626A:  CLRF   x45
0626C:  CLRF   x46
0626E:  CLRF   x47
06270:  CLRF   x48
06272:  CLRF   x49
06274:  CLRF   x4A
06276:  CLRF   x4B
06278:  CLRF   x4C
0627A:  CLRF   x4D
0627C:  CLRF   x4E
0627E:  CLRF   x4F
06280:  CLRF   x50
06282:  CLRF   x51
06284:  CLRF   x52
06286:  CLRF   x53
06288:  CLRF   x54
0628A:  CLRF   x55
0628C:  CLRF   x56
0628E:  CLRF   x57
06290:  CLRF   x58
06292:  CLRF   x59
06294:  CLRF   x5A
06296:  CLRF   x5B
06298:  CLRF   x5C
0629A:  CLRF   x5D
0629C:  CLRF   x5E
0629E:  CLRF   x5F
062A0:  CLRF   x60
062A2:  CLRF   x61
062A4:  CLRF   x62
062A6:  CLRF   x63
062A8:  CLRF   x64
062AA:  CLRF   x65
062AC:  CLRF   x66
062AE:  CLRF   x67
062B0:  CLRF   x68
062B2:  CLRF   x69
062B4:  CLRF   x6A
062B6:  CLRF   x6B
062B8:  CLRF   x6C
062BA:  CLRF   x6D
062BC:  CLRF   x6E
062BE:  CLRF   x6F
062C0:  CLRF   x70
062C2:  CLRF   x71
062C4:  CLRF   x72
062C6:  CLRF   x73
062C8:  CLRF   x74
062CA:  CLRF   x75
062CC:  CLRF   x76
062CE:  CLRF   x77
062D0:  CLRF   x78
062D2:  CLRF   x79
062D4:  CLRF   x7A
062D6:  CLRF   x7B
062D8:  CLRF   x7C
062DA:  CLRF   x7D
062DC:  CLRF   x7E
062DE:  CLRF   x7F
062E0:  CLRF   x80
062E2:  CLRF   x81
062E4:  CLRF   x82
062E6:  CLRF   x83
062E8:  CLRF   x84
062EA:  CLRF   x85
062EC:  CLRF   x86
062EE:  CLRF   x87
062F0:  MOVLB  A
062F2:  CLRF   x25
062F4:  CLRF   x26
062F6:  CLRF   x27
062F8:  CLRF   x28
062FA:  CLRF   x29
062FC:  CLRF   x2A
062FE:  CLRF   x2B
06300:  CLRF   x2C
06302:  CLRF   x2D
06304:  CLRF   x2E
06306:  CLRF   x2F
06308:  CLRF   x30
0630A:  CLRF   x31
0630C:  CLRF   x32
0630E:  CLRF   x33
06310:  CLRF   x34
06312:  CLRF   x35
06314:  CLRF   x36
06316:  CLRF   x37
06318:  CLRF   x38
0631A:  CLRF   x39
0631C:  CLRF   x3A
0631E:  CLRF   x3B
06320:  CLRF   x3C
06322:  CLRF   x3D
06324:  CLRF   x3E
06326:  CLRF   x3F
06328:  CLRF   x40
0632A:  CLRF   x41
0632C:  CLRF   x42
0632E:  CLRF   x43
06330:  CLRF   x44
06332:  CLRF   x45
06334:  CLRF   x46
06336:  CLRF   x47
06338:  CLRF   x48
0633A:  CLRF   x49
0633C:  CLRF   x4A
0633E:  CLRF   x4B
06340:  CLRF   x4C
06342:  CLRF   x4D
06344:  CLRF   x4E
06346:  CLRF   x4F
06348:  CLRF   x50
0634A:  CLRF   x51
0634C:  CLRF   x52
0634E:  CLRF   x53
06350:  CLRF   x54
06352:  CLRF   x55
06354:  CLRF   x56
06356:  CLRF   x57
06358:  CLRF   x58
0635A:  CLRF   x59
0635C:  CLRF   x5A
0635E:  CLRF   x5B
06360:  CLRF   x5C
06362:  CLRF   x5D
06364:  CLRF   x5E
06366:  CLRF   x5F
06368:  CLRF   x60
0636A:  CLRF   x61
0636C:  CLRF   x62
0636E:  CLRF   x63
06370:  CLRF   x64
06372:  CLRF   x65
06374:  CLRF   x66
06376:  CLRF   x67
06378:  CLRF   x68
0637A:  CLRF   x69
0637C:  CLRF   x6A
0637E:  CLRF   x6B
06380:  CLRF   x6C
06382:  CLRF   x6D
06384:  MOVLW  2B
06386:  MOVWF  x6E
06388:  MOVLW  39
0638A:  MOVWF  x6F
0638C:  MOVLW  31
0638E:  MOVWF  x70
06390:  MOVLW  37
06392:  MOVWF  x71
06394:  MOVLW  30
06396:  MOVWF  x72
06398:  MOVLW  34
0639A:  MOVWF  x73
0639C:  MOVWF  x74
0639E:  MOVLW  33
063A0:  MOVWF  x75
063A2:  MOVLW  34
063A4:  MOVWF  x76
063A6:  MOVLW  31
063A8:  MOVWF  x77
063AA:  MOVLW  34
063AC:  MOVWF  x78
063AE:  MOVLW  31
063B0:  MOVWF  x79
063B2:  MOVLW  34
063B4:  MOVWF  x7A
063B6:  MOVLW  2B
063B8:  MOVWF  x7B
063BA:  MOVLW  39
063BC:  MOVWF  x7C
063BE:  MOVLW  31
063C0:  MOVWF  x7D
063C2:  MOVLW  38
063C4:  MOVWF  x7E
063C6:  MOVLW  39
063C8:  MOVWF  x7F
063CA:  MOVLW  38
063CC:  MOVWF  x80
063CE:  MOVLW  31
063D0:  MOVWF  x81
063D2:  MOVLW  37
063D4:  MOVWF  x82
063D6:  MOVLW  38
063D8:  MOVWF  x83
063DA:  MOVLW  33
063DC:  MOVWF  x84
063DE:  MOVLW  36
063E0:  MOVWF  x85
063E2:  MOVLW  30
063E4:  MOVWF  x86
063E6:  MOVLW  39
063E8:  MOVWF  x87
063EA:  MOVLW  2B
063EC:  MOVWF  x88
063EE:  MOVLW  39
063F0:  MOVWF  x89
063F2:  MOVLW  31
063F4:  MOVWF  x8A
063F6:  MOVLW  39
063F8:  MOVWF  x8B
063FA:  MOVLW  38
063FC:  MOVWF  x8C
063FE:  MOVLW  30
06400:  MOVWF  x8D
06402:  MOVLW  34
06404:  MOVWF  x8E
06406:  MOVLW  36
06408:  MOVWF  x8F
0640A:  MOVWF  x90
0640C:  MOVLW  38
0640E:  MOVWF  x91
06410:  MOVLW  31
06412:  MOVWF  x92
06414:  MOVLW  32
06416:  MOVWF  x93
06418:  MOVWF  x94
0641A:  MOVLB  B
0641C:  CLRF   x10
0641E:  CLRF   x11
.................... { 
....................     unsigned int8 ui8Response                       = 0; 
....................     unsigned int8 ui8RetVal                         = 0; 
.................... //    unsigned int8 GprsFailedConnectionAttemptCount  = 0; 
.................... //	unsigned int8 GprsFailedToDisconnectCount 		= 0; 
.................... //	unsigned int8 ui8SendAttemptCount               = 0;	 
....................     g_fIsGPRSConnected                              = GPRS_NOT_CONNECTED; 
06420:  MOVLB  A
06422:  CLRF   x95
....................     g_fGPRSSequence                                 = 1; 
06424:  MOVLW  01
06426:  MOVLB  6
06428:  MOVWF  x93
....................      
.................... 	// Set Watch Dog Timer ON. 
....................     setup_wdt(WDT_ON); 
0642A:  BSF    FD1.0
....................      
.................... 	//Initialize 1 millisecond timer. 
.................... 	Init1MSTimer(); 
0642C:  MOVLB  0
0642E:  GOTO   0AAE
....................      
.................... //////    // TESTING Start 
.................... //////    // Initialize TIMER1. 
.................... //////    InitTIMER1(); 
.................... //////    // Initialize TIMER3. 
.................... //////    InitTIMER3(); 
.................... //////    // TESTING End 
.................... 	 
.................... 	//Initialize RS485 Receive interrupt. 
.................... 	InitRS485RxInterrupt(); 
06432:  GOTO   0AE6
.................... 	 
.................... 	//Initialize UART2 Receive interrupt 
....................     InitM66RxInterrupt(); 
06436:  GOTO   0B0A
....................  
.................... 	//Configure RS485 pins of micro. 
.................... 	SetRS485PortPinOfMicro(); 
0643A:  GOTO   0B10
.................... 	 
.................... 	 
.................... 	//for TESTING.  
.................... 	//ManipulateToleranceTable(); 
.................... 	 
.................... 	// Initialize Main Global variables  
.................... 	Initialize(); 
0643E:  GOTO   0D2A
....................      
....................     // Set GSM modem ready 
....................     delay_ms(3000); 
06442:  MOVLW  0C
06444:  MOVLB  B
06446:  MOVWF  x12
06448:  MOVLW  FA
0644A:  MOVWF  x34
0644C:  MOVLB  0
0644E:  CALL   0DB2
06452:  MOVLB  B
06454:  DECFSZ x12,F
06456:  BRA    6448
....................      
....................     // Configure SIM900 Module 
....................     //SetAutomaticSMSRecvOn();  // ##################### TODO must setup echo disable #################### 
....................     //SetM66BasicSMSConfiguration(); 
....................  
.................... 	// Reset WDT. 
.................... 	restart_wdt(); 
06458:  CLRWDT
....................  
.................... 	for(;;) 
.................... 	{  
....................         // TESTING Start 
....................         if (1 == g_fIBCDataReceived) 
0645A:  MOVLB  1
0645C:  DECFSZ x84,W
0645E:  GOTO   647E
....................         { 
....................             // The complete 5 byte data has been received 
....................             // Now we can process the data 
....................             g_fIBCDataReceived = 0; 
06462:  CLRF   x84
....................  
....................             // Insert Message into IBC Receive Queue 
....................             InsertIBCMsgQueue(&g_stIBCRcvQueue, &g_stIBCRcvData); 
06464:  MOVLW  01
06466:  MOVLB  B
06468:  MOVWF  x49
0646A:  MOVLW  D5
0646C:  MOVWF  x48
0646E:  MOVLW  01
06470:  MOVWF  x4B
06472:  MOVLW  2F
06474:  MOVWF  x4A
06476:  MOVLB  0
06478:  CALL   0E5C
0647C:  MOVLB  1
....................         } 
....................         //  
....................         //GetRTC(); 
....................         // Step 1: Check if a Node received in IBC..then process data. 
.................... //        if (g_fIBCDataReceived) 
.................... //        { 
.................... //            // Reset the flag 
.................... //            g_fIBCDataReceived = 0; 
.................... //             
.................... //            // Process data 
.................... //           ProcessIBCMsg(); 
.................... //        } 
....................          
....................         // Step 2: Check if there is any message in IBC Send Queue 
.................... //        if (IsMSGAvailableInIBCSendQueue() && (0 == g_fIBCSendBusy)) 
.................... //        { 
.................... //            // Make IBC Send Busy 
.................... //            g_fIBCSendBusy = 1; 
.................... //            // Call Send IBC Message 
.................... //            SendIBCMSG(); SendIBCMSGFromQ 
.................... //        } 
.................... //        if (IsMSGAvailableInIBCSendQueue() && (0 == g_fIBCSendBusy)) 
.................... //        { 
.................... //            // Make IBC Send Busy 
.................... //            g_fIBCSendBusy = 1; 
.................... //            // Call Send IBC Message 
.................... //            SendIBCMSGFromQ(); 
.................... //        } 
....................          
....................     // Check If There is data ready to send HMI through RS485 
....................     if (FLAG_RS485_DATA_SEND_ON == g_ui8fRS485DataSend)// && g_ui8ByteToSend > 0 ) 
0647E:  DECFSZ x2A,W
06480:  GOTO   64BC
....................     { 
....................         fputc(g_RS485TxBuffer[g_ui8RS485ByteCnt++], RS485); 
06484:  MOVLB  2
06486:  MOVF   x3D,W
06488:  INCF   x3D,F
0648A:  CLRF   03
0648C:  ADDLW  E2
0648E:  MOVWF  FE9
06490:  MOVLW  00
06492:  ADDWFC 03,W
06494:  MOVWF  FEA
06496:  MOVFF  FEF,B12
0649A:  MOVLB  B
0649C:  MOVF   x12,W
0649E:  MOVLB  0
064A0:  CALL   1050
....................         if (g_ui8RS485ByteCnt >= g_ui8ByteToSend) 
064A4:  MOVLB  1
064A6:  MOVF   x29,W
064A8:  MOVLB  2
064AA:  SUBWF  x3D,W
064AC:  BTFSS  FD8.0
064AE:  GOTO   64BE
....................         { 
....................             g_ui8RS485ByteCnt = 0; 
064B2:  CLRF   x3D
....................             g_ui8ByteToSend = 0; 
064B4:  MOVLB  1
064B6:  CLRF   x29
....................             g_ui8fRS485DataSend = FLAG_RS485_DATA_SEND_DONE; 
064B8:  MOVLW  02
064BA:  MOVWF  x2A
064BC:  MOVLB  2
....................         } 
....................     } 
....................      
....................     // Data Sending through IBC.     
....................     // Check if there is any message in IBC Send Queue 
....................     if (IsMSGInIBCQueue(&g_stIBCSendQueue) && (0 == g_fIBCSendBusy)) 
064BE:  MOVLW  01
064C0:  MOVLB  B
064C2:  MOVWF  x13
064C4:  MOVLW  88
064C6:  MOVWF  x12
064C8:  MOVLB  0
064CA:  CALL   105C
064CE:  MOVF   01,F
064D0:  BTFSC  FD8.2
064D2:  GOTO   64EE
064D6:  MOVLB  1
064D8:  MOVF   x85,F
064DA:  BTFSC  FD8.2
064DC:  BRA    64E4
064DE:  MOVLB  0
064E0:  GOTO   64EE
....................     { 
....................         // Make IBC Send Busy 
....................         g_fIBCSendBusy = 1; 
064E4:  MOVLW  01
064E6:  MOVWF  x85
....................         // Call Send IBC Message 
....................         SendIBCMSGFromQ(); 
064E8:  MOVLB  0
064EA:  GOTO   116E
....................     } 
....................  
....................     // Data receive through IBC. 
....................     // Check if there is any message in IBC Receive Queue 
....................     if (IsMSGInIBCQueue(&g_stIBCRcvQueue)) 
064EE:  MOVLW  01
064F0:  MOVLB  B
064F2:  MOVWF  x13
064F4:  MOVLW  D5
064F6:  MOVWF  x12
064F8:  MOVLB  0
064FA:  CALL   105C
064FE:  MOVF   01,F
06500:  BTFSC  FD8.2
06502:  GOTO   650A
....................     { 
....................         // Process IBC  
....................         ProcessIBCMsg(); 
06506:  GOTO   16EC
....................     } 
....................   
....................  
....................     // Step 3: Check for "AT-OK" after every 60 minutes. 
....................     if(CHECK_FOR_AT_RESPONSE == g_fShouldCheckForAtResponse) 
0650A:  MOVLB  2
0650C:  MOVF   x2A,W
0650E:  SUBLW  0F
06510:  BTFSS  FD8.2
06512:  GOTO   6576
....................     { 
....................         ui8Response = 0; 
06516:  MOVLB  B
06518:  CLRF   x10
....................         // Send AT Command. 
....................         ui8Response = SendATCommand(); 
0651A:  MOVLB  0
0651C:  GOTO   1ACE
06520:  MOVFF  01,B10
....................  
....................         // Check "AT" command response. 
....................         // If "OK" is not received then restart SIM900 module and MCU. 
....................         if(!ui8Response) 
06524:  MOVLB  B
06526:  MOVF   x10,F
06528:  BTFSS  FD8.2
0652A:  GOTO   656A
....................         { 
....................             // Check if MCU's consecutive restart prevents to reset. 
....................             if(REDAY_TO_RESTART_MCU == g_fIsReadyToRestartMCU) 
0652E:  MOVLB  2
06530:  MOVF   x3B,W
06532:  SUBLW  21
06534:  BTFSS  FD8.2
06536:  GOTO   6564
....................             { 
....................                 // Update SIM900 Module health check flag 
....................                 g_fIsSIM900ModuleOK = GPRS_MODULE_HEALTH_MODULE_IS_NOT_OK; 
0653A:  MOVLW  2D
0653C:  MOVLB  A
0653E:  MOVWF  x96
....................  
....................                 // Reset SIM900 
....................                 output_bit(PIN_IN_EXT_DI_00, 0); 
06540:  BCF    F8B.0
06542:  BCF    F94.0
....................                 delay_ms(5000); 
06544:  MOVLW  14
06546:  MOVLB  B
06548:  MOVWF  x12
0654A:  MOVLW  FA
0654C:  MOVWF  x34
0654E:  MOVLB  0
06550:  CALL   0DB2
06554:  MOVLB  B
06556:  DECFSZ x12,F
06558:  BRA    654A
....................                 output_bit(PIN_IN_EXT_DI_00, 1); 
0655A:  BSF    F8B.0
0655C:  BCF    F94.0
....................  
....................                 // Reset MCU  // ##### Warning -> Restart MCU will cause to loose GPRS queue data permanently ########### 
....................                 for(;;) 
....................                 { 
0655E:  GOTO   655E
06562:  MOVLB  2
....................  
....................                 } 
....................             } 
....................         } 
06564:  GOTO   6576
06568:  MOVLB  B
....................  
....................         else 
....................         { 
....................             // Update SIM900 Module health check flag 
....................             g_fIsSIM900ModuleOK = GPRS_MODULE_HEALTH_OK; 
0656A:  MOVLW  2C
0656C:  MOVLB  A
0656E:  MOVWF  x96
....................             // If "OK" received then reset flag 
....................             g_fShouldCheckForAtResponse = DO_NOT_CHECK_FOR_AT_RESPONSE; 
06570:  MOVLW  10
06572:  MOVLB  2
06574:  MOVWF  x2A
....................         }     
....................     } 
....................  
....................  
....................     // Step 4: Check if a byte received in Modbus..then process data. 
....................     if(ISR_RECEIVED_ALL_BYTE == g_fISRAllByteReceived) 
06576:  MOVF   x28,W
06578:  SUBLW  15
0657A:  BTFSS  FD8.2
0657C:  GOTO   658C
....................     {  
....................         // Process received data. 
....................         ProcessUART2ReceivedData(); 
06580:  MOVLB  0
06582:  GOTO   330A
....................  
....................         // Reset flag. 
....................         g_fISRAllByteReceived = ISR_PROCESSED_ALL_BYTE; 
06586:  MOVLW  16
06588:  MOVLB  2
0658A:  MOVWF  x28
....................     } 
....................      
....................          
....................         // Whole data sending process is segregated into small modules to freed-up  
....................         // the time for GPRS data sending so that main() get more time to run. 
....................         // Preliminary data is sent after every 1 minute 
....................          
....................  // ################ Below steps are for GPRS modular data sending ###################### 
....................          
....................         // Step 1: Check for should data send through GPRS 
....................         if(SHOULD_SEND_DATA == g_fShouldSendData && g_fGPRSSequence == GPRS_DATA_SENDING_SEQUENCE_1 && g_fIsSIM900ModuleOK == GPRS_MODULE_HEALTH_OK) 
0658C:  MOVF   x35,W
0658E:  SUBLW  19
06590:  BTFSS  FD8.2
06592:  GOTO   65CE
06596:  MOVLB  6
06598:  DECFSZ x93,W
0659A:  BRA    659E
0659C:  BRA    65A4
0659E:  MOVLB  2
065A0:  GOTO   65CE
065A4:  MOVLB  A
065A6:  MOVF   x96,W
065A8:  SUBLW  2C
065AA:  BTFSC  FD8.2
065AC:  BRA    65B4
065AE:  MOVLB  2
065B0:  GOTO   65CE
....................         { 
....................             // Check GPRS connection 
....................             // Send GPRS connection check query 
....................             //SendCheckGPRSConnectionQuery(); // SIM900 
....................             SendGPRSConnectionQuery(); // 4G_EC20 
065B4:  MOVLB  0
065B6:  GOTO   381C
....................              
....................             // Set timeout of 1 second. 
....................             SetTimeout(GPRS_CONNECTION_QUERY_TIMEOUT); 
065BA:  MOVLW  03
065BC:  MOVLB  B
065BE:  MOVWF  x1B
065C0:  MOVLB  0
065C2:  CALL   1AA6
....................              
....................             // Update sequence flag 
....................             g_fGPRSSequence = GPRS_DATA_SENDING_SEQUENCE_2; 
065C6:  MOVLW  02
065C8:  MOVLB  6
065CA:  MOVWF  x93
065CC:  MOVLB  2
....................              
....................         } 
....................          
....................         // Step 2: Check for GPRS check connection query response 
....................         if(1 == g_fIsTimedOut && g_fGPRSSequence == GPRS_DATA_SENDING_SEQUENCE_2) 
065CE:  DECFSZ x34,W
065D0:  GOTO   661E
065D4:  MOVLB  6
065D6:  MOVF   x93,W
065D8:  SUBLW  02
065DA:  BTFSC  FD8.2
065DC:  BRA    65E4
065DE:  MOVLB  2
065E0:  GOTO   661E
....................         { 
....................             // Check GPRS connection check query response 
....................             ui8RetVal = CheckGPRSConnectionQueryResponse(); 
065E4:  MOVLB  0
065E6:  GOTO   384E
065EA:  MOVFF  01,B11
....................              
....................             if(1 == ui8RetVal) // GPRS already connected 
065EE:  MOVLB  B
065F0:  DECFSZ x11,W
065F2:  GOTO   6608
....................             { 
....................                 // Update Flag. 
....................                 g_fIsGPRSConnected = GPRS_CONNECTED; 
065F6:  MOVLW  01
065F8:  MOVLB  A
065FA:  MOVWF  x95
....................                  
....................                 // Update sequence flag 
....................                 g_fGPRSSequence = GPRS_DATA_SENDING_SEQUENCE_4; 
065FC:  MOVLW  04
065FE:  MOVLB  6
06600:  MOVWF  x93
....................             } 
06602:  GOTO   661A
06606:  MOVLB  B
....................             else if(0 == ui8RetVal) // GPRS is not connected 
06608:  MOVF   x11,F
0660A:  BTFSS  FD8.2
0660C:  GOTO   661C
....................             { 
....................                 // Update Flag 
....................                 g_fIsGPRSConnected = GPRS_NOT_CONNECTED; 
06610:  MOVLB  A
06612:  CLRF   x95
....................                  
....................                 // Update sequence flag 
....................                 g_fGPRSSequence = GPRS_DATA_SENDING_SEQUENCE_3; 
06614:  MOVLW  03
06616:  MOVLB  6
06618:  MOVWF  x93
0661A:  MOVLB  B
0661C:  MOVLB  2
....................             
....................             } 
....................         } 
....................          
....................         // Step 3: If GPRS is not connected then connect GPRS 
....................         if(GPRS_NOT_CONNECTED == g_fIsGPRSConnected && g_fGPRSSequence == GPRS_DATA_SENDING_SEQUENCE_3) 
0661E:  MOVLB  A
06620:  MOVF   x95,F
06622:  BTFSS  FD8.2
06624:  GOTO   667C
06628:  MOVLB  6
0662A:  MOVF   x93,W
0662C:  SUBLW  03
0662E:  BTFSC  FD8.2
06630:  BRA    6638
06632:  MOVLB  A
06634:  GOTO   667C
....................         { 
....................             // Connect GPRS 
....................             ui8RetVal = ConnectGPRS(); 
06638:  MOVLB  0
0663A:  GOTO   3FBC
0663E:  MOVFF  01,B11
....................              
....................             // Check return value 
....................             if(0 == ui8RetVal) // On success 
06642:  MOVLB  B
06644:  MOVF   x11,F
06646:  BTFSS  FD8.2
06648:  GOTO   665E
....................             { 
....................                 // Update Flag. 
....................                 g_fIsGPRSConnected = GPRS_CONNECTED; 
0664C:  MOVLW  01
0664E:  MOVLB  A
06650:  MOVWF  x95
....................                  
....................                 // Update sequence flag 
....................                 g_fGPRSSequence = GPRS_DATA_SENDING_SEQUENCE_4; 
06652:  MOVLW  04
06654:  MOVLB  6
06656:  MOVWF  x93
....................             } 
06658:  GOTO   667A
0665C:  MOVLB  B
....................             else // On failure 
....................             { 
....................                 // Set failure flag from where GPRS process fails so that error 
....................                 // handling stuff can handle that easily 
....................                 g_fGPRSFailureBit = GPRS_CONNECTION_FAILS; 
0665E:  MOVLW  1E
06660:  MOVLB  6
06662:  MOVWF  x94
....................                  
....................                 // Set timeout of 3 seconds 
....................                 g_fIsTimedOut = 0; 
06664:  MOVLB  2
06666:  CLRF   x34
....................                 SetTimeout(DATA_RESEND_INTRVL_TIMEOUT); 
06668:  MOVLW  0A
0666A:  MOVLB  B
0666C:  MOVWF  x1B
0666E:  MOVLB  0
06670:  CALL   1AA6
....................                  
....................                 // Update sequence flag 
....................                 g_fGPRSSequence = GPRS_DATA_SENDING_SEQUENCE_8; 
06674:  MOVLW  08
06676:  MOVLB  6
06678:  MOVWF  x93
0667A:  MOVLB  A
....................             } 
....................         } 
....................          
....................         // Step 4: If GPRS connected then process data sending 
....................         if(GPRS_CONNECTED == g_fIsGPRSConnected && g_fGPRSSequence == GPRS_DATA_SENDING_SEQUENCE_4) 
0667C:  DECFSZ x95,W
0667E:  GOTO   66F2
06682:  MOVLB  6
06684:  MOVF   x93,W
06686:  SUBLW  04
06688:  BTFSC  FD8.2
0668A:  BRA    6692
0668C:  MOVLB  A
0668E:  GOTO   66F2
....................         { 
....................             // Check if there is msg available in  queue 
....................             ui8RetVal = IsGPRSMsgQueueEmpty(); 
06692:  MOVLB  0
06694:  GOTO   401E
06698:  MOVFF  01,B11
....................              
....................             // check return value 
....................             if(0 == ui8RetVal) // Queue is not empty 
0669C:  MOVLB  B
0669E:  MOVF   x11,F
066A0:  BTFSS  FD8.2
066A2:  GOTO   66CA
....................             { 
....................                 // Data available in queue..stop GPRS queue empty time count 
....................                 g_fGPRSQueueEmptyTimeStatus = GPRS_QUEUE_EMPTY_TIME_COUNT_STOP; 
066A6:  MOVLW  51
066A8:  MOVLB  2
066AA:  MOVWF  x3A
....................                          
....................                 // Send request to enable HTTP mode 
....................                 //SendEnableHTTPModeRequest(); 
....................                 SetHTTPURLParameter(); 
066AC:  MOVLB  0
066AE:  GOTO   46FE
....................                  
....................                 // Set timeout for 2 seconds 
....................                 SetTimeout(HTTP_URL_PARAMETER_SET_TIMEOUT); 
066B2:  MOVLW  02
066B4:  MOVLB  B
066B6:  MOVWF  x1B
066B8:  MOVLB  0
066BA:  CALL   1AA6
....................                  
....................                 // Update flag 
....................                 g_fGPRSSequence = GPRS_DATA_SENDING_SEQUENCE_5; 
066BE:  MOVLW  05
066C0:  MOVLB  6
066C2:  MOVWF  x93
....................             } 
066C4:  GOTO   66F0
066C8:  MOVLB  B
....................             else // Queue is empty 
....................             { 
....................                 // Data is not available..wait until data is available 
....................                 // Start GPRS queue empty time count 
....................                 g_fGPRSQueueEmptyTimeStatus = GPRS_QUEUE_EMPTY_TIME_COUNT_START; 
066CA:  MOVLW  50
066CC:  MOVLB  2
066CE:  MOVWF  x3A
....................                  
....................                 // Update sequence flag 
....................                 g_fGPRSSequence = GPRS_DATA_SENDING_SEQUENCE_4; 
066D0:  MOVLW  04
066D2:  MOVLB  6
066D4:  MOVWF  x93
....................                  
....................                 // Check queue empty timeout 
....................                 if(SHOULD_CHECK_GPRS_CONNECTIVITY == g_fCheckGPRSConnectivity) 
066D6:  MOVLB  2
066D8:  MOVF   x39,W
066DA:  SUBLW  37
066DC:  BTFSS  FD8.2
066DE:  GOTO   66EE
....................                 { 
....................                     // Update sequence flag 
....................                     g_fGPRSSequence = GPRS_DATA_SENDING_SEQUENCE_1; 
066E2:  MOVLW  01
066E4:  MOVLB  6
066E6:  MOVWF  x93
....................                      
....................                     // Reset flag 
....................                     g_fCheckGPRSConnectivity = SHOULD_NOT_CHECK_GPRS_CONNECTIVITY; 
066E8:  MOVLW  38
066EA:  MOVLB  2
066EC:  MOVWF  x39
066EE:  MOVLB  6
066F0:  MOVLB  A
....................                 } 
....................             } 
....................         } 
....................         // Step 5: Check enable HTTP mode request response 
....................         if(g_fIsTimedOut == 1 && GPRS_DATA_SENDING_SEQUENCE_5 == g_fGPRSSequence) 
066F2:  MOVLB  2
066F4:  DECFSZ x34,W
066F6:  GOTO   675E
066FA:  MOVLB  6
066FC:  MOVF   x93,W
066FE:  SUBLW  05
06700:  BTFSC  FD8.2
06702:  BRA    670A
06704:  MOVLB  2
06706:  GOTO   675E
....................         { 
....................             // Check response function 
....................             ui8RetVal = SetHTTPURLL(); 
0670A:  MOVLB  0
0670C:  GOTO   4A32
06710:  MOVFF  01,B11
....................              
....................             // Check return value 
....................             if(0 == ui8RetVal) // On success             
06714:  MOVLB  B
06716:  MOVF   x11,F
06718:  BTFSS  FD8.2
0671A:  GOTO   672A
....................             { 
....................                 // Update sequence flag 
....................                 g_fGPRSSequence = GPRS_DATA_SENDING_SEQUENCE_6; 
0671E:  MOVLW  06
06720:  MOVLB  6
06722:  MOVWF  x93
....................             } 
06724:  GOTO   675C
06728:  MOVLB  B
....................             else // On failure 
....................             { 
....................                 // GPRS module fails to set web service URL properly. 
....................                 // Set the failure bit. 
....................                 g_fGPRSFailureBit = GPRS_SET_WEB_SERVICE_URL_FAILS; 
0672A:  MOVLW  21
0672C:  MOVLB  6
0672E:  MOVWF  x94
....................                  
....................                 // Reset queue front to resend the data which gets failure on sending. 
....................                 if(g_ui8DataQueueLen >= 5) 
06730:  MOVF   x92,W
06732:  SUBLW  04
06734:  BTFSC  FD8.0
06736:  GOTO   6746
....................                 { 
....................                     g_stGPRSMsgSendQueue.m_i8Front -= 4; 
0673A:  MOVLW  04
0673C:  MOVLB  A
0673E:  SUBWF  x19,F
....................                 } 
06740:  GOTO   6744
06744:  MOVLB  6
....................                 else 
....................                 { 
....................                     //g_stGPRSMsgSendQueue.m_i8Front -= 1; 
....................                 } 
....................                  
....................                  
....................                 // Set the sequence bit. 
....................                 g_fGPRSSequence = GPRS_DATA_SENDING_SEQUENCE_8; 
06746:  MOVLW  08
06748:  MOVWF  x93
....................                  
....................                 // wait for 10 seconds before resend. 
....................                 g_fIsTimedOut = 0; 
0674A:  MOVLB  2
0674C:  CLRF   x34
....................                 SetTimeout(DATA_RESEND_INTRVL_TIMEOUT); 
0674E:  MOVLW  0A
06750:  MOVLB  B
06752:  MOVWF  x1B
06754:  MOVLB  0
06756:  CALL   1AA6
0675A:  MOVLB  6
0675C:  MOVLB  2
....................  
....................             } 
....................         } 
....................          
....................         // Step 6: Send request to set HTTP Bearer profile ID 
....................         if(GPRS_DATA_SENDING_SEQUENCE_6 == g_fGPRSSequence) 
0675E:  MOVLB  6
06760:  MOVF   x93,W
06762:  SUBLW  06
06764:  BTFSS  FD8.2
06766:  GOTO   6782
....................         { 
....................             // Send request to start HTTP get session to hit the URL. 
....................             SendHTTPGetSessionRequest(); 
0676A:  MOVLB  0
0676C:  GOTO   5590
....................              
....................             // Set timeout of 10 seconds 
....................             SetTimeout(HTTP_GET_SESSION_TIMEOUT); 
06770:  MOVLW  08
06772:  MOVLB  B
06774:  MOVWF  x1B
06776:  MOVLB  0
06778:  CALL   1AA6
....................              
....................             // Update sequence flag 
....................             g_fGPRSSequence = GPRS_DATA_SENDING_SEQUENCE_7; 
0677C:  MOVLW  07
0677E:  MOVLB  6
06780:  MOVWF  x93
....................         } 
....................          
....................         // Step 8: Check HTTP bearer profile id set request response 
....................         if(g_fIsTimedOut == 1 && g_fGPRSSequence == GPRS_DATA_SENDING_SEQUENCE_7) 
06782:  MOVLB  2
06784:  DECFSZ x34,W
06786:  GOTO   6840
0678A:  MOVLB  6
0678C:  MOVF   x93,W
0678E:  SUBLW  07
06790:  BTFSC  FD8.2
06792:  BRA    679A
06794:  MOVLB  2
06796:  GOTO   6840
....................         { 
....................             // Check response 
....................             ui8RetVal = CheckHTTPGETRequestResponse(); 
0679A:  MOVLB  0
0679C:  GOTO   55C2
067A0:  MOVFF  01,B11
....................  
....................             // Check return value 
....................             if(0 == ui8RetVal) // On success 
067A4:  MOVLB  B
067A6:  MOVF   x11,F
067A8:  BTFSS  FD8.2
067AA:  GOTO   680C
....................             { 
....................                 // Update data sending flag 
....................                 g_fShouldSendData = SHOULD_NOT_SEND_DATA; 
067AE:  MOVLW  1A
067B0:  MOVLB  2
067B2:  MOVWF  x35
....................  
....................                 //Increase GPRS send msg queue front. 
....................                 g_stGPRSMsgSendQueue.m_i8Front++;  
067B4:  MOVLB  A
067B6:  INCF   x19,F
....................                  
....................                 // Check if the sent data is the last data in GPRS queue. 
....................                 // If so then initialize GPRS message queue. 
....................                 if(1 == g_fIsLastElementInGPRSQueue && (g_stGPRSMsgSendQueue.m_i8Front > g_stGPRSMsgSendQueue.m_i8Rear)) 
067B8:  MOVLB  4
067BA:  DECFSZ x93,W
067BC:  GOTO   67E0
067C0:  MOVLB  A
067C2:  MOVF   x19,W
067C4:  SUBWF  x1A,W
067C6:  BTFSS  FD8.0
067C8:  BRA    67D0
067CA:  MOVLB  4
067CC:  GOTO   67E0
....................                 { 
....................                     // Reset flag. 
....................                     g_fIsLastElementInGPRSQueue = 0; 
067D0:  MOVLB  4
067D2:  CLRF   x93
....................                      
....................                     // Reset queue. 
....................                     InitializeGPRSMsgQueue(); 
067D4:  MOVLB  0
067D6:  CALL   0B4C
....................                     StuffDummyTimeStamp(); 
067DA:  CALL   0C4C
067DE:  MOVLB  4
....................                 } 
....................  
....................                 // Update sequence flag 
....................                 g_fGPRSSequence = 1; 
067E0:  MOVLW  01
067E2:  MOVLB  6
067E4:  MOVWF  x93
....................  
....................                 // Check if queue front reached at end 
....................                 if(g_stGPRSMsgSendQueue.m_i8Front != -1) 
067E6:  MOVLB  A
067E8:  MOVF   x19,W
067EA:  SUBLW  FF
067EC:  BTFSC  FD8.2
067EE:  GOTO   6806
....................                 { 
....................                     if(g_stGPRSMsgSendQueue.m_i8Front >= (SIZE_GPRS_DATA_NODE_QUEUE - 1)) 
067F2:  MOVF   x19,W
067F4:  SUBLW  62
067F6:  BTFSC  FD8.0
067F8:  GOTO   6806
....................                     { 
....................                         // Reset front 
....................                         g_stGPRSMsgSendQueue.m_i8Front = 0; 
067FC:  CLRF   x19
....................  
....................                         // Update sequence flag 
....................                         g_fGPRSSequence = 1; 
067FE:  MOVLW  01
06800:  MOVLB  6
06802:  MOVWF  x93
06804:  MOVLB  A
....................                     } 
....................                 }     
....................             } 
06806:  GOTO   683E
0680A:  MOVLB  B
....................             else // On failure 
....................             {        
....................                 // GPRS module fails to hit the URL properly. 
....................                 // Set the failure bit. 
....................                 g_fGPRSFailureBit = GPRS_START_HTTP_GET_SESSION_FAILS; 
0680C:  MOVLW  22
0680E:  MOVLB  6
06810:  MOVWF  x94
....................                  
....................                 // Reset queue front to resend the data which gets failure on sending. 
....................                 if(g_ui8DataQueueLen >= 5) 
06812:  MOVF   x92,W
06814:  SUBLW  04
06816:  BTFSC  FD8.0
06818:  GOTO   6828
....................                 { 
....................                     g_stGPRSMsgSendQueue.m_i8Front -= 4; 
0681C:  MOVLW  04
0681E:  MOVLB  A
06820:  SUBWF  x19,F
....................                 } 
06822:  GOTO   6826
06826:  MOVLB  6
....................                 else 
....................                 { 
....................                     //g_stGPRSMsgSendQueue.m_i8Front -= 1; 
....................                 } 
....................                  
....................                 // Set the sequence bit. 
....................                 g_fGPRSSequence = GPRS_DATA_SENDING_SEQUENCE_8; 
06828:  MOVLW  08
0682A:  MOVWF  x93
....................                  
....................                 // wait for 10 seconds before resend. 
....................                 g_fIsTimedOut = 0; 
0682C:  MOVLB  2
0682E:  CLRF   x34
....................                 SetTimeout(DATA_RESEND_INTRVL_TIMEOUT); 
06830:  MOVLW  0A
06832:  MOVLB  B
06834:  MOVWF  x1B
06836:  MOVLB  0
06838:  CALL   1AA6
0683C:  MOVLB  A
0683E:  MOVLB  2
....................             } 
....................         } 
....................    
....................         // Step 15: Handle error;if occur any on GRPS data sending process 
....................         if(g_fIsTimedOut == 1 && g_fGPRSSequence == GPRS_DATA_SENDING_SEQUENCE_8) 
06840:  DECFSZ x34,W
06842:  GOTO   688A
06846:  MOVLB  6
06848:  MOVF   x93,W
0684A:  SUBLW  08
0684C:  BTFSC  FD8.2
0684E:  BRA    6856
06850:  MOVLB  2
06852:  GOTO   688A
....................         { 
....................             // Check GPRS failure bit flag 
....................             if(GPRS_CONNECTION_FAILS == g_fGPRSFailureBit) 
06856:  MOVF   x94,W
06858:  SUBLW  1E
0685A:  BTFSS  FD8.2
0685C:  GOTO   6870
....................             { 
....................                 // Update sequence flag 
....................                 g_fGPRSSequence = GPRS_DATA_SENDING_SEQUENCE_1; 
06860:  MOVLW  01
06862:  MOVWF  x93
....................          
....................                  //Update data sending flag 
....................                  g_fShouldSendData = SHOULD_NOT_SEND_DATA; 
06864:  MOVLW  1A
06866:  MOVLB  2
06868:  MOVWF  x35
....................             } 
0686A:  GOTO   688A
0686E:  MOVLB  6
....................             else if(GPRS_SET_WEB_SERVICE_URL_FAILS == g_fGPRSFailureBit|| 
....................                     GPRS_START_HTTP_GET_SESSION_FAILS == g_fGPRSFailureBit) 
06870:  MOVF   x94,W
06872:  SUBLW  21
06874:  BTFSC  FD8.2
06876:  GOTO   6884
0687A:  MOVF   x94,W
0687C:  SUBLW  22
0687E:  BTFSS  FD8.2
06880:  GOTO   6888
....................             { 
....................                 // Update sequence flag 
....................                 g_fGPRSSequence = GPRS_DATA_SENDING_SEQUENCE_4; 
06884:  MOVLW  04
06886:  MOVWF  x93
06888:  MOVLB  2
....................             } 
....................              
....................         } 
....................      
.................... 		// Reset WDT. 
....................         restart_wdt();                 
0688A:  CLRWDT
0688C:  MOVLB  B
0688E:  GOTO   645A
.................... 	}	 
.................... } 
....................     	 
06892:  SLEEP 
....................  
....................  
....................  
....................  
....................  
.................... 	 

Configuration Fuses:
   Word  1: 0415   VREGSLEEP INTRC_HP SOSC_DIG NOXINST ECH NOPLLEN NOFCMEN NOIESO
   Word  2: 2B79   NOPUT NOBROWNOUT BORV18 ZPBORM WDT WDT1024
   Word  3: 8900   CANB MSSPMSK7 MCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
